# 第8章　函数基础

函数是JavaScript的核心概念，是第一类对象（First-class Object），可以作为值传递、存储在变量中、作为参数传递给其他函数，或作为返回值。理解函数是掌握JavaScript高级特性的关键。

## 8.1 函数声明方式

JavaScript提供了多种声明函数的方式，每种方式都有其特点和适用场景。理解这些差异对于编写高质量的代码至关重要。

### 函数声明（Function Declaration）

函数声明是最传统的定义函数的方式，具有提升（hoisting）特性：

```javascript
/**
 * 函数声明示例
 */
const FunctionDeclarationExamples = {
    /**
     * 基本函数声明
     */
    basicDeclarations() {
        console.log('=== 基本函数声明 ===');
        
        // 基本函数声明
        function greet(name) {
            return `Hello, ${name}!`;
        }
        
        console.log(greet('Alice')); // 输出: Hello, Alice!
        
        // 函数声明具有提升特性
        console.log(hoistedFunction()); // 可以在声明前调用
        
        function hoistedFunction() {
            return '我被提升了！';
        }
        
        // 带参数的函数
        function calculateArea(width, height) {
            return width * height;
        }
        
        console.log('矩形面积:', calculateArea(10, 5));
        
        // 带默认参数的函数声明
        function createUser(name, role = 'user') {
            return {
                name: name,
                role: role,
                createdAt: new Date()
            };
        }
        
        console.log('默认角色用户:', createUser('Bob'));
        console.log('管理员用户:', createUser('Alice', 'admin'));
    },
    
    /**
     * 函数声明的提升特性
     */
    hoistingBehavior() {
        console.log('=== 函数提升特性 ===');
        
        // 演示函数提升
        console.log('调用提升函数:', testHoisting());
        
        function testHoisting() {
            return '函数声明被提升到作用域顶部';
        }
        
        // 条件函数声明（不推荐）
        if (true) {
            function conditionalFunction() {
                return '条件内的函数声明';
            }
        }
        
        try {
            console.log('条件函数:', conditionalFunction());
        } catch (error) {
            console.log('条件函数可能不可用:', error.message);
        }
        
        // 嵌套函数声明
        function outerFunction() {
            console.log('外层函数执行');
            
            function innerFunction() {
                return '内层函数被调用';
            }
            
            return innerFunction();
        }
        
        console.log('嵌套函数结果:', outerFunction());
    }
};

FunctionDeclarationExamples.basicDeclarations();
FunctionDeclarationExamples.hoistingBehavior();
```

### 函数表达式（Function Expression）

函数表达式将函数赋值给变量，不具有提升特性：

```javascript
/**
 * 函数表达式示例
 */
const FunctionExpressionExamples = {
    /**
     * 基本函数表达式
     */
    basicExpressions() {
        console.log('=== 基本函数表达式 ===');
        
        // 匿名函数表达式
        const anonymousFunc = function(x, y) {
            return x + y;
        };
        
        console.log('匿名函数结果:', anonymousFunc(5, 3));
        
        // 命名函数表达式
        const namedFunc = function multiply(a, b) {
            return a * b;
        };
        
        console.log('命名函数表达式:', namedFunc(4, 6));
        
        // 立即执行函数表达式 (IIFE)
        const result = (function(name) {
            return `IIFE executed with ${name}`;
        })('test');
        
        console.log('IIFE结果:', result);
        
        // 函数表达式不会被提升
        try {
            console.log(notHoisted()); // 这会报错
        } catch (error) {
            console.log('函数表达式不会提升:', error.message);
        }
        
        var notHoisted = function() {
            return '我不会被提升';
        };
    },
    
    /**
     * 高阶函数表达式
     */
    higherOrderFunctions() {
        console.log('=== 高阶函数表达式 ===');
        
        // 返回函数的函数
        const createMultiplier = function(factor) {
            return function(number) {
                return number * factor;
            };
        };
        
        const double = createMultiplier(2);
        const triple = createMultiplier(3);
        
        console.log('双倍:', double(5));
        console.log('三倍:', triple(5));
        
        // 接受函数作为参数的函数
        const processArray = function(arr, callback) {
            const result = [];
            for (let i = 0; i < arr.length; i++) {
                result.push(callback(arr[i], i));
            }
            return result;
        };
        
        const numbers = [1, 2, 3, 4, 5];
        
        const squared = processArray(numbers, function(num) {
            return num * num;
        });
        
        const withIndex = processArray(numbers, function(num, index) {
            return `${num} at index ${index}`;
        });
        
        console.log('平方数组:', squared);
        console.log('带索引:', withIndex);
        
        // 条件函数表达式
        const condition = true;
        const conditionalFunc = condition ? 
            function() { return 'Condition is true'; } :
            function() { return 'Condition is false'; };
        
        console.log('条件函数:', conditionalFunc());
    }
};

FunctionExpressionExamples.basicExpressions();
FunctionExpressionExamples.higherOrderFunctions();
```

### 箭头函数（Arrow Function）

ES6引入的箭头函数提供了更简洁的语法：

```javascript
/**
 * 箭头函数示例
 */
const ArrowFunctionExamples = {
    /**
     * 基本箭头函数语法
     */
    basicSyntax() {
        console.log('=== 箭头函数基本语法 ===');
        
        // 基本箭头函数
        const add = (a, b) => a + b;
        console.log('加法:', add(3, 4));
        
        // 单参数箭头函数（可省略括号）
        const square = x => x * x;
        console.log('平方:', square(5));
        
        // 无参数箭头函数
        const getCurrentTime = () => new Date().toISOString();
        console.log('当前时间:', getCurrentTime());
        
        // 多行箭头函数
        const processUser = (user) => {
            const processed = {
                ...user,
                id: Math.random().toString(36).substr(2, 9),
                processedAt: new Date()
            };
            return processed;
        };
        
        const user = { name: 'Alice', email: 'alice@example.com' };
        console.log('处理用户:', processUser(user));
        
        // 返回对象字面量（需要括号）
        const createPoint = (x, y) => ({ x, y });
        console.log('创建点:', createPoint(10, 20));
        
        // 数组方法中的箭头函数
        const numbers = [1, 2, 3, 4, 5];
        
        const doubled = numbers.map(n => n * 2);
        const evens = numbers.filter(n => n % 2 === 0);
        const sum = numbers.reduce((acc, n) => acc + n, 0);
        
        console.log('原数组:', numbers);
        console.log('翻倍:', doubled);
        console.log('偶数:', evens);
        console.log('总和:', sum);
    },
    
    /**
     * 箭头函数与传统函数的差异
     */
    comparisonWithTraditional() {
        console.log('=== 箭头函数vs传统函数 ===');
        
        const obj = {
            name: 'TestObject',
            
            // 传统函数方法
            traditionalMethod: function() {
                return `传统函数中的this: ${this.name}`;
            },
            
            // 箭头函数方法
            arrowMethod: () => {
                // 箭头函数没有自己的this
                return `箭头函数中的this: ${this.name}`;
            },
            
            // 测试方法
            testThis: function() {
                console.log(this.traditionalMethod());
                console.log(this.arrowMethod());
                
                // 在传统函数中使用箭头函数
                const innerArrow = () => {
                    return `内部箭头函数的this: ${this.name}`;
                };
                
                console.log(innerArrow());
                
                // 传统函数内的传统函数
                const innerTraditional = function() {
                    return `内部传统函数的this: ${this.name}`;
                };
                
                console.log(innerTraditional.call(this));
            }
        };
        
        obj.testThis();
        
        // 箭头函数不能作为构造函数
        const ArrowConstructor = () => {
            this.name = 'Arrow';
        };
        
        try {
            const instance = new ArrowConstructor();
        } catch (error) {
            console.log('箭头函数不能作为构造函数:', error.message);
        }
        
        // 箭头函数没有arguments对象
        function traditionalArgs() {
            console.log('传统函数arguments:', arguments.length);
            return arguments;
        }
        
        const arrowArgs = (...args) => {
            console.log('箭头函数使用rest参数:', args.length);
            return args;
        };
        
        traditionalArgs(1, 2, 3);
        arrowArgs(1, 2, 3);
    }
};

ArrowFunctionExamples.basicSyntax();
ArrowFunctionExamples.comparisonWithTraditional();
```

### 函数构造器（Function Constructor）

Function构造器允许动态创建函数，但很少使用：

```javascript
/**
 * 函数构造器示例
 */
const FunctionConstructorExamples = {
    /**
     * 基本函数构造器用法
     */
    basicConstructor() {
        console.log('=== 函数构造器 ===');
        
        // 基本构造器语法
        const addFunction = new Function('a', 'b', 'return a + b');
        console.log('构造器函数结果:', addFunction(3, 4));
        
        // 动态创建函数
        const operation = 'multiply';
        const dynamicFunction = new Function('x', 'y', `
            if ('${operation}' === 'multiply') {
                return x * y;
            } else {
                return x + y;
            }
        `);
        
        console.log('动态函数结果:', dynamicFunction(5, 6));
        
        // 构造器创建的函数没有闭包
        const outerVar = 'outside';
        const normalFunction = function() {
            return outerVar; // 可以访问
        };
        
        const constructedFunction = new Function('return outerVar'); // 无法访问
        
        console.log('普通函数访问外部变量:', normalFunction());
        
        try {
            console.log('构造器函数访问外部变量:', constructedFunction());
        } catch (error) {
            console.log('构造器函数无法访问闭包变量:', error.message);
        }
    }
};

FunctionConstructorExamples.basicConstructor();
```

### 方法定义（Method Definition）

ES6引入了简化的方法定义语法：

```javascript
/**
 * 方法定义示例
 */
const MethodDefinitionExamples = {
    /**
     * 对象方法定义
     */
    objectMethods() {
        console.log('=== 对象方法定义 ===');
        
        const calculator = {
            // ES5风格方法
            addOld: function(a, b) {
                return a + b;
            },
            
            // ES6简化方法定义
            add(a, b) {
                return a + b;
            },
            
            // 异步方法
            async fetchData(url) {
                // 模拟异步操作
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve(`Data from ${url}`);
                    }, 100);
                });
            },
            
            // 生成器方法
            *generateNumbers(count) {
                for (let i = 1; i <= count; i++) {
                    yield i;
                }
            },
            
            // Getter和Setter
            get currentTime() {
                return new Date().toISOString();
            },
            
            set value(val) {
                this._value = val;
                console.log(`Value set to: ${val}`);
            },
            
            get value() {
                return this._value || 0;
            }
        };
        
        console.log('ES5方法:', calculator.addOld(2, 3));
        console.log('ES6方法:', calculator.add(2, 3));
        console.log('Getter:', calculator.currentTime);
        
        calculator.value = 42;
        console.log('Setter/Getter:', calculator.value);
        
        // 异步方法使用
        calculator.fetchData('https://api.example.com').then(result => {
            console.log('异步方法结果:', result);
        });
        
        // 生成器方法使用
        const numberGenerator = calculator.generateNumbers(3);
        console.log('生成器方法:');
        for (const num of numberGenerator) {
            console.log(`  生成数字: ${num}`);
        }
    },
    
    /**
     * 类方法定义
     */
    classMethods() {
        console.log('=== 类方法定义 ===');
        
        class UserManager {
            constructor() {
                this.users = [];
            }
            
            // 实例方法
            addUser(user) {
                this.users.push({
                    ...user,
                    id: Math.random().toString(36).substr(2, 9),
                    createdAt: new Date()
                });
                return this;
            }
            
            // 异步实例方法
            async validateUser(userId) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        const user = this.users.find(u => u.id === userId);
                        resolve(!!user);
                    }, 50);
                });
            }
            
            // 静态方法
            static createDefault() {
                return new UserManager();
            }
            
            // Getter
            get userCount() {
                return this.users.length;
            }
            
            // 生成器方法
            *getAllUsers() {
                for (const user of this.users) {
                    yield user;
                }
            }
        }
        
        const manager = UserManager.createDefault();
        
        manager
            .addUser({ name: 'Alice', email: 'alice@example.com' })
            .addUser({ name: 'Bob', email: 'bob@example.com' });
        
        console.log('用户数量:', manager.userCount);
        
        console.log('所有用户:');
        for (const user of manager.getAllUsers()) {
            console.log(`  ${user.name} - ${user.email}`);
        }
    }
};

MethodDefinitionExamples.objectMethods();
MethodDefinitionExamples.classMethods();
```

---

## 8.2 箭头函数与 this

箭头函数的this绑定机制与传统函数完全不同，这是JavaScript中最重要的概念之一。

### 箭头函数的语法特点

箭头函数提供了简洁的语法，但有特定的使用规则：

```javascript
/**
 * 箭头函数语法特点
 */
const ArrowFunctionSyntax = {
    /**
     * 语法变化形式
     */
    syntaxVariations() {
        console.log('=== 箭头函数语法形式 ===');
        
        // 最简形式：单参数，单表达式
        const double = x => x * 2;
        console.log('最简形式:', double(5));
        
        // 多参数需要括号
        const add = (a, b) => a + b;
        console.log('多参数:', add(3, 4));
        
        // 无参数需要空括号
        const greeting = () => 'Hello World';
        console.log('无参数:', greeting());
        
        // 多行函数体需要大括号和return
        const processData = (data) => {
            const processed = data.map(item => item * 2);
            const sum = processed.reduce((a, b) => a + b, 0);
            return { processed, sum };
        };
        
        console.log('多行函数:', processData([1, 2, 3]));
        
        // 返回对象字面量需要括号
        const createUser = name => ({ name, id: Date.now() });
        console.log('返回对象:', createUser('Alice'));
        
        // 高阶函数中的箭头函数
        const numbers = [1, 2, 3, 4, 5];
        
        // 链式调用
        const result = numbers
            .filter(n => n % 2 === 0)
            .map(n => n * 3)
            .reduce((sum, n) => sum + n, 0);
        
        console.log('链式箭头函数结果:', result);
    },
    
    /**
     * 箭头函数的限制
     */
    limitations() {
        console.log('=== 箭头函数限制 ===');
        
        // 1. 不能作为构造函数
        const ArrowFunc = () => {};
        try {
            new ArrowFunc();
        } catch (error) {
            console.log('1. 不能作为构造函数:', error.message);
        }
        
        // 2. 没有prototype属性
        console.log('2. 箭头函数prototype:', ArrowFunc.prototype);
        
        function RegularFunc() {}
        console.log('   普通函数prototype:', typeof RegularFunc.prototype);
        
        // 3. 没有arguments对象
        const arrowWithArgs = () => {
            try {
                console.log(arguments); // 报错
            } catch (error) {
                console.log('3. 没有arguments对象:', error.message);
            }
        };
        
        function regularWithArgs() {
            console.log('   普通函数arguments长度:', arguments.length);
        }
        
        arrowWithArgs(1, 2, 3);
        regularWithArgs(1, 2, 3);
        
        // 4. 不能使用yield关键字
        // const arrowGenerator = () => {
        //     yield 1; // 语法错误
        // };
        
        console.log('4. 箭头函数不能是生成器函数');
        
        // 5. 不能使用call、apply、bind改变this
        const arrowThis = () => {
            return this;
        };
        
        const obj = { name: 'test' };
        console.log('5. call/apply/bind对箭头函数无效');
        console.log('   箭头函数call结果:', arrowThis.call(obj));
        console.log('   箭头函数apply结果:', arrowThis.apply(obj));
        console.log('   箭头函数bind结果:', arrowThis.bind(obj)());
    }
};

ArrowFunctionSyntax.syntaxVariations();
ArrowFunctionSyntax.limitations();
```

### this绑定机制

箭头函数最重要的特性是它没有自己的this，而是继承外围作用域的this：

```javascript
/**
 * this绑定机制详解
 */
const ThisBindingExamples = {
    /**
     * 箭头函数与传统函数的this对比
     */
    thisComparison() {
        console.log('=== this绑定对比 ===');
        
        const obj = {
            name: 'MyObject',
            
            // 传统函数方法
            regularMethod: function() {
                console.log('传统函数this.name:', this.name);
                
                // 传统函数内的传统函数
                function innerRegular() {
                    console.log('内部传统函数this.name:', this.name); // undefined
                }
                innerRegular();
                
                // 传统函数内的箭头函数
                const innerArrow = () => {
                    console.log('内部箭头函数this.name:', this.name); // MyObject
                };
                innerArrow();
            },
            
            // 箭头函数方法
            arrowMethod: () => {
                console.log('箭头函数this.name:', this.name); // undefined
            }
        };
        
        obj.regularMethod();
        obj.arrowMethod();
        
        // 事件处理中的this
        console.log('=== 事件处理this ===');
        
        class Button {
            constructor(name) {
                this.name = name;
                this.clickCount = 0;
            }
            
            // 传统方法作为事件处理器
            handleClickRegular() {
                this.clickCount++;
                console.log(`${this.name} 传统方法点击: ${this.clickCount}`);
            }
            
            // 箭头函数作为事件处理器
            handleClickArrow = () => {
                this.clickCount++;
                console.log(`${this.name} 箭头函数点击: ${this.clickCount}`);
            }
            
            // 模拟绑定事件
            bindEvents() {
                // 模拟DOM事件
                const mockEvent = { type: 'click' };
                
                // 传统方法需要bind
                const boundRegular = this.handleClickRegular.bind(this);
                boundRegular.call(null); // 模拟事件调用
                
                // 箭头函数自动绑定
                this.handleClickArrow.call(null); // 模拟事件调用
            }
        }
        
        const button = new Button('MyButton');
        button.bindEvents();
    },
    
    /**
     * 类中的箭头函数
     */
    classArrowFunctions() {
        console.log('=== 类中的箭头函数 ===');
        
        class EventEmitter {
            constructor() {
                this.listeners = [];
                this.eventCount = 0;
            }
            
            // 传统方法
            addListener(callback) {
                this.listeners.push(callback);
                return this;
            }
            
            // 箭头函数方法（实例属性）
            emit = (eventData) => {
                this.eventCount++;
                console.log(`事件 #${this.eventCount}:`, eventData);
                
                this.listeners.forEach(callback => {
                    callback(eventData);
                });
                
                return this;
            }
            
            // 传统方法中使用箭头函数
            processEvents(events) {
                // 箭头函数保持this指向实例
                events.forEach(event => {
                    this.emit(event);
                });
            }
        }
        
        const emitter = new EventEmitter();
        
        emitter
            .addListener(data => console.log('监听器1:', data))
            .addListener(data => console.log('监听器2:', data))
            .emit('第一个事件')
            .processEvents(['批量事件1', '批量事件2']);
    },
    
    /**
     * 异步操作中的this
     */
    asyncOperationsThis() {
        console.log('=== 异步操作中的this ===');
        
        class DataProcessor {
            constructor(name) {
                this.name = name;
                this.data = [];
            }
            
            // 传统异步方法
            fetchDataTraditional(url) {
                const self = this; // 保存this引用
                
                setTimeout(function() {
                    console.log(`${self.name} 传统方法获取数据`);
                    self.data.push(`data from ${url}`);
                }, 100);
            }
            
            // 箭头函数异步方法
            fetchDataArrow(url) {
                setTimeout(() => {
                    console.log(`${this.name} 箭头函数获取数据`);
                    this.data.push(`data from ${url}`);
                }, 150);
            }
            
            // Promise中的this
            fetchDataPromise(url) {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        console.log(`${this.name} Promise获取数据`);
                        const newData = `promise data from ${url}`;
                        this.data.push(newData);
                        resolve(newData);
                    }, 200);
                });
            }
            
            // async/await中的this
            async fetchDataAsync(url) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        console.log(`${this.name} async/await获取数据`);
                        const newData = `async data from ${url}`;
                        this.data.push(newData);
                        resolve(newData);
                    }, 250);
                });
            }
            
            showData() {
                console.log(`${this.name} 的数据:`, this.data);
            }
        }
        
        const processor = new DataProcessor('DataProcessor');
        
        processor.fetchDataTraditional('api1');
        processor.fetchDataArrow('api2');
        processor.fetchDataPromise('api3');
        processor.fetchDataAsync('api4');
        
        // 延迟显示数据
        setTimeout(() => {
            processor.showData();
        }, 300);
    }
};

ThisBindingExamples.thisComparison();
ThisBindingExamples.classArrowFunctions();
ThisBindingExamples.asyncOperationsThis();
```

### 箭头函数的局限性

理解箭头函数的限制有助于正确选择使用场景：

```javascript
/**
 * 箭头函数局限性详解
 */
const ArrowFunctionLimitations = {
    /**
     * 不适合的使用场景
     */
    inappropriateUseCases() {
        console.log('=== 箭头函数不适合的场景 ===');
        
        // 1. 对象方法定义
        const obj = {
            name: 'TestObject',
            
            // ❌ 不推荐：箭头函数作为对象方法
            arrowMethod: () => {
                return `Hello from ${this.name}`; // this不指向obj
            },
            
            // ✅ 推荐：传统函数作为对象方法
            regularMethod: function() {
                return `Hello from ${this.name}`;
            }
        };
        
        console.log('箭头函数方法:', obj.arrowMethod());
        console.log('传统函数方法:', obj.regularMethod());
        
        // 2. 需要动态this的场景
        const button = {
            element: 'button',
            
            // ❌ 不推荐：事件处理器需要动态this
            clickHandler: () => {
                console.log('点击的元素:', this.element); // this不正确
            },
            
            // ✅ 推荐：传统函数获得正确this
            clickHandlerRegular: function() {
                console.log('点击的元素:', this.element);
            }
        };
        
        button.clickHandler.call(button);
        button.clickHandlerRegular.call(button);
        
        // 3. 构造函数
        function RegularConstructor(name) {
            this.name = name;
        }
        
        const ArrowConstructor = (name) => {
            this.name = name; // 无效
        };
        
        console.log('传统构造函数:', new RegularConstructor('Alice'));
        
        try {
            new ArrowConstructor('Bob');
        } catch (error) {
            console.log('箭头函数构造错误:', error.message);
        }
        
        // 4. 原型方法
        function Person(name) {
            this.name = name;
        }
        
        // ❌ 不推荐：箭头函数作为原型方法
        Person.prototype.greetArrow = () => {
            return `Hi, I'm ${this.name}`;
        };
        
        // ✅ 推荐：传统函数作为原型方法
        Person.prototype.greetRegular = function() {
            return `Hi, I'm ${this.name}`;
        };
        
        const person = new Person('Charlie');
        console.log('原型箭头方法:', person.greetArrow());
        console.log('原型传统方法:', person.greetRegular());
    },
    
    /**
     * 调试和性能考虑
     */
    debuggingAndPerformance() {
        console.log('=== 调试和性能考虑 ===');
        
        // 匿名箭头函数难以调试
        const operations = [1, 2, 3, 4, 5];
        
        // ❌ 匿名箭头函数在堆栈跟踪中显示为anonymous
        const anonymousResult = operations
            .filter(n => n > 2)
            .map(n => n * 2)
            .reduce((sum, n) => sum + n, 0);
        
        // ✅ 命名函数便于调试
        function isGreaterThanTwo(n) {
            return n > 2;
        }
        
        function multiplyByTwo(n) {
            return n * 2;
        }
        
        function sum(acc, n) {
            return acc + n;
        }
        
        const namedResult = operations
            .filter(isGreaterThanTwo)
            .map(multiplyByTwo)
            .reduce(sum, 0);
        
        console.log('匿名函数结果:', anonymousResult);
        console.log('命名函数结果:', namedResult);
        
        // 箭头函数的内存考虑
        class EventHandler {
            constructor() {
                this.handlers = [];
            }
            
            // 每次调用都创建新的箭头函数
            addHandlerBad() {
                this.handlers.push(() => {
                    console.log('处理事件');
                });
            }
            
            // 重用箭头函数
            handleEvent = () => {
                console.log('处理事件');
            }
            
            addHandlerGood() {
                this.handlers.push(this.handleEvent);
            }
        }
        
        const handler = new EventHandler();
        handler.addHandlerGood();
        handler.addHandlerGood();
        
        console.log('处理器数量:', handler.handlers.length);
        console.log('处理器相等?:', handler.handlers[0] === handler.handlers[1]);
    }
};

ArrowFunctionLimitations.inappropriateUseCases();
ArrowFunctionLimitations.debuggingAndPerformance();
```

### 实际应用场景

了解箭头函数的最佳使用场景：

```javascript
/**
 * 箭头函数最佳实践
 */
const ArrowFunctionBestPractices = {
    /**
     * 数组方法中的应用
     */
    arrayMethods() {
        console.log('=== 数组方法中的箭头函数 ===');
        
        const products = [
            { name: '笔记本', price: 999, category: '电子' },
            { name: '鼠标', price: 29, category: '电子' },
            { name: '键盘', price: 199, category: '电子' },
            { name: '杯子', price: 15, category: '生活' }
        ];
        
        // 筛选和转换
        const expensiveElectronics = products
            .filter(p => p.category === '电子')
            .filter(p => p.price > 50)
            .map(p => ({ ...p, discountPrice: p.price * 0.9 }))
            .sort((a, b) => b.price - a.price);
        
        console.log('高价电子产品:', expensiveElectronics);
        
        // 数据聚合
        const categoryStats = products.reduce((stats, product) => {
            const category = product.category;
            if (!stats[category]) {
                stats[category] = { count: 0, totalValue: 0, products: [] };
            }
            
            stats[category].count++;
            stats[category].totalValue += product.price;
            stats[category].products.push(product.name);
            
            return stats;
        }, {});
        
        console.log('分类统计:', categoryStats);
    },
    
    /**
     * React/Vue组件中的应用
     */
    componentMethods() {
        console.log('=== 组件中的箭头函数 ===');
        
        // 模拟React组件风格
        class TodoComponent {
            constructor() {
                this.state = {
                    todos: [],
                    newTodo: ''
                };
            }
            
            // 箭头函数自动绑定this
            handleInputChange = (event) => {
                this.setState({
                    newTodo: event.target.value
                });
            }
            
            handleSubmit = (event) => {
                event.preventDefault();
                if (this.state.newTodo.trim()) {
                    this.addTodo(this.state.newTodo);
                    this.setState({ newTodo: '' });
                }
            }
            
            handleToggle = (id) => {
                this.setState({
                    todos: this.state.todos.map(todo =>
                        todo.id === id ? { ...todo, completed: !todo.completed } : todo
                    )
                });
            }
            
            handleDelete = (id) => {
                this.setState({
                    todos: this.state.todos.filter(todo => todo.id !== id)
                });
            }
            
            addTodo(text) {
                const newTodo = {
                    id: Date.now(),
                    text: text,
                    completed: false
                };
                
                this.setState({
                    todos: [...this.state.todos, newTodo]
                });
            }
            
            setState(newState) {
                this.state = { ...this.state, ...newState };
                console.log('State updated:', this.state);
            }
            
            // 模拟组件方法调用
            simulateInteraction() {
                console.log('模拟用户交互:');
                
                // 模拟输入
                this.handleInputChange({ target: { value: '学习JavaScript' } });
                
                // 模拟提交
                this.handleSubmit({ preventDefault: () => {} });
                
                // 模拟切换状态
                this.handleToggle(this.state.todos[0]?.id);
            }
        }
        
        const todoApp = new TodoComponent();
        todoApp.simulateInteraction();
    },
    
    /**
     * 函数式编程中的应用
     */
    functionalProgramming() {
        console.log('=== 函数式编程应用 ===');
        
        // 柯里化函数
        const curry = fn => (...args1) => (...args2) => fn(...args1, ...args2);
        
        const add = (a, b, c) => a + b + c;
        const curriedAdd = curry(add);
        
        console.log('柯里化结果:', curriedAdd(1, 2)(3));
        
        // 组合函数
        const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);
        
        const multiply = x => x * 2;
        const addOne = x => x + 1;
        const square = x => x * x;
        
        const composed = compose(square, addOne, multiply);
        console.log('函数组合结果:', composed(5)); // ((5 * 2) + 1)^2
        
        // 管道函数
        const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);
        
        const piped = pipe(multiply, addOne, square);
        console.log('管道函数结果:', piped(5)); // ((5 * 2) + 1)^2
        
        // 高阶函数
        const createValidator = rule => value => rule(value);
        
        const isRequired = createValidator(val => val != null && val !== '');
        const isEmail = createValidator(val => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(val));
        const minLength = min => createValidator(val => val.length >= min);
        
        const validateInput = (value, validators) => {
            return validators.every(validator => validator(value));
        };
        
        const emailValidators = [isRequired, isEmail];
        const passwordValidators = [isRequired, minLength(8)];
        
        console.log('邮箱验证:', validateInput('test@example.com', emailValidators));
        console.log('密码验证:', validateInput('12345', passwordValidators));
    }
};

ArrowFunctionBestPractices.arrayMethods();
ArrowFunctionBestPractices.componentMethods();
ArrowFunctionBestPractices.functionalProgramming();
```

---

## 8.3 参数、默认参数、剩余参数

JavaScript函数提供了灵活的参数处理机制，ES6进一步增强了参数的功能。

### 基本参数处理

函数参数的基础概念和处理方式：

```javascript
/**
 * 基本参数处理
 */
const BasicParameterHandling = {
    /**
     * 传统参数处理
     */
    traditionalParameters() {
        console.log('=== 传统参数处理 ===');
        
        // 基本参数传递
        function greet(name, message) {
            return `${message}, ${name}!`;
        }
        
        console.log(greet('Alice', 'Hello'));
        console.log(greet('Bob')); // 缺少参数
        console.log(greet('Charlie', 'Hi', 'Extra')); // 多余参数
        
        // arguments对象（仅传统函数）
        function sumAll() {
            let total = 0;
            console.log('参数数量:', arguments.length);
            
            for (let i = 0; i < arguments.length; i++) {
                total += arguments[i];
            }
            
            return total;
        }
        
        console.log('求和结果:', sumAll(1, 2, 3, 4, 5));
        
        // 参数检查
        function divide(a, b) {
            if (arguments.length < 2) {
                throw new Error('需要两个参数');
            }
            
            if (b === 0) {
                throw new Error('除数不能为零');
            }
            
            return a / b;
        }
        
        try {
            console.log('除法结果:', divide(10, 2));
            console.log(divide(10)); // 会抛出错误
        } catch (error) {
            console.log('除法错误:', error.message);
        }
    },
    
    /**
     * 参数类型处理
     */
    parameterTypes() {
        console.log('=== 参数类型处理 ===');
        
        // 类型检查函数
        function processData(data, options) {
            // 参数验证
            if (typeof data !== 'object' || data === null) {
                throw new TypeError('data必须是对象');
            }
            
            if (options && typeof options !== 'object') {
                throw new TypeError('options必须是对象');
            }
            
            // 默认选项
            const defaultOptions = {
                format: 'json',
                validate: true,
                timeout: 5000
            };
            
            const mergedOptions = Object.assign({}, defaultOptions, options);
            
            console.log('处理数据:', data);
            console.log('使用选项:', mergedOptions);
            
            return {
                processed: true,
                data: data,
                options: mergedOptions
            };
        }
        
        const testData = { name: 'test', value: 42 };
        
        console.log(processData(testData));
        console.log(processData(testData, { format: 'xml', timeout: 10000 }));
        
        // 灵活参数处理
        function createUser(...args) {
            let name, age, email;
            
            if (args.length === 1 && typeof args[0] === 'object') {
                // 对象参数
                ({ name, age, email } = args[0]);
            } else if (args.length >= 2) {
                // 位置参数
                [name, age, email] = args;
            } else {
                throw new Error('参数不正确');
            }
            
            return { name, age, email };
        }
        
        console.log('对象参数:', createUser({ name: 'Alice', age: 25, email: 'alice@example.com' }));
        console.log('位置参数:', createUser('Bob', 30, 'bob@example.com'));
    }
};

BasicParameterHandling.traditionalParameters();
BasicParameterHandling.parameterTypes();
```

### 默认参数（Default Parameters）

ES6引入的默认参数功能，简化了参数处理：

```javascript
/**
 * 默认参数详解
 */
const DefaultParameterExamples = {
    /**
     * 基本默认参数
     */
    basicDefaults() {
        console.log('=== 基本默认参数 ===');
        
        // 基本默认参数语法
        function greet(name = 'Guest', message = 'Hello') {
            return `${message}, ${name}!`;
        }
        
        console.log(greet()); // 使用所有默认值
        console.log(greet('Alice')); // 使用部分默认值
        console.log(greet('Bob', 'Hi')); // 不使用默认值
        console.log(greet(undefined, 'Hey')); // 跳过第一个参数
        
        // 表达式作为默认值
        function createTimestamp(prefix = 'LOG', time = new Date()) {
            return `${prefix}: ${time.toISOString()}`;
        }
        
        console.log(createTimestamp());
        setTimeout(() => {
            console.log(createTimestamp('DEBUG'));
        }, 100);
        
        // 函数调用作为默认值
        function getRandomId() {
            return Math.random().toString(36).substr(2, 9);
        }
        
        function createRecord(data, id = getRandomId()) {
            return { id, data, created: new Date() };
        }
        
        console.log(createRecord({ name: 'Alice' }));
        console.log(createRecord({ name: 'Bob' }, 'custom-id'));
    },
    
    /**
     * 复杂默认参数
     */
    complexDefaults() {
        console.log('=== 复杂默认参数 ===');
        
        // 参数之间的依赖
        function createRectangle(width = 10, height = width) {
            return { width, height, area: width * height };
        }
        
        console.log('正方形:', createRectangle(5));
        console.log('矩形:', createRectangle(8, 6));
        console.log('默认正方形:', createRectangle());
        
        // 对象默认参数
        function configureServer(options = {}) {
            const defaults = {
                port: 3000,
                host: 'localhost',
                ssl: false,
                maxConnections: 100
            };
            
            const config = { ...defaults, ...options };
            
            console.log('服务器配置:', config);
            return config;
        }
        
        configureServer();
        configureServer({ port: 8080, ssl: true });
        
        // 解构默认参数
        function processUser({ 
            name = 'Anonymous', 
            age = 0, 
            role = 'user',
            active = true 
        } = {}) {
            const user = { name, age, role, active };
            console.log('处理用户:', user);
            return user;
        }
        
        processUser(); // 完全默认
        processUser({}); // 空对象，使用默认值
        processUser({ name: 'Alice', age: 25 }); // 部分覆盖
        
        // 数组解构默认参数
        function processCoordinates([x = 0, y = 0, z = 0] = []) {
            const coordinates = { x, y, z };
            console.log('坐标处理:', coordinates);
            return coordinates;
        }
        
        processCoordinates(); // 完全默认
        processCoordinates([10, 20]); // 部分提供
        processCoordinates([5, 15, 25]); // 全部提供
    },
    
    /**
     * 默认参数的注意事项
     */
    defaultParameterCaveats() {
        console.log('=== 默认参数注意事项 ===');
        
        // null vs undefined
        function testDefaults(value = 'default') {
            return value;
        }
        
        console.log('undefined参数:', testDefaults(undefined)); // 使用默认值
        console.log('null参数:', testDefaults(null)); // 不使用默认值
        console.log('false参数:', testDefaults(false)); // 不使用默认值
        console.log('0参数:', testDefaults(0)); // 不使用默认值
        
        // 默认参数的作用域
        let outerValue = 'outer';
        
        function scopeTest(param = outerValue) {
            let outerValue = 'inner'; // 不会影响默认参数
            return param;
        }
        
        console.log('作用域测试:', scopeTest());
        
        // 参数顺序的影响
        function orderTest(a = 1, b = a + 1, c = a + b) {
            return { a, b, c };
        }
        
        console.log('参数顺序依赖:', orderTest());
        console.log('参数顺序依赖:', orderTest(5));
        console.log('参数顺序依赖:', orderTest(5, 10));
        
        // 默认参数与arguments
        function argumentsWithDefaults(a = 1, b = 2) {
            console.log('参数列表长度:', arguments.length);
            console.log('实际参数值:', { a, b });
            console.log('arguments内容:', Array.from(arguments));
        }
        
        argumentsWithDefaults();
        argumentsWithDefaults(10);
        argumentsWithDefaults(10, 20);
    }
};

DefaultParameterExamples.basicDefaults();
DefaultParameterExamples.complexDefaults();
DefaultParameterExamples.defaultParameterCaveats();
```

### 剩余参数（Rest Parameters）

剩余参数允许函数接收任意数量的参数：

```javascript
/**
 * 剩余参数详解
 */
const RestParameterExamples = {
    /**
     * 基本剩余参数
     */
    basicRest() {
        console.log('=== 基本剩余参数 ===');
        
        // 基本剩余参数语法
        function sum(...numbers) {
            console.log('剩余参数类型:', typeof numbers);
            console.log('剩余参数是数组?', Array.isArray(numbers));
            
            return numbers.reduce((total, num) => total + num, 0);
        }
        
        console.log('求和结果:', sum(1, 2, 3, 4, 5));
        console.log('空参数求和:', sum());
        
        // 与固定参数组合
        function processData(operation, ...values) {
            console.log(`执行操作: ${operation}`);
            console.log('处理数据:', values);
            
            switch (operation) {
                case 'sum':
                    return values.reduce((a, b) => a + b, 0);
                case 'multiply':
                    return values.reduce((a, b) => a * b, 1);
                case 'average':
                    return values.length ? values.reduce((a, b) => a + b, 0) / values.length : 0;
                default:
                    return values;
            }
        }
        
        console.log(processData('sum', 1, 2, 3, 4));
        console.log(processData('multiply', 2, 3, 4));
        console.log(processData('average', 10, 20, 30));
        
        // 剩余参数与解构
        function analyzeScores(required, optional = 0, ...scores) {
            console.log('必需分数:', required);
            console.log('可选分数:', optional);
            console.log('其他分数:', scores);
            
            const total = required + optional + scores.reduce((a, b) => a + b, 0);
            const count = 2 + scores.length;
            
            return {
                total,
                average: total / count,
                count
            };
        }
        
        console.log(analyzeScores(85, 90, 78, 92, 88));
        console.log(analyzeScores(85));
    },
    
    /**
     * 剩余参数的应用场景
     */
    restApplications() {
        console.log('=== 剩余参数应用场景 ===');
        
        // 日志记录器
        function createLogger(level = 'info') {
            return function log(message, ...details) {
                const timestamp = new Date().toISOString();
                console.log(`[${timestamp}] ${level.toUpperCase()}: ${message}`);
                
                if (details.length > 0) {
                    console.log('详细信息:', ...details);
                }
            };
        }
        
        const logger = createLogger('debug');
        logger('用户登录', { userId: 123, ip: '192.168.1.1' });
        logger('系统启动');
        
        // 函数组合
        function compose(...functions) {
            return function(value) {
                return functions.reduceRight((acc, fn) => fn(acc), value);
            };
        }
        
        const add10 = x => x + 10;
        const multiply2 = x => x * 2;
        const square = x => x * x;
        
        const composedFunction = compose(square, add10, multiply2);
        console.log('函数组合结果:', composedFunction(5)); // ((5 * 2) + 10)^2
        
        // 事件发射器
        class EventEmitter {
            constructor() {
                this.events = {};
            }
            
            on(eventName, callback) {
                if (!this.events[eventName]) {
                    this.events[eventName] = [];
                }
                this.events[eventName].push(callback);
            }
            
            emit(eventName, ...args) {
                const callbacks = this.events[eventName] || [];
                console.log(`触发事件 "${eventName}"，参数:`, args);
                
                callbacks.forEach(callback => {
                    try {
                        callback(...args);
                    } catch (error) {
                        console.error('事件处理错误:', error.message);
                    }
                });
            }
        }
        
        const emitter = new EventEmitter();
        
        emitter.on('user-action', (action, userId, data) => {
            console.log(`用户${userId}执行了${action}:`, data);
        });
        
        emitter.on('user-action', (action) => {
            console.log(`记录操作: ${action}`);
        });
        
        emitter.emit('user-action', 'login', 123, { timestamp: Date.now() });
        
        // 数据验证器
        function createValidator(...rules) {
            return function validate(value) {
                const errors = [];
                
                for (const rule of rules) {
                    try {
                        const result = rule(value);
                        if (result !== true) {
                            errors.push(result);
                        }
                    } catch (error) {
                        errors.push(error.message);
                    }
                }
                
                return {
                    isValid: errors.length === 0,
                    errors
                };
            };
        }
        
        const required = value => value != null && value !== '' || '字段为必填项';
        const minLength = min => value => value.length >= min || `最少需要${min}个字符`;
        const isEmail = value => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value) || '邮箱格式不正确';
        
        const emailValidator = createValidator(required, isEmail);
        const passwordValidator = createValidator(required, minLength(8));
        
        console.log('邮箱验证:', emailValidator('test@example.com'));
        console.log('密码验证:', passwordValidator('123'));
    },
    
    /**
     * 剩余参数与展开操作符
     */
    restAndSpread() {
        console.log('=== 剩余参数与展开操作符 ===');
        
        // 数组处理
        function mergeArrays(...arrays) {
            // 使用展开操作符合并数组
            return [].concat(...arrays);
        }
        
        const arr1 = [1, 2, 3];
        const arr2 = [4, 5, 6];
        const arr3 = [7, 8, 9];
        
        console.log('合并数组:', mergeArrays(arr1, arr2, arr3));
        
        // 对象处理
        function mergeObjects(...objects) {
            return Object.assign({}, ...objects);
        }
        
        const obj1 = { a: 1, b: 2 };
        const obj2 = { c: 3, d: 4 };
        const obj3 = { e: 5, f: 6 };
        
        console.log('合并对象:', mergeObjects(obj1, obj2, obj3));
        
        // 数学运算
        function mathOperations(operation, ...numbers) {
            switch (operation) {
                case 'max':
                    return Math.max(...numbers);
                case 'min':
                    return Math.min(...numbers);
                case 'sum':
                    return numbers.reduce((a, b) => a + b, 0);
                case 'product':
                    return numbers.reduce((a, b) => a * b, 1);
                default:
                    return NaN;
            }
        }
        
        const testNumbers = [3, 7, 1, 9, 4, 6];
        
        console.log('最大值:', mathOperations('max', ...testNumbers));
        console.log('最小值:', mathOperations('min', ...testNumbers));
        console.log('总和:', mathOperations('sum', ...testNumbers));
        console.log('乘积:', mathOperations('product', 2, 3, 4));
    }
};

RestParameterExamples.basicRest();
RestParameterExamples.restApplications();
RestParameterExamples.restAndSpread();
```

### 参数解构

参数解构提供了更灵活的参数处理方式：

```javascript
/**
 * 参数解构详解
 */
const ParameterDestructuringExamples = {
    /**
     * 对象参数解构
     */
    objectDestructuring() {
        console.log('=== 对象参数解构 ===');
        
        // 基本对象解构
        function createUser({ name, age, email, role = 'user' }) {
            return {
                id: Math.random().toString(36).substr(2, 9),
                name,
                age,
                email,
                role,
                createdAt: new Date()
            };
        }
        
        const userData = { name: 'Alice', age: 25, email: 'alice@example.com' };
        console.log('创建用户:', createUser(userData));
        
        // 嵌套对象解构
        function processConfig({ 
            server: { host, port, ssl = false } = {},
            database: { type, connection } = {},
            logging: { level = 'info', enabled = true } = {}
        }) {
            return {
                serverConfig: { host, port, ssl },
                databaseConfig: { type, connection },
                loggingConfig: { level, enabled }
            };
        }
        
        const config = {
            server: { host: 'localhost', port: 3000 },
            database: { type: 'mongodb', connection: 'mongodb://localhost:27017' },
            logging: { level: 'debug' }
        };
        
        console.log('处理配置:', processConfig(config));
        
        // 重命名解构参数
        function calculateArea({ width: w, height: h, type = 'rectangle' }) {
            console.log(`计算${type}面积: 宽=${w}, 高=${h}`);
            
            switch (type) {
                case 'rectangle':
                    return w * h;
                case 'triangle':
                    return (w * h) / 2;
                case 'circle':
                    return Math.PI * w * w; // w作为半径
                default:
                    return 0;
            }
        }
        
        console.log('矩形面积:', calculateArea({ width: 10, height: 8 }));
        console.log('三角形面积:', calculateArea({ width: 10, height: 8, type: 'triangle' }));
    },
    
    /**
     * 数组参数解构
     */
    arrayDestructuring() {
        console.log('=== 数组参数解构 ===');
        
        // 基本数组解构
        function processCoordinates([x, y, z = 0]) {
            return {
                x: x || 0,
                y: y || 0,
                z: z,
                distance: Math.sqrt(x*x + y*y + z*z)
            };
        }
        
        console.log('2D坐标:', processCoordinates([3, 4]));
        console.log('3D坐标:', processCoordinates([3, 4, 5]));
        
        // 跳过数组元素
        function processMatrix([[a, b], [, d], [e]]) {
            console.log('矩阵元素:', { a, b, d, e });
            return { a, b, d, e };
        }
        
        const matrix = [
            [1, 2],
            [3, 4],
            [5, 6]
        ];
        
        processMatrix(matrix);
        
        // 剩余参数与解构结合
        function processNumbers([first, second, ...rest]) {
            console.log('第一个数:', first);
            console.log('第二个数:', second);
            console.log('其余数字:', rest);
            
            return {
                first: first || 0,
                second: second || 0,
                sum: rest.reduce((a, b) => a + b, (first || 0) + (second || 0))
            };
        }
        
        console.log('数字处理:', processNumbers([1, 2, 3, 4, 5, 6]));
    },
    
    /**
     * 混合解构模式
     */
    mixedDestructuring() {
        console.log('=== 混合解构模式 ===');
        
        // 对象和数组混合解构
        function processOrder({
            id,
            customer: { name, email },
            items: [firstItem, ...otherItems],
            shipping = {}
        }) {
            const { method = 'standard', cost = 0 } = shipping;
            
            return {
                orderId: id,
                customerName: name,
                customerEmail: email,
                primaryItem: firstItem,
                additionalItems: otherItems.length,
                shippingMethod: method,
                shippingCost: cost
            };
        }
        
        const order = {
            id: 'ORD-001',
            customer: { name: 'John Doe', email: 'john@example.com' },
            items: [
                { name: 'Laptop', price: 999 },
                { name: 'Mouse', price: 29 },
                { name: 'Keyboard', price: 79 }
            ],
            shipping: { method: 'express', cost: 15 }
        };
        
        console.log('订单处理:', processOrder(order));
        
        // 函数参数的深度解构
        function analyzeData({
            dataset: {
                name: datasetName,
                records: [firstRecord, ...remainingRecords] = []
            },
            options: {
                analysis = ['mean', 'median'],
                output = { format: 'json', decimals: 2 }
            } = {}
        }) {
            console.log('数据集名称:', datasetName);
            console.log('第一条记录:', firstRecord);
            console.log('剩余记录数:', remainingRecords.length);
            console.log('分析类型:', analysis);
            console.log('输出配置:', output);
            
            return {
                datasetName,
                recordCount: remainingRecords.length + (firstRecord ? 1 : 0),
                analysisTypes: analysis,
                outputConfig: output
            };
        }
        
        const analysisInput = {
            dataset: {
                name: 'Sales Data 2023',
                records: [
                    { id: 1, value: 100 },
                    { id: 2, value: 200 },
                    { id: 3, value: 150 }
                ]
            },
            options: {
                analysis: ['mean', 'sum', 'max'],
                output: { format: 'csv' }
            }
        };
        
        console.log('数据分析:', analyzeData(analysisInput));
    }
};

ParameterDestructuringExamples.objectDestructuring();
ParameterDestructuringExamples.arrayDestructuring();
ParameterDestructuringExamples.mixedDestructuring();
```

---

## 8.4 返回值与执行流程

函数的返回值和执行流程是理解JavaScript运行机制的关键。

### 函数返回值

JavaScript函数可以返回各种类型的值，包括基本类型、对象、函数等：

```javascript
/**
 * 函数返回值详解
 */
const FunctionReturnValues = {
    /**
     * 基本返回值类型
     */
    basicReturns() {
        console.log('=== 基本返回值 ===');
        
        // 返回基本类型
        function getNumber() {
            return 42;
        }
        
        function getString() {
            return 'Hello World';
        }
        
        function getBoolean() {
            return true;
        }
        
        function getUndefined() {
            // 没有return语句，返回undefined
        }
        
        function getNull() {
            return null;
        }
        
        console.log('数字:', getNumber());
        console.log('字符串:', getString());
        console.log('布尔值:', getBoolean());
        console.log('undefined:', getUndefined());
        console.log('null:', getNull());
        
        // 条件返回
        function getAbsoluteValue(number) {
            if (number >= 0) {
                return number;
            }
            return -number;
        }
        
        console.log('绝对值 -5:', getAbsoluteValue(-5));
        console.log('绝对值 3:', getAbsoluteValue(3));
        
        // 多个返回点
        function categorizeAge(age) {
            if (age < 0) {
                return 'invalid';
            }
            
            if (age < 13) {
                return 'child';
            }
            
            if (age < 20) {
                return 'teenager';
            }
            
            if (age < 60) {
                return 'adult';
            }
            
            return 'senior';
        }
        
        console.log('年龄分类:', [5, 15, 25, 65].map(categorizeAge));
    },
    
    /**
     * 返回复杂类型
     */
    complexReturns() {
        console.log('=== 复杂返回值 ===');
        
        // 返回对象
        function createUser(name, age) {
            return {
                id: Math.random().toString(36).substr(2, 9),
                name: name,
                age: age,
                createdAt: new Date(),
                greet: function() {
                    return `Hello, I'm ${this.name}`;
                }
            };
        }
        
        const user = createUser('Alice', 25);
        console.log('用户对象:', user);
        console.log('用户问候:', user.greet());
        
        // 返回数组
        function getRange(start, end) {
            const result = [];
            for (let i = start; i <= end; i++) {
                result.push(i);
            }
            return result;
        }
        
        console.log('数字范围:', getRange(1, 5));
        
        // 返回函数（高阶函数）
        function createMultiplier(factor) {
            return function(number) {
                return number * factor;
            };
        }
        
        const double = createMultiplier(2);
        const triple = createMultiplier(3);
        
        console.log('双倍函数:', double(5));
        console.log('三倍函数:', triple(4));
        
        // 返回Promise
        function fetchData(url) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    if (url.startsWith('http')) {
                        resolve({ data: `Data from ${url}`, status: 200 });
                    } else {
                        reject(new Error('Invalid URL'));
                    }
                }, 100);
            });
        }
        
        fetchData('https://api.example.com')
            .then(result => console.log('Promise结果:', result))
            .catch(error => console.log('Promise错误:', error.message));
        
        // 返回生成器
        function* createGenerator(count) {
            for (let i = 1; i <= count; i++) {
                yield i * i;
            }
            return 'Generator completed';
        }
        
        const generator = createGenerator(3);
        console.log('生成器返回值:');
        for (const value of generator) {
            console.log('  生成:', value);
        }
    },
    
    /**
     * 解构返回值
     */
    destructuredReturns() {
        console.log('=== 解构返回值 ===');
        
        // 返回数组供解构
        function getCoordinates() {
            return [10, 20, 30];
        }
        
        const [x, y, z] = getCoordinates();
        console.log('坐标解构:', { x, y, z });
        
        // 返回对象供解构
        function getUserInfo() {
            return {
                name: 'Bob',
                age: 30,
                email: 'bob@example.com',
                preferences: {
                    theme: 'dark',
                    language: 'en'
                }
            };
        }
        
        const { name, age, preferences: { theme } } = getUserInfo();
        console.log('用户信息解构:', { name, age, theme });
        
        // 返回多个值的模式
        function divideWithRemainder(dividend, divisor) {
            return {
                quotient: Math.floor(dividend / divisor),
                remainder: dividend % divisor,
                isExact: dividend % divisor === 0
            };
        }
        
        const { quotient, remainder, isExact } = divideWithRemainder(17, 5);
        console.log('除法结果:', { quotient, remainder, isExact });
        
        // 链式返回
        class Calculator {
            constructor(initial = 0) {
                this.value = initial;
            }
            
            add(num) {
                this.value += num;
                return this; // 返回this实现链式调用
            }
            
            multiply(num) {
                this.value *= num;
                return this;
            }
            
            subtract(num) {
                this.value -= num;
                return this;
            }
            
            getResult() {
                return this.value;
            }
        }
        
        const result = new Calculator(10)
            .add(5)
            .multiply(2)
            .subtract(3)
            .getResult();
        
        console.log('链式计算结果:', result);
    }
};

FunctionReturnValues.basicReturns();
FunctionReturnValues.complexReturns();
FunctionReturnValues.destructuredReturns();
```

### 执行上下文

每个函数调用都会创建一个新的执行上下文：

```javascript
/**
 * 执行上下文示例
 */
const ExecutionContextExamples = {
    /**
     * 作用域链演示
     */
    scopeChainDemo() {
        console.log('=== 作用域链演示 ===');
        
        let globalVar = 'global';
        
        function outerFunction() {
            let outerVar = 'outer';
            console.log('外层函数中访问:', { globalVar, outerVar });
            
            function innerFunction() {
                let innerVar = 'inner';
                console.log('内层函数中访问:', { globalVar, outerVar, innerVar });
                
                function deepestFunction() {
                    let deepestVar = 'deepest';
                    console.log('最深层函数中访问:', { 
                        globalVar, outerVar, innerVar, deepestVar 
                    });
                }
                
                deepestFunction();
            }
            
            innerFunction();
        }
        
        outerFunction();
    },
    
    /**
     * 变量提升演示
     */
    hoistingDemo() {
        console.log('=== 变量提升演示 ===');
        
        function demonstrateHoisting() {
            console.log('声明前访问函数:', typeof hoistedFunction);
            console.log('声明前访问var变量:', hoistedVar);
            
            try {
                console.log('声明前访问let变量:', letVar);
            } catch (error) {
                console.log('let变量访问错误:', error.message);
            }
            
            // 函数声明被提升
            function hoistedFunction() {
                return 'I am hoisted!';
            }
            
            // var变量声明被提升，但赋值不会
            var hoistedVar = 'var value';
            
            // let/const存在暂时性死区
            let letVar = 'let value';
            
            console.log('声明后访问:', {
                func: hoistedFunction(),
                varVar: hoistedVar,
                letVar: letVar
            });
        }
        
        demonstrateHoisting();
    },
    
    /**
     * 执行上下文栈
     */
    executionStack() {
        console.log('=== 执行上下文栈 ===');
        
        function first() {
            console.log('执行 first() - 开始');
            second();
            console.log('执行 first() - 结束');
        }
        
        function second() {
            console.log('执行 second() - 开始');
            third();
            console.log('执行 second() - 结束');
        }
        
        function third() {
            console.log('执行 third() - 开始');
            console.log('调用栈最深处');
            console.log('执行 third() - 结束');
        }
        
        console.log('程序开始执行');
        first();
        console.log('程序执行结束');
    }
};

ExecutionContextExamples.scopeChainDemo();
ExecutionContextExamples.hoistingDemo();
ExecutionContextExamples.executionStack();
```

### 调用栈

调用栈管理函数的执行顺序和嵌套关系：

```javascript
/**
 * 调用栈详解
 */
const CallStackExamples = {
    /**
     * 基本调用栈
     */
    basicCallStack() {
        console.log('=== 基本调用栈 ===');
        
        function trackCalls(name) {
            console.log(`进入 ${name}`);
            
            // 模拟获取调用栈信息
            const stack = new Error().stack;
            const lines = stack.split('\n').slice(1, 4);
            console.log('当前调用栈片段:');
            lines.forEach((line, index) => {
                console.log(`  ${index + 1}. ${line.trim()}`);
            });
            
            console.log(`退出 ${name}`);
        }
        
        function levelThree() {
            trackCalls('levelThree');
        }
        
        function levelTwo() {
            trackCalls('levelTwo');
            levelThree();
        }
        
        function levelOne() {
            trackCalls('levelOne');
            levelTwo();
        }
        
        levelOne();
    },
    
    /**
     * 栈溢出演示
     */
    stackOverflowDemo() {
        console.log('=== 栈溢出演示 ===');
        
        // 无限递归会导致栈溢出
        function infiniteRecursion(count = 0) {
            if (count > 10) { // 限制递归深度避免实际溢出
                console.log('停止递归以避免栈溢出');
                return;
            }
            console.log(`递归深度: ${count}`);
            return infiniteRecursion(count + 1);
        }
        
        try {
            infiniteRecursion();
        } catch (error) {
            console.log('栈溢出错误:', error.message);
        }
        
        // 尾递归优化示例（理论上的）
        function tailRecursionSum(n, accumulator = 0) {
            if (n <= 0) {
                return accumulator;
            }
            // 这是尾递归形式，但JavaScript引擎可能不会优化
            return tailRecursionSum(n - 1, accumulator + n);
        }
        
        console.log('尾递归求和 1-100:', tailRecursionSum(100));
        
        // 使用循环避免递归
        function iterativeSum(n) {
            let result = 0;
            for (let i = 1; i <= n; i++) {
                result += i;
            }
            return result;
        }
        
        console.log('循环求和 1-100:', iterativeSum(100));
    },
    
    /**
     * 异步调用栈
     */
    asyncCallStack() {
        console.log('=== 异步调用栈 ===');
        
        function syncFunction() {
            console.log('1. 同步函数执行');
        }
        
        function asyncFunction() {
            console.log('2. 异步函数开始');
            
            setTimeout(() => {
                console.log('4. setTimeout回调执行');
            }, 0);
            
            Promise.resolve().then(() => {
                console.log('3. Promise回调执行（微任务）');
            });
            
            console.log('2.5. 异步函数结束');
        }
        
        console.log('开始执行');
        syncFunction();
        asyncFunction();
        console.log('主线程执行完毕');
        
        // 展示事件循环的影响
        setTimeout(() => {
            console.log('=== 事件循环完成 ===');
        }, 10);
    }
};

CallStackExamples.basicCallStack();
CallStackExamples.stackOverflowDemo();
CallStackExamples.asyncCallStack();
```

### 递归函数

递归是函数调用自身的编程技术：

```javascript
/**
 * 递归函数详解
 */
const RecursiveFunctionExamples = {
    /**
     * 基础递归
     */
    basicRecursion() {
        console.log('=== 基础递归 ===');
        
        // 阶乘计算
        function factorial(n) {
            // 基础条件（递归终止条件）
            if (n <= 1) {
                return 1;
            }
            
            // 递归条件
            return n * factorial(n - 1);
        }
        
        console.log('阶乘计算:');
        [1, 2, 3, 4, 5].forEach(n => {
            console.log(`${n}! = ${factorial(n)}`);
        });
        
        // 斐波那契数列
        function fibonacci(n) {
            if (n <= 1) {
                return n;
            }
            
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
        
        console.log('斐波那契数列:');
        for (let i = 0; i < 8; i++) {
            console.log(`F(${i}) = ${fibonacci(i)}`);
        }
        
        // 优化版斐波那契（记忆化）
        function fibonacciMemoized() {
            const cache = {};
            
            function fib(n) {
                if (n <= 1) return n;
                
                if (cache[n]) {
                    return cache[n];
                }
                
                cache[n] = fib(n - 1) + fib(n - 2);
                return cache[n];
            }
            
            return fib;
        }
        
        const fastFib = fibonacciMemoized();
        console.log('优化版斐波那契 F(10):', fastFib(10));
    },
    
    /**
     * 树形结构递归
     */
    treeRecursion() {
        console.log('=== 树形结构递归 ===');
        
        const fileSystem = {
            name: 'root',
            type: 'folder',
            children: [
                {
                    name: 'documents',
                    type: 'folder',
                    children: [
                        { name: 'readme.txt', type: 'file', size: 1024 },
                        { name: 'manual.pdf', type: 'file', size: 2048 }
                    ]
                },
                {
                    name: 'photos',
                    type: 'folder',
                    children: [
                        { name: 'vacation.jpg', type: 'file', size: 3072 },
                        { name: 'family.png', type: 'file', size: 1536 }
                    ]
                },
                { name: 'config.json', type: 'file', size: 512 }
            ]
        };
        
        // 递归遍历文件系统
        function traverseFileSystem(node, depth = 0) {
            const indent = '  '.repeat(depth);
            
            if (node.type === 'folder') {
                console.log(`${indent}📁 ${node.name}/`);
                
                if (node.children) {
                    node.children.forEach(child => {
                        traverseFileSystem(child, depth + 1);
                    });
                }
            } else {
                console.log(`${indent}📄 ${node.name} (${node.size} bytes)`);
            }
        }
        
        console.log('文件系统结构:');
        traverseFileSystem(fileSystem);
        
        // 计算文件夹总大小
        function calculateSize(node) {
            if (node.type === 'file') {
                return node.size;
            }
            
            if (node.type === 'folder' && node.children) {
                return node.children.reduce((total, child) => {
                    return total + calculateSize(child);
                }, 0);
            }
            
            return 0;
        }
        
        console.log('文件系统总大小:', calculateSize(fileSystem), 'bytes');
        
        // 查找文件
        function findFile(node, filename) {
            if (node.type === 'file' && node.name === filename) {
                return node;
            }
            
            if (node.type === 'folder' && node.children) {
                for (const child of node.children) {
                    const found = findFile(child, filename);
                    if (found) {
                        return found;
                    }
                }
            }
            
            return null;
        }
        
        const found = findFile(fileSystem, 'vacation.jpg');
        console.log('查找文件结果:', found);
    },
    
    /**
     * 递归优化技巧
     */
    recursionOptimization() {
        console.log('=== 递归优化技巧 ===');
        
        // 尾递归优化
        function sumTailRecursive(n, accumulator = 0) {
            if (n <= 0) {
                return accumulator;
            }
            
            return sumTailRecursive(n - 1, accumulator + n);
        }
        
        console.log('尾递归求和:', sumTailRecursive(100));
        
        // 使用蹦床技术避免栈溢出
        function trampoline(fn) {
            return function(...args) {
                let result = fn(...args);
                
                while (typeof result === 'function') {
                    result = result();
                }
                
                return result;
            };
        }
        
        function factorialTrampoline(n, acc = 1) {
            if (n <= 1) {
                return acc;
            }
            
            return () => factorialTrampoline(n - 1, n * acc);
        }
        
        const trampolineFactorial = trampoline(factorialTrampoline);
        console.log('蹦床技术阶乘:', trampolineFactorial(10));
        
        // 迭代替代递归
        function fibonacciIterative(n) {
            if (n <= 1) return n;
            
            let prev = 0;
            let curr = 1;
            
            for (let i = 2; i <= n; i++) {
                const temp = prev + curr;
                prev = curr;
                curr = temp;
            }
            
            return curr;
        }
        
        console.log('迭代版斐波那契 F(10):', fibonacciIterative(10));
        
        // 递归深度限制
        function safeRecursion(fn, maxDepth = 1000) {
            let currentDepth = 0;
            
            return function recursiveWrapper(...args) {
                currentDepth++;
                
                if (currentDepth > maxDepth) {
                    currentDepth--;
                    throw new Error(`递归深度超过限制: ${maxDepth}`);
                }
                
                try {
                    const result = fn.apply(this, args);
                    currentDepth--;
                    return result;
                } catch (error) {
                    currentDepth--;
                    throw error;
                }
            };
        }
        
        const safeFactorial = safeRecursion(function(n) {
            if (n <= 1) return 1;
            return n * safeFactorial(n - 1);
        }, 10);
        
        try {
            console.log('安全递归 5!:', safeFactorial(5));
            safeFactorial(15); // 这会抛出错误
        } catch (error) {
            console.log('递归限制错误:', error.message);
        }
    }
};

RecursiveFunctionExamples.basicRecursion();
RecursiveFunctionExamples.treeRecursion();
RecursiveFunctionExamples.recursionOptimization();
```

---

## 8.5 闭包（Closure）基础

闭包是JavaScript最重要的概念之一，理解闭包对掌握高级编程技巧至关重要。

### 闭包的概念

闭包是指函数能够访问其外部作用域变量的特性：

```javascript
/**
 * 闭包基础概念
 */
const ClosureBasics = {
    /**
     * 基本闭包示例
     */
    basicClosure() {
        console.log('=== 基本闭包 ===');
        
        function outerFunction(x) {
            // 外部函数的变量
            
            function innerFunction(y) {
                // 内部函数可以访问外部函数的参数和变量
                return x + y;
            }
            
            return innerFunction;
        }
        
        const addFive = outerFunction(5);
        console.log('闭包计算:', addFive(3)); // 输出 8
        
        // 即使outerFunction执行完毕，闭包仍然保持对x的引用
        const addTen = outerFunction(10);
        console.log('另一个闭包:', addTen(3)); // 输出 13
    },
    
    /**
     * 闭包的作用域保持
     */
    scopePersistence() {
        console.log('=== 闭包作用域保持 ===');
        
        function createCounter() {
            let count = 0;
            
            return {
                increment: function() {
                    count++;
                    return count;
                },
                decrement: function() {
                    count--;
                    return count;
                },
                getCount: function() {
                    return count;
                }
            };
        }
        
        const counter1 = createCounter();
        const counter2 = createCounter();
        
        console.log('counter1 初始:', counter1.getCount());
        console.log('counter1 增加:', counter1.increment());
        console.log('counter1 增加:', counter1.increment());
        
        console.log('counter2 初始:', counter2.getCount());
        console.log('counter2 减少:', counter2.decrement());
        
        console.log('counter1 最终:', counter1.getCount());
        console.log('counter2 最终:', counter2.getCount());
    },
    
    /**
     * 闭包与循环
     */
    closureInLoops() {
        console.log('=== 闭包与循环 ===');
        
        // ❌ 常见错误：循环中的闭包
        console.log('错误示例:');
        const functions1 = [];
        
        for (var i = 0; i < 3; i++) {
            functions1.push(function() {
                return i; // 所有函数都引用同一个i
            });
        }
        
        functions1.forEach((fn, index) => {
            console.log(`函数 ${index} 返回:`, fn()); // 都返回3
        });
        
        // ✅ 正确方式1：使用let
        console.log('使用let解决:');
        const functions2 = [];
        
        for (let i = 0; i < 3; i++) {
            functions2.push(function() {
                return i; // 每个i都有独立的作用域
            });
        }
        
        functions2.forEach((fn, index) => {
            console.log(`函数 ${index} 返回:`, fn());
        });
        
        // ✅ 正确方式2：使用IIFE
        console.log('使用IIFE解决:');
        const functions3 = [];
        
        for (var i = 0; i < 3; i++) {
            functions3.push((function(index) {
                return function() {
                    return index;
                };
            })(i));
        }
        
        functions3.forEach((fn, index) => {
            console.log(`函数 ${index} 返回:`, fn());
        });
    }
};

ClosureBasics.basicClosure();
ClosureBasics.scopePersistence();
ClosureBasics.closureInLoops();
```

### 闭包的形成条件

闭包的形成需要满足特定条件：

```javascript
/**
 * 闭包形成条件详解
 */
const ClosureFormation = {
    /**
     * 闭包形成的必要条件
     */
    formationConditions() {
        console.log('=== 闭包形成条件 ===');
        
        // 条件1：嵌套函数
        // 条件2：内部函数引用外部函数的变量
        // 条件3：内部函数被外部函数返回或以其他方式暴露
        
        function createClosure() {
            let privateVar = 'I am private';
            
            // 内部函数引用外部变量
            return function() {
                return privateVar;
            };
        }
        
        const closure = createClosure();
        console.log('闭包访问私有变量:', closure());
        
        // 无法直接访问privateVar
        try {
            console.log(privateVar);
        } catch (error) {
            console.log('无法直接访问:', error.message);
        }
    },
    
    /**
     * 多层嵌套闭包
     */
    nestedClosures() {
        console.log('=== 多层嵌套闭包 ===');
        
        function level1(a) {
            console.log('Level 1, a =', a);
            
            function level2(b) {
                console.log('Level 2, a =', a, ', b =', b);
                
                function level3(c) {
                    console.log('Level 3, a =', a, ', b =', b, ', c =', c);
                    return a + b + c;
                }
                
                return level3;
            }
            
            return level2;
        }
        
        const fn1 = level1(1);
        const fn2 = fn1(2);
        const result = fn2(3);
        
        console.log('多层闭包结果:', result);
        
        // 链式调用
        const chainResult = level1(10)(20)(30);
        console.log('链式调用结果:', chainResult);
    },
    
    /**
     * 闭包与this
     */
    closureWithThis() {
        console.log('=== 闭包与this ===');
        
        const obj = {
            name: 'MyObject',
            
            // 传统函数方法
            createClosure: function() {
                console.log('createClosure中的this.name:', this.name);
                
                // 内部函数的this不指向obj
                return function() {
                    console.log('闭包中的this.name:', this.name);
                    return 'closure result';
                };
            },
            
            // 箭头函数保持this
            createArrowClosure: function() {
                console.log('createArrowClosure中的this.name:', this.name);
                
                return () => {
                    console.log('箭头函数闭包中的this.name:', this.name);
                    return 'arrow closure result';
                };
            },
            
            // 保存this引用
            createBoundClosure: function() {
                const self = this;
                
                return function() {
                    console.log('保存引用的闭包中的name:', self.name);
                    return 'bound closure result';
                };
            }
        };
        
        const closure1 = obj.createClosure();
        const closure2 = obj.createArrowClosure();
        const closure3 = obj.createBoundClosure();
        
        closure1();
        closure2();
        closure3();
    }
};

ClosureFormation.formationConditions();
ClosureFormation.nestedClosures();
ClosureFormation.closureWithThis();
```

### 闭包的实际应用

闭包在实际开发中有许多重要应用：

```javascript
/**
 * 闭包实际应用
 */
const ClosureApplications = {
    /**
     * 模块模式
     */
    modulePattern() {
        console.log('=== 模块模式 ===');
        
        // 使用闭包创建模块
        const UserModule = (function() {
            // 私有变量
            let users = [];
            let nextId = 1;
            
            // 私有方法
            function generateId() {
                return nextId++;
            }
            
            function validateUser(user) {
                return user.name && user.email;
            }
            
            // 公共API
            return {
                addUser: function(name, email) {
                    const user = { id: generateId(), name, email };
                    
                    if (validateUser(user)) {
                        users.push(user);
                        console.log('用户添加成功:', user);
                        return user;
                    } else {
                        console.log('用户验证失败');
                        return null;
                    }
                },
                
                getUser: function(id) {
                    return users.find(user => user.id === id);
                },
                
                getAllUsers: function() {
                    return [...users]; // 返回副本，保护内部数据
                },
                
                removeUser: function(id) {
                    const index = users.findIndex(user => user.id === id);
                    if (index !== -1) {
                        const removed = users.splice(index, 1)[0];
                        console.log('用户删除成功:', removed);
                        return removed;
                    }
                    return null;
                }
            };
        })();
        
        // 使用模块
        UserModule.addUser('Alice', 'alice@example.com');
        UserModule.addUser('Bob', 'bob@example.com');
        
        console.log('所有用户:', UserModule.getAllUsers());
        console.log('获取用户1:', UserModule.getUser(1));
        
        UserModule.removeUser(1);
        console.log('删除后的用户:', UserModule.getAllUsers());
    },
    
    /**
     * 函数工厂
     */
    functionFactory() {
        console.log('=== 函数工厂 ===');
        
        // 创建验证器工厂
        function createValidator(type) {
            switch (type) {
                case 'email':
                    return function(value) {
                        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                        return {
                            isValid: emailRegex.test(value),
                            message: emailRegex.test(value) ? '邮箱格式正确' : '邮箱格式错误'
                        };
                    };
                    
                case 'phone':
                    return function(value) {
                        const phoneRegex = /^1[3-9]\d{9}$/;
                        return {
                            isValid: phoneRegex.test(value),
                            message: phoneRegex.test(value) ? '手机号格式正确' : '手机号格式错误'
                        };
                    };
                    
                case 'password':
                    return function(value) {
                        const isValid = value.length >= 8 && /[A-Z]/.test(value) && /[a-z]/.test(value) && /[0-9]/.test(value);
                        return {
                            isValid: isValid,
                            message: isValid ? '密码强度合格' : '密码需包含大小写字母和数字，至少8位'
                        };
                    };
                    
                default:
                    return function() {
                        return { isValid: false, message: '未知验证类型' };
                    };
            }
        }
        
        const emailValidator = createValidator('email');
        const phoneValidator = createValidator('phone');
        const passwordValidator = createValidator('password');
        
        console.log('邮箱验证:', emailValidator('test@example.com'));
        console.log('手机号验证:', phoneValidator('13812345678'));
        console.log('密码验证:', passwordValidator('Password123'));
        
        // 创建配置器工厂
        function createConfigManager(defaultConfig) {
            let config = { ...defaultConfig };
            
            return {
                get: function(key) {
                    return key ? config[key] : { ...config };
                },
                
                set: function(key, value) {
                    if (typeof key === 'object') {
                        config = { ...config, ...key };
                    } else {
                        config[key] = value;
                    }
                },
                
                reset: function() {
                    config = { ...defaultConfig };
                },
                
                has: function(key) {
                    return key in config;
                }
            };
        }
        
        const appConfig = createConfigManager({
            theme: 'light',
            language: 'zh-CN',
            debug: false
        });
        
        console.log('初始配置:', appConfig.get());
        
        appConfig.set('theme', 'dark');
        appConfig.set({ language: 'en-US', debug: true });
        
        console.log('修改后配置:', appConfig.get());
        console.log('主题配置:', appConfig.get('theme'));
    },
    
    /**
     * 缓存和记忆化
     */
    memoization() {
        console.log('=== 缓存和记忆化 ===');
        
        // 通用记忆化函数
        function memoize(fn) {
            const cache = new Map();
            
            return function(...args) {
                const key = JSON.stringify(args);
                
                if (cache.has(key)) {
                    console.log(`缓存命中: ${key}`);
                    return cache.get(key);
                }
                
                console.log(`计算结果: ${key}`);
                const result = fn.apply(this, args);
                cache.set(key, result);
                
                return result;
            };
        }
        
        // 斐波那契数列（记忆化版本）
        const fibonacciMemo = memoize(function(n) {
            if (n <= 1) return n;
            return fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
        });
        
        console.log('斐波那契F(10):', fibonacciMemo(10));
        console.log('斐波那契F(10)再次:', fibonacciMemo(10)); // 缓存命中
        
        // 带有TTL的缓存
        function createTTLCache(ttl = 5000) {
            const cache = new Map();
            
            return function(key, generator) {
                const now = Date.now();
                
                if (cache.has(key)) {
                    const { value, timestamp } = cache.get(key);
                    
                    if (now - timestamp < ttl) {
                        console.log(`TTL缓存命中: ${key}`);
                        return value;
                    } else {
                        cache.delete(key);
                    }
                }
                
                console.log(`TTL缓存生成: ${key}`);
                const value = generator();
                cache.set(key, { value, timestamp: now });
                
                return value;
            };
        }
        
        const ttlCache = createTTLCache(2000);
        
        const data1 = ttlCache('user:123', () => ({ id: 123, name: 'Alice' }));
        console.log('TTL缓存数据:', data1);
        
        const data2 = ttlCache('user:123', () => ({ id: 123, name: 'Alice' }));
        console.log('TTL缓存数据再次:', data2);
    }
};

ClosureApplications.modulePattern();
ClosureApplications.functionFactory();
ClosureApplications.memoization();
```

### 闭包的注意事项

使用闭包时需要注意内存和性能问题：

```javascript
/**
 * 闭包注意事项
 */
const ClosureCaveats = {
    /**
     * 内存泄漏问题
     */
    memoryLeaks() {
        console.log('=== 内存泄漏问题 ===');
        
        // ❌ 可能导致内存泄漏的情况
        function createLeakyFunction() {
            const largeData = new Array(1000000).fill('data');
            let count = 0;
            
            // 即使只用到count，整个largeData也被引用
            return function() {
                count++;
                return count;
            };
        }
        
        // ✅ 改进版本：只保留需要的数据
        function createOptimizedFunction() {
            let count = 0;
            
            return function() {
                count++;
                return count;
            };
        }
        
        console.log('创建优化版闭包');
        const optimizedFn = createOptimizedFunction();
        console.log('调用次数:', optimizedFn());
        
        // DOM引用导致的内存泄漏示例
        function attachEventHandler() {
            const element = { id: 'button', data: new Array(10000).fill('data') };
            
            // ❌ 闭包引用了整个element对象
            const badHandler = function() {
                console.log(`处理${element.id}的事件`);
            };
            
            // ✅ 只保留需要的属性
            const elementId = element.id;
            const goodHandler = function() {
                console.log(`处理${elementId}的事件`);
            };
            
            return goodHandler;
        }
        
        const handler = attachEventHandler();
        handler();
    },
    
    /**
     * 性能考虑
     */
    performanceConsiderations() {
        console.log('=== 性能考虑 ===');
        
        // 闭包创建的性能成本
        function measureClosureCreation() {
            const iterations = 100000;
            
            // 测试闭包创建
            const start1 = performance.now();
            
            for (let i = 0; i < iterations; i++) {
                (function(x) {
                    return function(y) {
                        return x + y;
                    };
                })(i);
            }
            
            const end1 = performance.now();
            
            // 测试普通函数
            function add(x, y) {
                return x + y;
            }
            
            const start2 = performance.now();
            
            for (let i = 0; i < iterations; i++) {
                add.bind(null, i);
            }
            
            const end2 = performance.now();
            
            console.log(`闭包创建耗时: ${end1 - start1}ms`);
            console.log(`bind创建耗时: ${end2 - start2}ms`);
        }
        
        measureClosureCreation();
        
        // 闭包vs原型方法的性能对比
        function ClosureCounter() {
            let count = 0;
            
            this.increment = function() {
                count++;
                return count;
            };
        }
        
        function PrototypeCounter() {
            this.count = 0;
        }
        
        PrototypeCounter.prototype.increment = function() {
            this.count++;
            return this.count;
        };
        
        const closureCounter = new ClosureCounter();
        const prototypeCounter = new PrototypeCounter();
        
        console.log('闭包计数器:', closureCounter.increment());
        console.log('原型计数器:', prototypeCounter.increment());
        
        console.log('注意：每个闭包实例都有自己的方法副本');
        console.log('原型方法在所有实例间共享');
    },
    
    /**
     * 调试困难
     */
    debuggingChallenges() {
        console.log('=== 调试困难 ===');
        
        function createDebugFriendlyFunction() {
            let privateVar = 'secret';
            
            return {
                // 提供调试接口
                getPrivateVar: function() {
                    return privateVar;
                },
                
                // 命名函数便于调试
                namedFunction: function processData(data) {
                    return `${privateVar}: ${data}`;
                },
                
                // 添加调试信息
                debug: function() {
                    return {
                        privateVar: privateVar,
                        timestamp: new Date().toISOString()
                    };
                }
            };
        }
        
        const debugFn = createDebugFriendlyFunction();
        console.log('调试信息:', debugFn.debug());
        console.log('处理结果:', debugFn.namedFunction('test'));
        
        // 避免过度嵌套
        function avoidDeepNesting() {
            let level1Var = 'level1';
            
            return function level1Function() {
                let level2Var = 'level2';
                
                // ❌ 避免过深的嵌套
                return function level2Function() {
                    return `${level1Var} + ${level2Var}`;
                };
            };
        }
        
        const nestedFn = avoidDeepNesting()();
        console.log('嵌套函数结果:', nestedFn());
    }
};

ClosureCaveats.memoryLeaks();
ClosureCaveats.performanceConsiderations();
ClosureCaveats.debuggingChallenges();
```

---

**本章总结**

第8章全面介绍了JavaScript函数的基础知识：

1. **函数声明方式**: 掌握了函数声明、函数表达式、箭头函数、构造器和方法定义等多种方式
2. **箭头函数与this**: 深入理解了箭头函数的语法特点、this绑定机制、局限性和最佳实践
3. **参数处理**: 学会了基本参数、默认参数、剩余参数和参数解构等现代参数处理技术
4. **返回值与执行流程**: 理解了函数返回值、执行上下文、调用栈和递归等执行机制
5. **闭包基础**: 掌握了闭包的概念、形成条件、实际应用和注意事项

函数是JavaScript的核心，掌握这些基础概念为后续学习高级函数特性、面向对象编程和函数式编程奠定了坚实基础。

**下一章预告**

第9章将深入探讨JavaScript的对象与引用，包括对象的创建方式、属性访问与配置、引用模型的共享特性，以及浅拷贝与深拷贝等重要概念，为理解JavaScript的对象系统做好准备。
