# 第8章　函数基础

函数是JavaScript的核心概念，是第一类对象（First-class Object），可以作为值传递、存储在变量中、作为参数传递给其他函数，或作为返回值。理解函数是掌握JavaScript高级特性的关键。

## 8.1 函数声明方式

JavaScript提供了多种声明函数的方式，每种方式都有其特点和适用场景。理解这些差异对于编写高质量的代码至关重要。

### 函数声明（Function Declaration）

函数声明是最传统的定义函数的方式，具有提升（hoisting）特性：

```javascript
/**
 * 函数声明示例
 */
const FunctionDeclarationExamples = {
    /**
     * 基本函数声明
     */
    basicDeclarations() {
        console.log('=== 基本函数声明 ===');
        
        // 基本函数声明
        function greet(name) {
            return `Hello, ${name}!`;
        }
        
        console.log(greet('Alice')); // 输出: Hello, Alice!
        
        // 函数声明具有提升特性
        console.log(hoistedFunction()); // 可以在声明前调用
        
        function hoistedFunction() {
            return '我被提升了！';
        }
        
        // 带参数的函数
        function calculateArea(width, height) {
            return width * height;
        }
        
        console.log('矩形面积:', calculateArea(10, 5));
        
        // 带默认参数的函数声明
        function createUser(name, role = 'user') {
            return {
                name: name,
                role: role,
                createdAt: new Date()
            };
        }
        
        console.log('默认角色用户:', createUser('Bob'));
        console.log('管理员用户:', createUser('Alice', 'admin'));
    },
    
    /**
     * 函数声明的提升特性
     */
    hoistingBehavior() {
        console.log('=== 函数提升特性 ===');
        
        // 演示函数提升
        console.log('调用提升函数:', testHoisting());
        
        function testHoisting() {
            return '函数声明被提升到作用域顶部';
        }
        
        // 条件函数声明（不推荐）
        if (true) {
            function conditionalFunction() {
                return '条件内的函数声明';
            }
        }
        
        try {
            console.log('条件函数:', conditionalFunction());
        } catch (error) {
            console.log('条件函数可能不可用:', error.message);
        }
        
        // 嵌套函数声明
        function outerFunction() {
            console.log('外层函数执行');
            
            function innerFunction() {
                return '内层函数被调用';
            }
            
            return innerFunction();
        }
        
        console.log('嵌套函数结果:', outerFunction());
    }
};

FunctionDeclarationExamples.basicDeclarations();
FunctionDeclarationExamples.hoistingBehavior();
```

### 函数表达式（Function Expression）

函数表达式将函数赋值给变量，不具有提升特性：

```javascript
/**
 * 函数表达式示例
 */
const FunctionExpressionExamples = {
    /**
     * 基本函数表达式
     */
    basicExpressions() {
        console.log('=== 基本函数表达式 ===');
        
        // 匿名函数表达式
        const anonymousFunc = function(x, y) {
            return x + y;
        };
        
        console.log('匿名函数结果:', anonymousFunc(5, 3));
        
        // 命名函数表达式
        const namedFunc = function multiply(a, b) {
            return a * b;
        };
        
        console.log('命名函数表达式:', namedFunc(4, 6));
        
        // 立即执行函数表达式 (IIFE)
        const result = (function(name) {
            return `IIFE executed with ${name}`;
        })('test');
        
        console.log('IIFE结果:', result);
        
        // 函数表达式不会被提升
        try {
            console.log(notHoisted()); // 这会报错
        } catch (error) {
            console.log('函数表达式不会提升:', error.message);
        }
        
        var notHoisted = function() {
            return '我不会被提升';
        };
    },
    
    /**
     * 高阶函数表达式
     */
    higherOrderFunctions() {
        console.log('=== 高阶函数表达式 ===');
        
        // 返回函数的函数
        const createMultiplier = function(factor) {
            return function(number) {
                return number * factor;
            };
        };
        
        const double = createMultiplier(2);
        const triple = createMultiplier(3);
        
        console.log('双倍:', double(5));
        console.log('三倍:', triple(5));
        
        // 接受函数作为参数的函数
        const processArray = function(arr, callback) {
            const result = [];
            for (let i = 0; i < arr.length; i++) {
                result.push(callback(arr[i], i));
            }
            return result;
        };
        
        const numbers = [1, 2, 3, 4, 5];
        
        const squared = processArray(numbers, function(num) {
            return num * num;
        });
        
        const withIndex = processArray(numbers, function(num, index) {
            return `${num} at index ${index}`;
        });
        
        console.log('平方数组:', squared);
        console.log('带索引:', withIndex);
        
        // 条件函数表达式
        const condition = true;
        const conditionalFunc = condition ? 
            function() { return 'Condition is true'; } :
            function() { return 'Condition is false'; };
        
        console.log('条件函数:', conditionalFunc());
    }
};

FunctionExpressionExamples.basicExpressions();
FunctionExpressionExamples.higherOrderFunctions();
```

### 箭头函数（Arrow Function）

ES6引入的箭头函数提供了更简洁的语法：

```javascript
/**
 * 箭头函数示例
 */
const ArrowFunctionExamples = {
    /**
     * 基本箭头函数语法
     */
    basicSyntax() {
        console.log('=== 箭头函数基本语法 ===');
        
        // 基本箭头函数
        const add = (a, b) => a + b;
        console.log('加法:', add(3, 4));
        
        // 单参数箭头函数（可省略括号）
        const square = x => x * x;
        console.log('平方:', square(5));
        
        // 无参数箭头函数
        const getCurrentTime = () => new Date().toISOString();
        console.log('当前时间:', getCurrentTime());
        
        // 多行箭头函数
        const processUser = (user) => {
            const processed = {
                ...user,
                id: Math.random().toString(36).substr(2, 9),
                processedAt: new Date()
            };
            return processed;
        };
        
        const user = { name: 'Alice', email: 'alice@example.com' };
        console.log('处理用户:', processUser(user));
        
        // 返回对象字面量（需要括号）
        const createPoint = (x, y) => ({ x, y });
        console.log('创建点:', createPoint(10, 20));
        
        // 数组方法中的箭头函数
        const numbers = [1, 2, 3, 4, 5];
        
        const doubled = numbers.map(n => n * 2);
        const evens = numbers.filter(n => n % 2 === 0);
        const sum = numbers.reduce((acc, n) => acc + n, 0);
        
        console.log('原数组:', numbers);
        console.log('翻倍:', doubled);
        console.log('偶数:', evens);
        console.log('总和:', sum);
    },
    
    /**
     * 箭头函数与传统函数的差异
     */
    comparisonWithTraditional() {
        console.log('=== 箭头函数vs传统函数 ===');
        
        const obj = {
            name: 'TestObject',
            
            // 传统函数方法
            traditionalMethod: function() {
                return `传统函数中的this: ${this.name}`;
            },
            
            // 箭头函数方法
            arrowMethod: () => {
                // 箭头函数没有自己的this
                return `箭头函数中的this: ${this.name}`;
            },
            
            // 测试方法
            testThis: function() {
                console.log(this.traditionalMethod());
                console.log(this.arrowMethod());
                
                // 在传统函数中使用箭头函数
                const innerArrow = () => {
                    return `内部箭头函数的this: ${this.name}`;
                };
                
                console.log(innerArrow());
                
                // 传统函数内的传统函数
                const innerTraditional = function() {
                    return `内部传统函数的this: ${this.name}`;
                };
                
                console.log(innerTraditional.call(this));
            }
        };
        
        obj.testThis();
        
        // 箭头函数不能作为构造函数
        const ArrowConstructor = () => {
            this.name = 'Arrow';
        };
        
        try {
            const instance = new ArrowConstructor();
        } catch (error) {
            console.log('箭头函数不能作为构造函数:', error.message);
        }
        
        // 箭头函数没有arguments对象
        function traditionalArgs() {
            console.log('传统函数arguments:', arguments.length);
            return arguments;
        }
        
        const arrowArgs = (...args) => {
            console.log('箭头函数使用rest参数:', args.length);
            return args;
        };
        
        traditionalArgs(1, 2, 3);
        arrowArgs(1, 2, 3);
    }
};

ArrowFunctionExamples.basicSyntax();
ArrowFunctionExamples.comparisonWithTraditional();
```

### 函数构造器（Function Constructor）

Function构造器允许动态创建函数，但很少使用：

```javascript
/**
 * 函数构造器示例
 */
const FunctionConstructorExamples = {
    /**
     * 基本函数构造器用法
     */
    basicConstructor() {
        console.log('=== 函数构造器 ===');
        
        // 基本构造器语法
        const addFunction = new Function('a', 'b', 'return a + b');
        console.log('构造器函数结果:', addFunction(3, 4));
        
        // 动态创建函数
        const operation = 'multiply';
        const dynamicFunction = new Function('x', 'y', `
            if ('${operation}' === 'multiply') {
                return x * y;
            } else {
                return x + y;
            }
        `);
        
        console.log('动态函数结果:', dynamicFunction(5, 6));
        
        // 构造器创建的函数没有闭包
        const outerVar = 'outside';
        const normalFunction = function() {
            return outerVar; // 可以访问
        };
        
        const constructedFunction = new Function('return outerVar'); // 无法访问
        
        console.log('普通函数访问外部变量:', normalFunction());
        
        try {
            console.log('构造器函数访问外部变量:', constructedFunction());
        } catch (error) {
            console.log('构造器函数无法访问闭包变量:', error.message);
        }
    }
};

FunctionConstructorExamples.basicConstructor();
```

### 方法定义（Method Definition）

ES6引入了简化的方法定义语法：

```javascript
/**
 * 方法定义示例
 */
const MethodDefinitionExamples = {
    /**
     * 对象方法定义
     */
    objectMethods() {
        console.log('=== 对象方法定义 ===');
        
        const calculator = {
            // ES5风格方法
            addOld: function(a, b) {
                return a + b;
            },
            
            // ES6简化方法定义
            add(a, b) {
                return a + b;
            },
            
            // 异步方法
            async fetchData(url) {
                // 模拟异步操作
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve(`Data from ${url}`);
                    }, 100);
                });
            },
            
            // 生成器方法
            *generateNumbers(count) {
                for (let i = 1; i <= count; i++) {
                    yield i;
                }
            },
            
            // Getter和Setter
            get currentTime() {
                return new Date().toISOString();
            },
            
            set value(val) {
                this._value = val;
                console.log(`Value set to: ${val}`);
            },
            
            get value() {
                return this._value || 0;
            }
        };
        
        console.log('ES5方法:', calculator.addOld(2, 3));
        console.log('ES6方法:', calculator.add(2, 3));
        console.log('Getter:', calculator.currentTime);
        
        calculator.value = 42;
        console.log('Setter/Getter:', calculator.value);
        
        // 异步方法使用
        calculator.fetchData('https://api.example.com').then(result => {
            console.log('异步方法结果:', result);
        });
        
        // 生成器方法使用
        const numberGenerator = calculator.generateNumbers(3);
        console.log('生成器方法:');
        for (const num of numberGenerator) {
            console.log(`  生成数字: ${num}`);
        }
    },
    
    /**
     * 类方法定义
     */
    classMethods() {
        console.log('=== 类方法定义 ===');
        
        class UserManager {
            constructor() {
                this.users = [];
            }
            
            // 实例方法
            addUser(user) {
                this.users.push({
                    ...user,
                    id: Math.random().toString(36).substr(2, 9),
                    createdAt: new Date()
                });
                return this;
            }
            
            // 异步实例方法
            async validateUser(userId) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        const user = this.users.find(u => u.id === userId);
                        resolve(!!user);
                    }, 50);
                });
            }
            
            // 静态方法
            static createDefault() {
                return new UserManager();
            }
            
            // Getter
            get userCount() {
                return this.users.length;
            }
            
            // 生成器方法
            *getAllUsers() {
                for (const user of this.users) {
                    yield user;
                }
            }
        }
        
        const manager = UserManager.createDefault();
        
        manager
            .addUser({ name: 'Alice', email: 'alice@example.com' })
            .addUser({ name: 'Bob', email: 'bob@example.com' });
        
        console.log('用户数量:', manager.userCount);
        
        console.log('所有用户:');
        for (const user of manager.getAllUsers()) {
            console.log(`  ${user.name} - ${user.email}`);
        }
    }
};

MethodDefinitionExamples.objectMethods();
MethodDefinitionExamples.classMethods();
```

---

## 8.2 箭头函数与 this

箭头函数的this绑定机制与传统函数完全不同，这是JavaScript中最重要的概念之一。

### 箭头函数的语法特点

箭头函数提供了简洁的语法，但有特定的使用规则：

```javascript
/**
 * 箭头函数语法特点
 */
const ArrowFunctionSyntax = {
    /**
     * 语法变化形式
     */
    syntaxVariations() {
        console.log('=== 箭头函数语法形式 ===');
        
        // 最简形式：单参数，单表达式
        const double = x => x * 2;
        console.log('最简形式:', double(5));
        
        // 多参数需要括号
        const add = (a, b) => a + b;
        console.log('多参数:', add(3, 4));
        
        // 无参数需要空括号
        const greeting = () => 'Hello World';
        console.log('无参数:', greeting());
        
        // 多行函数体需要大括号和return
        const processData = (data) => {
            const processed = data.map(item => item * 2);
            const sum = processed.reduce((a, b) => a + b, 0);
            return { processed, sum };
        };
        
        console.log('多行函数:', processData([1, 2, 3]));
        
        // 返回对象字面量需要括号
        const createUser = name => ({ name, id: Date.now() });
        console.log('返回对象:', createUser('Alice'));
        
        // 高阶函数中的箭头函数
        const numbers = [1, 2, 3, 4, 5];
        
        // 链式调用
        const result = numbers
            .filter(n => n % 2 === 0)
            .map(n => n * 3)
            .reduce((sum, n) => sum + n, 0);
        
        console.log('链式箭头函数结果:', result);
    },
    
    /**
     * 箭头函数的限制
     */
    limitations() {
        console.log('=== 箭头函数限制 ===');
        
        // 1. 不能作为构造函数
        const ArrowFunc = () => {};
        try {
            new ArrowFunc();
        } catch (error) {
            console.log('1. 不能作为构造函数:', error.message);
        }
        
        // 2. 没有prototype属性
        console.log('2. 箭头函数prototype:', ArrowFunc.prototype);
        
        function RegularFunc() {}
        console.log('   普通函数prototype:', typeof RegularFunc.prototype);
        
        // 3. 没有arguments对象
        const arrowWithArgs = () => {
            try {
                console.log(arguments); // 报错
            } catch (error) {
                console.log('3. 没有arguments对象:', error.message);
            }
        };
        
        function regularWithArgs() {
            console.log('   普通函数arguments长度:', arguments.length);
        }
        
        arrowWithArgs(1, 2, 3);
        regularWithArgs(1, 2, 3);
        
        // 4. 不能使用yield关键字
        // const arrowGenerator = () => {
        //     yield 1; // 语法错误
        // };
        
        console.log('4. 箭头函数不能是生成器函数');
        
        // 5. 不能使用call、apply、bind改变this
        const arrowThis = () => {
            return this;
        };
        
        const obj = { name: 'test' };
        console.log('5. call/apply/bind对箭头函数无效');
        console.log('   箭头函数call结果:', arrowThis.call(obj));
        console.log('   箭头函数apply结果:', arrowThis.apply(obj));
        console.log('   箭头函数bind结果:', arrowThis.bind(obj)());
    }
};

ArrowFunctionSyntax.syntaxVariations();
ArrowFunctionSyntax.limitations();
```

---

## 8.3 参数、默认参数、剩余参数

### 基本参数处理

### 默认参数（Default Parameters）

### 剩余参数（Rest Parameters）

### 参数解构

---

## 8.4 返回值与执行流程

### 函数返回值

### 执行上下文

### 调用栈

### 递归函数

---

## 8.5 闭包（Closure）基础

### 闭包的概念

### 闭包的形成条件

### 闭包的实际应用

### 闭包的注意事项

---

**本章总结**

**下一章预告**
