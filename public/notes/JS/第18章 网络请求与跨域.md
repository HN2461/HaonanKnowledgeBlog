# 第18章　网络请求与跨域

网络请求是现代Web应用的核心功能，本章将深入探讨HTTP协议基础、现代Fetch API、流行的Axios库、跨域问题的CORS原理以及常用的跨域解决方案。

## 18.1 HTTP基础

理解HTTP协议的核心概念和工作原理。

### HTTP协议概述

```javascript
/**
 * HTTP基础概念示例
 */
const HTTPBasics = {
    /**
     * HTTP请求方法详解
     */
    httpMethods() {
        console.log('=== HTTP请求方法详解 ===');
        
        // HTTP方法的语义化使用
        const httpMethodExamples = {
            // GET - 获取资源
            GET: {
                purpose: '获取资源',
                characteristics: ['安全', '幂等', '可缓存'],
                example: 'GET /api/users/123 - 获取用户信息'
            },
            
            // POST - 创建资源
            POST: {
                purpose: '创建资源',
                characteristics: ['非安全', '非幂等', '不可缓存'],
                example: 'POST /api/users - 创建新用户'
            },
            
            // PUT - 更新/替换资源
            PUT: {
                purpose: '更新替换资源',
                characteristics: ['非安全', '幂等', '不可缓存'],
                example: 'PUT /api/users/123 - 完整更新用户'
            },
            
            // PATCH - 部分更新资源
            PATCH: {
                purpose: '部分更新资源',
                characteristics: ['非安全', '非幂等', '不可缓存'],
                example: 'PATCH /api/users/123 - 部分更新用户'
            },
            
            // DELETE - 删除资源
            DELETE: {
                purpose: '删除资源',
                characteristics: ['非安全', '幂等', '不可缓存'],
                example: 'DELETE /api/users/123 - 删除用户'
            }
        };
        
        Object.entries(httpMethodExamples).forEach(([method, info]) => {
            console.log(`${method}:`, info);
        });
        
        // RESTful API设计示例
        const restfulAPI = {
            users: {
                'GET /users': '获取用户列表',
                'GET /users/:id': '获取特定用户',
                'POST /users': '创建新用户',
                'PUT /users/:id': '完整更新用户',
                'PATCH /users/:id': '部分更新用户',
                'DELETE /users/:id': '删除用户'
            },
            posts: {
                'GET /users/:id/posts': '获取用户的文章',
                'POST /users/:id/posts': '为用户创建文章',
                'GET /posts/:id': '获取特定文章',
                'PUT /posts/:id': '更新文章',
                'DELETE /posts/:id': '删除文章'
            }
        };
        
        console.log('RESTful API设计示例:', restfulAPI);
    },
    
    /**
     * HTTP状态码详解
     */
    httpStatusCodes() {
        console.log('=== HTTP状态码详解 ===');
        
        const statusCodes = {
            // 1xx 信息性状态码
            '1xx': {
                name: '信息性状态码',
                codes: {
                    100: 'Continue - 继续请求',
                    101: 'Switching Protocols - 切换协议'
                }
            },
            
            // 2xx 成功状态码
            '2xx': {
                name: '成功状态码',
                codes: {
                    200: 'OK - 请求成功',
                    201: 'Created - 资源创建成功',
                    202: 'Accepted - 请求已接受',
                    204: 'No Content - 请求成功但无内容返回',
                    206: 'Partial Content - 部分内容'
                }
            },
            
            // 3xx 重定向状态码
            '3xx': {
                name: '重定向状态码',
                codes: {
                    301: 'Moved Permanently - 永久重定向',
                    302: 'Found - 临时重定向',
                    304: 'Not Modified - 资源未修改',
                    307: 'Temporary Redirect - 临时重定向（保持方法）',
                    308: 'Permanent Redirect - 永久重定向（保持方法）'
                }
            },
            
            // 4xx 客户端错误
            '4xx': {
                name: '客户端错误',
                codes: {
                    400: 'Bad Request - 请求格式错误',
                    401: 'Unauthorized - 未授权',
                    403: 'Forbidden - 禁止访问',
                    404: 'Not Found - 资源不存在',
                    405: 'Method Not Allowed - 方法不允许',
                    409: 'Conflict - 资源冲突',
                    422: 'Unprocessable Entity - 无法处理的实体',
                    429: 'Too Many Requests - 请求过多'
                }
            },
            
            // 5xx 服务器错误
            '5xx': {
                name: '服务器错误',
                codes: {
                    500: 'Internal Server Error - 内部服务器错误',
                    501: 'Not Implemented - 功能未实现',
                    502: 'Bad Gateway - 网关错误',
                    503: 'Service Unavailable - 服务不可用',
                    504: 'Gateway Timeout - 网关超时'
                }
            }
        };
        
        Object.entries(statusCodes).forEach(([category, info]) => {
            console.log(`${category} - ${info.name}:`, info.codes);
        });
    },
    
    /**
     * HTTP请求头详解
     */
    httpHeaders() {
        console.log('=== HTTP请求头详解 ===');
        
        const commonHeaders = {
            // 通用头部
            general: {
                'Cache-Control': '缓存控制',
                'Connection': '连接管理',
                'Date': '消息发送时间',
                'Transfer-Encoding': '传输编码'
            },
            
            // 请求头部
            request: {
                'Accept': '可接受的内容类型',
                'Accept-Encoding': '可接受的编码',
                'Accept-Language': '可接受的语言',
                'Authorization': '认证信息',
                'Content-Type': '请求体内容类型',
                'Cookie': '客户端Cookie',
                'Host': '目标主机',
                'User-Agent': '用户代理信息',
                'Referer': '来源页面',
                'Origin': '请求来源'
            },
            
            // 响应头部
            response: {
                'Content-Type': '响应内容类型',
                'Content-Length': '内容长度',
                'Set-Cookie': '设置Cookie',
                'Location': '重定向地址',
                'Server': '服务器信息',
                'Access-Control-Allow-Origin': 'CORS允许源',
                'Access-Control-Allow-Methods': 'CORS允许方法',
                'Access-Control-Allow-Headers': 'CORS允许头部'
            }
        };
        
        Object.entries(commonHeaders).forEach(([type, headers]) => {
            console.log(`${type.toUpperCase()}头部:`, headers);
        });
        
        // Content-Type常见值
        const contentTypes = {
            'application/json': 'JSON数据',
            'application/x-www-form-urlencoded': '表单数据',
            'multipart/form-data': '文件上传',
            'text/html': 'HTML文档',
            'text/plain': '纯文本',
            'text/css': 'CSS样式表',
            'application/javascript': 'JavaScript代码',
            'image/jpeg': 'JPEG图片',
            'image/png': 'PNG图片',
            'application/pdf': 'PDF文档'
        };
        
        console.log('常见Content-Type:', contentTypes);
    }
};

HTTPBasics.httpMethods();
setTimeout(() => HTTPBasics.httpStatusCodes(), 1000);
setTimeout(() => HTTPBasics.httpHeaders(), 2000);
```

### HTTP请求响应流程

```javascript
/**
 * HTTP请求响应流程示例
 */
const HTTPFlow = {
    /**
     * 请求响应周期模拟
     */
    requestResponseCycle() {
        console.log('=== HTTP请求响应周期 ===');
        
        // 模拟HTTP请求类
        class HTTPRequest {
            constructor(method, url, headers = {}, body = null) {
                this.method = method;
                this.url = url;
                this.headers = {
                    'User-Agent': 'Mozilla/5.0 Custom Browser',
                    'Accept': 'application/json',
                    ...headers
                };
                this.body = body;
                this.timestamp = new Date().toISOString();
            }
            
            // 格式化请求信息
            toString() {
                let request = `${this.method} ${this.url} HTTP/1.1\n`;
                
                Object.entries(this.headers).forEach(([key, value]) => {
                    request += `${key}: ${value}\n`;
                });
                
                if (this.body) {
                    request += `\n${JSON.stringify(this.body)}`;
                }
                
                return request;
            }
        }
        
        // 模拟HTTP响应类
        class HTTPResponse {
            constructor(status, statusText, headers = {}, data = null) {
                this.status = status;
                this.statusText = statusText;
                this.headers = {
                    'Content-Type': 'application/json',
                    'Date': new Date().toUTCString(),
                    'Server': 'Custom-Server/1.0',
                    ...headers
                };
                this.data = data;
                this.ok = status >= 200 && status < 300;
            }
            
            // 格式化响应信息
            toString() {
                let response = `HTTP/1.1 ${this.status} ${this.statusText}\n`;
                
                Object.entries(this.headers).forEach(([key, value]) => {
                    response += `${key}: ${value}\n`;
                });
                
                if (this.data) {
                    response += `\n${JSON.stringify(this.data, null, 2)}`;
                }
                
                return response;
            }
        }
        
        // 模拟服务器处理请求
        function processRequest(request) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    console.log('请求详情:');
                    console.log(request.toString());
                    
                    let response;
                    
                    // 根据请求路径和方法返回不同响应
                    if (request.url.includes('/users') && request.method === 'GET') {
                        response = new HTTPResponse(200, 'OK', {}, {
                            users: [
                                { id: 1, name: 'Alice', email: 'alice@example.com' },
                                { id: 2, name: 'Bob', email: 'bob@example.com' }
                            ]
                        });
                    } else if (request.url.includes('/users') && request.method === 'POST') {
                        response = new HTTPResponse(201, 'Created', {
                            'Location': '/users/3'
                        }, {
                            id: 3,
                            name: request.body.name,
                            email: request.body.email,
                            created: new Date().toISOString()
                        });
                    } else if (request.url.includes('/users/999')) {
                        response = new HTTPResponse(404, 'Not Found', {}, {
                            error: 'User not found'
                        });
                    } else {
                        response = new HTTPResponse(500, 'Internal Server Error', {}, {
                            error: 'Unexpected error'
                        });
                    }
                    
                    console.log('响应详情:');
                    console.log(response.toString());
                    console.log('---');
                    
                    resolve(response);
                }, Math.random() * 500 + 100);
            });
        }
        
        // 测试不同类型的请求
        const requests = [
            new HTTPRequest('GET', '/api/users'),
            new HTTPRequest('POST', '/api/users', {
                'Content-Type': 'application/json'
            }, {
                name: 'Charlie',
                email: 'charlie@example.com'
            }),
            new HTTPRequest('GET', '/api/users/999'),
            new HTTPRequest('PUT', '/api/unknown')
        ];
        
        // 依次处理请求
        async function processAllRequests() {
            for (const request of requests) {
                await processRequest(request);
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
        
        processAllRequests();
    },
    
    /**
     * HTTP缓存机制演示
     */
    httpCaching() {
        console.log('=== HTTP缓存机制 ===');
        
        // 缓存控制示例
        const cacheExamples = {
            // 强缓存
            strongCache: {
                'Cache-Control': 'max-age=3600', // 1小时
                'Expires': new Date(Date.now() + 3600000).toUTCString()
            },
            
            // 协商缓存
            conditionalCache: {
                'Cache-Control': 'no-cache',
                'ETag': '"abc123"',
                'Last-Modified': new Date(Date.now() - 86400000).toUTCString()
            },
            
            // 不缓存
            noCache: {
                'Cache-Control': 'no-store, no-cache, must-revalidate',
                'Pragma': 'no-cache',
                'Expires': '0'
            }
        };
        
        console.log('缓存策略示例:', cacheExamples);
        
        // 模拟缓存验证
        function validateCache(requestHeaders, cachedResponse) {
            const ifNoneMatch = requestHeaders['If-None-Match'];
            const ifModifiedSince = requestHeaders['If-Modified-Since'];
            
            // ETag验证
            if (ifNoneMatch && cachedResponse.headers['ETag'] === ifNoneMatch) {
                return { status: 304, message: 'Not Modified (ETag匹配)' };
            }
            
            // Last-Modified验证
            if (ifModifiedSince) {
                const lastModified = new Date(cachedResponse.headers['Last-Modified']);
                const clientTime = new Date(ifModifiedSince);
                
                if (lastModified <= clientTime) {
                    return { status: 304, message: 'Not Modified (未修改)' };
                }
            }
            
            return { status: 200, message: '返回新内容' };
        }
        
        // 测试缓存验证
        const cachedResponse = {
            headers: {
                'ETag': '"version-123"',
                'Last-Modified': new Date(Date.now() - 86400000).toUTCString()
            }
        };
        
        const testRequests = [
            { 'If-None-Match': '"version-123"' },
            { 'If-None-Match': '"version-456"' },
            { 'If-Modified-Since': new Date(Date.now() - 48 * 60 * 60 * 1000).toUTCString() }
        ];
        
        testRequests.forEach((headers, index) => {
            const result = validateCache(headers, cachedResponse);
            console.log(`缓存验证${index + 1}:`, result);
        });
    }
};

HTTPFlow.requestResponseCycle();
setTimeout(() => HTTPFlow.httpCaching(), 3000);
```

---

## 18.2 Fetch API

现代浏览器的标准网络请求API。

### Fetch基础用法

```javascript
/**
 * Fetch API基础用法示例
 */
const FetchBasics = {
    /**
     * 基础GET请求
     */
    async basicGet() {
        console.log('=== 基础GET请求 ===');
        
        try {
            // 模拟API端点
            const mockAPI = 'https://jsonplaceholder.typicode.com/posts/1';
            
            const response = await fetch(mockAPI);
            
            // 检查响应状态
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('GET响应数据:', data);
            
            // 响应对象属性
            console.log('响应对象信息:', {
                status: response.status,
                statusText: response.statusText,
                ok: response.ok,
                url: response.url,
                headers: [...response.headers.entries()]
            });
            
        } catch (error) {
            console.error('请求失败:', error);
        }
    },
    
    /**
     * POST请求发送数据
     */
    async postData() {
        console.log('=== POST请求发送数据 ===');
        
        const postData = {
            title: 'JavaScript学习笔记',
            body: '这是一篇关于Fetch API的文章',
            userId: 1
        };
        
        try {
            const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify(postData)
            });
            
            if (!response.ok) {
                throw new Error(`请求失败: ${response.status}`);
            }
            
            const result = await response.json();
            console.log('POST响应:', result);
            
        } catch (error) {
            console.error('POST请求错误:', error);
        }
    },
    
    /**
     * 不同数据格式处理
     */
    async differentDataTypes() {
        console.log('=== 不同数据格式处理 ===');
        
        // 表单数据
        const formData = new FormData();
        formData.append('name', 'John Doe');
        formData.append('email', 'john@example.com');
        
        // URL编码数据
        const urlEncoded = new URLSearchParams();
        urlEncoded.append('name', 'Jane Doe');
        urlEncoded.append('email', 'jane@example.com');
        
        const requestExamples = [
            {
                name: 'JSON数据',
                config: {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: 'Alice', age: 25 })
                }
            },
            {
                name: 'FormData',
                config: {
                    method: 'POST',
                    body: formData // 不设置Content-Type，浏览器自动设置
                }
            },
            {
                name: 'URL编码',
                config: {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: urlEncoded
                }
            },
            {
                name: '纯文本',
                config: {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: '这是纯文本数据'
                }
            }
        ];
        
        for (const example of requestExamples) {
            console.log(`${example.name}请求配置:`, example.config);
        }
    }
};

FetchBasics.basicGet();
setTimeout(() => FetchBasics.postData(), 1000);
setTimeout(() => FetchBasics.differentDataTypes(), 2000);
```

### 高级配置和错误处理

```javascript
/**
 * Fetch高级配置示例
 */
const FetchAdvanced = {
    /**
     * 请求配置和超时控制
     */
    async advancedConfig() {
        console.log('=== 高级配置 ===');
        
        // 超时控制
        function fetchWithTimeout(url, options = {}, timeout = 5000) {
            return Promise.race([
                fetch(url, options),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('请求超时')), timeout)
                )
            ]);
        }
        
        // AbortController取消请求
        const controller = new AbortController();
        
        // 5秒后取消请求
        setTimeout(() => {
            controller.abort();
            console.log('请求已取消');
        }, 5000);
        
        try {
            const response = await fetch('https://httpbin.org/delay/3', {
                method: 'GET',
                headers: {
                    'Accept': 'application/json',
                    'User-Agent': 'Custom-App/1.0'
                },
                signal: controller.signal, // 绑定取消信号
                cache: 'no-cache', // 缓存策略
                credentials: 'same-origin', // Cookie策略
                redirect: 'follow', // 重定向策略
                referrer: 'no-referrer' // 引用策略
            });
            
            if (!response.ok) {
                throw new Error(`请求失败: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('高级配置响应:', data);
            
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('请求被用户取消');
            } else {
                console.error('请求错误:', error.message);
            }
        }
    },
    
    /**
     * 响应处理和错误分类
     */
    async responseHandling() {
        console.log('=== 响应处理和错误分类 ===');
        
        // 通用响应处理器
        async function handleResponse(response) {
            const contentType = response.headers.get('Content-Type') || '';
            
            if (contentType.includes('application/json')) {
                return await response.json();
            } else if (contentType.includes('text/')) {
                return await response.text();
            } else if (contentType.includes('application/octet-stream')) {
                return await response.blob();
            } else {
                return await response.arrayBuffer();
            }
        }
        
        // 错误分类处理器
        class HTTPError extends Error {
            constructor(response) {
                super(`HTTP Error: ${response.status} ${response.statusText}`);
                this.response = response;
                this.status = response.status;
            }
        }
        
        async function fetchWithErrorHandling(url, options = {}) {
            try {
                const response = await fetch(url, options);
                
                if (!response.ok) {
                    throw new HTTPError(response);
                }
                
                return await handleResponse(response);
                
            } catch (error) {
                if (error instanceof HTTPError) {
                    // HTTP错误处理
                    switch (error.status) {
                        case 400:
                            console.error('请求参数错误');
                            break;
                        case 401:
                            console.error('未授权访问');
                            break;
                        case 403:
                            console.error('禁止访问');
                            break;
                        case 404:
                            console.error('资源不存在');
                            break;
                        case 500:
                            console.error('服务器内部错误');
                            break;
                        default:
                            console.error('HTTP错误:', error.message);
                    }
                } else if (error.name === 'TypeError') {
                    // 网络错误
                    console.error('网络连接失败');
                } else {
                    // 其他错误
                    console.error('未知错误:', error.message);
                }
                throw error;
            }
        }
        
        // 测试不同错误场景
        const testURLs = [
            'https://jsonplaceholder.typicode.com/posts/1', // 成功
            'https://jsonplaceholder.typicode.com/posts/999', // 404
            'https://invalid-url-that-does-not-exist.com' // 网络错误
        ];
        
        for (const url of testURLs) {
            try {
                await fetchWithErrorHandling(url);
                console.log(`✅ ${url} 请求成功`);
            } catch (error) {
                console.log(`❌ ${url} 请求失败`);
            }
        }
    }
};

setTimeout(() => FetchAdvanced.advancedConfig(), 3000);
setTimeout(() => FetchAdvanced.responseHandling(), 5000);
```

---

## 18.3 Axios

流行的JavaScript HTTP客户端库。

### Axios核心功能

```javascript
/**
 * Axios核心功能示例（概念演示）
 */
const AxiosDemo = {
    /**
     * Axios基础用法模拟
     */
    basicUsage() {
        console.log('=== Axios基础用法 ===');
        
        // 模拟axios API
        const mockAxios = {
            // GET请求
            get: async (url, config = {}) => {
                console.log(`GET ${url}`, config);
                return {
                    data: { id: 1, title: 'Mock Data' },
                    status: 200,
                    statusText: 'OK',
                    headers: { 'content-type': 'application/json' },
                    config: { url, method: 'GET', ...config }
                };
            },
            
            // POST请求
            post: async (url, data, config = {}) => {
                console.log(`POST ${url}`, { data, config });
                return {
                    data: { id: 2, ...data, created: true },
                    status: 201,
                    statusText: 'Created',
                    headers: { 'content-type': 'application/json' },
                    config: { url, method: 'POST', data, ...config }
                };
            },
            
            // 通用请求方法
            request: async (config) => {
                console.log('Request config:', config);
                return {
                    data: { message: 'Success' },
                    status: 200,
                    statusText: 'OK',
                    headers: {},
                    config
                };
            }
        };
        
        // Axios使用示例
        const axiosExamples = {
            // 基础GET请求
            async basicGet() {
                const response = await mockAxios.get('/api/users');
                console.log('GET响应:', response.data);
            },
            
            // 带参数的GET请求
            async getWithParams() {
                const response = await mockAxios.get('/api/users', {
                    params: { page: 1, limit: 10 }
                });
                console.log('带参数GET响应:', response);
            },
            
            // POST请求
            async postData() {
                const userData = { name: 'John', email: 'john@example.com' };
                const response = await mockAxios.post('/api/users', userData);
                console.log('POST响应:', response.data);
            },
            
            // 使用request方法
            async genericRequest() {
                const response = await mockAxios.request({
                    method: 'PUT',
                    url: '/api/users/1',
                    data: { name: 'Updated Name' },
                    headers: { 'Authorization': 'Bearer token123' }
                });
                console.log('通用请求响应:', response.data);
            }
        };
        
        // 执行示例
        Object.values(axiosExamples).forEach(async (example, index) => {
            setTimeout(() => example(), index * 500);
        });
    }
};

AxiosDemo.basicUsage();
```

---

## 18.4 CORS原理

跨域资源共享机制详解。

### 同源策略和跨域问题

```javascript
/**
 * CORS原理和跨域问题示例
 */
const CORSDemo = {
    /**
     * 同源策略说明
     */
    sameOriginPolicy() {
        console.log('=== 同源策略 ===');
        
        // 同源检查函数
        function isSameOrigin(url1, url2) {
            const parseURL = (url) => {
                const a = document.createElement('a');
                a.href = url;
                return {
                    protocol: a.protocol,
                    hostname: a.hostname,
                    port: a.port || (a.protocol === 'https:' ? '443' : '80')
                };
            };
            
            const origin1 = parseURL(url1);
            const origin2 = parseURL(url2);
            
            return origin1.protocol === origin2.protocol &&
                   origin1.hostname === origin2.hostname &&
                   origin1.port === origin2.port;
        }
        
        // 测试同源检查
        const currentURL = 'https://example.com:8080/page';
        const testURLs = [
            'https://example.com:8080/api/data', // 同源
            'https://example.com/api/data', // 不同端口
            'http://example.com:8080/api/data', // 不同协议
            'https://api.example.com:8080/data', // 不同域名
            'https://example.com:8080/different/path' // 同源（路径不影响）
        ];
        
        testURLs.forEach(url => {
            const result = isSameOrigin(currentURL, url);
            console.log(`${url}: ${result ? '✅ 同源' : '❌ 跨域'}`);
        });
    },
    
    /**
     * CORS工作流程
     */
    corsWorkflow() {
        console.log('=== CORS工作流程 ===');
        
        // 简单请求 vs 复杂请求判断
        function isSimpleRequest(method, headers) {
            const simpleMethods = ['GET', 'POST', 'HEAD'];
            const simpleHeaders = [
                'accept',
                'accept-language',
                'content-language',
                'content-type'
            ];
            
            // 检查方法
            if (!simpleMethods.includes(method.toUpperCase())) {
                return false;
            }
            
            // 检查Content-Type
            const contentType = headers['content-type'];
            if (contentType && ![
                'application/x-www-form-urlencoded',
                'multipart/form-data',
                'text/plain'
            ].includes(contentType)) {
                return false;
            }
            
            // 检查自定义头部
            const customHeaders = Object.keys(headers).filter(
                header => !simpleHeaders.includes(header.toLowerCase())
            );
            
            return customHeaders.length === 0;
        }
        
        // 模拟CORS预检请求
        function simulatePreflight(method, headers, origin) {
            console.log('发送预检请求 (OPTIONS)');
            
            const preflightRequest = {
                method: 'OPTIONS',
                headers: {
                    'Origin': origin,
                    'Access-Control-Request-Method': method,
                    'Access-Control-Request-Headers': Object.keys(headers).join(', ')
                }
            };
            
            console.log('预检请求:', preflightRequest);
            
            // 模拟服务器响应
            const preflightResponse = {
                headers: {
                    'Access-Control-Allow-Origin': origin,
                    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',
                    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
                    'Access-Control-Max-Age': '86400'
                }
            };
            
            console.log('预检响应:', preflightResponse);
            return true;
        }
        
        // 测试不同请求类型
        const requests = [
            {
                name: '简单GET请求',
                method: 'GET',
                headers: { 'accept': 'application/json' }
            },
            {
                name: '简单POST请求',
                method: 'POST',
                headers: { 'content-type': 'application/x-www-form-urlencoded' }
            },
            {
                name: '复杂PUT请求',
                method: 'PUT',
                headers: { 'content-type': 'application/json' }
            },
            {
                name: '带自定义头部请求',
                method: 'GET',
                headers: { 'authorization': 'Bearer token123' }
            }
        ];
        
        requests.forEach(req => {
            const isSimple = isSimpleRequest(req.method, req.headers);
            console.log(`\n${req.name}: ${isSimple ? '简单请求' : '复杂请求'}`);
            
            if (!isSimple) {
                simulatePreflight(req.method, req.headers, 'https://frontend.com');
            }
        });
    }
};

CORSDemo.sameOriginPolicy();
setTimeout(() => CORSDemo.corsWorkflow(), 1000);
```

---

## 18.5 前端常用跨域方案

解决跨域问题的实用方法。

### 开发和生产环境方案

```javascript
/**
 * 跨域解决方案示例
 */
const CrossOriginSolutions = {
    /**
     * 开发环境代理配置
     */
    developmentProxy() {
        console.log('=== 开发环境代理配置 ===');
        
        // Webpack Dev Server代理配置示例
        const webpackProxyConfig = {
            devServer: {
                proxy: {
                    '/api': {
                        target: 'http://localhost:3000',
                        changeOrigin: true,
                        pathRewrite: {
                            '^/api': '/api/v1'
                        }
                    },
                    '/upload': {
                        target: 'http://upload-server.com',
                        changeOrigin: true,
                        secure: false // 允许HTTPS到HTTP
                    }
                }
            }
        };
        
        // Vite代理配置示例
        const viteProxyConfig = {
            server: {
                proxy: {
                    '/api': {
                        target: 'http://localhost:3000',
                        changeOrigin: true,
                        rewrite: (path) => path.replace(/^\/api/, '/api/v1')
                    }
                }
            }
        };
        
        console.log('Webpack代理配置:', webpackProxyConfig);
        console.log('Vite代理配置:', viteProxyConfig);
    },
    
    /**
     * JSONP方案（仅GET请求）
     */
    jsonpSolution() {
        console.log('=== JSONP跨域方案 ===');
        
        // JSONP实现
        function jsonp(url, params = {}, callback) {
            return new Promise((resolve, reject) => {
                const callbackName = `jsonp_${Date.now()}_${Math.random().toString(36).substr(2)}`;
                
                // 创建script标签
                const script = document.createElement('script');
                
                // 设置全局回调函数
                window[callbackName] = (data) => {
                    resolve(data);
                    document.head.removeChild(script);
                    delete window[callbackName];
                };
                
                // 构建URL
                const query = new URLSearchParams({
                    ...params,
                    callback: callbackName
                }).toString();
                
                script.src = `${url}?${query}`;
                script.onerror = () => {
                    reject(new Error('JSONP请求失败'));
                    document.head.removeChild(script);
                    delete window[callbackName];
                };
                
                document.head.appendChild(script);
            });
        }
        
        // 使用示例
        console.log('JSONP使用示例:');
        console.log(`jsonp('http://api.example.com/data', { id: 123 })`);
    },
    
    /**
     * 生产环境CORS配置
     */
    productionCORS() {
        console.log('=== 生产环境CORS配置 ===');
        
        // Express.js CORS中间件配置示例
        const expressCorsConfig = {
            // 基础配置
            basic: `
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', 'https://yourdomain.com');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.header('Access-Control-Allow-Credentials', 'true');
  next();
});`,
            
            // 动态配置
            dynamic: `
const allowedOrigins = ['https://yourdomain.com', 'https://admin.yourdomain.com'];

app.use((req, res, next) => {
  const origin = req.headers.origin;
  if (allowedOrigins.includes(origin)) {
    res.header('Access-Control-Allow-Origin', origin);
  }
  next();
});`
        };
        
        // Nginx反向代理配置
        const nginxConfig = `
server {
    listen 80;
    server_name api.yourdomain.com;
    
    location / {
        add_header 'Access-Control-Allow-Origin' 'https://yourdomain.com' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization' always;
        add_header 'Access-Control-Allow-Credentials' 'true' always;
        
        if ($request_method = 'OPTIONS') {
            return 204;
        }
        
        proxy_pass http://localhost:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}`;
        
        console.log('Express CORS配置:', expressCorsConfig);
        console.log('Nginx代理配置:', nginxConfig);
    }
};

CrossOriginSolutions.developmentProxy();
setTimeout(() => CrossOriginSolutions.jsonpSolution(), 500);
setTimeout(() => CrossOriginSolutions.productionCORS(), 1000);
```

---

**本章总结**

第18章全面探讨了网络请求与跨域的核心技术：

1. **HTTP基础**：
   - HTTP方法、状态码、请求头的完整理解
   - 请求响应流程和缓存机制
   - RESTful API设计原则

2. **Fetch API**：
   - 现代浏览器标准网络请求API
   - 高级配置、错误处理和响应类型
   - 超时控制和请求取消机制

3. **Axios库**：
   - 流行的HTTP客户端库特性
   - 请求配置和响应处理
   - 拦截器和实例管理

4. **CORS原理**：
   - 同源策略的工作机制
   - 简单请求vs复杂请求
   - 预检请求的完整流程

5. **跨域解决方案**：
   - 开发环境代理配置
   - JSONP传统跨域方案
   - 生产环境CORS配置

**关键要点**：
- HTTP是Web通信的基础协议
- Fetch是现代JavaScript网络请求的标准
- CORS是解决跨域问题的现代方案
- 开发和生产环境需要不同的跨域策略

**下一章预告**

第19章将开始ES6+现代JavaScript的学习，包括let/const声明、解构赋值、展开语法、模板字符串等核心语法，这些是现代JavaScript开发的基础。
