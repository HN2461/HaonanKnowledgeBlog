# 第6章　运算符、表达式与逻辑

运算符是JavaScript编程的基础工具，用于执行各种操作和逻辑判断。掌握运算符的使用方法、优先级规则以及现代JavaScript的新特性，能够让你编写更简洁高效的代码。

## 6.1 算术、比较、逻辑运算符

### 算术运算符

算术运算符用于执行数学运算，包括基本的加减乘除和其他数学操作：

```javascript
/**
 * 算术运算符详解
 */
const ArithmeticOperators = {
    /**
     * 基本算术运算符
     */
    basicOperators() {
        console.log('=== 基本算术运算符 ===');
        
        // 加法 (+)
        console.log('加法运算:');
        console.log('5 + 3 =', 5 + 3);                    // 8
        console.log('1.1 + 2.2 =', 1.1 + 2.2);            // 3.3000000000000003 (浮点精度问题)
        console.log('"Hello" + " World" =', "Hello" + " World"); // "Hello World" (字符串拼接)
        
        // 减法 (-)
        console.log('减法运算:');
        console.log('10 - 4 =', 10 - 4);                  // 6
        console.log('5.5 - 2.1 =', 5.5 - 2.1);            // 3.4
        
        // 乘法 (*)
        console.log('乘法运算:');
        console.log('6 * 7 =', 6 * 7);                    // 42
        console.log('3.14 * 2 =', 3.14 * 2);              // 6.28
        
        // 除法 (/)
        console.log('除法运算:');
        console.log('15 / 3 =', 15 / 3);                  // 5
        console.log('10 / 3 =', 10 / 3);                  // 3.3333333333333335
        console.log('10 / 0 =', 10 / 0);                  // Infinity
        console.log('-10 / 0 =', -10 / 0);                // -Infinity
        
        // 取余 (%)
        console.log('取余运算:');
        console.log('10 % 3 =', 10 % 3);                  // 1
        console.log('15 % 4 =', 15 % 4);                  // 3
        console.log('-10 % 3 =', -10 % 3);                // -1 (结果符号与被除数相同)
        
        // 指数 (**)
        console.log('指数运算:');
        console.log('2 ** 3 =', 2 ** 3);                  // 8
        console.log('4 ** 0.5 =', 4 ** 0.5);              // 2 (平方根)
        console.log('(-2) ** 2 =', (-2) ** 2);            // 4
    },
    
    /**
     * 一元算术运算符
     */
    unaryOperators() {
        console.log('=== 一元算术运算符 ===');
        
        let num = 5;
        
        // 正号 (+)
        console.log('+num =', +num);                      // 5
        console.log('+"42" =', +"42");                    // 42 (字符串转数字)
        console.log('+true =', +true);                    // 1
        console.log('+false =', +false);                  // 0
        
        // 负号 (-)
        console.log('-num =', -num);                      // -5
        console.log('-(-10) =', -(-10));                  // 10
        
        // 前置递增 (++variable)
        console.log('前置递增:');
        let a = 5;
        console.log('++a =', ++a);                        // 6 (先增后用)
        console.log('a =', a);                            // 6
        
        // 后置递增 (variable++)
        console.log('后置递增:');
        let b = 5;
        console.log('b++ =', b++);                        // 5 (先用后增)
        console.log('b =', b);                            // 6
        
        // 前置递减 (--variable)
        console.log('前置递减:');
        let c = 5;
        console.log('--c =', --c);                        // 4 (先减后用)
        console.log('c =', c);                            // 4
        
        // 后置递减 (variable--)
        console.log('后置递减:');
        let d = 5;
        console.log('d-- =', d--);                        // 5 (先用后减)
        console.log('d =', d);                            // 4
    },
    
    /**
     * 算术运算的特殊情况
     */
    specialCases() {
        console.log('=== 算术运算特殊情况 ===');
        
        // NaN 的运算
        console.log('NaN 运算:');
        console.log('NaN + 5 =', NaN + 5);                // NaN
        console.log('NaN * 0 =', NaN * 0);                // NaN
        console.log('NaN === NaN =', NaN === NaN);        // false
        
        // Infinity 的运算
        console.log('Infinity 运算:');
        console.log('Infinity + 1 =', Infinity + 1);      // Infinity
        console.log('Infinity - Infinity =', Infinity - Infinity); // NaN
        console.log('Infinity / Infinity =', Infinity / Infinity); // NaN
        
        // 字符串与数字的混合运算
        console.log('字符串与数字混合:');
        console.log('"5" + 3 =', "5" + 3);                // "53" (字符串拼接)
        console.log('"5" - 3 =', "5" - 3);                // 2 (字符串转数字)
        console.log('"5" * 2 =', "5" * 2);                // 10
        console.log('"abc" - 5 =', "abc" - 5);            // NaN
        
        /**
         * 安全的数学运算函数
         * @param {number} a - 第一个数
         * @param {number} b - 第二个数
         * @param {string} operation - 运算符
         * @returns {number|string} 运算结果或错误信息
         */
        function safeCalculate(a, b, operation) {
            // 类型检查
            if (typeof a !== 'number' || typeof b !== 'number') {
                return 'Error: 参数必须为数字';
            }
            
            // NaN 检查
            if (Number.isNaN(a) || Number.isNaN(b)) {
                return 'Error: 参数不能为 NaN';
            }
            
            switch (operation) {
                case '+':
                    return a + b;
                case '-':
                    return a - b;
                case '*':
                    return a * b;
                case '/':
                    if (b === 0) return 'Error: 除数不能为0';
                    return a / b;
                case '%':
                    if (b === 0) return 'Error: 除数不能为0';
                    return a % b;
                case '**':
                    return a ** b;
                default:
                    return 'Error: 不支持的运算符';
            }
        }
        
        console.log('安全计算示例:');
        console.log('safeCalculate(10, 3, "/"):', safeCalculate(10, 3, '/'));
        console.log('safeCalculate(10, 0, "/"):', safeCalculate(10, 0, '/'));
        console.log('safeCalculate("5", 3, "+"):', safeCalculate("5", 3, '+'));
    }
};

ArithmeticOperators.basicOperators();
ArithmeticOperators.unaryOperators();
ArithmeticOperators.specialCases();
```

### 比较运算符

比较运算符用于比较两个值，返回布尔结果：

```javascript
/**
 * 比较运算符详解
 */
const ComparisonOperators = {
    /**
     * 基本比较运算符
     */
    basicComparisons() {
        console.log('=== 基本比较运算符 ===');
        
        // 大于 (>)
        console.log('大于比较:');
        console.log('5 > 3 =', 5 > 3);                    // true
        console.log('3 > 5 =', 3 > 5);                    // false
        console.log('"b" > "a" =', "b" > "a");            // true (字符串按字典序比较)
        
        // 大于等于 (>=)
        console.log('大于等于比较:');
        console.log('5 >= 5 =', 5 >= 5);                  // true
        console.log('4 >= 5 =', 4 >= 5);                  // false
        
        // 小于 (<)
        console.log('小于比较:');
        console.log('3 < 5 =', 3 < 5);                    // true
        console.log('5 < 3 =', 5 < 3);                    // false
        
        // 小于等于 (<=)
        console.log('小于等于比较:');
        console.log('3 <= 5 =', 3 <= 5);                  // true
        console.log('5 <= 5 =', 5 <= 5);                  // true
        console.log('6 <= 5 =', 6 <= 5);                  // false
    },
    
    /**
     * 相等性比较
     */
    equalityComparisons() {
        console.log('=== 相等性比较 ===');
        
        // 抽象相等 (==) - 会进行类型转换
        console.log('抽象相等 (==):');
        console.log('5 == 5 =', 5 == 5);                  // true
        console.log('5 == "5" =', 5 == "5");              // true (字符串转数字)
        console.log('true == 1 =', true == 1);            // true (布尔转数字)
        console.log('false == 0 =', false == 0);          // true
        console.log('null == undefined =', null == undefined); // true (特殊规则)
        console.log('"" == 0 =', "" == 0);                // true (空字符串转数字0)
        
        // 严格相等 (===) - 不进行类型转换
        console.log('严格相等 (===):');
        console.log('5 === 5 =', 5 === 5);                // true
        console.log('5 === "5" =', 5 === "5");            // false (类型不同)
        console.log('true === 1 =', true === 1);          // false
        console.log('null === undefined =', null === undefined); // false
        
        // 不等 (!=) 和严格不等 (!==)
        console.log('不等比较:');
        console.log('5 != "6" =', 5 != "6");              // true
        console.log('5 !== "5" =', 5 !== "5");            // true (类型不同)
        console.log('5 != "5" =', 5 != "5");              // false (转换后相等)
    },
    
    /**
     * 特殊值的比较
     */
    specialValueComparisons() {
        console.log('=== 特殊值比较 ===');
        
        // NaN 的比较
        console.log('NaN 比较:');
        console.log('NaN == NaN =', NaN == NaN);          // false
        console.log('NaN === NaN =', NaN === NaN);        // false
        console.log('Number.isNaN(NaN) =', Number.isNaN(NaN)); // true (正确判断方式)
        
        // null 和 undefined 的比较
        console.log('null 和 undefined:');
        console.log('null == undefined =', null == undefined); // true
        console.log('null === undefined =', null === undefined); // false
        console.log('null > 0 =', null > 0);              // false (null转为0)
        console.log('null >= 0 =', null >= 0);            // true (null转为0)
        console.log('null == 0 =', null == 0);            // false (特殊规则)
        
        // 对象的比较
        console.log('对象比较:');
        const obj1 = { name: 'Alice' };
        const obj2 = { name: 'Alice' };
        const obj3 = obj1;
        
        console.log('obj1 == obj2 =', obj1 == obj2);      // false (不同引用)
        console.log('obj1 === obj3 =', obj1 === obj3);    // true (相同引用)
        
        // 数组的比较
        console.log('数组比较:');
        console.log('[1,2] == [1,2] =', [1,2] == [1,2]);  // false (不同引用)
        console.log('[1,2] == "1,2" =', [1,2] == "1,2");  // true (数组转字符串)
    },
    
    /**
     * 实用的比较工具函数
     */
    comparisonUtilities() {
        console.log('=== 比较工具函数 ===');
        
        /**
         * 深度比较两个值是否相等
         * @param {*} a - 第一个值
         * @param {*} b - 第二个值
         * @returns {boolean} 是否深度相等
         */
        function deepEqual(a, b) {
            // 严格相等检查
            if (a === b) return true;
            
            // null 或 undefined 检查
            if (a == null || b == null) return a === b;
            
            // 类型检查
            if (typeof a !== typeof b) return false;
            
            // 数组检查
            if (Array.isArray(a)) {
                if (!Array.isArray(b) || a.length !== b.length) return false;
                for (let i = 0; i < a.length; i++) {
                    if (!deepEqual(a[i], b[i])) return false;
                }
                return true;
            }
            
            // 对象检查
            if (typeof a === 'object') {
                const keysA = Object.keys(a);
                const keysB = Object.keys(b);
                
                if (keysA.length !== keysB.length) return false;
                
                for (const key of keysA) {
                    if (!keysB.includes(key) || !deepEqual(a[key], b[key])) {
                        return false;
                    }
                }
                return true;
            }
            
            return false;
        }
        
        /**
         * 安全的数值比较（处理浮点精度问题）
         * @param {number} a - 第一个数
         * @param {number} b - 第二个数
         * @param {number} epsilon - 精度阈值
         * @returns {boolean} 是否相等
         */
        function nearlyEqual(a, b, epsilon = Number.EPSILON) {
            return Math.abs(a - b) < epsilon;
        }
        
        // 测试深度比较
        console.log('深度比较测试:');
        console.log('deepEqual([1,2], [1,2]):', deepEqual([1,2], [1,2]));
        console.log('deepEqual({a:1}, {a:1}):', deepEqual({a:1}, {a:1}));
        console.log('deepEqual({a:1}, {a:2}):', deepEqual({a:1}, {a:2}));
        
        // 测试浮点数比较
        console.log('浮点数比较测试:');
        console.log('0.1 + 0.2 === 0.3:', 0.1 + 0.2 === 0.3);
        console.log('nearlyEqual(0.1 + 0.2, 0.3):', nearlyEqual(0.1 + 0.2, 0.3));
    }
};

ComparisonOperators.basicComparisons();
ComparisonOperators.equalityComparisons();
ComparisonOperators.specialValueComparisons();
ComparisonOperators.comparisonUtilities();
```

### 逻辑运算符

逻辑运算符用于逻辑运算，通常与布尔值配合使用：

```javascript
/**
 * 逻辑运算符详解
 */
const LogicalOperators = {
    /**
     * 基本逻辑运算符
     */
    basicLogicalOps() {
        console.log('=== 基本逻辑运算符 ===');
        
        // 逻辑与 (&&)
        console.log('逻辑与 (&&):');
        console.log('true && true =', true && true);      // true
        console.log('true && false =', true && false);    // false
        console.log('false && true =', false && true);    // false
        console.log('false && false =', false && false);  // false
        
        // 逻辑或 (||)
        console.log('逻辑或 (||):');
        console.log('true || true =', true || true);      // true
        console.log('true || false =', true || false);    // true
        console.log('false || true =', false || true);    // true
        console.log('false || false =', false || false);  // false
        
        // 逻辑非 (!)
        console.log('逻辑非 (!):');
        console.log('!true =', !true);                    // false
        console.log('!false =', !false);                  // true
        console.log('!!true =', !!true);                  // true (双重否定)
        console.log('!!"hello" =', !!"hello");            // true (转布尔值)
    },
    
    /**
     * 真值和假值
     */
    truthyFalsyValues() {
        console.log('=== 真值和假值 ===');
        
        // 假值 (falsy values)
        const falsyValues = [false, 0, -0, 0n, '', null, undefined, NaN];
        
        console.log('假值测试:');
        falsyValues.forEach(value => {
            console.log(`!${JSON.stringify(value)} = ${!value}`);
        });
        
        // 真值 (truthy values) - 除假值外的所有值
        const truthyValues = [true, 1, -1, 'hello', ' ', [], {}, function(){}];
        
        console.log('真值测试:');
        truthyValues.forEach(value => {
            const strValue = typeof value === 'function' ? 'function(){}' : 
                           typeof value === 'object' ? JSON.stringify(value) : value;
            console.log(`!${strValue} = ${!value}`);
        });
        
        /**
         * 检查值是否为真值
         * @param {*} value - 要检查的值
         * @returns {boolean} 是否为真值
         */
        function isTruthy(value) {
            return Boolean(value);
        }
        
        /**
         * 检查值是否为假值
         * @param {*} value - 要检查的值
         * @returns {boolean} 是否为假值
         */
        function isFalsy(value) {
            return !Boolean(value);
        }
        
        console.log('工具函数测试:');
        console.log('isTruthy("hello"):', isTruthy("hello"));
        console.log('isFalsy(0):', isFalsy(0));
        console.log('isTruthy([]):', isTruthy([])); // 注意：空数组是真值
        console.log('isTruthy({}):', isTruthy({})); // 注意：空对象是真值
    },
    
    /**
     * 逻辑运算符的返回值
     */
    returnValues() {
        console.log('=== 逻辑运算符的返回值 ===');
        
        // && 返回第一个假值或最后一个真值
        console.log('&& 返回值:');
        console.log('5 && 3 =', 5 && 3);                  // 3 (最后一个值)
        console.log('0 && 3 =', 0 && 3);                  // 0 (第一个假值)
        console.log('"hello" && "world" =', "hello" && "world"); // "world"
        console.log('null && "test" =', null && "test");  // null
        
        // || 返回第一个真值或最后一个假值
        console.log('|| 返回值:');
        console.log('5 || 3 =', 5 || 3);                  // 5 (第一个真值)
        console.log('0 || 3 =', 0 || 3);                  // 3 (第一个真值)
        console.log('false || 0 =', false || 0);          // 0 (最后一个值)
        console.log('"" || "default" =', "" || "default"); // "default"
        
        /**
         * 使用逻辑运算符设置默认值
         * @param {string} name - 用户名
         * @param {number} age - 年龄
         * @returns {Object} 用户信息
         */
        function createUser(name, age) {
            return {
                name: name || 'Anonymous',        // 默认用户名
                age: age || 0,                   // 默认年龄
                isValid: name && age > 0         // 验证用户信息
            };
        }
        
        console.log('默认值应用:');
        console.log('createUser("Alice", 25):', createUser("Alice", 25));
        console.log('createUser("", 0):', createUser("", 0));
        console.log('createUser(null, undefined):', createUser(null, undefined));
    },
    
    /**
     * 复杂逻辑表达式
     */
    complexExpressions() {
        console.log('=== 复杂逻辑表达式 ===');
        
        const user = {
            name: 'Alice',
            age: 25,
            isActive: true,
            permissions: ['read', 'write']
        };
        
        // 多条件判断
        const canEdit = user.isActive && 
                       user.age >= 18 && 
                       user.permissions.includes('write');
        
        console.log('用户是否可以编辑:', canEdit);
        
        // 复杂条件组合
        const isValidUser = (user.name && user.name.length > 0) &&
                           (user.age > 0 && user.age < 120) &&
                           (user.isActive !== undefined);
        
        console.log('是否为有效用户:', isValidUser);
        
        /**
         * 权限检查函数
         * @param {Object} user - 用户对象
         * @param {string} action - 要执行的操作
         * @returns {boolean} 是否有权限
         */
        function hasPermission(user, action) {
            // 用户必须存在且处于活跃状态
            if (!user || !user.isActive) {
                return false;
            }
            
            // 管理员拥有所有权限
            if (user.role === 'admin') {
                return true;
            }
            
            // 检查具体权限
            return user.permissions && 
                   user.permissions.includes(action) &&
                   user.age >= 18;
        }
        
        const adminUser = { ...user, role: 'admin' };
        const childUser = { ...user, age: 16 };
        
        console.log('权限检查:');
        console.log('普通用户写权限:', hasPermission(user, 'write'));
        console.log('管理员写权限:', hasPermission(adminUser, 'write'));
        console.log('未成年用户写权限:', hasPermission(childUser, 'write'));
        
        /**
         * 条件链式调用
         * @param {*} value - 初始值
         * @returns {Object} 链式操作对象
         */
        function chain(value) {
            return {
                value,
                and(condition) {
                    return chain(this.value && condition);
                },
                or(condition) {
                    return chain(this.value || condition);
                },
                not() {
                    return chain(!this.value);
                },
                result() {
                    return this.value;
                }
            };
        }
        
        console.log('链式逻辑操作:');
        const result = chain(true)
            .and(5 > 3)
            .and("hello")
            .or(false)
            .result();
        
        console.log('链式操作结果:', result);
    }
};

LogicalOperators.basicLogicalOps();
LogicalOperators.truthyFalsyValues();
LogicalOperators.returnValues();
LogicalOperators.complexExpressions();
```

---

## 6.2 短路逻辑

短路逻辑是JavaScript中逻辑运算符的重要特性，当第一个操作数就能确定整个表达式的结果时，JavaScript会停止求值后续操作数。

### 逻辑与（&&）的短路特性

逻辑与操作符从左到右求值，当遇到第一个假值时立即返回该值，否则返回最后一个值：

```javascript
/**
 * 逻辑与（&&）短路特性详解
 */
const AndShortCircuit = {
    /**
     * 基本短路行为
     */
    basicBehavior() {
        console.log('=== 逻辑与短路行为 ===');
        
        // 第一个操作数为假值时短路
        console.log('false && console.log("不会执行") =', false && console.log("不会执行"));
        console.log('0 && "hello" =', 0 && "hello");              // 0
        console.log('"" && 42 =', "" && 42);                      // ""
        console.log('null && "test" =', null && "test");          // null
        console.log('undefined && 5 =', undefined && 5);          // undefined
        
        // 所有操作数都为真值时返回最后一个值
        console.log('true && "hello" =', true && "hello");        // "hello"
        console.log('5 && 10 && 15 =', 5 && 10 && 15);          // 15
        console.log('"a" && "b" && "c" =', "a" && "b" && "c");   // "c"
        
        // 混合情况
        console.log('true && false && "never" =', true && false && "never"); // false
    },
    
    /**
     * 函数调用的短路
     */
    functionCallShortCircuit() {
        console.log('=== 函数调用短路 ===');
        
        let callCount = 0;
        
        /**
         * 测试函数，会增加调用计数
         * @param {string} name - 函数名称
         * @returns {boolean} 总是返回true
         */
        function testFunction(name) {
            callCount++;
            console.log(`${name} 被调用了，调用次数: ${callCount}`);
            return true;
        }
        
        /**
         * 返回假值的函数
         */
        function returnsFalse() {
            console.log('returnsFalse 被调用');
            return false;
        }
        
        // 测试短路情况
        console.log('短路测试:');
        callCount = 0;
        
        const result1 = false && testFunction('func1');
        console.log('false && testFunction() =', result1);
        console.log('testFunction 调用次数:', callCount); // 0，因为短路了
        
        callCount = 0;
        const result2 = true && testFunction('func2') && testFunction('func3');
        console.log('true && func2() && func3() =', result2);
        console.log('testFunction 调用次数:', callCount); // 2
        
        callCount = 0;
        const result3 = testFunction('func4') && returnsFalse() && testFunction('func5');
        console.log('func4() && returnsFalse() && func5() =', result3);
        console.log('testFunction 调用次数:', callCount); // 1，func5没有被调用
    },
    
    /**
     * 条件执行模式
     */
    conditionalExecution() {
        console.log('=== 条件执行模式 ===');
        
        const user = { name: 'Alice', age: 25, isActive: true };
        const emptyUser = null;
        
        // 安全的方法调用
        console.log('安全方法调用:');
        user && console.log(`用户名: ${user.name}`);           // 执行
        emptyUser && console.log(`用户名: ${emptyUser.name}`); // 不执行，避免错误
        
        // 条件赋值
        let message = '';
        user && user.isActive && (message = `欢迎回来，${user.name}！`);
        console.log('条件赋值结果:', message);
        
        // 数组操作安全检查
        const items = ['a', 'b', 'c'];
        const emptyItems = null;
        
        console.log('数组安全操作:');
        items && items.length > 0 && console.log('第一个元素:', items[0]);
        emptyItems && emptyItems.length > 0 && console.log('不会执行');
        
        /**
         * 安全的深层属性访问
         * @param {Object} obj - 对象
         */
        function safeAccess(obj) {
            // 传统方式（冗长）
            if (obj && obj.user && obj.user.profile && obj.user.profile.address) {
                console.log('传统方式 - 地址:', obj.user.profile.address.city);
            }
            
            // 使用 && 短路（简洁）
            obj && 
            obj.user && 
            obj.user.profile && 
            obj.user.profile.address && 
            console.log('短路方式 - 地址:', obj.user.profile.address.city);
        }
        
        const complexObj = {
            user: {
                profile: {
                    address: { city: 'Beijing' }
                }
            }
        };
        
        console.log('深层访问测试:');
        safeAccess(complexObj);
        safeAccess({}); // 不会报错
    }
};

AndShortCircuit.basicBehavior();
AndShortCircuit.functionCallShortCircuit();
AndShortCircuit.conditionalExecution();
```

### 逻辑或（||）的短路特性

逻辑或操作符从左到右求值，当遇到第一个真值时立即返回该值，否则返回最后一个值：

```javascript
/**
 * 逻辑或（||）短路特性详解
 */
const OrShortCircuit = {
    /**
     * 基本短路行为
     */
    basicBehavior() {
        console.log('=== 逻辑或短路行为 ===');
        
        // 第一个操作数为真值时短路
        console.log('true || console.log("不会执行") =', true || console.log("不会执行"));
        console.log('5 || "hello" =', 5 || "hello");              // 5
        console.log('"test" || 42 =', "test" || 42);              // "test"
        console.log('[] || "empty" =', [] || "empty");            // []（空数组是真值）
        
        // 第一个操作数为假值时继续求值
        console.log('false || "default" =', false || "default");  // "default"
        console.log('0 || 42 =', 0 || 42);                        // 42
        console.log('"" || "fallback" =', "" || "fallback");      // "fallback"
        console.log('null || undefined || "final" =', null || undefined || "final"); // "final"
        
        // 所有操作数都为假值时返回最后一个值
        console.log('false || 0 || "" =', false || 0 || "");      // ""
        console.log('null || undefined || NaN =', null || undefined || NaN); // NaN
    },
    
    /**
     * 默认值设置模式
     */
    defaultValuePattern() {
        console.log('=== 默认值设置 ===');
        
        /**
         * 用户配置函数
         * @param {Object} options - 配置选项
         */
        function createConfig(options = {}) {
            return {
                // 使用 || 设置默认值
                theme: options.theme || 'light',
                fontSize: options.fontSize || 14,
                language: options.language || 'zh-CN',
                autoSave: options.autoSave || false,
                maxItems: options.maxItems || 100
            };
        }
        
        const config1 = createConfig({
            theme: 'dark',
            fontSize: 16
        });
        
        const config2 = createConfig({});
        
        console.log('部分配置:', config1);
        console.log('默认配置:', config2);
        
        /**
         * 函数参数默认值
         * @param {string} name - 用户名
         * @param {number} age - 年龄
         * @param {string} role - 角色
         */
        function createUser(name, age, role) {
            return {
                name: name || 'Anonymous',
                age: age || 0,
                role: role || 'user',
                // 注意：使用 || 的陷阱
                isAdmin: role === 'admin' || false  // 正确的布尔判断
            };
        }
        
        console.log('用户创建测试:');
        console.log('createUser("Alice", 25, "admin"):', createUser("Alice", 25, "admin"));
        console.log('createUser():', createUser());
        console.log('createUser("", 0, ""):', createUser("", 0, "")); // 注意：0和""会被替换
    },
    
    /**
     * 备用值链
     */
    fallbackChain() {
        console.log('=== 备用值链 ===');
        
        // 模拟不同数据源
        const primaryData = null;
        const secondaryData = undefined;
        const cacheData = "";
        const defaultData = "默认数据";
        
        // 多级备用
        const finalData = primaryData || secondaryData || cacheData || defaultData;
        console.log('多级备用结果:', finalData);
        
        /**
         * 配置获取函数
         * @param {string} key - 配置键
         * @returns {*} 配置值
         */
        function getConfig(key) {
            const userConfig = getUserConfig(key);
            const localConfig = getLocalConfig(key);
            const defaultConfig = getDefaultConfig(key);
            
            return userConfig || localConfig || defaultConfig;
        }
        
        /**
         * 模拟用户配置
         * @param {string} key - 配置键
         */
        function getUserConfig(key) {
            const configs = { theme: null, lang: 'en' };
            return configs[key];
        }
        
        /**
         * 模拟本地配置
         * @param {string} key - 配置键
         */
        function getLocalConfig(key) {
            const configs = { theme: 'dark', fontSize: 14 };
            return configs[key];
        }
        
        /**
         * 默认配置
         * @param {string} key - 配置键
         */
        function getDefaultConfig(key) {
            const configs = { theme: 'light', lang: 'zh-CN', fontSize: 16 };
            return configs[key];
        }
        
        console.log('配置获取测试:');
        console.log('theme配置:', getConfig('theme'));     // 'dark' (从本地配置)
        console.log('lang配置:', getConfig('lang'));       // 'en' (从用户配置)
        console.log('fontSize配置:', getConfig('fontSize')); // 14 (从本地配置)
        console.log('unknown配置:', getConfig('unknown'));  // undefined
    },
    
    /**
     * || 运算符的陷阱
     */
    commonPitfalls() {
        console.log('=== || 运算符的陷阱 ===');
        
        console.log('数值0的陷阱:');
        const score = 0;
        const displayScore = score || '未评分';  // 错误：0被当作假值
        console.log('显示分数:', displayScore);  // "未评分" 而不是 0
        
        // 正确的处理方式
        const correctScore = (score !== undefined && score !== null) ? score : '未评分';
        console.log('正确的分数显示:', correctScore); // 0
        
        console.log('空字符串的陷阱:');
        const userInput = "";
        const message = userInput || "请输入内容";  // 空字符串可能是有效输入
        console.log('消息:', message);
        
        // 更精确的检查
        const betterMessage = (userInput !== null && userInput !== undefined) ? userInput : "请输入内容";
        console.log('更好的消息处理:', betterMessage);
        
        console.log('布尔值false的陷阱:');
        const isVisible = false;
        const visibility = isVisible || true;  // 错误：false被替换了
        console.log('可见性:', visibility);    // true 而不是 false
        
        /**
         * 安全的默认值设置
         * @param {*} value - 原始值
         * @param {*} defaultValue - 默认值
         * @returns {*} 处理后的值
         */
        function safeDefault(value, defaultValue) {
            return (value !== null && value !== undefined) ? value : defaultValue;
        }
        
        console.log('安全默认值测试:');
        console.log('safeDefault(0, 10):', safeDefault(0, 10));           // 0
        console.log('safeDefault("", "默认"):', safeDefault("", "默认"));    // ""
        console.log('safeDefault(false, true):', safeDefault(false, true)); // false
        console.log('safeDefault(null, "默认"):', safeDefault(null, "默认")); // "默认"
    }
};

OrShortCircuit.basicBehavior();
OrShortCircuit.defaultValuePattern();
OrShortCircuit.fallbackChain();
OrShortCircuit.commonPitfalls();
```

### 短路逻辑的实际应用

短路逻辑在实际编程中有许多实用的应用场景：

```javascript
/**
 * 短路逻辑的实际应用
 */
const ShortCircuitApplications = {
    /**
     * 性能优化
     */
    performanceOptimization() {
        console.log('=== 性能优化应用 ===');
        
        /**
         * 昂贵的计算函数
         * @param {number} n - 输入数字
         * @returns {number} 计算结果
         */
        function expensiveCalculation(n) {
            console.log('执行昂贵的计算...');
            // 模拟复杂计算
            let result = 0;
            for (let i = 0; i < n * 1000; i++) {
                result += Math.random();
            }
            return result;
        }
        
        const useCache = true;
        const cachedResult = 42;
        
        // 使用短路避免不必要的计算
        const result = useCache && cachedResult || expensiveCalculation(1000);
        console.log('计算结果:', result);
        
        /**
         * 条件性API调用
         * @param {boolean} hasInternetConnection - 是否有网络连接
         * @param {boolean} needsUpdate - 是否需要更新
         */
        function conditionalApiCall(hasInternetConnection, needsUpdate) {
            console.log('检查API调用条件...');
            
            // 只有在有网络且需要更新时才调用API
            hasInternetConnection && 
            needsUpdate && 
            console.log('调用API更新数据');
            
            // 或者提供离线功能
            !hasInternetConnection && console.log('使用离线数据');
        }
        
        console.log('条件API调用测试:');
        conditionalApiCall(true, true);   // 会调用API
        conditionalApiCall(false, true);  // 使用离线数据
        conditionalApiCall(true, false);  // 不会调用API
    },
    
    /**
     * 错误处理和防护
     */
    errorHandling() {
        console.log('=== 错误处理应用 ===');
        
        /**
         * 安全的对象方法调用
         * @param {Object} obj - 可能为null的对象
         */
        function safeMethodCall(obj) {
            // 传统方式
            if (obj && typeof obj.method === 'function') {
                obj.method();
            }
            
            // 短路方式（更简洁）
            obj && typeof obj.method === 'function' && obj.method();
        }
        
        const validObj = {
            method() {
                console.log('方法被安全调用');
            }
        };
        
        console.log('安全方法调用测试:');
        safeMethodCall(validObj);  // 正常调用
        safeMethodCall(null);      // 不会报错
        safeMethodCall({});        // 不会报错
        
        /**
         * 数组操作安全检查
         * @param {Array} arr - 可能为空的数组
         */
        function safeArrayOperations(arr) {
            console.log('数组安全操作:');
            
            // 检查数组存在且有元素
            arr && arr.length > 0 && console.log('第一个元素:', arr[0]);
            arr && arr.length > 0 && console.log('数组长度:', arr.length);
            
            // 安全的数组方法调用
            arr && Array.isArray(arr) && arr.forEach && 
            console.log('数组元素:', arr.join(', '));
        }
        
        console.log('数组安全操作测试:');
        safeArrayOperations([1, 2, 3]);  // 正常操作
        safeArrayOperations([]);         // 不会输出
        safeArrayOperations(null);       // 不会报错
        
        /**
         * DOM操作安全检查
         * @param {string} elementId - 元素ID
         */
        function safeDOMOperation(elementId) {
            // 模拟DOM操作
            const element = { 
                style: { display: 'block' },
                textContent: '模拟元素'
            };
            
            // 安全的DOM操作
            element && element.style && (element.style.display = 'none');
            element && element.textContent !== undefined && 
            console.log('元素内容:', element.textContent);
        }
        
        safeDOMOperation('test-element');
    },
    
    /**
     * 条件渲染和UI逻辑
     */
    conditionalRendering() {
        console.log('=== 条件渲染应用 ===');
        
        /**
         * 模拟React组件的条件渲染
         * @param {Object} props - 组件属性
         */
        function UserProfile(props) {
            const { user, isLoggedIn, showAvatar } = props;
            
            console.log('渲染用户资料:');
            
            // 条件渲染逻辑
            isLoggedIn && user && console.log(`用户名: ${user.name}`);
            isLoggedIn && user && user.email && console.log(`邮箱: ${user.email}`);
            isLoggedIn && user && showAvatar && user.avatar && 
            console.log(`头像: ${user.avatar}`);
            
            // 错误状态处理
            !isLoggedIn && console.log('请登录');
            isLoggedIn && !user && console.log('用户信息加载中...');
        }
        
        const mockUser = {
            name: 'Alice',
            email: 'alice@example.com',
            avatar: 'avatar.jpg'
        };
        
        console.log('条件渲染测试:');
        UserProfile({ user: mockUser, isLoggedIn: true, showAvatar: true });
        UserProfile({ user: null, isLoggedIn: false, showAvatar: true });
        
        /**
         * 表单验证
         * @param {Object} formData - 表单数据
         */
        function validateForm(formData) {
            console.log('表单验证:');
            
            const errors = [];
            
            // 使用短路进行验证
            !formData.username && errors.push('用户名不能为空');
            !formData.email && errors.push('邮箱不能为空');
            formData.email && !formData.email.includes('@') && 
            errors.push('邮箱格式不正确');
            !formData.password && errors.push('密码不能为空');
            formData.password && formData.password.length < 6 && 
            errors.push('密码长度不能少于6位');
            
            // 显示验证结果
            errors.length === 0 && console.log('表单验证通过');
            errors.length > 0 && console.log('验证错误:', errors);
            
            return errors.length === 0;
        }
        
        console.log('表单验证测试:');
        validateForm({
            username: 'alice',
            email: 'alice@example.com',
            password: '123456'
        });
        
        validateForm({
            username: '',
            email: 'invalid-email',
            password: '123'
        });
    },
    
    /**
     * 链式操作和流水线
     */
    chainingOperations() {
        console.log('=== 链式操作应用 ===');
        
        /**
         * 数据处理流水线
         * @param {Array} data - 原始数据
         */
        function processingPipeline(data) {
            console.log('数据处理流水线:');
            
            // 使用短路实现流水线处理
            const result = data &&
                          Array.isArray(data) &&
                          data.filter(item => item && item.active) &&
                          data.map(item => ({ ...item, processed: true })) &&
                          data.sort((a, b) => a.priority - b.priority);
            
            result && console.log('处理结果:', result);
            !result && console.log('数据处理失败');
            
            return result;
        }
        
        const testData = [
            { id: 1, active: true, priority: 2 },
            { id: 2, active: false, priority: 1 },
            { id: 3, active: true, priority: 3 }
        ];
        
        processingPipeline(testData);
        processingPipeline(null);
        
        /**
         * 配置初始化链
         * @param {Object} options - 配置选项
         */
        function initializeApp(options) {
            console.log('应用初始化:');
            
            // 初始化链
            const success = options &&
                           options.apiKey &&
                           console.log('API密钥验证通过') ||
                           options.debug && console.log('调试模式开启') ||
                           console.log('基本配置加载完成');
            
            return success;
        }
        
        console.log('应用初始化测试:');
        initializeApp({ apiKey: 'abc123', debug: true });
        initializeApp({ debug: false });
    }
};

ShortCircuitApplications.performanceOptimization();
ShortCircuitApplications.errorHandling();
ShortCircuitApplications.conditionalRendering();
ShortCircuitApplications.chainingOperations();
```

---

## 6.3 可选链（?.）与空值合并（??）

ES2020引入的可选链和空值合并操作符为JavaScript提供了更安全、更简洁的属性访问和默认值设置方式。

### 可选链操作符（?.）

可选链操作符允许安全地访问深层嵌套的对象属性，而不必验证每个引用：

```javascript
/**
 * 可选链操作符（?.）详解
 */
const OptionalChaining = {
    /**
     * 基本用法
     */
    basicUsage() {
        console.log('=== 可选链基本用法 ===');
        
        const user = {
            id: 1,
            name: 'Alice',
            address: {
                street: '123 Main St',
                city: 'Beijing',
                country: 'China'
            },
            contacts: {
                email: 'alice@example.com'
            }
        };
        
        const emptyUser = null;
        
        // 传统的安全访问方式（冗长）
        console.log('传统方式:');
        console.log('用户城市:', user && user.address && user.address.city);
        console.log('空用户城市:', emptyUser && emptyUser.address && emptyUser.address.city);
        
        // 使用可选链（简洁）
        console.log('可选链方式:');
        console.log('用户城市:', user?.address?.city);           // 'Beijing'
        console.log('空用户城市:', emptyUser?.address?.city);     // undefined
        console.log('不存在的属性:', user?.profile?.avatar);      // undefined
        
        // 可选链的短路特性
        console.log('短路特性:');
        console.log('user?.nonExistent?.deep?.property:', user?.nonExistent?.deep?.property); // undefined
    },
    
    /**
     * 数组和方法的可选链
     */
    arrayAndMethodChaining() {
        console.log('=== 数组和方法可选链 ===');
        
        const data = {
            items: [
                { id: 1, name: 'Item 1' },
                { id: 2, name: 'Item 2' }
            ],
            getItemById(id) {
                return this.items.find(item => item.id === id);
            }
        };
        
        const emptyData = null;
        
        // 数组索引的可选链
        console.log('数组访问:');
        console.log('第一个项目:', data?.items?.[0]?.name);        // 'Item 1'
        console.log('第十个项目:', data?.items?.[9]?.name);        // undefined
        console.log('空数据项目:', emptyData?.items?.[0]?.name);   // undefined
        
        // 方法调用的可选链
        console.log('方法调用:');
        console.log('调用方法:', data?.getItemById?.(1)?.name);   // 'Item 1'
        console.log('调用不存在的方法:', data?.nonExistentMethod?.()); // undefined
        console.log('空对象方法调用:', emptyData?.getItemById?.(1)); // undefined
        
        // 动态属性访问
        const propName = 'items';
        const index = 0;
        console.log('动态访问:', data?.[propName]?.[index]?.name); // 'Item 1'
    },
    
    /**
     * 实际应用场景
     */
    practicalApplications() {
        console.log('=== 实际应用场景 ===');
        
        // API响应处理
        const apiResponse = {
            data: {
                user: {
                    profile: {
                        personal: {
                            firstName: 'John',
                            lastName: 'Doe'
                        },
                        preferences: {
                            theme: 'dark',
                            notifications: true
                        }
                    }
                }
            }
        };
        
        const emptyResponse = null;
        
        console.log('API响应处理:');
        console.log('用户名:', apiResponse?.data?.user?.profile?.personal?.firstName);
        console.log('主题:', apiResponse?.data?.user?.profile?.preferences?.theme);
        console.log('空响应:', emptyResponse?.data?.user?.profile?.personal?.firstName);
        
        // DOM操作安全检查
        const mockElement = {
            parentElement: {
                children: [
                    { tagName: 'DIV', textContent: 'Child 1' },
                    { tagName: 'SPAN', textContent: 'Child 2' }
                ]
            }
        };
        
        console.log('DOM操作:');
        console.log('父元素第一个子元素:', mockElement?.parentElement?.children?.[0]?.textContent);
        console.log('不存在的元素:', mockElement?.nonExistent?.children?.[0]?.textContent);
        
        /**
         * 配置对象安全访问
         * @param {Object} config - 配置对象
         */
        function processConfig(config) {
            console.log('配置处理:');
            console.log('数据库主机:', config?.database?.connection?.host || 'localhost');
            console.log('缓存TTL:', config?.cache?.redis?.ttl || 3600);
            console.log('日志级别:', config?.logging?.level || 'info');
        }
        
        const fullConfig = {
            database: {
                connection: { host: 'db.example.com', port: 5432 }
            },
            cache: {
                redis: { ttl: 7200 }
            }
        };
        
        processConfig(fullConfig);
        processConfig({});
        processConfig(null);
    }
};

OptionalChaining.basicUsage();
OptionalChaining.arrayAndMethodChaining();
OptionalChaining.practicalApplications();
```

### 空值合并操作符（??）

空值合并操作符只有在左侧为null或undefined时才返回右侧值：

```javascript
/**
 * 空值合并操作符（??）详解  
 */
const NullishCoalescing = {
    /**
     * 基本用法
     */
    basicUsage() {
        console.log('=== 空值合并基本用法 ===');
        
        // ?? vs ||  的区别
        const values = [null, undefined, false, 0, '', 'hello', NaN];
        
        console.log('?? vs || 对比:');
        values.forEach(value => {
            const strValue = value === null ? 'null' : 
                           value === undefined ? 'undefined' :
                           typeof value === 'string' ? `"${value}"` : value;
            
            console.log(`${strValue} ?? "default" =`, value ?? "default");
            console.log(`${strValue} || "default" =`, value || "default");
            console.log('---');
        });
        
        // ?? 只处理 null 和 undefined
        console.log('仅处理null和undefined:');
        console.log('false ?? true =', false ?? true);         // false
        console.log('0 ?? 42 =', 0 ?? 42);                     // 0
        console.log('"" ?? "default" =', "" ?? "default");     // ""
        console.log('null ?? "default" =', null ?? "default"); // "default"
        console.log('undefined ?? "default" =', undefined ?? "default"); // "default"
    },
    
    /**
     * 配置默认值
     */
    configurationDefaults() {
        console.log('=== 配置默认值 ===');
        
        /**
         * 创建应用配置
         * @param {Object} userConfig - 用户配置
         */
        function createAppConfig(userConfig = {}) {
            return {
                // 使用 ?? 保留有效的falsy值
                theme: userConfig.theme ?? 'light',
                fontSize: userConfig.fontSize ?? 14,
                autoSave: userConfig.autoSave ?? true,
                maxConnections: userConfig.maxConnections ?? 10,
                timeout: userConfig.timeout ?? 5000,
                debug: userConfig.debug ?? false
            };
        }
        
        const config1 = createAppConfig({
            theme: 'dark',
            fontSize: 0,        // 有效值：最小字号
            autoSave: false,    // 有效值：关闭自动保存
            timeout: 0          // 有效值：无超时
        });
        
        const config2 = createAppConfig({
            theme: null,        // 使用默认值
            fontSize: undefined // 使用默认值
        });
        
        console.log('配置1 (保留falsy值):', config1);
        console.log('配置2 (使用默认值):', config2);
        
        // 对比使用 || 的问题
        function createAppConfigWithOr(userConfig = {}) {
            return {
                theme: userConfig.theme || 'light',
                fontSize: userConfig.fontSize || 14,
                autoSave: userConfig.autoSave || true,
                timeout: userConfig.timeout || 5000,
                debug: userConfig.debug || false
            };
        }
        
        const configWithOr = createAppConfigWithOr({
            fontSize: 0,        // 会被替换为14
            autoSave: false,    // 会被替换为true
            timeout: 0          // 会被替换为5000
        });
        
        console.log('使用 || 的配置 (丢失有效falsy值):', configWithOr);
    },
    
    /**
     * 函数参数默认值
     */
    functionDefaults() {
        console.log('=== 函数参数默认值 ===');
        
        /**
         * 用户信息处理函数
         * @param {Object} options - 选项
         */
        function processUser(options) {
            const {
                name = 'Anonymous',      // ES6默认参数
                age,
                isActive,
                score,
                tags
            } = options ?? {};          // 防止options为null/undefined
            
            // 使用 ?? 处理可能的null/undefined值
            const userAge = age ?? 0;
            const userActive = isActive ?? false;  
            const userScore = score ?? -1;         // -1表示未评分
            const userTags = tags ?? [];
            
            console.log('处理后的用户信息:');
            console.log(`姓名: ${name}`);
            console.log(`年龄: ${userAge}`);
            console.log(`活跃: ${userActive}`);
            console.log(`评分: ${userScore}`);
            console.log(`标签: [${userTags.join(', ')}]`);
        }
        
        // 测试不同的输入
        processUser({
            name: 'Alice',
            age: 0,         // 有效的0值
            isActive: false, // 有效的false值
            score: 0,       // 有效的0分
            tags: []        // 有效的空数组
        });
        
        processUser({
            name: 'Bob',
            age: null,      // 使用默认值
            isActive: null, // 使用默认值
            score: undefined, // 使用默认值
            tags: null      // 使用默认值
        });
        
        processUser(null); // 整个options为null
    }
};

NullishCoalescing.basicUsage();
NullishCoalescing.configurationDefaults();
NullishCoalescing.functionDefaults();
```

### 现代JavaScript的安全访问模式

结合可选链和空值合并，可以创建更安全、更简洁的代码模式：

```javascript
/**
 * 现代JavaScript安全访问模式
 */
const ModernSafeAccess = {
    /**
     * 组合使用?.和??
     */
    combinedUsage() {
        console.log('=== 组合使用?.和?? ===');
        
        const apiData = {
            user: {
                profile: null,
                settings: {
                    theme: '',
                    fontSize: 0,
                    notifications: false
                }
            }
        };
        
        // 组合使用：安全访问 + 默认值
        const theme = apiData?.user?.settings?.theme ?? 'light';
        const fontSize = apiData?.user?.settings?.fontSize ?? 14;
        const notifications = apiData?.user?.settings?.notifications ?? true;
        const avatar = apiData?.user?.profile?.avatar ?? 'default.png';
        
        console.log('组合使用结果:');
        console.log('主题:', theme);                    // 'light' (空字符串被保留,但??处理)
        console.log('字体大小:', fontSize);            // 0 (保留有效的0值)
        console.log('通知:', notifications);           // false (保留有效的false值)  
        console.log('头像:', avatar);                  // 'default.png' (profile为null)
    },
    
    /**
     * 实用工具函数
     */
    utilityFunctions() {
        console.log('=== 实用工具函数 ===');
        
        /**
         * 安全获取深层属性
         * @param {Object} obj - 源对象
         * @param {string} path - 属性路径
         * @param {*} defaultValue - 默认值
         * @returns {*} 属性值或默认值
         */
        function safeGet(obj, path, defaultValue) {
            const keys = path.split('.');
            let current = obj;
            
            for (const key of keys) {
                current = current?.[key];
                if (current === null || current === undefined) {
                    return defaultValue;
                }
            }
            
            return current ?? defaultValue;
        }
        
        /**
         * 现代版本使用模板字符串
         * @param {Object} obj - 源对象  
         * @param {string} path - 属性路径
         * @param {*} defaultValue - 默认值
         */
        function modernSafeGet(obj, path, defaultValue) {
            try {
                // 动态构建可选链表达式
                const result = new Function('obj', `return obj?.${path.replace(/\./g, '?.')}`)(obj);
                return result ?? defaultValue;
            } catch (error) {
                return defaultValue;
            }
        }
        
        const testData = {
            user: {
                profile: {
                    personal: {
                        name: 'Alice',
                        age: 0
                    }
                }
            }
        };
        
        console.log('safeGet测试:');
        console.log('姓名:', safeGet(testData, 'user.profile.personal.name', 'Unknown'));
        console.log('年龄:', safeGet(testData, 'user.profile.personal.age', 18));
        console.log('不存在:', safeGet(testData, 'user.profile.nonExistent', 'Default'));
        
        console.log('modernSafeGet测试:');
        console.log('姓名:', modernSafeGet(testData, 'user.profile.personal.name', 'Unknown'));
        console.log('年龄:', modernSafeGet(testData, 'user.profile.personal.age', 18));
    },
    
    /**
     * 表单处理示例
     */
    formProcessing() {
        console.log('=== 表单处理示例 ===');
        
        /**
         * 处理表单提交
         * @param {Object} formData - 表单数据
         */
        function processForm(formData) {
            // 使用现代语法安全处理表单数据
            const userData = {
                // 必需字段使用??,确保有默认值
                name: formData?.personalInfo?.name ?? '',
                email: formData?.contactInfo?.email ?? '',
                
                // 可选字段,保留有效的falsy值
                age: formData?.personalInfo?.age ?? null,
                phone: formData?.contactInfo?.phone ?? null,
                
                // 布尔字段,明确处理null/undefined
                newsletter: formData?.preferences?.newsletter ?? false,
                smsNotifications: formData?.preferences?.smsNotifications ?? false,
                
                // 数组字段
                interests: formData?.preferences?.interests ?? [],
                
                // 嵌套对象
                address: {
                    street: formData?.address?.street ?? '',
                    city: formData?.address?.city ?? '',
                    country: formData?.address?.country ?? 'CN'
                }
            };
            
            console.log('处理后的用户数据:', userData);
            
            // 验证必需字段
            const requiredFields = ['name', 'email'];
            const missingFields = requiredFields.filter(field => !userData[field]);
            
            if (missingFields.length > 0) {
                console.log('缺少必需字段:', missingFields);
                return { success: false, errors: missingFields };
            }
            
            return { success: true, data: userData };
        }
        
        // 测试完整表单
        const completeForm = {
            personalInfo: {
                name: 'John Doe',
                age: 0  // 有效的0岁（婴儿）
            },
            contactInfo: {
                email: 'john@example.com',
                phone: ''  // 有效的空手机号
            },
            preferences: {
                newsletter: false,  // 明确不订阅
                smsNotifications: null,  // 未设置,使用默认值
                interests: ['tech', 'music']
            },
            address: {
                street: '123 Main St',
                city: 'Beijing'
                // country缺失,使用默认值
            }
        };
        
        // 测试不完整表单
        const incompleteForm = {
            personalInfo: {
                name: 'Jane'  // 缺少email
            }
        };
        
        console.log('完整表单处理:');
        processForm(completeForm);
        
        console.log('不完整表单处理:');
        processForm(incompleteForm);
    }
};

ModernSafeAccess.combinedUsage();
ModernSafeAccess.utilityFunctions();
ModernSafeAccess.formProcessing();
```

---

## 6.4 == vs ===

理解==和===的区别是JavaScript编程的重要基础，选择正确的比较操作符可以避免许多隐藏的错误。

### 等值比较（==）

等值比较会进行类型转换，试图将两个值转换为可比较的类型：

```javascript
/**
 * 等值比较（==）详解
 */
const LooseEquality = {
    /**
     * 基本类型转换规则
     */
    basicConversions() {
        console.log('=== 等值比较的类型转换 ===');
        
        // 数字与字符串比较
        console.log('数字与字符串:');
        console.log('5 == "5" =', 5 == "5");              // true (字符串转数字)
        console.log('0 == "" =', 0 == "");                // true (空字符串转数字0)
        console.log('123 == "123" =', 123 == "123");      // true
        
        // 布尔值与其他类型比较
        console.log('布尔值比较:');
        console.log('true == 1 =', true == 1);            // true (布尔转数字)
        console.log('false == 0 =', false == 0);          // true
        console.log('true == "1" =', true == "1");        // true (both convert to 1)
        console.log('false == "" =', false == "");        // true (both convert to 0)
        
        // null和undefined的特殊规则
        console.log('null和undefined:');
        console.log('null == undefined =', null == undefined); // true (特殊规则)
        console.log('null == 0 =', null == 0);            // false (null不转换为0)
        console.log('undefined == 0 =', undefined == 0);  // false
        
        // 对象与基本类型比较
        console.log('对象转换:');
        console.log('[1] == 1 =', [1] == 1);              // true (数组转换为"1"，再转数字)
        console.log('[1,2] == "1,2" =', [1,2] == "1,2");  // true (数组转字符串)
        console.log('{} == "[object Object]" =', {} == "[object Object]"); // true
    },
    
    /**
     * 复杂转换案例
     */
    complexCases() {
        console.log('=== 复杂转换案例 ===');
        
        // 经典的比较陷阱
        console.log('经典陷阱:');
        console.log('[] == ![] =', [] == ![]);            // true!
        console.log('步骤分解:');
        console.log('1. ![] =', ![]);                     // false (空数组是真值，取反为false)
        console.log('2. [] == false =', [] == false);     // true (数组转""，false转0，""转0)
        
        console.log('"0" == false =', "0" == false);      // true
        console.log('0 == false =', 0 == false);          // true
        console.log('"" == 0 =', "" == 0);                // true
        
        // 多步转换
        console.log('多步转换:');
        console.log('[0] == false =', [0] == false);      // true
        console.log('分解: [0] -> "0" -> 0, false -> 0'); // 说明转换过程
        
        /**
         * 模拟==操作符的转换过程
         * @param {*} left - 左操作数
         * @param {*} right - 右操作数
         * @returns {boolean} 比较结果
         */
        function simulateLooseEquality(left, right) {
            console.log(`比较 ${JSON.stringify(left)} == ${JSON.stringify(right)}`);
            
            // 类型相同时直接比较
            if (typeof left === typeof right) {
                return left === right;
            }
            
            // null和undefined的特殊规则
            if ((left === null && right === undefined) || 
                (left === undefined && right === null)) {
                return true;
            }
            
            // 数字与字符串
            if (typeof left === 'number' && typeof right === 'string') {
                const rightAsNumber = Number(right);
                console.log(`  转换: "${right}" -> ${rightAsNumber}`);
                return left === rightAsNumber;
            }
            
            if (typeof left === 'string' && typeof right === 'number') {
                const leftAsNumber = Number(left);
                console.log(`  转换: "${left}" -> ${leftAsNumber}`);
                return leftAsNumber === right;
            }
            
            // 布尔值转换
            if (typeof left === 'boolean') {
                const leftAsNumber = Number(left);
                console.log(`  转换: ${left} -> ${leftAsNumber}`);
                return simulateLooseEquality(leftAsNumber, right);
            }
            
            if (typeof right === 'boolean') {
                const rightAsNumber = Number(right);
                console.log(`  转换: ${right} -> ${rightAsNumber}`);
                return simulateLooseEquality(left, rightAsNumber);
            }
            
            return false;
        }
        
        console.log('转换过程模拟:');
        simulateLooseEquality("5", 5);
        simulateLooseEquality(true, "1");
    },
    
    /**
     * 实际问题案例
     */
    practicalProblems() {
        console.log('=== 实际问题案例 ===');
        
        // 用户输入验证的问题
        function checkUserInput(input) {
            if (input == 0) {
                return '输入为零';
            } else if (input == '') {
                return '输入为空';
            } else if (input == false) {
                return '输入为假';
            }
            return '有效输入';
        }
        
        console.log('用户输入验证问题:');
        console.log('checkUserInput(0):', checkUserInput(0));        // "输入为零"
        console.log('checkUserInput(""):', checkUserInput(""));      // "输入为空"  
        console.log('checkUserInput("0"):', checkUserInput("0"));    // "输入为零"（意外！）
        console.log('checkUserInput(false):', checkUserInput(false)); // "输入为假"
        
        // 数组查找的问题
        const numbers = [1, 2, 3, "4", 5];
        console.log('数组查找问题:');
        console.log('numbers.indexOf(4):', numbers.indexOf(4));      // -1 (严格查找)
        console.log('numbers.includes(4):', numbers.includes(4));    // false (严格查找)
        
        // 手动使用==查找
        const found = numbers.find(item => item == 4);
        console.log('使用==查找:', found);                           // "4" (找到了字符串)
        
        // 对象属性比较问题
        const userData = {
            age: "25",
            score: "0",
            isActive: "false"
        };
        
        console.log('对象属性比较:');
        console.log('userData.age == 25:', userData.age == 25);      // true (意外类型转换)
        console.log('userData.score == false:', userData.score == false); // true (意外!)
        console.log('userData.isActive == false:', userData.isActive == false); // false
    }
};

LooseEquality.basicConversions();
LooseEquality.complexCases();
LooseEquality.practicalProblems();
```

### 严格相等比较（===）

严格相等比较不进行类型转换，只有类型和值都相同才返回true：

```javascript
/**
 * 严格相等比较（===）详解
 */
const StrictEquality = {
    /**
     * 基本严格比较
     */
    basicComparisons() {
        console.log('=== 严格相等比较 ===');
        
        // 相同类型和值
        console.log('相同类型和值:');
        console.log('5 === 5 =', 5 === 5);                // true
        console.log('"hello" === "hello" =', "hello" === "hello"); // true
        console.log('true === true =', true === true);    // true
        
        // 不同类型（即使值"相等"）
        console.log('不同类型:');
        console.log('5 === "5" =', 5 === "5");            // false
        console.log('true === 1 =', true === 1);          // false
        console.log('false === 0 =', false === 0);        // false
        console.log('null === undefined =', null === undefined); // false
        
        // 特殊值比较
        console.log('特殊值:');
        console.log('NaN === NaN =', NaN === NaN);          // false (NaN特殊规则)
        console.log('0 === -0 =', 0 === -0);                // true (但Object.is(0, -0)是false)
        console.log('Infinity === Infinity =', Infinity === Infinity); // true
        
        // 对象和数组（引用比较）
        console.log('对象和数组:');
        const obj1 = { a: 1 };
        const obj2 = { a: 1 };
        const obj3 = obj1;
        
        console.log('obj1 === obj2 =', obj1 === obj2);      // false (不同引用)
        console.log('obj1 === obj3 =', obj1 === obj3);      // true (相同引用)
        
        console.log('[1,2] === [1,2] =', [1,2] === [1,2]);  // false (不同引用)
    },
    
    /**
     * Object.is() 方法
     */
    objectIs() {
        console.log('=== Object.is() 方法 ===');
        
        // Object.is() 比 === 更严格
        console.log('Object.is vs ===:');
        console.log('Object.is(NaN, NaN) =', Object.is(NaN, NaN));    // true
        console.log('NaN === NaN =', NaN === NaN);                    // false
        
        console.log('Object.is(0, -0) =', Object.is(0, -0));         // false
        console.log('0 === -0 =', 0 === -0);                         // true
        
        console.log('Object.is(+0, -0) =', Object.is(+0, -0));       // false
        console.log('+0 === -0 =', +0 === -0);                       // true
        
        // 其他情况下与===相同
        console.log('其他情况:');
        console.log('Object.is(5, 5) =', Object.is(5, 5));           // true
        console.log('Object.is("a", "a") =', Object.is("a", "a"));   // true
        console.log('Object.is(5, "5") =', Object.is(5, "5"));       // false
        
        /**
         * 选择合适的比较方法
         * @param {*} a - 第一个值
         * @param {*} b - 第二个值
         * @returns {Object} 不同方法的比较结果
         */
        function compareValues(a, b) {
            return {
                'a == b': a == b,
                'a === b': a === b,
                'Object.is(a, b)': Object.is(a, b)
            };
        }
        
        console.log('比较方法对比:');
        console.log('5, "5":', compareValues(5, "5"));
        console.log('NaN, NaN:', compareValues(NaN, NaN));
        console.log('0, -0:', compareValues(0, -0));
    },
    
    /**
     * 实际应用优势
     */
    practicalAdvantages() {
        console.log('=== 严格比较的优势 ===');
        
        // 避免意外的类型转换
        function safeUserInputValidation(input) {
            if (input === 0) {
                return '输入为数字零';
            } else if (input === '') {
                return '输入为空字符串';  
            } else if (input === false) {
                return '输入为布尔假';
            } else if (input === null) {
                return '输入为null';
            } else if (input === undefined) {
                return '输入为undefined';
            }
            return '有效输入: ' + typeof input;
        }
        
        console.log('安全的用户输入验证:');
        console.log('safeUserInputValidation(0):', safeUserInputValidation(0));
        console.log('safeUserInputValidation(""):', safeUserInputValidation(""));
        console.log('safeUserInputValidation("0"):', safeUserInputValidation("0"));
        console.log('safeUserInputValidation(false):', safeUserInputValidation(false));
        
        // 数组操作的安全性
        const mixedArray = [1, "1", true, 1, false, 0];
        
        console.log('数组操作安全性:');
        console.log('原数组:', mixedArray);
        
        // 使用===进行精确过滤
        const exactOnes = mixedArray.filter(item => item === 1);
        console.log('精确的数字1:', exactOnes);
        
        const exactStrings = mixedArray.filter(item => item === "1");
        console.log('精确的字符串"1":', exactStrings);
        
        // 配置对象比较
        const defaultConfig = { debug: false, timeout: 0, theme: '' };
        const userConfig = { debug: false, timeout: 0, theme: '' };
        
        console.log('配置比较:');
        console.log('debug相等:', defaultConfig.debug === userConfig.debug);
        console.log('timeout相等:', defaultConfig.timeout === userConfig.timeout);
        console.log('theme相等:', defaultConfig.theme === userConfig.theme);
        
        // 如果使用==可能出现的问题
        const problematicConfig = { debug: "false", timeout: "", theme: 0 };
        console.log('问题配置的==比较:');
        console.log('debug == false:', problematicConfig.debug == false);        // false (意外!)
        console.log('timeout == 0:', problematicConfig.timeout == 0);           // true (意外转换)
        console.log('theme == "":', problematicConfig.theme == "");             // true (意外转换)
    }
};

StrictEquality.basicComparisons();
StrictEquality.objectIs();
StrictEquality.practicalAdvantages();
```

### 比较运算的最佳实践

基于==和===的特性，这里是一些最佳实践建议：

```javascript
/**
 * 比较运算最佳实践
 */
const ComparisonBestPractices = {
    /**
     * 何时使用===
     */
    whenToUseStrict() {
        console.log('=== 推荐使用===的场景 ===');
        
        // 1. 一般情况下总是使用===
        console.log('1. 默认选择===');
        
        // 2. 配置和状态比较
        function processConfig(config) {
            if (config.enabled === true) {          // 明确要求布尔true
                console.log('功能已启用');
            }
            
            if (config.level === 0) {               // 明确要求数字0
                console.log('级别为零');
            }
            
            if (config.theme === '') {              // 明确要求空字符串
                console.log('未设置主题');
            }
        }
        
        // 3. 数组和对象操作
        const users = [
            { id: 1, name: 'Alice' },
            { id: '1', name: 'Bob' },              // 注意：字符串ID
            { id: 1, name: 'Charlie' }
        ];
        
        function findUserById(id) {
            return users.find(user => user.id === id);  // 精确匹配ID类型
        }
        
        console.log('查找数字ID 1:', findUserById(1));
        console.log('查找字符串ID "1":', findUserById('1'));
        
        // 4. 类型安全的工具函数
        /**
         * 安全的类型检查函数
         * @param {*} value - 要检查的值
         * @param {*} expectedValue - 期望值
         * @param {string} expectedType - 期望类型
         * @returns {boolean} 是否匹配
         */
        function strictTypeCheck(value, expectedValue, expectedType) {
            return typeof value === expectedType && value === expectedValue;
        }
        
        console.log('类型安全检查:');
        console.log('strictTypeCheck(5, 5, "number"):', strictTypeCheck(5, 5, "number"));
        console.log('strictTypeCheck("5", 5, "number"):', strictTypeCheck("5", 5, "number"));
    },
    
    /**
     * 何时可以使用==
     */
    whenToUseLoose() {
        console.log('=== 可以考虑使用==的场景 ===');
        
        // 1. null/undefined检查（唯一推荐的场景）
        function processValue(value) {
            if (value == null) {                    // 检查null或undefined
                console.log('值为null或undefined');
                return;
            }
            console.log('处理值:', value);
        }
        
        console.log('null/undefined检查:');
        processValue(null);
        processValue(undefined);
        processValue(0);                            // 不会被当作null处理
        
        // 但是更明确的写法是：
        function explicitNullCheck(value) {
            if (value === null || value === undefined) {
                console.log('值为null或undefined（明确检查）');
                return;
            }
            console.log('处理值:', value);
        }
        
        // 2. 与用户输入的宽松比较（谨慎使用）
        function flexibleSearch(searchTerm, items) {
            // 注意：这种用法需要明确文档说明
            return items.filter(item => item.id == searchTerm);
        }
        
        const items = [
            { id: 1, name: 'Item 1' },
            { id: '2', name: 'Item 2' },
            { id: 3, name: 'Item 3' }
        ];
        
        console.log('宽松搜索 "1":', flexibleSearch('1', items));
        console.log('宽松搜索 2:', flexibleSearch(2, items));
    },
    
    /**
     * 避免常见陷阱
     */
    avoidCommonPitfalls() {
        console.log('=== 避免常见陷阱 ===');
        
        // 1. 布尔值比较陷阱
        console.log('1. 布尔值比较:');
        const isEnabled = 'true';                   // 来自API的字符串
        
        // ❌ 错误的比较
        if (isEnabled == true) {
            console.log('这不会执行'); 
        }
        
        // ✅ 正确的处理
        if (isEnabled === 'true') {
            console.log('正确的字符串比较');
        }
        
        // 或者明确转换
        if (Boolean(isEnabled)) {
            console.log('明确转换为布尔值');
        }
        
        // 2. 数字比较陷阱
        console.log('2. 数字比较:');
        const userAge = '25';                       // 来自表单的字符串
        
        // ❌ 危险的比较
        if (userAge == 25) {
            console.log('年龄匹配（但类型不安全）');
        }
        
        // ✅ 正确的处理
        const ageAsNumber = parseInt(userAge, 10);
        if (ageAsNumber === 25) {
            console.log('年龄匹配（类型安全）');
        }
        
        // 3. 数组包含检查陷阱
        console.log('3. 数组包含检查:');
        const numbers = [1, 2, 3, '4', 5];
        
        // ❌ 使用==查找可能有意外结果
        const hasNumber4 = numbers.some(n => n == 4);
        console.log('包含数字4（宽松）:', hasNumber4);    // true，但找到的是字符串'4'
        
        // ✅ 使用===进行精确查找
        const hasExactNumber4 = numbers.some(n => n === 4);
        console.log('包含精确数字4:', hasExactNumber4);   // false
        
        const hasString4 = numbers.some(n => n === '4');
        console.log('包含字符串"4":', hasString4);        // true
        
        /**
         * 推荐的比较工具函数
         */
        const ComparisonUtils = {
            /**
             * 安全的相等比较
             * @param {*} a - 第一个值
             * @param {*} b - 第二个值
             * @returns {boolean} 是否相等
             */
            safeEquals(a, b) {
                // 使用===进行严格比较
                return a === b;
            },
            
            /**
             * 宽松的null检查
             * @param {*} value - 要检查的值
             * @returns {boolean} 是否为null或undefined
             */
            isNullish(value) {
                return value === null || value === undefined;
            },
            
            /**
             * 类型安全的比较
             * @param {*} a - 第一个值
             * @param {*} b - 第二个值
             * @param {string} expectedType - 期望类型
             * @returns {boolean} 是否相等且类型匹配
             */
            typeSafeEquals(a, b, expectedType) {
                return typeof a === expectedType && 
                       typeof b === expectedType && 
                       a === b;
            }
        };
        
        console.log('推荐工具函数测试:');
        console.log('safeEquals(5, 5):', ComparisonUtils.safeEquals(5, 5));
        console.log('safeEquals(5, "5"):', ComparisonUtils.safeEquals(5, "5"));
        console.log('isNullish(null):', ComparisonUtils.isNullish(null));
        console.log('isNullish(0):', ComparisonUtils.isNullish(0));
        console.log('typeSafeEquals(5, 5, "number"):', ComparisonUtils.typeSafeEquals(5, 5, "number"));
    }
};

ComparisonBestPractices.whenToUseStrict();
ComparisonBestPractices.whenToUseLoose();
ComparisonBestPractices.avoidCommonPitfalls();
```

---

## 6.5 优先级规则

运算符优先级决定了表达式的求值顺序，理解优先级规则有助于编写正确且可读的代码。

### 运算符优先级表

JavaScript运算符的优先级从高到低排列：

```javascript
/**
 * 运算符优先级演示
 */
const OperatorPrecedence = {
    /**
     * 优先级表演示
     */
    precedenceTable() {
        console.log('=== 运算符优先级表（高到低）===');
        
        // 1. 成员访问和函数调用（优先级最高）
        console.log('1. 成员访问和调用:');
        const obj = { x: 10, fn: () => 5 };
        const arr = [1, 2, 3];
        console.log('obj.x =', obj.x);                     // 成员访问: .
        console.log('arr[0] =', arr[0]);                   // 计算成员访问: []
        console.log('obj.fn() =', obj.fn());               // 函数调用: ()
        console.log('new Date() =', new Date().getFullYear()); // new (带参数)
        
        // 2. 后置递增/递减
        console.log('2. 后置递增/递减:');
        let a = 5;
        console.log('a++ =', a++);                         // 5 (后置递增)
        console.log('a =', a);                             // 6
        
        // 3. 前置递增/递减、一元操作符  
        console.log('3. 前置和一元操作符:');
        let b = 5;
        console.log('++b =', ++b);                         // 6 (前置递增)
        console.log('!true =', !true);                    // false (逻辑非)
        console.log('typeof 123 =', typeof 123);          // "number"
        console.log('+true =', +true);                    // 1 (一元加)
        console.log('-5 =', -5);                          // -5 (一元减)
        
        // 4. 乘法、除法、取余
        console.log('4. 乘除运算:');
        console.log('2 * 3 + 1 =', 2 * 3 + 1);           // 7 (* 优先于 +)
        console.log('8 / 2 - 1 =', 8 / 2 - 1);           // 3 (/ 优先于 -)
        console.log('7 % 3 + 1 =', 7 % 3 + 1);           // 2 (% 优先于 +)
        
        // 5. 加法、减法
        console.log('5. 加减运算:');
        console.log('1 + 2 * 3 =', 1 + 2 * 3);           // 7 (乘法优先)
        console.log('10 - 4 / 2 =', 10 - 4 / 2);         // 8 (除法优先)
        
        // 6. 比较运算符
        console.log('6. 比较运算:');
        console.log('5 + 1 > 3 * 2 =', 5 + 1 > 3 * 2);   // false (6 > 6)
        console.log('2 * 3 >= 5 + 1 =', 2 * 3 >= 5 + 1); // true (6 >= 6)
        
        // 7. 相等性比较
        console.log('7. 相等性比较:');  
        console.log('5 > 3 == true =', 5 > 3 == true);    // true (比较优先于相等)
        console.log('1 + 1 === 2 =', 1 + 1 === 2);       // true
        
        // 8. 逻辑与 (&&)
        console.log('8. 逻辑与:');
        console.log('true && false || true =', true && false || true); // true (&&优先于||)
        
        // 9. 逻辑或 (||)
        console.log('9. 逻辑或:');
        console.log('false || true && false =', false || true && false); // false
        
        // 10. 条件运算符 (?:)
        console.log('10. 条件运算符:');
        console.log('true ? 1 + 1 : 2 * 2 =', true ? 1 + 1 : 2 * 2); // 2
        
        // 11. 赋值运算符（优先级最低）
        console.log('11. 赋值运算:');
        let x = 1 + 2 * 3;                                // 先计算1+6，再赋值
        console.log('x = 1 + 2 * 3; x =', x);             // 7
    },
    
    /**
     * 复杂表达式示例
     */
    complexExpressions() {
        console.log('=== 复杂表达式求值 ===');
        
        // 混合运算优先级
        console.log('混合运算示例:');
        
        const result1 = 2 + 3 * 4 > 10 && true || false;
        console.log('2 + 3 * 4 > 10 && true || false =', result1);
        console.log('求值过程:');
        console.log('  1. 3 * 4 = 12');
        console.log('  2. 2 + 12 = 14');  
        console.log('  3. 14 > 10 = true');
        console.log('  4. true && true = true');
        console.log('  5. true || false = true');
        
        const result2 = !false && 3 + 2 * 4 === 11;
        console.log('!false && 3 + 2 * 4 === 11 =', result2);
        console.log('求值过程:');
        console.log('  1. !false = true');
        console.log('  2. 2 * 4 = 8');
        console.log('  3. 3 + 8 = 11');
        console.log('  4. 11 === 11 = true');
        console.log('  5. true && true = true');
        
        // 函数调用与运算符混合
        function getValue() {
            console.log('getValue() 被调用');
            return 5;
        }
        
        console.log('函数调用混合:');
        const result3 = getValue() + 2 * 3;
        console.log('getValue() + 2 * 3 =', result3);    // 函数先调用，然后乘法，最后加法
    }
};

OperatorPrecedence.precedenceTable();
OperatorPrecedence.complexExpressions();
```

### 结合性规则

当运算符具有相同优先级时，结合性决定求值顺序：

```javascript
/**
 * 运算符结合性演示
 */
const AssociativityRules = {
    /**
     * 左结合性
     */
    leftAssociative() {
        console.log('=== 左结合性运算符 ===');
        
        // 算术运算符（左结合）
        console.log('算术运算符:');
        console.log('8 - 3 - 1 =', 8 - 3 - 1);           // ((8 - 3) - 1) = 4
        console.log('等价于: (8 - 3) - 1 =', (8 - 3) - 1);
        
        console.log('12 / 3 / 2 =', 12 / 3 / 2);         // ((12 / 3) / 2) = 2
        console.log('等价于: (12 / 3) / 2 =', (12 / 3) / 2);
        
        // 比较运算符（左结合）
        console.log('比较运算符:');
        // 注意：连续比较在JavaScript中通常不是预期的行为
        console.log('5 > 3 > 1 =', 5 > 3 > 1);           // false (true > 1 → 1 > 1)
        console.log('分解: (5 > 3) > 1 → true > 1 → 1 > 1 = false');
        
        // 逻辑运算符（左结合）
        console.log('逻辑运算符:');
        console.log('true && false && true =', true && false && true);
        console.log('等价于: (true && false) && true =', (true && false) && true);
        
        console.log('true || false || true =', true || false || true);
        console.log('但由于短路，实际只求值第一个表达式');
    },
    
    /**
     * 右结合性
     */
    rightAssociative() {
        console.log('=== 右结合性运算符 ===');
        
        // 赋值运算符（右结合）
        console.log('赋值运算符:');
        let a, b, c;
        a = b = c = 5;                                    // c = 5; b = c; a = b;
        console.log('a = b = c = 5; 结果: a =', a, 'b =', b, 'c =', c);
        
        // 指数运算符（右结合）
        console.log('指数运算符:');
        console.log('2 ** 3 ** 2 =', 2 ** 3 ** 2);       // 2 ** (3 ** 2) = 2 ** 9 = 512
        console.log('等价于: 2 ** (3 ** 2) =', 2 ** (3 ** 2));
        console.log('如果是左结合: (2 ** 3) ** 2 =', (2 ** 3) ** 2); // 不同结果: 64
        
        // 条件运算符（右结合）
        console.log('条件运算符:');
        const result = true ? false ? 1 : 2 : 3;         // true ? (false ? 1 : 2) : 3
        console.log('true ? false ? 1 : 2 : 3 =', result);
        console.log('等价于: true ? (false ? 1 : 2) : 3 =', true ? (false ? 1 : 2) : 3);
        
        // 一元运算符（右结合）
        console.log('一元运算符:');
        let x = 5;
        console.log('++x =', ++x);                        // 从右到左：++x
        console.log('typeof typeof 42 =', typeof typeof 42); // typeof (typeof 42)
    },
    
    /**
     * 结合性的实际影响
     */
    practicalImplications() {
        console.log('=== 结合性的实际影响 ===');
        
        // 连续赋值的陷阱
        console.log('连续赋值陷阱:');
        const obj1 = {};
        const obj2 = {};
        
        // 这可能不是你想要的
        obj1.prop = obj2.prop = 'value';
        console.log('obj1.prop =', obj1.prop);
        console.log('obj2.prop =', obj2.prop);
        
        // 更安全的方式
        obj1.prop = 'value';
        obj2.prop = 'value';
        
        // 数学运算的精度问题
        console.log('浮点数运算顺序:');
        console.log('0.1 + 0.2 + 0.3 =', 0.1 + 0.2 + 0.3);
        console.log('(0.1 + 0.2) + 0.3 =', (0.1 + 0.2) + 0.3);
        console.log('0.1 + (0.2 + 0.3) =', 0.1 + (0.2 + 0.3));
        
        // 字符串连接
        console.log('字符串连接顺序:');
        console.log('"a" + 1 + 2 =', "a" + 1 + 2);       // "a12" (左结合)
        console.log('1 + 2 + "a" =', 1 + 2 + "a");       // "3a" (先算数字)
        console.log('"a" + (1 + 2) =', "a" + (1 + 2));   // "a3" (括号改变顺序)
    }
};

AssociativityRules.leftAssociative();
AssociativityRules.rightAssociative();
AssociativityRules.practicalImplications();
```

### 复杂表达式的求值顺序

理解复杂表达式的求值顺序有助于调试和优化代码：

```javascript
/**
 * 复杂表达式求值顺序
 */
const ExpressionEvaluation = {
    /**
     * 求值顺序分析
     */
    evaluationOrder() {
        console.log('=== 表达式求值顺序 ===');
        
        /**
         * 模拟带副作用的函数
         * @param {string} name - 函数名
         * @param {*} value - 返回值
         * @returns {*} 返回值
         */
        function sideEffect(name, value) {
            console.log(`函数 ${name}() 被调用，返回: ${value}`);
            return value;
        }
        
        console.log('函数调用顺序测试:');
        const result1 = sideEffect('A', 2) + sideEffect('B', 3) * sideEffect('C', 4);
        console.log('A() + B() * C() 的结果:', result1);
        console.log('调用顺序: 由于*优先级更高，但实际调用顺序是从左到右');
        
        console.log('');
        console.log('逻辑运算中的短路求值:');
        const result2 = sideEffect('D', false) && sideEffect('E', true) && sideEffect('F', true);
        console.log('D() && E() && F() 的结果:', result2);
        console.log('由于短路，E() 和 F() 不会被调用');
        
        console.log('');
        const result3 = sideEffect('G', true) || sideEffect('H', false) || sideEffect('I', true);
        console.log('G() || H() || I() 的结果:', result3);
        console.log('由于短路，H() 和 I() 不会被调用');
    },
    
    /**
     * 复杂条件表达式
     */
    complexConditionals() {
        console.log('=== 复杂条件表达式 ===');
        
        const user = {
            age: 25,
            isActive: true,
            permissions: ['read', 'write'],
            profile: {
                isComplete: true
            }
        };
        
        // 复杂的条件判断
        console.log('复杂条件判断:');
        const canPerformAction = 
            user.age >= 18 &&                           // 年龄检查
            user.isActive &&                            // 活跃状态
            user.permissions.includes('write') &&       // 权限检查
            user.profile?.isComplete !== false;         // 资料完整性
        
        console.log('用户是否可以执行操作:', canPerformAction);
        
        // 使用括号明确优先级
        const complexExpression = 
            (user.age >= 18 && user.isActive) &&
            (user.permissions.includes('read') || user.permissions.includes('write')) &&
            user.profile?.isComplete;
        
        console.log('使用括号的表达式结果:', complexExpression);
        
        // 分步骤求值（更可读）
        const isAdultAndActive = user.age >= 18 && user.isActive;
        const hasPermissions = user.permissions.includes('read') || user.permissions.includes('write');
        const hasCompleteProfile = user.profile?.isComplete;
        
        const stepByStepResult = isAdultAndActive && hasPermissions && hasCompleteProfile;
        console.log('分步骤求值结果:', stepByStepResult);
    },
    
    /**
     * 性能相关的求值优化
     */
    performanceOptimization() {
        console.log('=== 性能优化考虑 ===');
        
        /**
         * 模拟昂贵的操作
         * @param {string} name - 操作名称
         * @returns {boolean} 结果
         */
        function expensiveOperation(name) {
            console.log(`执行昂贵操作: ${name}`);
            // 模拟耗时操作
            return Math.random() > 0.5;
        }
        
        /**
         * 模拟快速检查
         * @param {string} name - 检查名称
         * @returns {boolean} 结果
         */
        function quickCheck(name) {
            console.log(`快速检查: ${name}`);
            return true;
        }
        
        console.log('优化前（可能执行不必要的昂贵操作）:');
        // ❌ 不好的顺序：昂贵操作可能被不必要地执行
        const badOrder = expensiveOperation('数据库查询') && quickCheck('内存检查');
        console.log('结果:', badOrder);
        
        console.log('');
        console.log('优化后（先执行快速检查）:');
        // ✅ 好的顺序：快速失败
        const goodOrder = quickCheck('内存检查') && expensiveOperation('数据库查询');
        console.log('结果:', goodOrder);
        
        console.log('');
        console.log('使用短路特性优化多重检查:');
        const config = { enabled: true, debug: false };
        
        // 利用短路避免不必要的检查
        const shouldProcess = 
            config.enabled &&                          // 最快的检查
            quickCheck('权限检查') &&                   // 中等速度
            expensiveOperation('资源可用性检查');       // 最慢的检查
        
        console.log('处理结果:', shouldProcess);
    }
};

ExpressionEvaluation.evaluationOrder();
ExpressionEvaluation.complexConditionals();  
ExpressionEvaluation.performanceOptimization();
```

### 括号的使用建议

合理使用括号可以提高代码的可读性和正确性：

```javascript
/**
 * 括号使用最佳实践
 */
const ParenthesesBestPractices = {
    /**
     * 何时使用括号
     */
    whenToUseParentheses() {
        console.log('=== 括号使用建议 ===');
        
        // 1. 明确复杂表达式的意图
        console.log('1. 明确复杂表达式:');
        
        // ❌ 不清晰的表达式
        const unclear = 2 + 3 * 4 > 10 && true || false;
        console.log('不清晰:', unclear);
        
        // ✅ 使用括号明确意图
        const clear = ((2 + (3 * 4)) > 10) && (true || false);
        console.log('清晰:', clear);
        
        // 2. 改变默认优先级
        console.log('2. 改变优先级:');
        console.log('默认: 2 + 3 * 4 =', 2 + 3 * 4);      // 14
        console.log('括号: (2 + 3) * 4 =', (2 + 3) * 4);   // 20
        
        // 3. 函数调用中的复杂参数
        console.log('3. 函数参数中使用括号:');
        
        function processData(condition, value) {
            return condition ? value * 2 : value / 2;
        }
        
        const x = 10, y = 5;
        // ❌ 可能引起混淆
        const result1 = processData(x > y, x + y * 2);
        
        // ✅ 使用括号明确参数边界
        const result2 = processData((x > y), (x + y * 2));
        
        console.log('函数调用结果:', result1, result2);
        
        // 4. 三元运算符嵌套
        console.log('4. 三元运算符嵌套:');
        
        const score = 85;
        // ❌ 难以理解的嵌套
        const grade1 = score >= 90 ? 'A' : score >= 80 ? 'B' : score >= 70 ? 'C' : 'D';
        
        // ✅ 使用括号和换行
        const grade2 = score >= 90 ? 'A' : 
                      (score >= 80 ? 'B' : 
                      (score >= 70 ? 'C' : 'D'));
        
        console.log('成绩:', grade1, grade2);
    },
    
    /**
     * 避免过度使用括号
     */
    avoidOveruse() {
        console.log('=== 避免过度使用括号 ===');
        
        // ❌ 不必要的括号
        const unnecessary = (5) + (3) * (2);
        console.log('过度使用括号:', unnecessary);
        
        // ✅ 简洁明了
        const clean = 5 + 3 * 2;
        console.log('简洁版本:', clean);
        
        // ❌ 过度嵌套的括号
        const overNested = ((((x + y) * 2) / 3) > 10);
        
        // ✅ 合理的括号使用
        const x = 5, y = 3;
        const reasonable = (x + y) * 2 / 3 > 10;
        console.log('合理的括号使用:', reasonable);
        
        // 括号使用的一般原则
        console.log('括号使用原则:');
        console.log('1. 当默认优先级不是你想要的时候使用');
        console.log('2. 当表达式复杂到难以理解时使用');
        console.log('3. 在团队协作中，宁可多用也不要让人猜测');
        console.log('4. 避免为了简单运算添加不必要的括号');
    },
    
    /**
     * 实际项目中的最佳实践
     */
    realWorldPractices() {
        console.log('=== 实际项目最佳实践 ===');
        
        // 配置对象检查
        const config = {
            api: { enabled: true, timeout: 5000 },
            cache: { enabled: false, ttl: 3600 },
            debug: true
        };
        
        // ✅ 清晰的条件检查
        const shouldUseCache = 
            config.cache?.enabled && 
            (config.cache.ttl > 0) &&
            !config.debug;
        
        console.log('是否使用缓存:', shouldUseCache);
        
        // 数学计算中的括号
        const width = 100, height = 50, padding = 10;
        
        // ✅ 明确的几何计算
        const area = (width - 2 * padding) * (height - 2 * padding);
        const perimeter = 2 * ((width - padding) + (height - padding));
        
        console.log('有效区域面积:', area);
        console.log('周长:', perimeter);
        
        // 字符串操作中的优先级
        const firstName = 'John', lastName = 'Doe', title = 'Mr.';
        
        // ✅ 明确的字符串拼接顺序
        const fullName = (title + ' ' + firstName) + ' ' + lastName;
        const displayName = firstName + (' ' + lastName).toUpperCase();
        
        console.log('全名:', fullName);
        console.log('显示名:', displayName);
        
        /**
         * 表达式复杂度评估工具
         * @param {string} expression - 表达式描述
         * @param {number} operatorCount - 运算符数量
         * @param {number} precedenceLevels - 涉及的优先级层数
         * @returns {string} 建议
         */
        function assessComplexity(expression, operatorCount, precedenceLevels) {
            if (operatorCount <= 2 && precedenceLevels <= 2) {
                return '表达式简单，可能不需要括号';
            } else if (operatorCount <= 4 && precedenceLevels <= 3) {
                return '表达式中等复杂，建议在关键位置使用括号';
            } else {
                return '表达式复杂，强烈建议分解或大量使用括号';
            }
        }
        
        console.log('表达式复杂度评估:');
        console.log('a + b * c:', assessComplexity('a + b * c', 2, 2));
        console.log('a > b && c < d || e === f:', assessComplexity('a > b && c < d || e === f', 5, 3));
    }
};

ParenthesesBestPractices.whenToUseParentheses();
ParenthesesBestPractices.avoidOveruse();
ParenthesesBestPractices.realWorldPractices();
```

---

**本章总结**

第6章深入探讨了JavaScript的运算符、表达式与逻辑：

1. **算术、比较、逻辑运算符**：掌握了各类运算符的基本用法、特殊情况和实用工具函数
2. **短路逻辑**：理解了&&和||的短路特性，学会利用短路进行性能优化和条件执行
3. **可选链与空值合并**：掌握了现代JavaScript的安全访问模式，避免了深层属性访问的错误
4. **== vs ===**：深入理解了两种比较方式的区别，学会了选择合适的比较操作符
5. **优先级规则**：掌握了运算符优先级和结合性，学会了使用括号提高代码可读性

理解运算符和表达式是编写高质量JavaScript代码的重要基础，正确使用这些概念能够让代码更安全、更高效、更易维护。

**下一章预告**

第7章将探讨JavaScript的流程控制，包括条件语句、循环语句、跳转语句等的使用方法和最佳实践。
