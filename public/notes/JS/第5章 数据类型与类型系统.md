# 第5章　数据类型与类型系统

数据类型是编程语言的基础概念，JavaScript作为动态类型语言，具有灵活而复杂的类型系统。理解数据类型及其转换机制，是掌握JavaScript的关键。

## 5.1 基本类型（七种）

### 基本类型概览

JavaScript有7种基本数据类型（原始类型），它们都是不可变的，存储在栈内存中：

| 类型 | 引入版本 | 描述 | 默认值 | 特殊值 |
|------|----------|------|--------|--------|
| `Number` | ES1 | 数值类型 | `0` | `NaN`, `Infinity` |
| `String` | ES1 | 字符串类型 | `""` | 无 |
| `Boolean` | ES1 | 布尔类型 | `false` | 无 |
| `Null` | ES1 | 空值类型 | `null` | 无 |
| `Undefined` | ES1 | 未定义类型 | `undefined` | 无 |
| `Symbol` | ES6 | 符号类型 | 无默认值 | 无 |
| `BigInt` | ES2020 | 大整数类型 | `0n` | 无 |

### Number（数值类型）

JavaScript中所有数值都使用64位浮点数表示（IEEE 754标准）：

#### 1. 数值表示方式

```javascript
// 整数表示
const intNumber = 42;
const negativeInt = -100;
const zero = 0;

// 浮点数表示
const floatNumber = 3.14159;
const scientific = 1.23e10;  // 科学记数法：12300000000
const negative = -2.5e-3;    // -0.0025

// 不同进制表示
const binary = 0b1010;       // 二进制：10
const octal = 0o755;         // 八进制：493
const hexadecimal = 0xFF;    // 十六进制：255

console.log(binary, octal, hexadecimal); // 输出: 10 493 255
```

#### 2. 特殊数值

```javascript
/**
 * 特殊数值的判断和处理
 */
console.log('=== NaN (Not a Number) ===');
const notANumber = 0 / 0;
console.log(notANumber);           // NaN
console.log(Number.isNaN(notANumber)); // true
console.log(notANumber === notANumber); // false (NaN不等于自身)

console.log('=== Infinity ===');
const positiveInfinity = 1 / 0;
const negativeInfinity = -1 / 0;
console.log(positiveInfinity);     // Infinity
console.log(negativeInfinity);     // -Infinity
console.log(Number.isFinite(positiveInfinity)); // false

/**
 * 数值精度问题
 */
console.log('=== 浮点数精度问题 ===');
console.log(0.1 + 0.2);           // 0.30000000000000004
console.log(0.1 + 0.2 === 0.3);   // false

// 解决精度问题的方法
const EPSILON = Number.EPSILON || 2.220446049250313e-16;

/**
 * 比较两个浮点数是否相等
 * @param {number} a - 第一个数
 * @param {number} b - 第二个数
 * @returns {boolean} 是否相等
 */
function floatEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
}

console.log(floatEqual(0.1 + 0.2, 0.3)); // true
```

#### 3. Number对象方法

```javascript
/**
 * Number类型的常用方法
 */
const NumberUtils = {
    /**
     * 数值验证方法
     */
    validateNumbers() {
        console.log('Number.isInteger(42):', Number.isInteger(42));     // true
        console.log('Number.isInteger(42.0):', Number.isInteger(42.0)); // true
        console.log('Number.isInteger(42.1):', Number.isInteger(42.1)); // false
        
        console.log('Number.isSafeInteger(42):', Number.isSafeInteger(42)); // true
        console.log('Number.MAX_SAFE_INTEGER:', Number.MAX_SAFE_INTEGER);   // 9007199254740991
        
        console.log('Number.parseFloat("3.14abc"):', Number.parseFloat("3.14abc")); // 3.14
        console.log('Number.parseInt("42px", 10):', Number.parseInt("42px", 10));   // 42
    },
    
    /**
     * 数值格式化
     * @param {number} num - 要格式化的数字
     */
    formatNumber(num) {
        return {
            fixed: num.toFixed(2),           // 保留2位小数
            exponential: num.toExponential(2), // 科学记数法
            precision: num.toPrecision(4),   // 有效数字
            string: num.toString(16)         // 转换为16进制字符串
        };
    }
};

NumberUtils.validateNumbers();
console.log(NumberUtils.formatNumber(123.456789));
// 输出: {fixed: "123.46", exponential: "1.23e+2", precision: "123.5", string: "7b"}
```

### String（字符串类型）

字符串是不可变的Unicode字符序列：

#### 1. 字符串创建方式

```javascript
// 字符串字面量
const singleQuoted = 'Hello World';
const doubleQuoted = "Hello World";
const templateLiteral = `Hello World`;

// 字符串构造函数（不推荐）
const stringObject = new String('Hello World'); // 返回对象，不是基本类型

// 转义字符
const escapedString = 'It\'s a "beautiful" day\nwith\\backslashes';
console.log(escapedString);
// 输出:
// It's a "beautiful" day
// with\backslashes

/**
 * 模板字符串的强大功能
 */
const name = 'JavaScript';
const version = 2023;
const multiLineTemplate = `
    Language: ${name}
    Version: ${version}
    Expression: ${2 + 3}
    Function call: ${name.toUpperCase()}
`;

console.log(multiLineTemplate);
```

#### 2. 字符串方法

```javascript
/**
 * 字符串工具类
 */
class StringHelper {
    /**
     * 字符串查找和检测
     * @param {string} str - 目标字符串
     */
    static searchMethods(str) {
        console.log('=== 字符串查找 ===');
        console.log(`原字符串: "${str}"`);
        console.log(`长度: ${str.length}`);
        console.log(`indexOf('Script'): ${str.indexOf('Script')}`);
        console.log(`lastIndexOf('a'): ${str.lastIndexOf('a')}`);
        console.log(`includes('Java'): ${str.includes('Java')}`);
        console.log(`startsWith('Java'): ${str.startsWith('Java')}`);
        console.log(`endsWith('Script'): ${str.endsWith('Script')}`);
    }
    
    /**
     * 字符串提取
     * @param {string} str - 目标字符串
     */
    static extractMethods(str) {
        console.log('=== 字符串提取 ===');
        console.log(`charAt(4): ${str.charAt(4)}`);
        console.log(`charCodeAt(0): ${str.charCodeAt(0)}`);
        console.log(`slice(0, 4): ${str.slice(0, 4)}`);
        console.log(`substring(4, 10): ${str.substring(4, 10)}`);
        console.log(`substr(4, 6): ${str.substr(4, 6)}`); // 已废弃，不推荐使用
    }
    
    /**
     * 字符串转换
     * @param {string} str - 目标字符串
     */
    static transformMethods(str) {
        console.log('=== 字符串转换 ===');
        console.log(`toLowerCase(): ${str.toLowerCase()}`);
        console.log(`toUpperCase(): ${str.toUpperCase()}`);
        console.log(`trim(): "${str.trim()}"`);
        console.log(`replace('Script', 'World'): ${str.replace('Script', 'World')}`);
        console.log(`split(''): ${JSON.stringify(str.split(''))}`);
    }
}

const testString = '  JavaScript Programming  ';
StringHelper.searchMethods(testString);
StringHelper.extractMethods(testString);
StringHelper.transformMethods(testString);
```

### Boolean（布尔类型）

布尔类型只有两个值：`true`和`false`：

```javascript
/**
 * 布尔值的创建和使用
 */
const boolTrue = true;
const boolFalse = false;
const boolFromFunction = Boolean(42);  // true
const boolFromNegation = !!'hello';    // true

console.log(typeof boolTrue);          // "boolean"
console.log(Boolean(1));               // true
console.log(Boolean(0));               // false
console.log(Boolean(''));              // false
console.log(Boolean('false'));         // true (非空字符串都是true)

/**
 * 真值和假值
 */
const FalsyValues = {
    // JavaScript中的所有假值
    values: [false, 0, -0, 0n, '', null, undefined, NaN],
    
    /**
     * 检测假值
     * @param {*} value - 要检测的值
     */
    isFalsy(value) {
        return !value;
    },
    
    /**
     * 检测真值
     * @param {*} value - 要检测的值
     */
    isTruthy(value) {
        return !!value;
    },
    
    /**
     * 演示所有假值
     */
    demonstrateFalsyValues() {
        console.log('=== 假值演示 ===');
        this.values.forEach((value, index) => {
            console.log(`${index + 1}. ${JSON.stringify(value)} -> ${this.isFalsy(value)}`);
        });
    }
};

FalsyValues.demonstrateFalsyValues();
```

### Null（空值类型）

`null`表示有意的空值或不存在的对象：

```javascript
/**
 * null的特性和使用
 */
let emptyValue = null;

console.log(typeof null);              // "object" (这是JavaScript的一个历史bug)
console.log(null == undefined);        // true (相等但不全等)
console.log(null === undefined);       // false
console.log(Boolean(null));            // false

/**
 * null的实际应用场景
 */
const UserProfile = {
    name: 'John Doe',
    avatar: null,        // 用户没有设置头像
    lastLogin: null,     // 用户从未登录过
    
    /**
     * 设置头像
     * @param {string|null} avatarUrl - 头像URL或null
     */
    setAvatar(avatarUrl) {
        this.avatar = avatarUrl;
    },
    
    /**
     * 清除头像
     */
    clearAvatar() {
        this.avatar = null;
    },
    
    /**
     * 检查是否有头像
     * @returns {boolean} 是否有头像
     */
    hasAvatar() {
        return this.avatar !== null;
    }
};

console.log(UserProfile.hasAvatar());  // false
UserProfile.setAvatar('https://example.com/avatar.jpg');
console.log(UserProfile.hasAvatar());  // true
```

### Undefined（未定义类型）

`undefined`表示变量已声明但未赋值，或不存在的对象属性：

```javascript
/**
 * undefined的各种情况
 */
let undeclaredVar;                     // undefined
const obj = { name: 'test' };
const nonExistentProp = obj.age;       // undefined
const funcWithoutReturn = () => {};
const returnValue = funcWithoutReturn(); // undefined

console.log(typeof undefined);         // "undefined"
console.log(undefined == null);        // true
console.log(undefined === null);       // false

/**
 * 检测undefined的最佳实践
 */
const UndefinedUtils = {
    /**
     * 安全检测undefined
     * @param {*} value - 要检测的值
     */
    isUndefined(value) {
        return typeof value === 'undefined';
    },
    
    /**
     * 检测是否为null或undefined
     * @param {*} value - 要检测的值
     */
    isNullish(value) {
        return value == null; // 同时检测null和undefined
    },
    
    /**
     * 提供默认值（类似于空值合并运算符 ??）
     * @param {*} value - 原始值
     * @param {*} defaultValue - 默认值
     */
    defaultValue(value, defaultValue) {
        return value != null ? value : defaultValue;
    }
};

console.log(UndefinedUtils.isUndefined(undeclaredVar));        // true
console.log(UndefinedUtils.isNullish(null));                  // true
console.log(UndefinedUtils.isNullish(undefined));             // true
console.log(UndefinedUtils.defaultValue(null, 'default'));     // 'default'
```

### Symbol（符号类型）

Symbol是ES6引入的新基本类型，表示唯一的标识符：

```javascript
/**
 * Symbol的创建和特性
 */
const symbol1 = Symbol();
const symbol2 = Symbol('description');
const symbol3 = Symbol('description');

console.log(typeof symbol1);           // "symbol"
console.log(symbol2 === symbol3);      // false (每个Symbol都是唯一的)
console.log(symbol2.toString());       // "Symbol(description)"

/**
 * Symbol的实际应用
 */
const SymbolExamples = {
    /**
     * 作为对象属性名避免冲突
     */
    objectProperties() {
        const ID_SYMBOL = Symbol('id');
        const user = {
            name: 'John',
            [ID_SYMBOL]: 12345    // Symbol作为属性名
        };
        
        console.log(user.name);           // "John"
        console.log(user[ID_SYMBOL]);     // 12345
        console.log(Object.keys(user));   // ["name"] (Symbol属性不被枚举)
    },
    
    /**
     * 全局Symbol注册表
     */
    globalSymbols() {
        const globalSym1 = Symbol.for('global.id');
        const globalSym2 = Symbol.for('global.id');
        
        console.log(globalSym1 === globalSym2);           // true
        console.log(Symbol.keyFor(globalSym1));           // "global.id"
    },
    
    /**
     * 内置Symbol
     */
    wellKnownSymbols() {
        const customIterable = {
            data: [1, 2, 3],
            
            // 实现Iterator接口
            [Symbol.iterator]() {
                let index = 0;
                const data = this.data;
                
                return {
                    next() {
                        if (index < data.length) {
                            return { value: data[index++], done: false };
                        }
                        return { done: true };
                    }
                };
            }
        };
        
        // 现在对象可以被迭代
        for (const value of customIterable) {
            console.log('迭代值:', value);
        }
    }
};

SymbolExamples.objectProperties();
SymbolExamples.globalSymbols();
SymbolExamples.wellKnownSymbols();
```

### BigInt（大整数类型）

BigInt是ES2020引入的新类型，用于表示任意精度的整数：

```javascript
/**
 * BigInt的创建和使用
 */
const bigInt1 = 123456789012345678901234567890n; // 字面量形式
const bigInt2 = BigInt('123456789012345678901234567890'); // 构造函数形式
const bigInt3 = BigInt(123);                     // 从Number转换

console.log(typeof bigInt1);                     // "bigint"
console.log(bigInt1 === bigInt2);               // true

/**
 * BigInt的运算和限制
 */
const BigIntCalculator = {
    /**
     * BigInt基本运算
     */
    basicOperations() {
        const a = 123456789012345678901234567890n;
        const b = 987654321098765432109876543210n;
        
        console.log('=== BigInt运算 ===');
        console.log('加法:', a + b);
        console.log('减法:', b - a);
        console.log('乘法:', a * 2n);               // 必须是BigInt
        console.log('除法:', b / a);
        console.log('求余:', b % a);
        console.log('幂运算:', 2n ** 100n);
    },
    
    /**
     * BigInt与Number的区别
     */
    compareWithNumber() {
        console.log('=== BigInt vs Number ===');
        
        // ❌ 不能混合运算
        // console.log(123n + 456);  // TypeError
        
        // ✅ 需要显式转换
        console.log(123n + BigInt(456));           // 579n
        console.log(Number(123n) + 456);           // 579
        
        // 比较操作
        console.log(123n == 123);                  // true (相等)
        console.log(123n === 123);                 // false (类型不同)
        console.log(123n < 124);                   // true (可以比较)
    },
    
    /**
     * BigInt的实际应用
     */
    practicalUsage() {
        /**
         * 计算阶乘 - 处理大数运算
         * @param {number|bigint} n - 计算阶乘的数
         * @returns {bigint} 阶乘结果
         */
        function factorial(n) {
            const num = BigInt(n);
            let result = 1n;
            
            for (let i = 2n; i <= num; i++) {
                result *= i;
            }
            
            return result;
        }
        
        console.log('=== 大数阶乘计算 ===');
        console.log('50! =', factorial(50).toString());
        
        /**
         * 处理超出Number.MAX_SAFE_INTEGER的整数
         */
        console.log('=== 安全整数范围 ===');
        console.log('MAX_SAFE_INTEGER:', Number.MAX_SAFE_INTEGER);
        console.log('超出安全范围的BigInt:', 9007199254740992n);
    }
};

BigIntCalculator.basicOperations();
BigIntCalculator.compareWithNumber();
BigIntCalculator.practicalUsage();
```

---

## 5.2 引用类型

### 引用类型的特点

引用类型（对象类型）存储在堆内存中，变量存储的是对象的引用地址：

#### 引用类型与基本类型的区别

| 特性 | 基本类型 | 引用类型 |
|------|----------|----------|
| 存储位置 | 栈内存 | 堆内存 |
| 存储内容 | 值本身 | 引用地址 |
| 可变性 | 不可变 | 可变 |
| 比较方式 | 值比较 | 引用比较 |
| 复制行为 | 值复制 | 引用复制 |

```javascript
// 引用类型的基本特性演示
let obj1 = { name: 'Alice' };
let obj2 = obj1;                    // 引用复制

obj2.name = 'Bob';
console.log(obj1.name);             // 'Bob' (两个变量指向同一个对象)

let obj3 = { name: 'Charlie' };
console.log(obj1 === obj2);         // true (相同引用)
console.log(obj1 === obj3);         // false (不同对象)
console.log(obj1.name === obj3.name); // false (值不同)
```

### Object（对象类型）

对象是键值对的集合，是JavaScript中最重要的数据类型：

#### 1. 对象创建方式

```javascript
/**
 * 对象的多种创建方式
 */
const ObjectCreationMethods = {
    /**
     * 对象字面量（最常用）
     */
    literalObjects() {
        const person = {
            name: 'John',
            age: 30,
            greet() {
                return `Hello, I'm ${this.name}`;
            }
        };
        
        // 计算属性名
        const propName = 'dynamicProperty';
        const dynamicObj = {
            [propName]: 'dynamic value',
            [`${propName}_2`]: 'another value'
        };
        
        return { person, dynamicObj };
    },
    
    /**
     * 构造函数方式
     */
    constructorObjects() {
        // Object构造函数
        const obj1 = new Object();
        obj1.name = 'Created with constructor';
        
        // 自定义构造函数
        function Person(name, age) {
            this.name = name;
            this.age = age;
            this.greet = function() {
                return `Hello, I'm ${this.name}`;
            };
        }
        
        const person = new Person('Alice', 25);
        return { obj1, person };
    },
    
    /**
     * Object.create方式
     */
    createMethod() {
        const prototype = {
            greet() {
                return `Hello, I'm ${this.name}`;
            }
        };
        
        const person = Object.create(prototype);
        person.name = 'Bob';
        person.age = 28;
        
        return person;
    }
};

console.log(ObjectCreationMethods.literalObjects());
console.log(ObjectCreationMethods.constructorObjects());
console.log(ObjectCreationMethods.createMethod());
```

#### 2. 对象属性操作

```javascript
/**
 * 对象属性操作工具类
 */
class ObjectPropertyManager {
    /**
     * 属性访问方式
     * @param {Object} obj - 目标对象
     */
    static accessProperties(obj) {
        console.log('=== 属性访问 ===');
        
        // 点号访问
        console.log('点号访问 obj.name:', obj.name);
        
        // 方括号访问
        console.log('方括号访问 obj["name"]:', obj['name']);
        
        // 动态属性名
        const propName = 'age';
        console.log(`动态属性 obj[${propName}]:`, obj[propName]);
        
        // 访问不存在的属性
        console.log('不存在的属性:', obj.nonExistent); // undefined
    }
    
    /**
     * 属性检测
     * @param {Object} obj - 目标对象
     */
    static detectProperties(obj) {
        console.log('=== 属性检测 ===');
        
        // in 操作符（检查原型链）
        console.log('"name" in obj:', 'name' in obj);
        console.log('"toString" in obj:', 'toString' in obj);
        
        // hasOwnProperty（只检查自身属性）
        console.log('obj.hasOwnProperty("name"):', obj.hasOwnProperty('name'));
        console.log('obj.hasOwnProperty("toString"):', obj.hasOwnProperty('toString'));
        
        // Object.hasOwn（ES2022新方法）
        if (Object.hasOwn) {
            console.log('Object.hasOwn(obj, "name"):', Object.hasOwn(obj, 'name'));
        }
    }
    
    /**
     * 属性枚举
     * @param {Object} obj - 目标对象
     */
    static enumerateProperties(obj) {
        console.log('=== 属性枚举 ===');
        
        // Object.keys（可枚举的自身属性）
        console.log('Object.keys(obj):', Object.keys(obj));
        
        // Object.values（属性值）
        console.log('Object.values(obj):', Object.values(obj));
        
        // Object.entries（键值对）
        console.log('Object.entries(obj):', Object.entries(obj));
        
        // for...in 循环（包括原型链）
        console.log('for...in 循环:');
        for (const prop in obj) {
            console.log(`  ${prop}: ${obj[prop]}`);
        }
    }
}

const testObj = { name: 'Test', age: 30, city: 'Beijing' };
ObjectPropertyManager.accessProperties(testObj);
ObjectPropertyManager.detectProperties(testObj);
ObjectPropertyManager.enumerateProperties(testObj);
```

### Array（数组类型）

数组是特殊的对象，用于存储有序的数据集合：

#### 1. 数组创建和基本操作

```javascript
/**
 * 数组操作示例
 */
const ArrayExamples = {
    /**
     * 数组创建方式
     */
    creation() {
        // 数组字面量（推荐）
        const fruits = ['apple', 'banana', 'orange'];
        
        // Array构造函数
        const numbers = new Array(1, 2, 3, 4, 5);
        const emptyArray = new Array(5); // 创建长度为5的空数组
        
        // Array.from() 创建数组
        const fromString = Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']
        const fromRange = Array.from({length: 5}, (_, i) => i + 1); // [1, 2, 3, 4, 5]
        
        return { fruits, numbers, emptyArray, fromString, fromRange };
    },
    
    /**
     * 数组基本操作
     */
    basicOperations() {
        const arr = [1, 2, 3];
        
        console.log('=== 数组基本操作 ===');
        console.log('原数组:', arr);
        console.log('长度:', arr.length);
        console.log('访问元素 arr[1]:', arr[1]);
        
        // 添加元素
        arr.push(4);                    // 尾部添加
        arr.unshift(0);                 // 头部添加
        console.log('添加元素后:', arr);
        
        // 删除元素
        const lastItem = arr.pop();     // 删除尾部
        const firstItem = arr.shift();  // 删除头部
        console.log('删除元素后:', arr);
        console.log('删除的元素:', { lastItem, firstItem });
        
        // 修改元素
        arr[1] = 'modified';
        console.log('修改后:', arr);
    },
    
    /**
     * 数组高级方法
     */
    advancedMethods() {
        const numbers = [1, 2, 3, 4, 5];
        const users = [
            { name: 'Alice', age: 25, active: true },
            { name: 'Bob', age: 30, active: false },
            { name: 'Charlie', age: 35, active: true }
        ];
        
        console.log('=== 数组高级方法 ===');
        
        // 查找方法
        console.log('indexOf(3):', numbers.indexOf(3));
        console.log('includes(4):', numbers.includes(4));
        console.log('find active user:', users.find(user => user.active));
        console.log('findIndex age>30:', users.findIndex(user => user.age > 30));
        
        // 测试方法
        console.log('some active:', users.some(user => user.active));
        console.log('every active:', users.every(user => user.active));
        
        // 转换方法
        console.log('map doubled:', numbers.map(n => n * 2));
        console.log('filter active:', users.filter(user => user.active));
        console.log('reduce sum:', numbers.reduce((sum, n) => sum + n, 0));
    }
};

console.log(ArrayExamples.creation());
ArrayExamples.basicOperations();
ArrayExamples.advancedMethods();
```

### Function（函数类型）

函数是JavaScript中的一等公民，也是对象类型：

```javascript
/**
 * 函数类型的特性和使用
 */
const FunctionExamples = {
    /**
     * 函数创建方式
     */
    creationMethods() {
        // 函数声明
        function declared() {
            return 'declared function';
        }
        
        // 函数表达式
        const expression = function() {
            return 'function expression';
        };
        
        // 箭头函数
        const arrow = () => 'arrow function';
        
        // Function构造函数（不推荐）
        const constructed = new Function('return "constructed function"');
        
        return { declared, expression, arrow, constructed };
    },
    
    /**
     * 函数作为对象的特性
     */
    objectCharacteristics() {
        function myFunction(a, b) {
            return a + b;
        }
        
        // 函数属性
        myFunction.customProperty = 'I am a function property';
        myFunction.counter = 0;
        
        // 函数方法
        myFunction.increment = function() {
            this.counter++;
        };
        
        console.log('=== 函数对象特性 ===');
        console.log('函数名称:', myFunction.name);
        console.log('参数个数:', myFunction.length);
        console.log('自定义属性:', myFunction.customProperty);
        
        myFunction.increment();
        console.log('调用方法后的计数器:', myFunction.counter);
    },
    
    /**
     * 高阶函数示例
     */
    higherOrderFunctions() {
        /**
         * 创建乘法函数的工厂函数
         * @param {number} multiplier - 乘数
         * @returns {Function} 乘法函数
         */
        function createMultiplier(multiplier) {
            return function(x) {
                return x * multiplier;
            };
        }
        
        const double = createMultiplier(2);
        const triple = createMultiplier(3);
        
        console.log('=== 高阶函数 ===');
        console.log('double(5):', double(5));
        console.log('triple(4):', triple(4));
        
        /**
         * 函数作为参数
         * @param {Array} arr - 数组
         * @param {Function} callback - 回调函数
         */
        function processArray(arr, callback) {
            return arr.map(callback);
        }
        
        const numbers = [1, 2, 3, 4, 5];
        console.log('processArray with double:', processArray(numbers, double));
    }
};

console.log(FunctionExamples.creationMethods());
FunctionExamples.objectCharacteristics();
FunctionExamples.higherOrderFunctions();
```

### Date（日期类型）

Date对象用于处理日期和时间：

```javascript
/**
 * Date类型的使用
 */
const DateExamples = {
    /**
     * Date对象创建
     */
    creation() {
        console.log('=== Date对象创建 ===');
        
        // 当前时间
        const now = new Date();
        console.log('当前时间:', now);
        
        // 指定日期
        const specificDate = new Date('2023-12-25');
        const detailedDate = new Date(2023, 11, 25, 10, 30, 0); // 月份从0开始
        
        // 时间戳
        const fromTimestamp = new Date(1703505000000);
        
        console.log('指定日期:', specificDate);
        console.log('详细日期:', detailedDate);
        console.log('从时间戳:', fromTimestamp);
    },
    
    /**
     * 日期格式化和操作
     */
    formatting() {
        const date = new Date('2023-12-25T10:30:00');
        
        console.log('=== 日期格式化 ===');
        console.log('ISO字符串:', date.toISOString());
        console.log('本地字符串:', date.toString());
        console.log('日期部分:', date.toDateString());
        console.log('时间部分:', date.toTimeString());
        console.log('本地化日期:', date.toLocaleDateString('zh-CN'));
        console.log('本地化时间:', date.toLocaleTimeString('zh-CN'));
    },
    
    /**
     * 日期计算
     */
    calculations() {
        const date1 = new Date('2023-12-25');
        const date2 = new Date('2023-12-20');
        
        console.log('=== 日期计算 ===');
        
        // 日期差值（毫秒）
        const diffMs = date1 - date2;
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        console.log('日期差值:', diffDays, '天');
        
        // 添加天数
        const futureDate = new Date(date1);
        futureDate.setDate(futureDate.getDate() + 7);
        console.log('7天后:', futureDate.toDateString());
        
        /**
         * 实用的日期工具函数
         */
        const DateUtils = {
            /**
             * 格式化日期为 YYYY-MM-DD
             * @param {Date} date - 日期对象
             */
            formatDate(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            },
            
            /**
             * 获取两个日期间的天数差
             * @param {Date} date1 - 第一个日期
             * @param {Date} date2 - 第二个日期
             */
            daysDiff(date1, date2) {
                const oneDay = 24 * 60 * 60 * 1000;
                return Math.round(Math.abs((date1 - date2) / oneDay));
            }
        };
        
        console.log('格式化日期:', DateUtils.formatDate(new Date()));
        console.log('工具函数计算天数差:', DateUtils.daysDiff(date1, date2));
    }
};

DateExamples.creation();
DateExamples.formatting();
DateExamples.calculations();
```

### RegExp（正则表达式类型）

正则表达式用于模式匹配和文本处理：

```javascript
/**
 * 正则表达式的使用
 */
const RegExpExamples = {
    /**
     * 正则表达式创建
     */
    creation() {
        console.log('=== 正则表达式创建 ===');
        
        // 字面量语法
        const regex1 = /hello/i;  // i表示忽略大小写
        
        // RegExp构造函数
        const regex2 = new RegExp('world', 'g'); // g表示全局匹配
        
        // 动态正则表达式
        const pattern = 'JavaScript';
        const regex3 = new RegExp(pattern, 'gi');
        
        console.log('字面量正则:', regex1);
        console.log('构造函数正则:', regex2);
        console.log('动态正则:', regex3);
    },
    
    /**
     * 正则表达式方法
     */
    methods() {
        const text = 'JavaScript is awesome. JavaScript rocks!';
        const regex = /JavaScript/gi;
        
        console.log('=== 正则表达式方法 ===');
        console.log('原文本:', text);
        
        // test() - 测试是否匹配
        console.log('regex.test():', regex.test(text));
        
        // exec() - 执行匹配
        regex.lastIndex = 0; // 重置全局匹配位置
        let match;
        console.log('exec() 匹配结果:');
        while ((match = regex.exec(text)) !== null) {
            console.log(`  找到 "${match[0]}" 在位置 ${match.index}`);
        }
        
        // 字符串的正则方法
        console.log('=== 字符串正则方法 ===');
        console.log('match():', text.match(/JavaScript/g));
        console.log('search():', text.search(/awesome/));
        console.log('replace():', text.replace(/JavaScript/g, 'JS'));
        console.log('split():', text.split(/\s+/)); // 按空白字符分割
    },
    
    /**
     * 实用的正则表达式模式
     */
    commonPatterns() {
        /**
         * 常用正则表达式工具
         */
        const RegexUtils = {
            // 邮箱验证
            email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
            
            // 手机号验证（中国）
            phone: /^1[3-9]\d{9}$/,
            
            // URL验证
            url: /^https?:\/\/([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/,
            
            // 身份证号验证（简单版）
            idCard: /^[1-9]\d{5}(19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}[\dXx]$/,
            
            /**
             * 验证邮箱
             * @param {string} email - 邮箱地址
             */
            validateEmail(email) {
                return this.email.test(email);
            },
            
            /**
             * 验证手机号
             * @param {string} phone - 手机号
             */
            validatePhone(phone) {
                return this.phone.test(phone);
            },
            
            /**
             * 提取文本中的所有数字
             * @param {string} text - 文本
             */
            extractNumbers(text) {
                return text.match(/\d+/g) || [];
            },
            
            /**
             * 驼峰转下划线
             * @param {string} str - 驼峰字符串
             */
            camelToSnake(str) {
                return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
            }
        };
        
        console.log('=== 实用正则模式 ===');
        console.log('邮箱验证:', RegexUtils.validateEmail('test@example.com'));
        console.log('手机验证:', RegexUtils.validatePhone('13812345678'));
        console.log('提取数字:', RegexUtils.extractNumbers('价格是99.9元，折扣20%'));
        console.log('驼峰转下划线:', RegexUtils.camelToSnake('myVariableName'));
    }
};

RegExpExamples.creation();
RegExpExamples.methods();
RegExpExamples.commonPatterns();
```

---

## 5.3 栈与堆

### 内存分配模式

JavaScript使用两种内存区域存储数据：栈（Stack）和堆（Heap），了解它们的区别有助于理解数据类型的行为：

```
JavaScript内存模型
├── 栈内存 (Stack Memory)
│   ├── 基本类型值
│   ├── 引用地址
│   └── 执行上下文
└── 堆内存 (Heap Memory)
    ├── 对象实例
    ├── 数组实例
    └── 函数实例
```

### 基本类型的栈存储

基本类型直接存储在栈内存中，具有以下特点：

```javascript
/**
 * 栈内存中基本类型的行为
 */
function demonstrateStackBehavior() {
    console.log('=== 栈内存：基本类型 ===');
    
    // 基本类型存储在栈中
    let a = 10;
    let b = a;          // 值复制
    
    console.log('初始值 - a:', a, 'b:', b);
    
    // 修改b不影响a
    b = 20;
    console.log('修改b后 - a:', a, 'b:', b); // a: 10, b: 20
    
    /**
     * 函数参数传递（值传递）
     * @param {number} num - 数值参数
     */
    function modifyNumber(num) {
        num = 999;
        console.log('函数内部 num:', num);
    }
    
    let originalNum = 100;
    modifyNumber(originalNum);
    console.log('函数外部 originalNum:', originalNum); // 100 (未被修改)
    
    /**
     * 栈内存的特点演示
     */
    console.log('=== 栈内存特点 ===');
    console.log('1. 存储基本类型值');
    console.log('2. 变量直接访问值');
    console.log('3. 值复制，互不影响');
    console.log('4. 内存回收自动，速度快');
}

demonstrateStackBehavior();
```

### 引用类型的堆存储

引用类型存储在堆内存中，栈中只存储引用地址：

```javascript
/**
 * 堆内存中引用类型的行为
 */
function demonstrateHeapBehavior() {
    console.log('=== 堆内存：引用类型 ===');
    
    // 引用类型存储在堆中，变量存储引用地址
    let obj1 = { name: 'Alice', age: 25 };
    let obj2 = obj1;    // 引用复制，指向同一个对象
    
    console.log('初始状态:');
    console.log('obj1:', obj1);
    console.log('obj2:', obj2);
    console.log('obj1 === obj2:', obj1 === obj2); // true
    
    // 修改obj2会影响obj1（指向同一对象）
    obj2.name = 'Bob';
    console.log('修改obj2.name后:');
    console.log('obj1.name:', obj1.name); // 'Bob'
    console.log('obj2.name:', obj2.name); // 'Bob'
    
    // 重新赋值obj2不影响obj1
    obj2 = { name: 'Charlie', age: 30 };
    console.log('重新赋值obj2后:');
    console.log('obj1:', obj1); // { name: 'Bob', age: 25 }
    console.log('obj2:', obj2); // { name: 'Charlie', age: 30 }
    console.log('obj1 === obj2:', obj1 === obj2); // false
}

demonstrateHeapBehavior();

/**
 * 深拷贝 vs 浅拷贝
 */
const CopyExamples = {
    /**
     * 浅拷贝演示
     */
    shallowCopy() {
        console.log('=== 浅拷贝 ===');
        
        const original = {
            name: 'John',
            age: 30,
            address: {
                city: 'Beijing',
                country: 'China'
            },
            hobbies: ['reading', 'gaming']
        };
        
        // 浅拷贝方法
        const copy1 = Object.assign({}, original);
        const copy2 = { ...original };
        
        console.log('原对象:', original);
        console.log('浅拷贝1:', copy1);
        console.log('浅拷贝2:', copy2);
        
        // 修改第一层属性
        copy1.name = 'Alice';
        console.log('修改copy1.name后:');
        console.log('original.name:', original.name); // 'John' (未受影响)
        console.log('copy1.name:', copy1.name);       // 'Alice'
        
        // 修改嵌套对象
        copy2.address.city = 'Shanghai';
        console.log('修改copy2.address.city后:');
        console.log('original.address.city:', original.address.city); // 'Shanghai' (被影响)
        console.log('copy2.address.city:', copy2.address.city);       // 'Shanghai'
    },
    
    /**
     * 深拷贝演示
     */
    deepCopy() {
        console.log('=== 深拷贝 ===');
        
        const original = {
            name: 'John',
            age: 30,
            address: {
                city: 'Beijing',
                country: 'China'
            },
            hobbies: ['reading', 'gaming'],
            createdAt: new Date('2023-01-01')
        };
        
        /**
         * 简单深拷贝（JSON方法，有限制）
         */
        const jsonCopy = JSON.parse(JSON.stringify(original));
        
        /**
         * 手动实现深拷贝
         * @param {*} obj - 要拷贝的对象
         * @returns {*} 深拷贝后的对象
         */
        function deepClone(obj) {
            if (obj === null || typeof obj !== 'object') {
                return obj;
            }
            
            if (obj instanceof Date) {
                return new Date(obj.getTime());
            }
            
            if (obj instanceof Array) {
                return obj.map(item => deepClone(item));
            }
            
            if (typeof obj === 'object') {
                const cloned = {};
                Object.keys(obj).forEach(key => {
                    cloned[key] = deepClone(obj[key]);
                });
                return cloned;
            }
        }
        
        const manualCopy = deepClone(original);
        
        console.log('原对象:', original);
        console.log('JSON深拷贝:', jsonCopy);
        console.log('手动深拷贝:', manualCopy);
        
        // 修改嵌套对象测试
        manualCopy.address.city = 'Guangzhou';
        manualCopy.hobbies.push('swimming');
        
        console.log('修改深拷贝对象后:');
        console.log('original.address.city:', original.address.city); // 'Beijing' (未受影响)
        console.log('manualCopy.address.city:', manualCopy.address.city); // 'Guangzhou'
        console.log('original.hobbies:', original.hobbies); // ['reading', 'gaming']
        console.log('manualCopy.hobbies:', manualCopy.hobbies); // ['reading', 'gaming', 'swimming']
    }
};

CopyExamples.shallowCopy();
CopyExamples.deepCopy();
```

### 内存管理与垃圾回收

JavaScript自动管理内存，但了解垃圾回收机制有助于编写高效代码：

```javascript
/**
 * 内存管理和垃圾回收示例
 */
const MemoryManagement = {
    /**
     * 内存泄漏的常见情况
     */
    memoryLeaks() {
        console.log('=== 内存泄漏示例 ===');
        
        // 1. 全局变量（不会被回收）
        window.globalLeak = {
            data: new Array(1000000).fill('memory leak')
        };
        
        // 2. 闭包引用（可能造成内存泄漏）
        function createClosure() {
            const largeData = new Array(1000000).fill('large data');
            
            return function() {
                // 即使不使用largeData，闭包也会保持对它的引用
                console.log('closure function');
            };
        }
        
        const closureFunction = createClosure();
        
        // 3. 定时器未清除
        const timerId = setInterval(() => {
            console.log('timer running');
        }, 1000);
        
        // ❌ 忘记清除定时器会造成内存泄漏
        // clearInterval(timerId);
        
        // 4. DOM引用未清除
        const element = document.createElement('div');
        element.innerHTML = 'test element';
        
        const elementRef = element; // 保持对已删除DOM的引用
        // 即使element被从DOM中删除，elementRef仍然引用它
        
        console.log('创建了可能的内存泄漏');
    },
    
    /**
     * 避免内存泄漏的最佳实践
     */
    bestPractices() {
        console.log('=== 内存管理最佳实践 ===');
        
        /**
         * 1. 及时清除引用
         */
        function properResourceManagement() {
            let largeObject = {
                data: new Array(1000000).fill('data')
            };
            
            // 使用完毕后清除引用
            largeObject = null;
        }
        
        /**
         * 2. 使用WeakMap和WeakSet
         */
        function useWeakReferences() {
            const weakMap = new WeakMap();
            const weakSet = new WeakSet();
            
            let obj = { name: 'test' };
            
            // WeakMap和WeakSet不会阻止垃圾回收
            weakMap.set(obj, 'some data');
            weakSet.add(obj);
            
            // 当obj被清除时，WeakMap和WeakSet中的引用也会被自动清除
            obj = null;
        }
        
        /**
         * 3. 清理定时器和事件监听器
         */
        function properCleanup() {
            const timerId = setTimeout(() => {
                console.log('timer executed');
            }, 1000);
            
            const element = document.createElement('button');
            const handler = () => console.log('clicked');
            
            element.addEventListener('click', handler);
            
            // 清理函数
            function cleanup() {
                clearTimeout(timerId);
                element.removeEventListener('click', handler);
            }
            
            // 在适当的时候调用cleanup
            return cleanup;
        }
        
        /**
         * 4. 监控内存使用
         */
        function monitorMemory() {
            if (performance.memory) {
                const memInfo = performance.memory;
                console.log('JavaScript内存使用情况:');
                console.log('已使用:', (memInfo.usedJSHeapSize / 1024 / 1024).toFixed(2), 'MB');
                console.log('总分配:', (memInfo.totalJSHeapSize / 1024 / 1024).toFixed(2), 'MB');
                console.log('限制:', (memInfo.jsHeapSizeLimit / 1024 / 1024).toFixed(2), 'MB');
            }
        }
        
        properResourceManagement();
        useWeakReferences();
        const cleanup = properCleanup();
        monitorMemory();
        
        // 在需要时调用清理函数
        setTimeout(cleanup, 2000);
    },
    
    /**
     * 垃圾回收机制说明
     */
    garbageCollectionExplanation() {
        console.log('=== 垃圾回收机制 ===');
        console.log('JavaScript垃圾回收算法:');
        console.log('1. 标记清除 (Mark and Sweep) - 主要算法');
        console.log('2. 引用计数 (Reference Counting) - 辅助算法');
        console.log('3. 分代回收 (Generational Collection)');
        console.log('   - 新生代: 存活时间短的对象');
        console.log('   - 老生代: 存活时间长的对象');
        
        /**
         * 演示对象生命周期
         */
        function objectLifecycle() {
            // 对象创建（分配内存）
            const obj = {
                name: 'lifecycle demo',
                data: new Array(1000).fill('data')
            };
            
            // 对象使用
            console.log('对象创建并使用:', obj.name);
            
            // 对象不再被引用（可被垃圾回收）
            return null; // obj将在函数结束后被回收
        }
        
        objectLifecycle();
        
        // 强制垃圾回收（仅在开发环境中可用）
        if (window.gc) {
            window.gc();
            console.log('手动触发垃圾回收');
        }
    }
};

// MemoryManagement.memoryLeaks(); // 注释掉以避免实际内存泄漏
MemoryManagement.bestPractices();
MemoryManagement.garbageCollectionExplanation();
```

---

## 5.4 类型判断：typeof、instanceof

### typeof 操作符

`typeof` 是JavaScript中最基本的类型判断操作符，用于判断变量的数据类型：

#### 1. typeof 的基本用法

```javascript
/**
 * typeof操作符的基本使用
 */
function demonstrateTypeof() {
    console.log('=== typeof 操作符 ===');
    
    // 基本类型
    console.log('typeof undefined:', typeof undefined);     // "undefined"
    console.log('typeof true:', typeof true);               // "boolean"
    console.log('typeof 42:', typeof 42);                   // "number"
    console.log('typeof "hello":', typeof "hello");         // "string"
    console.log('typeof Symbol():', typeof Symbol());       // "symbol"
    console.log('typeof 123n:', typeof 123n);               // "bigint"
    
    // 引用类型
    console.log('typeof {}:', typeof {});                   // "object"
    console.log('typeof []:', typeof []);                   // "object"
    console.log('typeof null:', typeof null);               // "object" (历史遗留bug)
    console.log('typeof function(){}:', typeof function(){}); // "function"
    console.log('typeof new Date():', typeof new Date());   // "object"
    console.log('typeof /regex/:', typeof /regex/);         // "object"
}

demonstrateTypeof();

/**
 * typeof的特殊情况和陷阱
 */
const TypeofTraps = {
    /**
     * null的typeof问题
     */
    nullProblem() {
        console.log('=== typeof null 问题 ===');
        console.log('typeof null:', typeof null); // "object" (错误的结果)
        
        // 正确判断null的方法
        const value = null;
        console.log('value === null:', value === null);           // true
        console.log('!value && typeof value === "object":', 
                   !value && typeof value === "object");          // true
    },
    
    /**
     * 数组的typeof问题
     */
    arrayProblem() {
        console.log('=== 数组判断问题 ===');
        const arr = [1, 2, 3];
        console.log('typeof arr:', typeof arr); // "object"
        
        // 正确判断数组的方法
        console.log('Array.isArray(arr):', Array.isArray(arr));           // true
        console.log('arr instanceof Array:', arr instanceof Array);       // true
        console.log('arr.constructor === Array:', arr.constructor === Array); // true
        console.log('Object.prototype.toString.call(arr):', 
                   Object.prototype.toString.call(arr)); // "[object Array]"
    },
    
    /**
     * 未声明变量的typeof
     */
    undeclaredVariable() {
        console.log('=== 未声明变量 ===');
        
        // typeof对未声明变量不会抛出错误
        console.log('typeof undeclaredVar:', typeof undeclaredVar); // "undefined"
        
        // 直接访问会抛出ReferenceError
        try {
            console.log(undeclaredVar);
        } catch (error) {
            console.log('直接访问未声明变量会报错:', error.name);
        }
    }
};

TypeofTraps.nullProblem();
TypeofTraps.arrayProblem();
TypeofTraps.undeclaredVariable();
```

#### 2. typeof 的应用场景

```javascript
/**
 * typeof的实际应用
 */
const TypeofApplications = {
    /**
     * 参数验证
     * @param {Function} callback - 回调函数
     * @param {number} delay - 延迟时间
     */
    validateParameters(callback, delay) {
        if (typeof callback !== 'function') {
            throw new TypeError('callback must be a function');
        }
        
        if (typeof delay !== 'number') {
            throw new TypeError('delay must be a number');
        }
        
        setTimeout(callback, delay);
    },
    
    /**
     * 功能检测
     */
    featureDetection() {
        console.log('=== 功能检测 ===');
        
        // 检测localStorage是否可用
        const hasLocalStorage = typeof Storage !== 'undefined' && 
                              typeof localStorage !== 'undefined';
        console.log('localStorage可用:', hasLocalStorage);
        
        // 检测Promise是否支持
        const hasPromise = typeof Promise !== 'undefined';
        console.log('Promise支持:', hasPromise);
        
        // 检测箭头函数支持（间接检测）
        let hasArrowFunction = false;
        try {
            eval('(() => {})');
            hasArrowFunction = true;
        } catch (e) {
            hasArrowFunction = false;
        }
        console.log('箭头函数支持:', hasArrowFunction);
    },
    
    /**
     * 安全的属性访问
     * @param {Object} obj - 对象
     * @param {string} prop - 属性名
     */
    safePropertyAccess(obj, prop) {
        if (typeof obj !== 'object' || obj === null) {
            return undefined;
        }
        
        return typeof obj[prop] !== 'undefined' ? obj[prop] : undefined;
    }
};

// TypeofApplications.validateParameters(() => console.log('test'), 1000);
TypeofApplications.featureDetection();
console.log('安全访问:', TypeofApplications.safePropertyAccess({name: 'test'}, 'name'));
```

### instanceof 操作符

`instanceof` 用于检测对象是否为特定构造函数的实例：

#### 1. instanceof 的基本原理

```javascript
/**
 * instanceof操作符详解
 */
function demonstrateInstanceof() {
    console.log('=== instanceof 基本用法 ===');
    
    // 基本用法
    const arr = [1, 2, 3];
    const obj = { name: 'test' };
    const date = new Date();
    const regex = /pattern/;
    
    console.log('arr instanceof Array:', arr instanceof Array);         // true
    console.log('arr instanceof Object:', arr instanceof Object);       // true
    console.log('obj instanceof Object:', obj instanceof Object);       // true
    console.log('date instanceof Date:', date instanceof Date);         // true
    console.log('date instanceof Object:', date instanceof Object);     // true
    console.log('regex instanceof RegExp:', regex instanceof RegExp);   // true
    
    // 自定义构造函数
    function Person(name) {
        this.name = name;
    }
    
    const person = new Person('Alice');
    console.log('person instanceof Person:', person instanceof Person); // true
    console.log('person instanceof Object:', person instanceof Object); // true
    
    /**
     * instanceof的工作原理
     */
    console.log('=== instanceof 原理 ===');
    
    // instanceof检查原型链
    console.log('Array.prototype:', Array.prototype);
    console.log('Object.prototype:', Object.prototype);
    console.log('arr.__proto__ === Array.prototype:', arr.__proto__ === Array.prototype);
    console.log('arr.__proto__.__proto__ === Object.prototype:', 
               arr.__proto__.__proto__ === Object.prototype);
}

demonstrateInstanceof();

/**
 * 手动实现instanceof
 * @param {*} left - 要检测的对象
 * @param {Function} right - 构造函数
 * @returns {boolean} 是否为实例
 */
function myInstanceof(left, right) {
    // 基本类型直接返回false
    if (typeof left !== 'object' || left === null) {
        return false;
    }
    
    // 获取构造函数的prototype
    const prototype = right.prototype;
    
    // 获取对象的原型
    let proto = Object.getPrototypeOf(left);
    
    // 沿着原型链查找
    while (proto !== null) {
        if (proto === prototype) {
            return true;
        }
        proto = Object.getPrototypeOf(proto);
    }
    
    return false;
}

// 测试自定义instanceof
console.log('=== 自定义instanceof测试 ===');
const testArr = [1, 2, 3];
console.log('myInstanceof(testArr, Array):', myInstanceof(testArr, Array));
console.log('myInstanceof(testArr, Object):', myInstanceof(testArr, Object));
console.log('myInstanceof("string", String):', myInstanceof("string", String));
```

#### 2. instanceof 的陷阱和限制

```javascript
/**
 * instanceof的局限性
 */
const InstanceofLimitations = {
    /**
     * 基本类型包装对象问题
     */
    wrapperObjects() {
        console.log('=== 基本类型包装对象 ===');
        
        const str1 = 'hello';
        const str2 = new String('hello');
        const num1 = 42;
        const num2 = new Number(42);
        
        console.log('str1 instanceof String:', str1 instanceof String);   // false
        console.log('str2 instanceof String:', str2 instanceof String);   // true
        console.log('num1 instanceof Number:', num1 instanceof Number);   // false
        console.log('num2 instanceof Number:', num2 instanceof Number);   // true
        
        // typeof vs instanceof
        console.log('typeof str1:', typeof str1); // "string"
        console.log('typeof str2:', typeof str2); // "object"
    },
    
    /**
     * 跨frame/iframe问题
     */
    crossFrameIssue() {
        console.log('=== 跨frame问题 ===');
        
        // 在不同的执行上下文中，Array构造函数可能不同
        // 这里模拟这种情况
        const fakeArray = {
            length: 0,
            push: Array.prototype.push,
            pop: Array.prototype.pop
        };
        
        // 设置假的原型链
        Object.setPrototypeOf(fakeArray, Array.prototype);
        
        console.log('fakeArray instanceof Array:', fakeArray instanceof Array); // true
        console.log('Array.isArray(fakeArray):', Array.isArray(fakeArray));     // false
    },
    
    /**
     * 原型链被修改的情况
     */
    modifiedPrototypeChain() {
        console.log('=== 原型链修改问题 ===');
        
        function MyClass() {}
        const instance = new MyClass();
        
        console.log('修改前 instanceof:', instance instanceof MyClass); // true
        
        // 修改原型链
        MyClass.prototype = {};
        
        console.log('修改后 instanceof:', instance instanceof MyClass); // false
        
        // 但对象本身没有改变
        console.log('对象类型:', Object.prototype.toString.call(instance));
    }
};

InstanceofLimitations.wrapperObjects();
InstanceofLimitations.crossFrameIssue();
InstanceofLimitations.modifiedPrototypeChain();
```

### 其他类型判断方法

除了 `typeof` 和 `instanceof`，还有其他更精确的类型判断方法：

```javascript
/**
 * 其他类型判断方法
 */
const AlternativeTypeMethods = {
    /**
     * Object.prototype.toString 方法
     */
    objectToString() {
        console.log('=== Object.prototype.toString ===');
        
        const toString = Object.prototype.toString;
        
        // 各种类型的toString结果
        console.log('toString.call(undefined):', toString.call(undefined)); // "[object Undefined]"
        console.log('toString.call(null):', toString.call(null));           // "[object Null]"
        console.log('toString.call(true):', toString.call(true));           // "[object Boolean]"
        console.log('toString.call(42):', toString.call(42));               // "[object Number]"
        console.log('toString.call("str"):', toString.call("str"));         // "[object String]"
        console.log('toString.call(Symbol()):', toString.call(Symbol()));   // "[object Symbol]"
        console.log('toString.call(123n):', toString.call(123n));           // "[object BigInt]"
        console.log('toString.call({}):', toString.call({}));               // "[object Object]"
        console.log('toString.call([]):', toString.call([]));               // "[object Array]"
        console.log('toString.call(function(){}):', toString.call(function(){})); // "[object Function]"
        console.log('toString.call(new Date()):', toString.call(new Date())); // "[object Date]"
        console.log('toString.call(/regex/):', toString.call(/regex/));      // "[object RegExp]"
    },
    
    /**
     * constructor 属性
     */
    constructorProperty() {
        console.log('=== constructor 属性 ===');
        
        const arr = [1, 2, 3];
        const obj = { name: 'test' };
        const str = 'hello';
        
        console.log('arr.constructor === Array:', arr.constructor === Array);
        console.log('obj.constructor === Object:', obj.constructor === Object);
        console.log('str.constructor === String:', str.constructor === String);
        
        // constructor可能被修改，不够可靠
        arr.constructor = Object;
        console.log('修改后 arr.constructor === Array:', arr.constructor === Array); // false
        console.log('但 Array.isArray(arr):', Array.isArray(arr)); // true
    },
    
    /**
     * 特定类型的内置判断方法
     */
    builtinMethods() {
        console.log('=== 内置判断方法 ===');
        
        // 数组判断
        console.log('Array.isArray([]):', Array.isArray([]));               // true
        console.log('Array.isArray("not array"):', Array.isArray("not array")); // false
        
        // NaN判断
        console.log('Number.isNaN(NaN):', Number.isNaN(NaN));               // true
        console.log('Number.isNaN("NaN"):', Number.isNaN("NaN"));           // false
        console.log('isNaN("NaN"):', isNaN("NaN"));                         // true (会转换)
        
        // 有限数判断
        console.log('Number.isFinite(42):', Number.isFinite(42));           // true
        console.log('Number.isFinite(Infinity):', Number.isFinite(Infinity)); // false
        console.log('Number.isFinite("42"):', Number.isFinite("42"));       // false
        console.log('isFinite("42"):', isFinite("42"));                     // true (会转换)
        
        // 整数判断
        console.log('Number.isInteger(42):', Number.isInteger(42));         // true
        console.log('Number.isInteger(42.0):', Number.isInteger(42.0));     // true
        console.log('Number.isInteger(42.1):', Number.isInteger(42.1));     // false
    }
};

AlternativeTypeMethods.objectToString();
AlternativeTypeMethods.constructorProperty();
AlternativeTypeMethods.builtinMethods();
```

### 准确的类型判断工具函数

基于以上方法，我们可以创建一套完整的类型判断工具：

```javascript
/**
 * 完整的类型判断工具库
 */
const TypeChecker = {
    /**
     * 获取精确的数据类型
     * @param {*} value - 要检测的值
     * @returns {string} 类型名称
     */
    getType(value) {
        const type = Object.prototype.toString.call(value);
        return type.slice(8, -1).toLowerCase();
    },
    
    /**
     * 基本类型判断方法
     */
    isUndefined(value) { return value === undefined; },
    isNull(value) { return value === null; },
    isBoolean(value) { return typeof value === 'boolean'; },
    isNumber(value) { return typeof value === 'number' && !isNaN(value); },
    isString(value) { return typeof value === 'string'; },
    isSymbol(value) { return typeof value === 'symbol'; },
    isBigInt(value) { return typeof value === 'bigint'; },
    
    /**
     * 引用类型判断方法
     */
    isObject(value) { 
        return value !== null && typeof value === 'object' && !Array.isArray(value); 
    },
    isArray(value) { return Array.isArray(value); },
    isFunction(value) { return typeof value === 'function'; },
    isDate(value) { return value instanceof Date && !isNaN(value.getTime()); },
    isRegExp(value) { return value instanceof RegExp; },
    
    /**
     * 特殊值判断
     */
    isNaN(value) { return Number.isNaN(value); },
    isFinite(value) { return Number.isFinite(value); },
    isInteger(value) { return Number.isInteger(value); },
    
    /**
     * 复合类型判断
     */
    isPrimitive(value) {
        return value === null || 
               typeof value === 'undefined' ||
               typeof value === 'boolean' ||
               typeof value === 'number' ||
               typeof value === 'string' ||
               typeof value === 'symbol' ||
               typeof value === 'bigint';
    },
    
    isReference(value) {
        return !this.isPrimitive(value);
    },
    
    isEmpty(value) {
        if (this.isNull(value) || this.isUndefined(value)) return true;
        if (this.isString(value) || this.isArray(value)) return value.length === 0;
        if (this.isObject(value)) return Object.keys(value).length === 0;
        return false;
    },
    
    /**
     * 类型兼容性判断
     * @param {*} value - 要检测的值
     * @param {string|Array} expectedTypes - 期望的类型
     * @returns {boolean} 是否匹配
     */
    isType(value, expectedTypes) {
        const actualType = this.getType(value);
        const types = Array.isArray(expectedTypes) ? expectedTypes : [expectedTypes];
        return types.some(type => type.toLowerCase() === actualType);
    },
    
    /**
     * 深度类型检测
     * @param {*} value - 要检测的值
     * @returns {Object} 详细的类型信息
     */
    deepTypeCheck(value) {
        const result = {
            value: value,
            type: this.getType(value),
            isPrimitive: this.isPrimitive(value),
            isReference: this.isReference(value),
            isEmpty: this.isEmpty(value),
            constructor: value?.constructor?.name || null,
            proto: value?.__proto__?.constructor?.name || null
        };
        
        // 针对特定类型添加额外信息
        if (this.isNumber(value)) {
            result.isInteger = this.isInteger(value);
            result.isFinite = this.isFinite(value);
        }
        
        if (this.isArray(value)) {
            result.length = value.length;
        }
        
        if (this.isObject(value)) {
            result.keys = Object.keys(value);
            result.propertyCount = Object.keys(value).length;
        }
        
        return result;
    }
};

/**
 * 类型判断工具使用示例
 */
function demonstrateTypeChecker() {
    console.log('=== 类型判断工具测试 ===');
    
    const testValues = [
        undefined,
        null,
        true,
        42,
        'hello',
        Symbol('test'),
        123n,
        {},
        [],
        function(){},
        new Date(),
        /regex/,
        NaN,
        Infinity
    ];
    
    testValues.forEach(value => {
        console.log(`值: ${value}, 类型: ${TypeChecker.getType(value)}`);
    });
    
    // 深度类型检测示例
    console.log('=== 深度类型检测 ===');
    const complexObj = {
        name: 'test',
        items: [1, 2, 3],
        nested: { prop: 'value' }
    };
    
    console.log('复杂对象类型信息:', TypeChecker.deepTypeCheck(complexObj));
    
    // 类型匹配测试
    console.log('=== 类型匹配测试 ===');
    console.log('42 是 number:', TypeChecker.isType(42, 'number'));
    console.log('[1,2,3] 是 array 或 object:', TypeChecker.isType([1,2,3], ['array', 'object']));
}

demonstrateTypeChecker();

/**
 * 实际应用：参数验证装饰器
 * @param  {...string} expectedTypes - 期望的参数类型
 */
function validateParams(...expectedTypes) {
    return function(target, propertyName, descriptor) {
        const method = descriptor.value;
        
        descriptor.value = function(...args) {
            // 验证参数数量
            if (args.length < expectedTypes.length) {
                throw new Error(`Expected ${expectedTypes.length} arguments, got ${args.length}`);
            }
            
            // 验证参数类型
            expectedTypes.forEach((expectedType, index) => {
                const actualType = TypeChecker.getType(args[index]);
                if (actualType !== expectedType.toLowerCase()) {
                    throw new TypeError(
                        `Argument ${index + 1} expected ${expectedType}, got ${actualType}`
                    );
                }
            });
            
            return method.apply(this, args);
        };
        
        return descriptor;
    };
}

// 使用示例（装饰器需要在支持的环境中使用）
class Calculator {
    /**
     * 加法运算（带类型验证）
     * @param {number} a - 第一个数
     * @param {number} b - 第二个数
     * @returns {number} 和
     */
    add(a, b) {
        // 手动类型验证示例
        if (!TypeChecker.isNumber(a) || !TypeChecker.isNumber(b)) {
            throw new TypeError('Both arguments must be numbers');
        }
        return a + b;
    }
}

const calc = new Calculator();
console.log('=== 计算器测试 ===');
console.log('calc.add(5, 3):', calc.add(5, 3));

try {
    calc.add('5', 3);
} catch (error) {
    console.log('类型错误捕获:', error.message);
}
```

---

## 5.5 类型转换（隐式与显式）

### 隐式类型转换

### 显式类型转换

### 转换规则与机制

### 常见转换陷阱

---

## 5.6 JSON 的本质与应用

### JSON 数据格式

### JSON 序列化与反序列化

### JSON 与 JavaScript 对象的差异

### 实际应用场景

---

**本章总结**

**下一章预告**
