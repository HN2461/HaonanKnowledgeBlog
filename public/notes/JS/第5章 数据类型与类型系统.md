# 第5章　数据类型与类型系统

数据类型是编程语言的基础概念，JavaScript作为动态类型语言，具有灵活而复杂的类型系统。理解数据类型及其转换机制，是掌握JavaScript的关键。

## 5.1 基本类型（七种）

### 基本类型概览

JavaScript有7种基本数据类型（原始类型），它们都是不可变的，存储在栈内存中：

| 类型 | 引入版本 | 描述 | 默认值 | 特殊值 |
|------|----------|------|--------|--------|
| `Number` | ES1 | 数值类型 | `0` | `NaN`, `Infinity` |
| `String` | ES1 | 字符串类型 | `""` | 无 |
| `Boolean` | ES1 | 布尔类型 | `false` | 无 |
| `Null` | ES1 | 空值类型 | `null` | 无 |
| `Undefined` | ES1 | 未定义类型 | `undefined` | 无 |
| `Symbol` | ES6 | 符号类型 | 无默认值 | 无 |
| `BigInt` | ES2020 | 大整数类型 | `0n` | 无 |

### Number（数值类型）

JavaScript中所有数值都使用64位浮点数表示（IEEE 754标准）：

#### 1. 数值表示方式

```javascript
// 整数表示
const intNumber = 42;
const negativeInt = -100;
const zero = 0;

// 浮点数表示
const floatNumber = 3.14159;
const scientific = 1.23e10;  // 科学记数法：12300000000
const negative = -2.5e-3;    // -0.0025

// 不同进制表示
const binary = 0b1010;       // 二进制：10
const octal = 0o755;         // 八进制：493
const hexadecimal = 0xFF;    // 十六进制：255

console.log(binary, octal, hexadecimal); // 输出: 10 493 255
```

#### 2. 特殊数值

```javascript
/**
 * 特殊数值的判断和处理
 */
console.log('=== NaN (Not a Number) ===');
const notANumber = 0 / 0;
console.log(notANumber);           // NaN
console.log(Number.isNaN(notANumber)); // true
console.log(notANumber === notANumber); // false (NaN不等于自身)

console.log('=== Infinity ===');
const positiveInfinity = 1 / 0;
const negativeInfinity = -1 / 0;
console.log(positiveInfinity);     // Infinity
console.log(negativeInfinity);     // -Infinity
console.log(Number.isFinite(positiveInfinity)); // false

/**
 * 数值精度问题
 */
console.log('=== 浮点数精度问题 ===');
console.log(0.1 + 0.2);           // 0.30000000000000004
console.log(0.1 + 0.2 === 0.3);   // false

// 解决精度问题的方法
const EPSILON = Number.EPSILON || 2.220446049250313e-16;

/**
 * 比较两个浮点数是否相等
 * @param {number} a - 第一个数
 * @param {number} b - 第二个数
 * @returns {boolean} 是否相等
 */
function floatEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
}

console.log(floatEqual(0.1 + 0.2, 0.3)); // true
```

#### 3. Number对象方法

```javascript
/**
 * Number类型的常用方法
 */
const NumberUtils = {
    /**
     * 数值验证方法
     */
    validateNumbers() {
        console.log('Number.isInteger(42):', Number.isInteger(42));     // true
        console.log('Number.isInteger(42.0):', Number.isInteger(42.0)); // true
        console.log('Number.isInteger(42.1):', Number.isInteger(42.1)); // false
        
        console.log('Number.isSafeInteger(42):', Number.isSafeInteger(42)); // true
        console.log('Number.MAX_SAFE_INTEGER:', Number.MAX_SAFE_INTEGER);   // 9007199254740991
        
        console.log('Number.parseFloat("3.14abc"):', Number.parseFloat("3.14abc")); // 3.14
        console.log('Number.parseInt("42px", 10):', Number.parseInt("42px", 10));   // 42
    },
    
    /**
     * 数值格式化
     * @param {number} num - 要格式化的数字
     */
    formatNumber(num) {
        return {
            fixed: num.toFixed(2),           // 保留2位小数
            exponential: num.toExponential(2), // 科学记数法
            precision: num.toPrecision(4),   // 有效数字
            string: num.toString(16)         // 转换为16进制字符串
        };
    }
};

NumberUtils.validateNumbers();
console.log(NumberUtils.formatNumber(123.456789));
// 输出: {fixed: "123.46", exponential: "1.23e+2", precision: "123.5", string: "7b"}
```

### String（字符串类型）

字符串是不可变的Unicode字符序列：

#### 1. 字符串创建方式

```javascript
// 字符串字面量
const singleQuoted = 'Hello World';
const doubleQuoted = "Hello World";
const templateLiteral = `Hello World`;

// 字符串构造函数（不推荐）
const stringObject = new String('Hello World'); // 返回对象，不是基本类型

// 转义字符
const escapedString = 'It\'s a "beautiful" day\nwith\\backslashes';
console.log(escapedString);
// 输出:
// It's a "beautiful" day
// with\backslashes

/**
 * 模板字符串的强大功能
 */
const name = 'JavaScript';
const version = 2023;
const multiLineTemplate = `
    Language: ${name}
    Version: ${version}
    Expression: ${2 + 3}
    Function call: ${name.toUpperCase()}
`;

console.log(multiLineTemplate);
```

#### 2. 字符串方法

```javascript
/**
 * 字符串工具类
 */
class StringHelper {
    /**
     * 字符串查找和检测
     * @param {string} str - 目标字符串
     */
    static searchMethods(str) {
        console.log('=== 字符串查找 ===');
        console.log(`原字符串: "${str}"`);
        console.log(`长度: ${str.length}`);
        console.log(`indexOf('Script'): ${str.indexOf('Script')}`);
        console.log(`lastIndexOf('a'): ${str.lastIndexOf('a')}`);
        console.log(`includes('Java'): ${str.includes('Java')}`);
        console.log(`startsWith('Java'): ${str.startsWith('Java')}`);
        console.log(`endsWith('Script'): ${str.endsWith('Script')}`);
    }
    
    /**
     * 字符串提取
     * @param {string} str - 目标字符串
     */
    static extractMethods(str) {
        console.log('=== 字符串提取 ===');
        console.log(`charAt(4): ${str.charAt(4)}`);
        console.log(`charCodeAt(0): ${str.charCodeAt(0)}`);
        console.log(`slice(0, 4): ${str.slice(0, 4)}`);
        console.log(`substring(4, 10): ${str.substring(4, 10)}`);
        console.log(`substr(4, 6): ${str.substr(4, 6)}`); // 已废弃，不推荐使用
    }
    
    /**
     * 字符串转换
     * @param {string} str - 目标字符串
     */
    static transformMethods(str) {
        console.log('=== 字符串转换 ===');
        console.log(`toLowerCase(): ${str.toLowerCase()}`);
        console.log(`toUpperCase(): ${str.toUpperCase()}`);
        console.log(`trim(): "${str.trim()}"`);
        console.log(`replace('Script', 'World'): ${str.replace('Script', 'World')}`);
        console.log(`split(''): ${JSON.stringify(str.split(''))}`);
    }
}

const testString = '  JavaScript Programming  ';
StringHelper.searchMethods(testString);
StringHelper.extractMethods(testString);
StringHelper.transformMethods(testString);
```

### Boolean（布尔类型）

布尔类型只有两个值：`true`和`false`：

```javascript
/**
 * 布尔值的创建和使用
 */
const boolTrue = true;
const boolFalse = false;
const boolFromFunction = Boolean(42);  // true
const boolFromNegation = !!'hello';    // true

console.log(typeof boolTrue);          // "boolean"
console.log(Boolean(1));               // true
console.log(Boolean(0));               // false
console.log(Boolean(''));              // false
console.log(Boolean('false'));         // true (非空字符串都是true)

/**
 * 真值和假值
 */
const FalsyValues = {
    // JavaScript中的所有假值
    values: [false, 0, -0, 0n, '', null, undefined, NaN],
    
    /**
     * 检测假值
     * @param {*} value - 要检测的值
     */
    isFalsy(value) {
        return !value;
    },
    
    /**
     * 检测真值
     * @param {*} value - 要检测的值
     */
    isTruthy(value) {
        return !!value;
    },
    
    /**
     * 演示所有假值
     */
    demonstrateFalsyValues() {
        console.log('=== 假值演示 ===');
        this.values.forEach((value, index) => {
            console.log(`${index + 1}. ${JSON.stringify(value)} -> ${this.isFalsy(value)}`);
        });
    }
};

FalsyValues.demonstrateFalsyValues();
```

### Null（空值类型）

`null`表示有意的空值或不存在的对象：

```javascript
/**
 * null的特性和使用
 */
let emptyValue = null;

console.log(typeof null);              // "object" (这是JavaScript的一个历史bug)
console.log(null == undefined);        // true (相等但不全等)
console.log(null === undefined);       // false
console.log(Boolean(null));            // false

/**
 * null的实际应用场景
 */
const UserProfile = {
    name: 'John Doe',
    avatar: null,        // 用户没有设置头像
    lastLogin: null,     // 用户从未登录过
    
    /**
     * 设置头像
     * @param {string|null} avatarUrl - 头像URL或null
     */
    setAvatar(avatarUrl) {
        this.avatar = avatarUrl;
    },
    
    /**
     * 清除头像
     */
    clearAvatar() {
        this.avatar = null;
    },
    
    /**
     * 检查是否有头像
     * @returns {boolean} 是否有头像
     */
    hasAvatar() {
        return this.avatar !== null;
    }
};

console.log(UserProfile.hasAvatar());  // false
UserProfile.setAvatar('https://example.com/avatar.jpg');
console.log(UserProfile.hasAvatar());  // true
```

### Undefined（未定义类型）

`undefined`表示变量已声明但未赋值，或不存在的对象属性：

```javascript
/**
 * undefined的各种情况
 */
let undeclaredVar;                     // undefined
const obj = { name: 'test' };
const nonExistentProp = obj.age;       // undefined
const funcWithoutReturn = () => {};
const returnValue = funcWithoutReturn(); // undefined

console.log(typeof undefined);         // "undefined"
console.log(undefined == null);        // true
console.log(undefined === null);       // false

/**
 * 检测undefined的最佳实践
 */
const UndefinedUtils = {
    /**
     * 安全检测undefined
     * @param {*} value - 要检测的值
     */
    isUndefined(value) {
        return typeof value === 'undefined';
    },
    
    /**
     * 检测是否为null或undefined
     * @param {*} value - 要检测的值
     */
    isNullish(value) {
        return value == null; // 同时检测null和undefined
    },
    
    /**
     * 提供默认值（类似于空值合并运算符 ??）
     * @param {*} value - 原始值
     * @param {*} defaultValue - 默认值
     */
    defaultValue(value, defaultValue) {
        return value != null ? value : defaultValue;
    }
};

console.log(UndefinedUtils.isUndefined(undeclaredVar));        // true
console.log(UndefinedUtils.isNullish(null));                  // true
console.log(UndefinedUtils.isNullish(undefined));             // true
console.log(UndefinedUtils.defaultValue(null, 'default'));     // 'default'
```

### Symbol（符号类型）

Symbol是ES6引入的新基本类型，表示唯一的标识符：

```javascript
/**
 * Symbol的创建和特性
 */
const symbol1 = Symbol();
const symbol2 = Symbol('description');
const symbol3 = Symbol('description');

console.log(typeof symbol1);           // "symbol"
console.log(symbol2 === symbol3);      // false (每个Symbol都是唯一的)
console.log(symbol2.toString());       // "Symbol(description)"

/**
 * Symbol的实际应用
 */
const SymbolExamples = {
    /**
     * 作为对象属性名避免冲突
     */
    objectProperties() {
        const ID_SYMBOL = Symbol('id');
        const user = {
            name: 'John',
            [ID_SYMBOL]: 12345    // Symbol作为属性名
        };
        
        console.log(user.name);           // "John"
        console.log(user[ID_SYMBOL]);     // 12345
        console.log(Object.keys(user));   // ["name"] (Symbol属性不被枚举)
    },
    
    /**
     * 全局Symbol注册表
     */
    globalSymbols() {
        const globalSym1 = Symbol.for('global.id');
        const globalSym2 = Symbol.for('global.id');
        
        console.log(globalSym1 === globalSym2);           // true
        console.log(Symbol.keyFor(globalSym1));           // "global.id"
    },
    
    /**
     * 内置Symbol
     */
    wellKnownSymbols() {
        const customIterable = {
            data: [1, 2, 3],
            
            // 实现Iterator接口
            [Symbol.iterator]() {
                let index = 0;
                const data = this.data;
                
                return {
                    next() {
                        if (index < data.length) {
                            return { value: data[index++], done: false };
                        }
                        return { done: true };
                    }
                };
            }
        };
        
        // 现在对象可以被迭代
        for (const value of customIterable) {
            console.log('迭代值:', value);
        }
    }
};

SymbolExamples.objectProperties();
SymbolExamples.globalSymbols();
SymbolExamples.wellKnownSymbols();
```

### BigInt（大整数类型）

BigInt是ES2020引入的新类型，用于表示任意精度的整数：

```javascript
/**
 * BigInt的创建和使用
 */
const bigInt1 = 123456789012345678901234567890n; // 字面量形式
const bigInt2 = BigInt('123456789012345678901234567890'); // 构造函数形式
const bigInt3 = BigInt(123);                     // 从Number转换

console.log(typeof bigInt1);                     // "bigint"
console.log(bigInt1 === bigInt2);               // true

/**
 * BigInt的运算和限制
 */
const BigIntCalculator = {
    /**
     * BigInt基本运算
     */
    basicOperations() {
        const a = 123456789012345678901234567890n;
        const b = 987654321098765432109876543210n;
        
        console.log('=== BigInt运算 ===');
        console.log('加法:', a + b);
        console.log('减法:', b - a);
        console.log('乘法:', a * 2n);               // 必须是BigInt
        console.log('除法:', b / a);
        console.log('求余:', b % a);
        console.log('幂运算:', 2n ** 100n);
    },
    
    /**
     * BigInt与Number的区别
     */
    compareWithNumber() {
        console.log('=== BigInt vs Number ===');
        
        // ❌ 不能混合运算
        // console.log(123n + 456);  // TypeError
        
        // ✅ 需要显式转换
        console.log(123n + BigInt(456));           // 579n
        console.log(Number(123n) + 456);           // 579
        
        // 比较操作
        console.log(123n == 123);                  // true (相等)
        console.log(123n === 123);                 // false (类型不同)
        console.log(123n < 124);                   // true (可以比较)
    },
    
    /**
     * BigInt的实际应用
     */
    practicalUsage() {
        /**
         * 计算阶乘 - 处理大数运算
         * @param {number|bigint} n - 计算阶乘的数
         * @returns {bigint} 阶乘结果
         */
        function factorial(n) {
            const num = BigInt(n);
            let result = 1n;
            
            for (let i = 2n; i <= num; i++) {
                result *= i;
            }
            
            return result;
        }
        
        console.log('=== 大数阶乘计算 ===');
        console.log('50! =', factorial(50).toString());
        
        /**
         * 处理超出Number.MAX_SAFE_INTEGER的整数
         */
        console.log('=== 安全整数范围 ===');
        console.log('MAX_SAFE_INTEGER:', Number.MAX_SAFE_INTEGER);
        console.log('超出安全范围的BigInt:', 9007199254740992n);
    }
};

BigIntCalculator.basicOperations();
BigIntCalculator.compareWithNumber();
BigIntCalculator.practicalUsage();
```

---

## 5.2 引用类型

### 引用类型的特点

引用类型（对象类型）存储在堆内存中，变量存储的是对象的引用地址：

#### 引用类型与基本类型的区别

| 特性 | 基本类型 | 引用类型 |
|------|----------|----------|
| 存储位置 | 栈内存 | 堆内存 |
| 存储内容 | 值本身 | 引用地址 |
| 可变性 | 不可变 | 可变 |
| 比较方式 | 值比较 | 引用比较 |
| 复制行为 | 值复制 | 引用复制 |

```javascript
// 引用类型的基本特性演示
let obj1 = { name: 'Alice' };
let obj2 = obj1;                    // 引用复制

obj2.name = 'Bob';
console.log(obj1.name);             // 'Bob' (两个变量指向同一个对象)

let obj3 = { name: 'Charlie' };
console.log(obj1 === obj2);         // true (相同引用)
console.log(obj1 === obj3);         // false (不同对象)
console.log(obj1.name === obj3.name); // false (值不同)
```

### Object（对象类型）

对象是键值对的集合，是JavaScript中最重要的数据类型：

#### 1. 对象创建方式

```javascript
/**
 * 对象的多种创建方式
 */
const ObjectCreationMethods = {
    /**
     * 对象字面量（最常用）
     */
    literalObjects() {
        const person = {
            name: 'John',
            age: 30,
            greet() {
                return `Hello, I'm ${this.name}`;
            }
        };
        
        // 计算属性名
        const propName = 'dynamicProperty';
        const dynamicObj = {
            [propName]: 'dynamic value',
            [`${propName}_2`]: 'another value'
        };
        
        return { person, dynamicObj };
    },
    
    /**
     * 构造函数方式
     */
    constructorObjects() {
        // Object构造函数
        const obj1 = new Object();
        obj1.name = 'Created with constructor';
        
        // 自定义构造函数
        function Person(name, age) {
            this.name = name;
            this.age = age;
            this.greet = function() {
                return `Hello, I'm ${this.name}`;
            };
        }
        
        const person = new Person('Alice', 25);
        return { obj1, person };
    },
    
    /**
     * Object.create方式
     */
    createMethod() {
        const prototype = {
            greet() {
                return `Hello, I'm ${this.name}`;
            }
        };
        
        const person = Object.create(prototype);
        person.name = 'Bob';
        person.age = 28;
        
        return person;
    }
};

console.log(ObjectCreationMethods.literalObjects());
console.log(ObjectCreationMethods.constructorObjects());
console.log(ObjectCreationMethods.createMethod());
```

#### 2. 对象属性操作

```javascript
/**
 * 对象属性操作工具类
 */
class ObjectPropertyManager {
    /**
     * 属性访问方式
     * @param {Object} obj - 目标对象
     */
    static accessProperties(obj) {
        console.log('=== 属性访问 ===');
        
        // 点号访问
        console.log('点号访问 obj.name:', obj.name);
        
        // 方括号访问
        console.log('方括号访问 obj["name"]:', obj['name']);
        
        // 动态属性名
        const propName = 'age';
        console.log(`动态属性 obj[${propName}]:`, obj[propName]);
        
        // 访问不存在的属性
        console.log('不存在的属性:', obj.nonExistent); // undefined
    }
    
    /**
     * 属性检测
     * @param {Object} obj - 目标对象
     */
    static detectProperties(obj) {
        console.log('=== 属性检测 ===');
        
        // in 操作符（检查原型链）
        console.log('"name" in obj:', 'name' in obj);
        console.log('"toString" in obj:', 'toString' in obj);
        
        // hasOwnProperty（只检查自身属性）
        console.log('obj.hasOwnProperty("name"):', obj.hasOwnProperty('name'));
        console.log('obj.hasOwnProperty("toString"):', obj.hasOwnProperty('toString'));
        
        // Object.hasOwn（ES2022新方法）
        if (Object.hasOwn) {
            console.log('Object.hasOwn(obj, "name"):', Object.hasOwn(obj, 'name'));
        }
    }
    
    /**
     * 属性枚举
     * @param {Object} obj - 目标对象
     */
    static enumerateProperties(obj) {
        console.log('=== 属性枚举 ===');
        
        // Object.keys（可枚举的自身属性）
        console.log('Object.keys(obj):', Object.keys(obj));
        
        // Object.values（属性值）
        console.log('Object.values(obj):', Object.values(obj));
        
        // Object.entries（键值对）
        console.log('Object.entries(obj):', Object.entries(obj));
        
        // for...in 循环（包括原型链）
        console.log('for...in 循环:');
        for (const prop in obj) {
            console.log(`  ${prop}: ${obj[prop]}`);
        }
    }
}

const testObj = { name: 'Test', age: 30, city: 'Beijing' };
ObjectPropertyManager.accessProperties(testObj);
ObjectPropertyManager.detectProperties(testObj);
ObjectPropertyManager.enumerateProperties(testObj);
```

### Array（数组类型）

数组是特殊的对象，用于存储有序的数据集合：

#### 1. 数组创建和基本操作

```javascript
/**
 * 数组操作示例
 */
const ArrayExamples = {
    /**
     * 数组创建方式
     */
    creation() {
        // 数组字面量（推荐）
        const fruits = ['apple', 'banana', 'orange'];
        
        // Array构造函数
        const numbers = new Array(1, 2, 3, 4, 5);
        const emptyArray = new Array(5); // 创建长度为5的空数组
        
        // Array.from() 创建数组
        const fromString = Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']
        const fromRange = Array.from({length: 5}, (_, i) => i + 1); // [1, 2, 3, 4, 5]
        
        return { fruits, numbers, emptyArray, fromString, fromRange };
    },
    
    /**
     * 数组基本操作
     */
    basicOperations() {
        const arr = [1, 2, 3];
        
        console.log('=== 数组基本操作 ===');
        console.log('原数组:', arr);
        console.log('长度:', arr.length);
        console.log('访问元素 arr[1]:', arr[1]);
        
        // 添加元素
        arr.push(4);                    // 尾部添加
        arr.unshift(0);                 // 头部添加
        console.log('添加元素后:', arr);
        
        // 删除元素
        const lastItem = arr.pop();     // 删除尾部
        const firstItem = arr.shift();  // 删除头部
        console.log('删除元素后:', arr);
        console.log('删除的元素:', { lastItem, firstItem });
        
        // 修改元素
        arr[1] = 'modified';
        console.log('修改后:', arr);
    },
    
    /**
     * 数组高级方法
     */
    advancedMethods() {
        const numbers = [1, 2, 3, 4, 5];
        const users = [
            { name: 'Alice', age: 25, active: true },
            { name: 'Bob', age: 30, active: false },
            { name: 'Charlie', age: 35, active: true }
        ];
        
        console.log('=== 数组高级方法 ===');
        
        // 查找方法
        console.log('indexOf(3):', numbers.indexOf(3));
        console.log('includes(4):', numbers.includes(4));
        console.log('find active user:', users.find(user => user.active));
        console.log('findIndex age>30:', users.findIndex(user => user.age > 30));
        
        // 测试方法
        console.log('some active:', users.some(user => user.active));
        console.log('every active:', users.every(user => user.active));
        
        // 转换方法
        console.log('map doubled:', numbers.map(n => n * 2));
        console.log('filter active:', users.filter(user => user.active));
        console.log('reduce sum:', numbers.reduce((sum, n) => sum + n, 0));
    }
};

console.log(ArrayExamples.creation());
ArrayExamples.basicOperations();
ArrayExamples.advancedMethods();
```

### Function（函数类型）

函数是JavaScript中的一等公民，也是对象类型：

```javascript
/**
 * 函数类型的特性和使用
 */
const FunctionExamples = {
    /**
     * 函数创建方式
     */
    creationMethods() {
        // 函数声明
        function declared() {
            return 'declared function';
        }
        
        // 函数表达式
        const expression = function() {
            return 'function expression';
        };
        
        // 箭头函数
        const arrow = () => 'arrow function';
        
        // Function构造函数（不推荐）
        const constructed = new Function('return "constructed function"');
        
        return { declared, expression, arrow, constructed };
    },
    
    /**
     * 函数作为对象的特性
     */
    objectCharacteristics() {
        function myFunction(a, b) {
            return a + b;
        }
        
        // 函数属性
        myFunction.customProperty = 'I am a function property';
        myFunction.counter = 0;
        
        // 函数方法
        myFunction.increment = function() {
            this.counter++;
        };
        
        console.log('=== 函数对象特性 ===');
        console.log('函数名称:', myFunction.name);
        console.log('参数个数:', myFunction.length);
        console.log('自定义属性:', myFunction.customProperty);
        
        myFunction.increment();
        console.log('调用方法后的计数器:', myFunction.counter);
    },
    
    /**
     * 高阶函数示例
     */
    higherOrderFunctions() {
        /**
         * 创建乘法函数的工厂函数
         * @param {number} multiplier - 乘数
         * @returns {Function} 乘法函数
         */
        function createMultiplier(multiplier) {
            return function(x) {
                return x * multiplier;
            };
        }
        
        const double = createMultiplier(2);
        const triple = createMultiplier(3);
        
        console.log('=== 高阶函数 ===');
        console.log('double(5):', double(5));
        console.log('triple(4):', triple(4));
        
        /**
         * 函数作为参数
         * @param {Array} arr - 数组
         * @param {Function} callback - 回调函数
         */
        function processArray(arr, callback) {
            return arr.map(callback);
        }
        
        const numbers = [1, 2, 3, 4, 5];
        console.log('processArray with double:', processArray(numbers, double));
    }
};

console.log(FunctionExamples.creationMethods());
FunctionExamples.objectCharacteristics();
FunctionExamples.higherOrderFunctions();
```

### Date（日期类型）

Date对象用于处理日期和时间：

```javascript
/**
 * Date类型的使用
 */
const DateExamples = {
    /**
     * Date对象创建
     */
    creation() {
        console.log('=== Date对象创建 ===');
        
        // 当前时间
        const now = new Date();
        console.log('当前时间:', now);
        
        // 指定日期
        const specificDate = new Date('2023-12-25');
        const detailedDate = new Date(2023, 11, 25, 10, 30, 0); // 月份从0开始
        
        // 时间戳
        const fromTimestamp = new Date(1703505000000);
        
        console.log('指定日期:', specificDate);
        console.log('详细日期:', detailedDate);
        console.log('从时间戳:', fromTimestamp);
    },
    
    /**
     * 日期格式化和操作
     */
    formatting() {
        const date = new Date('2023-12-25T10:30:00');
        
        console.log('=== 日期格式化 ===');
        console.log('ISO字符串:', date.toISOString());
        console.log('本地字符串:', date.toString());
        console.log('日期部分:', date.toDateString());
        console.log('时间部分:', date.toTimeString());
        console.log('本地化日期:', date.toLocaleDateString('zh-CN'));
        console.log('本地化时间:', date.toLocaleTimeString('zh-CN'));
    },
    
    /**
     * 日期计算
     */
    calculations() {
        const date1 = new Date('2023-12-25');
        const date2 = new Date('2023-12-20');
        
        console.log('=== 日期计算 ===');
        
        // 日期差值（毫秒）
        const diffMs = date1 - date2;
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        console.log('日期差值:', diffDays, '天');
        
        // 添加天数
        const futureDate = new Date(date1);
        futureDate.setDate(futureDate.getDate() + 7);
        console.log('7天后:', futureDate.toDateString());
        
        /**
         * 实用的日期工具函数
         */
        const DateUtils = {
            /**
             * 格式化日期为 YYYY-MM-DD
             * @param {Date} date - 日期对象
             */
            formatDate(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            },
            
            /**
             * 获取两个日期间的天数差
             * @param {Date} date1 - 第一个日期
             * @param {Date} date2 - 第二个日期
             */
            daysDiff(date1, date2) {
                const oneDay = 24 * 60 * 60 * 1000;
                return Math.round(Math.abs((date1 - date2) / oneDay));
            }
        };
        
        console.log('格式化日期:', DateUtils.formatDate(new Date()));
        console.log('工具函数计算天数差:', DateUtils.daysDiff(date1, date2));
    }
};

DateExamples.creation();
DateExamples.formatting();
DateExamples.calculations();
```

### RegExp（正则表达式类型）

正则表达式用于模式匹配和文本处理：

```javascript
/**
 * 正则表达式的使用
 */
const RegExpExamples = {
    /**
     * 正则表达式创建
     */
    creation() {
        console.log('=== 正则表达式创建 ===');
        
        // 字面量语法
        const regex1 = /hello/i;  // i表示忽略大小写
        
        // RegExp构造函数
        const regex2 = new RegExp('world', 'g'); // g表示全局匹配
        
        // 动态正则表达式
        const pattern = 'JavaScript';
        const regex3 = new RegExp(pattern, 'gi');
        
        console.log('字面量正则:', regex1);
        console.log('构造函数正则:', regex2);
        console.log('动态正则:', regex3);
    },
    
    /**
     * 正则表达式方法
     */
    methods() {
        const text = 'JavaScript is awesome. JavaScript rocks!';
        const regex = /JavaScript/gi;
        
        console.log('=== 正则表达式方法 ===');
        console.log('原文本:', text);
        
        // test() - 测试是否匹配
        console.log('regex.test():', regex.test(text));
        
        // exec() - 执行匹配
        regex.lastIndex = 0; // 重置全局匹配位置
        let match;
        console.log('exec() 匹配结果:');
        while ((match = regex.exec(text)) !== null) {
            console.log(`  找到 "${match[0]}" 在位置 ${match.index}`);
        }
        
        // 字符串的正则方法
        console.log('=== 字符串正则方法 ===');
        console.log('match():', text.match(/JavaScript/g));
        console.log('search():', text.search(/awesome/));
        console.log('replace():', text.replace(/JavaScript/g, 'JS'));
        console.log('split():', text.split(/\s+/)); // 按空白字符分割
    },
    
    /**
     * 实用的正则表达式模式
     */
    commonPatterns() {
        /**
         * 常用正则表达式工具
         */
        const RegexUtils = {
            // 邮箱验证
            email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
            
            // 手机号验证（中国）
            phone: /^1[3-9]\d{9}$/,
            
            // URL验证
            url: /^https?:\/\/([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/,
            
            // 身份证号验证（简单版）
            idCard: /^[1-9]\d{5}(19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}[\dXx]$/,
            
            /**
             * 验证邮箱
             * @param {string} email - 邮箱地址
             */
            validateEmail(email) {
                return this.email.test(email);
            },
            
            /**
             * 验证手机号
             * @param {string} phone - 手机号
             */
            validatePhone(phone) {
                return this.phone.test(phone);
            },
            
            /**
             * 提取文本中的所有数字
             * @param {string} text - 文本
             */
            extractNumbers(text) {
                return text.match(/\d+/g) || [];
            },
            
            /**
             * 驼峰转下划线
             * @param {string} str - 驼峰字符串
             */
            camelToSnake(str) {
                return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
            }
        };
        
        console.log('=== 实用正则模式 ===');
        console.log('邮箱验证:', RegexUtils.validateEmail('test@example.com'));
        console.log('手机验证:', RegexUtils.validatePhone('13812345678'));
        console.log('提取数字:', RegexUtils.extractNumbers('价格是99.9元，折扣20%'));
        console.log('驼峰转下划线:', RegexUtils.camelToSnake('myVariableName'));
    }
};

RegExpExamples.creation();
RegExpExamples.methods();
RegExpExamples.commonPatterns();
```

---

## 5.3 栈与堆

### 内存分配模式

JavaScript使用两种内存区域存储数据：栈（Stack）和堆（Heap），了解它们的区别有助于理解数据类型的行为：

```
JavaScript内存模型
├── 栈内存 (Stack Memory)
│   ├── 基本类型值
│   ├── 引用地址
│   └── 执行上下文
└── 堆内存 (Heap Memory)
    ├── 对象实例
    ├── 数组实例
    └── 函数实例
```

### 基本类型的栈存储

基本类型直接存储在栈内存中，具有以下特点：

```javascript
/**
 * 栈内存中基本类型的行为
 */
function demonstrateStackBehavior() {
    console.log('=== 栈内存：基本类型 ===');
    
    // 基本类型存储在栈中
    let a = 10;
    let b = a;          // 值复制
    
    console.log('初始值 - a:', a, 'b:', b);
    
    // 修改b不影响a
    b = 20;
    console.log('修改b后 - a:', a, 'b:', b); // a: 10, b: 20
    
    /**
     * 函数参数传递（值传递）
     * @param {number} num - 数值参数
     */
    function modifyNumber(num) {
        num = 999;
        console.log('函数内部 num:', num);
    }
    
    let originalNum = 100;
    modifyNumber(originalNum);
    console.log('函数外部 originalNum:', originalNum); // 100 (未被修改)
    
    /**
     * 栈内存的特点演示
     */
    console.log('=== 栈内存特点 ===');
    console.log('1. 存储基本类型值');
    console.log('2. 变量直接访问值');
    console.log('3. 值复制，互不影响');
    console.log('4. 内存回收自动，速度快');
}

demonstrateStackBehavior();
```

### 引用类型的堆存储

引用类型存储在堆内存中，栈中只存储引用地址：

```javascript
/**
 * 堆内存中引用类型的行为
 */
function demonstrateHeapBehavior() {
    console.log('=== 堆内存：引用类型 ===');
    
    // 引用类型存储在堆中，变量存储引用地址
    let obj1 = { name: 'Alice', age: 25 };
    let obj2 = obj1;    // 引用复制，指向同一个对象
    
    console.log('初始状态:');
    console.log('obj1:', obj1);
    console.log('obj2:', obj2);
    console.log('obj1 === obj2:', obj1 === obj2); // true
    
    // 修改obj2会影响obj1（指向同一对象）
    obj2.name = 'Bob';
    console.log('修改obj2.name后:');
    console.log('obj1.name:', obj1.name); // 'Bob'
    console.log('obj2.name:', obj2.name); // 'Bob'
    
    // 重新赋值obj2不影响obj1
    obj2 = { name: 'Charlie', age: 30 };
    console.log('重新赋值obj2后:');
    console.log('obj1:', obj1); // { name: 'Bob', age: 25 }
    console.log('obj2:', obj2); // { name: 'Charlie', age: 30 }
    console.log('obj1 === obj2:', obj1 === obj2); // false
}

demonstrateHeapBehavior();

/**
 * 深拷贝 vs 浅拷贝
 */
const CopyExamples = {
    /**
     * 浅拷贝演示
     */
    shallowCopy() {
        console.log('=== 浅拷贝 ===');
        
        const original = {
            name: 'John',
            age: 30,
            address: {
                city: 'Beijing',
                country: 'China'
            },
            hobbies: ['reading', 'gaming']
        };
        
        // 浅拷贝方法
        const copy1 = Object.assign({}, original);
        const copy2 = { ...original };
        
        console.log('原对象:', original);
        console.log('浅拷贝1:', copy1);
        console.log('浅拷贝2:', copy2);
        
        // 修改第一层属性
        copy1.name = 'Alice';
        console.log('修改copy1.name后:');
        console.log('original.name:', original.name); // 'John' (未受影响)
        console.log('copy1.name:', copy1.name);       // 'Alice'
        
        // 修改嵌套对象
        copy2.address.city = 'Shanghai';
        console.log('修改copy2.address.city后:');
        console.log('original.address.city:', original.address.city); // 'Shanghai' (被影响)
        console.log('copy2.address.city:', copy2.address.city);       // 'Shanghai'
    },
    
    /**
     * 深拷贝演示
     */
    deepCopy() {
        console.log('=== 深拷贝 ===');
        
        const original = {
            name: 'John',
            age: 30,
            address: {
                city: 'Beijing',
                country: 'China'
            },
            hobbies: ['reading', 'gaming'],
            createdAt: new Date('2023-01-01')
        };
        
        /**
         * 简单深拷贝（JSON方法，有限制）
         */
        const jsonCopy = JSON.parse(JSON.stringify(original));
        
        /**
         * 手动实现深拷贝
         * @param {*} obj - 要拷贝的对象
         * @returns {*} 深拷贝后的对象
         */
        function deepClone(obj) {
            if (obj === null || typeof obj !== 'object') {
                return obj;
            }
            
            if (obj instanceof Date) {
                return new Date(obj.getTime());
            }
            
            if (obj instanceof Array) {
                return obj.map(item => deepClone(item));
            }
            
            if (typeof obj === 'object') {
                const cloned = {};
                Object.keys(obj).forEach(key => {
                    cloned[key] = deepClone(obj[key]);
                });
                return cloned;
            }
        }
        
        const manualCopy = deepClone(original);
        
        console.log('原对象:', original);
        console.log('JSON深拷贝:', jsonCopy);
        console.log('手动深拷贝:', manualCopy);
        
        // 修改嵌套对象测试
        manualCopy.address.city = 'Guangzhou';
        manualCopy.hobbies.push('swimming');
        
        console.log('修改深拷贝对象后:');
        console.log('original.address.city:', original.address.city); // 'Beijing' (未受影响)
        console.log('manualCopy.address.city:', manualCopy.address.city); // 'Guangzhou'
        console.log('original.hobbies:', original.hobbies); // ['reading', 'gaming']
        console.log('manualCopy.hobbies:', manualCopy.hobbies); // ['reading', 'gaming', 'swimming']
    }
};

CopyExamples.shallowCopy();
CopyExamples.deepCopy();
```

### 内存管理与垃圾回收

JavaScript自动管理内存，但了解垃圾回收机制有助于编写高效代码：

```javascript
/**
 * 内存管理和垃圾回收示例
 */
const MemoryManagement = {
    /**
     * 内存泄漏的常见情况
     */
    memoryLeaks() {
        console.log('=== 内存泄漏示例 ===');
        
        // 1. 全局变量（不会被回收）
        window.globalLeak = {
            data: new Array(1000000).fill('memory leak')
        };
        
        // 2. 闭包引用（可能造成内存泄漏）
        function createClosure() {
            const largeData = new Array(1000000).fill('large data');
            
            return function() {
                // 即使不使用largeData，闭包也会保持对它的引用
                console.log('closure function');
            };
        }
        
        const closureFunction = createClosure();
        
        // 3. 定时器未清除
        const timerId = setInterval(() => {
            console.log('timer running');
        }, 1000);
        
        // ❌ 忘记清除定时器会造成内存泄漏
        // clearInterval(timerId);
        
        // 4. DOM引用未清除
        const element = document.createElement('div');
        element.innerHTML = 'test element';
        
        const elementRef = element; // 保持对已删除DOM的引用
        // 即使element被从DOM中删除，elementRef仍然引用它
        
        console.log('创建了可能的内存泄漏');
    },
    
    /**
     * 避免内存泄漏的最佳实践
     */
    bestPractices() {
        console.log('=== 内存管理最佳实践 ===');
        
        /**
         * 1. 及时清除引用
         */
        function properResourceManagement() {
            let largeObject = {
                data: new Array(1000000).fill('data')
            };
            
            // 使用完毕后清除引用
            largeObject = null;
        }
        
        /**
         * 2. 使用WeakMap和WeakSet
         */
        function useWeakReferences() {
            const weakMap = new WeakMap();
            const weakSet = new WeakSet();
            
            let obj = { name: 'test' };
            
            // WeakMap和WeakSet不会阻止垃圾回收
            weakMap.set(obj, 'some data');
            weakSet.add(obj);
            
            // 当obj被清除时，WeakMap和WeakSet中的引用也会被自动清除
            obj = null;
        }
        
        /**
         * 3. 清理定时器和事件监听器
         */
        function properCleanup() {
            const timerId = setTimeout(() => {
                console.log('timer executed');
            }, 1000);
            
            const element = document.createElement('button');
            const handler = () => console.log('clicked');
            
            element.addEventListener('click', handler);
            
            // 清理函数
            function cleanup() {
                clearTimeout(timerId);
                element.removeEventListener('click', handler);
            }
            
            // 在适当的时候调用cleanup
            return cleanup;
        }
        
        /**
         * 4. 监控内存使用
         */
        function monitorMemory() {
            if (performance.memory) {
                const memInfo = performance.memory;
                console.log('JavaScript内存使用情况:');
                console.log('已使用:', (memInfo.usedJSHeapSize / 1024 / 1024).toFixed(2), 'MB');
                console.log('总分配:', (memInfo.totalJSHeapSize / 1024 / 1024).toFixed(2), 'MB');
                console.log('限制:', (memInfo.jsHeapSizeLimit / 1024 / 1024).toFixed(2), 'MB');
            }
        }
        
        properResourceManagement();
        useWeakReferences();
        const cleanup = properCleanup();
        monitorMemory();
        
        // 在需要时调用清理函数
        setTimeout(cleanup, 2000);
    },
    
    /**
     * 垃圾回收机制说明
     */
    garbageCollectionExplanation() {
        console.log('=== 垃圾回收机制 ===');
        console.log('JavaScript垃圾回收算法:');
        console.log('1. 标记清除 (Mark and Sweep) - 主要算法');
        console.log('2. 引用计数 (Reference Counting) - 辅助算法');
        console.log('3. 分代回收 (Generational Collection)');
        console.log('   - 新生代: 存活时间短的对象');
        console.log('   - 老生代: 存活时间长的对象');
        
        /**
         * 演示对象生命周期
         */
        function objectLifecycle() {
            // 对象创建（分配内存）
            const obj = {
                name: 'lifecycle demo',
                data: new Array(1000).fill('data')
            };
            
            // 对象使用
            console.log('对象创建并使用:', obj.name);
            
            // 对象不再被引用（可被垃圾回收）
            return null; // obj将在函数结束后被回收
        }
        
        objectLifecycle();
        
        // 强制垃圾回收（仅在开发环境中可用）
        if (window.gc) {
            window.gc();
            console.log('手动触发垃圾回收');
        }
    }
};

// MemoryManagement.memoryLeaks(); // 注释掉以避免实际内存泄漏
MemoryManagement.bestPractices();
MemoryManagement.garbageCollectionExplanation();
```

---

## 5.4 类型判断：typeof、instanceof

### typeof 操作符

`typeof` 是JavaScript中最基本的类型判断操作符，用于判断变量的数据类型：

#### 1. typeof 的基本用法

```javascript
/**
 * typeof操作符的基本使用
 */
function demonstrateTypeof() {
    console.log('=== typeof 操作符 ===');
    
    // 基本类型
    console.log('typeof undefined:', typeof undefined);     // "undefined"
    console.log('typeof true:', typeof true);               // "boolean"
    console.log('typeof 42:', typeof 42);                   // "number"
    console.log('typeof "hello":', typeof "hello");         // "string"
    console.log('typeof Symbol():', typeof Symbol());       // "symbol"
    console.log('typeof 123n:', typeof 123n);               // "bigint"
    
    // 引用类型
    console.log('typeof {}:', typeof {});                   // "object"
    console.log('typeof []:', typeof []);                   // "object"
    console.log('typeof null:', typeof null);               // "object" (历史遗留bug)
    console.log('typeof function(){}:', typeof function(){}); // "function"
    console.log('typeof new Date():', typeof new Date());   // "object"
    console.log('typeof /regex/:', typeof /regex/);         // "object"
}

demonstrateTypeof();

/**
 * typeof的特殊情况和陷阱
 */
const TypeofTraps = {
    /**
     * null的typeof问题
     */
    nullProblem() {
        console.log('=== typeof null 问题 ===');
        console.log('typeof null:', typeof null); // "object" (错误的结果)
        
        // 正确判断null的方法
        const value = null;
        console.log('value === null:', value === null);           // true
        console.log('!value && typeof value === "object":', 
                   !value && typeof value === "object");          // true
    },
    
    /**
     * 数组的typeof问题
     */
    arrayProblem() {
        console.log('=== 数组判断问题 ===');
        const arr = [1, 2, 3];
        console.log('typeof arr:', typeof arr); // "object"
        
        // 正确判断数组的方法
        console.log('Array.isArray(arr):', Array.isArray(arr));           // true
        console.log('arr instanceof Array:', arr instanceof Array);       // true
        console.log('arr.constructor === Array:', arr.constructor === Array); // true
        console.log('Object.prototype.toString.call(arr):', 
                   Object.prototype.toString.call(arr)); // "[object Array]"
    },
    
    /**
     * 未声明变量的typeof
     */
    undeclaredVariable() {
        console.log('=== 未声明变量 ===');
        
        // typeof对未声明变量不会抛出错误
        console.log('typeof undeclaredVar:', typeof undeclaredVar); // "undefined"
        
        // 直接访问会抛出ReferenceError
        try {
            console.log(undeclaredVar);
        } catch (error) {
            console.log('直接访问未声明变量会报错:', error.name);
        }
    }
};

TypeofTraps.nullProblem();
TypeofTraps.arrayProblem();
TypeofTraps.undeclaredVariable();
```

#### 2. typeof 的应用场景

```javascript
/**
 * typeof的实际应用
 */
const TypeofApplications = {
    /**
     * 参数验证
     * @param {Function} callback - 回调函数
     * @param {number} delay - 延迟时间
     */
    validateParameters(callback, delay) {
        if (typeof callback !== 'function') {
            throw new TypeError('callback must be a function');
        }
        
        if (typeof delay !== 'number') {
            throw new TypeError('delay must be a number');
        }
        
        setTimeout(callback, delay);
    },
    
    /**
     * 功能检测
     */
    featureDetection() {
        console.log('=== 功能检测 ===');
        
        // 检测localStorage是否可用
        const hasLocalStorage = typeof Storage !== 'undefined' && 
                              typeof localStorage !== 'undefined';
        console.log('localStorage可用:', hasLocalStorage);
        
        // 检测Promise是否支持
        const hasPromise = typeof Promise !== 'undefined';
        console.log('Promise支持:', hasPromise);
        
        // 检测箭头函数支持（间接检测）
        let hasArrowFunction = false;
        try {
            eval('(() => {})');
            hasArrowFunction = true;
        } catch (e) {
            hasArrowFunction = false;
        }
        console.log('箭头函数支持:', hasArrowFunction);
    },
    
    /**
     * 安全的属性访问
     * @param {Object} obj - 对象
     * @param {string} prop - 属性名
     */
    safePropertyAccess(obj, prop) {
        if (typeof obj !== 'object' || obj === null) {
            return undefined;
        }
        
        return typeof obj[prop] !== 'undefined' ? obj[prop] : undefined;
    }
};

// TypeofApplications.validateParameters(() => console.log('test'), 1000);
TypeofApplications.featureDetection();
console.log('安全访问:', TypeofApplications.safePropertyAccess({name: 'test'}, 'name'));
```

### instanceof 操作符

`instanceof` 用于检测对象是否为特定构造函数的实例：

#### 1. instanceof 的基本原理

```javascript
/**
 * instanceof操作符详解
 */
function demonstrateInstanceof() {
    console.log('=== instanceof 基本用法 ===');
    
    // 基本用法
    const arr = [1, 2, 3];
    const obj = { name: 'test' };
    const date = new Date();
    const regex = /pattern/;
    
    console.log('arr instanceof Array:', arr instanceof Array);         // true
    console.log('arr instanceof Object:', arr instanceof Object);       // true
    console.log('obj instanceof Object:', obj instanceof Object);       // true
    console.log('date instanceof Date:', date instanceof Date);         // true
    console.log('date instanceof Object:', date instanceof Object);     // true
    console.log('regex instanceof RegExp:', regex instanceof RegExp);   // true
    
    // 自定义构造函数
    function Person(name) {
        this.name = name;
    }
    
    const person = new Person('Alice');
    console.log('person instanceof Person:', person instanceof Person); // true
    console.log('person instanceof Object:', person instanceof Object); // true
    
    /**
     * instanceof的工作原理
     */
    console.log('=== instanceof 原理 ===');
    
    // instanceof检查原型链
    console.log('Array.prototype:', Array.prototype);
    console.log('Object.prototype:', Object.prototype);
    console.log('arr.__proto__ === Array.prototype:', arr.__proto__ === Array.prototype);
    console.log('arr.__proto__.__proto__ === Object.prototype:', 
               arr.__proto__.__proto__ === Object.prototype);
}

demonstrateInstanceof();

/**
 * 手动实现instanceof
 * @param {*} left - 要检测的对象
 * @param {Function} right - 构造函数
 * @returns {boolean} 是否为实例
 */
function myInstanceof(left, right) {
    // 基本类型直接返回false
    if (typeof left !== 'object' || left === null) {
        return false;
    }
    
    // 获取构造函数的prototype
    const prototype = right.prototype;
    
    // 获取对象的原型
    let proto = Object.getPrototypeOf(left);
    
    // 沿着原型链查找
    while (proto !== null) {
        if (proto === prototype) {
            return true;
        }
        proto = Object.getPrototypeOf(proto);
    }
    
    return false;
}

// 测试自定义instanceof
console.log('=== 自定义instanceof测试 ===');
const testArr = [1, 2, 3];
console.log('myInstanceof(testArr, Array):', myInstanceof(testArr, Array));
console.log('myInstanceof(testArr, Object):', myInstanceof(testArr, Object));
console.log('myInstanceof("string", String):', myInstanceof("string", String));
```

#### 2. instanceof 的陷阱和限制

```javascript
/**
 * instanceof的局限性
 */
const InstanceofLimitations = {
    /**
     * 基本类型包装对象问题
     */
    wrapperObjects() {
        console.log('=== 基本类型包装对象 ===');
        
        const str1 = 'hello';
        const str2 = new String('hello');
        const num1 = 42;
        const num2 = new Number(42);
        
        console.log('str1 instanceof String:', str1 instanceof String);   // false
        console.log('str2 instanceof String:', str2 instanceof String);   // true
        console.log('num1 instanceof Number:', num1 instanceof Number);   // false
        console.log('num2 instanceof Number:', num2 instanceof Number);   // true
        
        // typeof vs instanceof
        console.log('typeof str1:', typeof str1); // "string"
        console.log('typeof str2:', typeof str2); // "object"
    },
    
    /**
     * 跨frame/iframe问题
     */
    crossFrameIssue() {
        console.log('=== 跨frame问题 ===');
        
        // 在不同的执行上下文中，Array构造函数可能不同
        // 这里模拟这种情况
        const fakeArray = {
            length: 0,
            push: Array.prototype.push,
            pop: Array.prototype.pop
        };
        
        // 设置假的原型链
        Object.setPrototypeOf(fakeArray, Array.prototype);
        
        console.log('fakeArray instanceof Array:', fakeArray instanceof Array); // true
        console.log('Array.isArray(fakeArray):', Array.isArray(fakeArray));     // false
    },
    
    /**
     * 原型链被修改的情况
     */
    modifiedPrototypeChain() {
        console.log('=== 原型链修改问题 ===');
        
        function MyClass() {}
        const instance = new MyClass();
        
        console.log('修改前 instanceof:', instance instanceof MyClass); // true
        
        // 修改原型链
        MyClass.prototype = {};
        
        console.log('修改后 instanceof:', instance instanceof MyClass); // false
        
        // 但对象本身没有改变
        console.log('对象类型:', Object.prototype.toString.call(instance));
    }
};

InstanceofLimitations.wrapperObjects();
InstanceofLimitations.crossFrameIssue();
InstanceofLimitations.modifiedPrototypeChain();
```

### 其他类型判断方法

除了 `typeof` 和 `instanceof`，还有其他更精确的类型判断方法：

```javascript
/**
 * 其他类型判断方法
 */
const AlternativeTypeMethods = {
    /**
     * Object.prototype.toString 方法
     */
    objectToString() {
        console.log('=== Object.prototype.toString ===');
        
        const toString = Object.prototype.toString;
        
        // 各种类型的toString结果
        console.log('toString.call(undefined):', toString.call(undefined)); // "[object Undefined]"
        console.log('toString.call(null):', toString.call(null));           // "[object Null]"
        console.log('toString.call(true):', toString.call(true));           // "[object Boolean]"
        console.log('toString.call(42):', toString.call(42));               // "[object Number]"
        console.log('toString.call("str"):', toString.call("str"));         // "[object String]"
        console.log('toString.call(Symbol()):', toString.call(Symbol()));   // "[object Symbol]"
        console.log('toString.call(123n):', toString.call(123n));           // "[object BigInt]"
        console.log('toString.call({}):', toString.call({}));               // "[object Object]"
        console.log('toString.call([]):', toString.call([]));               // "[object Array]"
        console.log('toString.call(function(){}):', toString.call(function(){})); // "[object Function]"
        console.log('toString.call(new Date()):', toString.call(new Date())); // "[object Date]"
        console.log('toString.call(/regex/):', toString.call(/regex/));      // "[object RegExp]"
    },
    
    /**
     * constructor 属性
     */
    constructorProperty() {
        console.log('=== constructor 属性 ===');
        
        const arr = [1, 2, 3];
        const obj = { name: 'test' };
        const str = 'hello';
        
        console.log('arr.constructor === Array:', arr.constructor === Array);
        console.log('obj.constructor === Object:', obj.constructor === Object);
        console.log('str.constructor === String:', str.constructor === String);
        
        // constructor可能被修改，不够可靠
        arr.constructor = Object;
        console.log('修改后 arr.constructor === Array:', arr.constructor === Array); // false
        console.log('但 Array.isArray(arr):', Array.isArray(arr)); // true
    },
    
    /**
     * 特定类型的内置判断方法
     */
    builtinMethods() {
        console.log('=== 内置判断方法 ===');
        
        // 数组判断
        console.log('Array.isArray([]):', Array.isArray([]));               // true
        console.log('Array.isArray("not array"):', Array.isArray("not array")); // false
        
        // NaN判断
        console.log('Number.isNaN(NaN):', Number.isNaN(NaN));               // true
        console.log('Number.isNaN("NaN"):', Number.isNaN("NaN"));           // false
        console.log('isNaN("NaN"):', isNaN("NaN"));                         // true (会转换)
        
        // 有限数判断
        console.log('Number.isFinite(42):', Number.isFinite(42));           // true
        console.log('Number.isFinite(Infinity):', Number.isFinite(Infinity)); // false
        console.log('Number.isFinite("42"):', Number.isFinite("42"));       // false
        console.log('isFinite("42"):', isFinite("42"));                     // true (会转换)
        
        // 整数判断
        console.log('Number.isInteger(42):', Number.isInteger(42));         // true
        console.log('Number.isInteger(42.0):', Number.isInteger(42.0));     // true
        console.log('Number.isInteger(42.1):', Number.isInteger(42.1));     // false
    }
};

AlternativeTypeMethods.objectToString();
AlternativeTypeMethods.constructorProperty();
AlternativeTypeMethods.builtinMethods();
```

### 准确的类型判断工具函数

基于以上方法，我们可以创建一套完整的类型判断工具：

```javascript
/**
 * 完整的类型判断工具库
 */
const TypeChecker = {
    /**
     * 获取精确的数据类型
     * @param {*} value - 要检测的值
     * @returns {string} 类型名称
     */
    getType(value) {
        const type = Object.prototype.toString.call(value);
        return type.slice(8, -1).toLowerCase();
    },
    
    /**
     * 基本类型判断方法
     */
    isUndefined(value) { return value === undefined; },
    isNull(value) { return value === null; },
    isBoolean(value) { return typeof value === 'boolean'; },
    isNumber(value) { return typeof value === 'number' && !isNaN(value); },
    isString(value) { return typeof value === 'string'; },
    isSymbol(value) { return typeof value === 'symbol'; },
    isBigInt(value) { return typeof value === 'bigint'; },
    
    /**
     * 引用类型判断方法
     */
    isObject(value) { 
        return value !== null && typeof value === 'object' && !Array.isArray(value); 
    },
    isArray(value) { return Array.isArray(value); },
    isFunction(value) { return typeof value === 'function'; },
    isDate(value) { return value instanceof Date && !isNaN(value.getTime()); },
    isRegExp(value) { return value instanceof RegExp; },
    
    /**
     * 特殊值判断
     */
    isNaN(value) { return Number.isNaN(value); },
    isFinite(value) { return Number.isFinite(value); },
    isInteger(value) { return Number.isInteger(value); },
    
    /**
     * 复合类型判断
     */
    isPrimitive(value) {
        return value === null || 
               typeof value === 'undefined' ||
               typeof value === 'boolean' ||
               typeof value === 'number' ||
               typeof value === 'string' ||
               typeof value === 'symbol' ||
               typeof value === 'bigint';
    },
    
    isReference(value) {
        return !this.isPrimitive(value);
    },
    
    isEmpty(value) {
        if (this.isNull(value) || this.isUndefined(value)) return true;
        if (this.isString(value) || this.isArray(value)) return value.length === 0;
        if (this.isObject(value)) return Object.keys(value).length === 0;
        return false;
    },
    
    /**
     * 类型兼容性判断
     * @param {*} value - 要检测的值
     * @param {string|Array} expectedTypes - 期望的类型
     * @returns {boolean} 是否匹配
     */
    isType(value, expectedTypes) {
        const actualType = this.getType(value);
        const types = Array.isArray(expectedTypes) ? expectedTypes : [expectedTypes];
        return types.some(type => type.toLowerCase() === actualType);
    },
    
    /**
     * 深度类型检测
     * @param {*} value - 要检测的值
     * @returns {Object} 详细的类型信息
     */
    deepTypeCheck(value) {
        const result = {
            value: value,
            type: this.getType(value),
            isPrimitive: this.isPrimitive(value),
            isReference: this.isReference(value),
            isEmpty: this.isEmpty(value),
            constructor: value?.constructor?.name || null,
            proto: value?.__proto__?.constructor?.name || null
        };
        
        // 针对特定类型添加额外信息
        if (this.isNumber(value)) {
            result.isInteger = this.isInteger(value);
            result.isFinite = this.isFinite(value);
        }
        
        if (this.isArray(value)) {
            result.length = value.length;
        }
        
        if (this.isObject(value)) {
            result.keys = Object.keys(value);
            result.propertyCount = Object.keys(value).length;
        }
        
        return result;
    }
};

/**
 * 类型判断工具使用示例
 */
function demonstrateTypeChecker() {
    console.log('=== 类型判断工具测试 ===');
    
    const testValues = [
        undefined,
        null,
        true,
        42,
        'hello',
        Symbol('test'),
        123n,
        {},
        [],
        function(){},
        new Date(),
        /regex/,
        NaN,
        Infinity
    ];
    
    testValues.forEach(value => {
        console.log(`值: ${value}, 类型: ${TypeChecker.getType(value)}`);
    });
    
    // 深度类型检测示例
    console.log('=== 深度类型检测 ===');
    const complexObj = {
        name: 'test',
        items: [1, 2, 3],
        nested: { prop: 'value' }
    };
    
    console.log('复杂对象类型信息:', TypeChecker.deepTypeCheck(complexObj));
    
    // 类型匹配测试
    console.log('=== 类型匹配测试 ===');
    console.log('42 是 number:', TypeChecker.isType(42, 'number'));
    console.log('[1,2,3] 是 array 或 object:', TypeChecker.isType([1,2,3], ['array', 'object']));
}

demonstrateTypeChecker();

/**
 * 实际应用：参数验证装饰器
 * @param  {...string} expectedTypes - 期望的参数类型
 */
function validateParams(...expectedTypes) {
    return function(target, propertyName, descriptor) {
        const method = descriptor.value;
        
        descriptor.value = function(...args) {
            // 验证参数数量
            if (args.length < expectedTypes.length) {
                throw new Error(`Expected ${expectedTypes.length} arguments, got ${args.length}`);
            }
            
            // 验证参数类型
            expectedTypes.forEach((expectedType, index) => {
                const actualType = TypeChecker.getType(args[index]);
                if (actualType !== expectedType.toLowerCase()) {
                    throw new TypeError(
                        `Argument ${index + 1} expected ${expectedType}, got ${actualType}`
                    );
                }
            });
            
            return method.apply(this, args);
        };
        
        return descriptor;
    };
}

// 使用示例（装饰器需要在支持的环境中使用）
class Calculator {
    /**
     * 加法运算（带类型验证）
     * @param {number} a - 第一个数
     * @param {number} b - 第二个数
     * @returns {number} 和
     */
    add(a, b) {
        // 手动类型验证示例
        if (!TypeChecker.isNumber(a) || !TypeChecker.isNumber(b)) {
            throw new TypeError('Both arguments must be numbers');
        }
        return a + b;
    }
}

const calc = new Calculator();
console.log('=== 计算器测试 ===');
console.log('calc.add(5, 3):', calc.add(5, 3));

try {
    calc.add('5', 3);
} catch (error) {
    console.log('类型错误捕获:', error.message);
}
```

---

## 5.5 类型转换（隐式与显式）

### 隐式类型转换

JavaScript会在特定情况下自动执行类型转换，这被称为隐式类型转换或强制类型转换：

#### 1. 字符串转换

```javascript
/**
 * 字符串隐式转换示例
 */
function stringConversion() {
    console.log('=== 字符串隐式转换 ===');
    
    // + 操作符遇到字符串时会进行字符串拼接
    console.log('数字 + 字符串:', 42 + ''); // '42'
    console.log('布尔 + 字符串:', true + ''); // 'true'
    console.log('null + 字符串:', null + ''); // 'null'
    console.log('undefined + 字符串:', undefined + ''); // 'undefined'
    console.log('对象 + 字符串:', {} + ''); // '[object Object]'
    console.log('数组 + 字符串:', [1,2,3] + ''); // '1,2,3'
    
    // 模板字符串中的转换
    const age = 25;
    const name = 'Alice';
    console.log(`姓名: ${name}, 年龄: ${age}`); // 自动转换为字符串
    
    // 字符串拼接的优先级
    console.log('=== 字符串拼接优先级 ===');
    console.log(1 + 2 + '3'); // '33' (先计算1+2=3，再与'3'拼接)
    console.log('1' + 2 + 3); // '123' (从左到右，都是字符串拼接)
    console.log(1 + '2' + 3); // '123'
}

stringConversion();
```

#### 2. 数值转换

```javascript
/**
 * 数值隐式转换示例
 */
function numericConversion() {
    console.log('=== 数值隐式转换 ===');
    
    // 算术操作符会触发数值转换（除了+在有字符串时）
    console.log('字符串数字运算:');
    console.log('5' - 3); // 2
    console.log('5' * 2); // 10
    console.log('10' / 2); // 5
    console.log('10' % 3); // 1
    
    // 一元+操作符强制转换为数字
    console.log('一元+操作符:');
    console.log(+'42'); // 42
    console.log(+'3.14'); // 3.14
    console.log(+'hello'); // NaN
    console.log(+true); // 1
    console.log(+false); // 0
    console.log(+null); // 0
    console.log(+undefined); // NaN
    console.log(+[]); // 0
    console.log(+[1]); // 1
    console.log(+[1,2]); // NaN
    
    // 比较操作符的数值转换
    console.log('比较操作符:');
    console.log('10' > 5); // true (字符串'10'转换为数字10)
    console.log('2' > '10'); // true (字符串按字典序比较，不转换)
    console.log('2' > 10); // false ('2'转换为数字2)
}

numericConversion();
```

#### 3. 布尔转换

```javascript
/**
 * 布尔隐式转换示例
 */
function booleanConversion() {
    console.log('=== 布尔隐式转换 ===');
    
    // 假值 (falsy values)
    const falsyValues = [false, 0, -0, 0n, '', null, undefined, NaN];
    
    console.log('假值转换:');
    falsyValues.forEach(value => {
        console.log(`${JSON.stringify(value)} -> ${Boolean(value)}`);
    });
    
    // 真值 (truthy values) - 除了假值外的所有值
    const truthyValues = [true, 1, -1, 'hello', ' ', [], {}, function(){}];
    
    console.log('真值转换:');
    truthyValues.forEach(value => {
        const strValue = typeof value === 'function' ? 'function(){}' : 
                        typeof value === 'object' ? JSON.stringify(value) : value;
        console.log(`${strValue} -> ${Boolean(value)}`);
    });
    
    // 在条件语句中的转换
    console.log('=== 条件语句中的转换 ===');
    if (1) console.log('1 是真值');
    if (0) console.log('这不会执行');
    if ('') console.log('这不会执行');
    if ('0') console.log('"0" 是真值'); // 注意：字符串'0'是真值
    if ([]) console.log('空数组是真值');
    if ({}) console.log('空对象是真值');
}

booleanConversion();
```

### 显式类型转换

显式类型转换是程序员主动执行的类型转换，更可控和可预测：

```javascript
/**
 * 显式类型转换方法
 */
const ExplicitConversion = {
    /**
     * 转换为字符串
     */
    toString() {
        console.log('=== 显式转换为字符串 ===');
        
        // String() 函数
        console.log('String() 函数:');
        console.log('String(42):', String(42)); // '42'
        console.log('String(true):', String(true)); // 'true'
        console.log('String(null):', String(null)); // 'null'
        console.log('String(undefined):', String(undefined)); // 'undefined'
        console.log('String([1,2,3]):', String([1,2,3])); // '1,2,3'
        console.log('String({}):', String({})); // '[object Object]'
        
        // toString() 方法
        console.log('toString() 方法:');
        console.log('(42).toString():', (42).toString()); // '42'
        console.log('true.toString():', true.toString()); // 'true'
        console.log('[1,2,3].toString():', [1,2,3].toString()); // '1,2,3'
        
        // 进制转换
        console.log('进制转换:');
        console.log('(15).toString(16):', (15).toString(16)); // 'f' (十六进制)
        console.log('(15).toString(2):', (15).toString(2)); // '1111' (二进制)
        console.log('(15).toString(8):', (15).toString(8)); // '17' (八进制)
        
        // JSON.stringify()
        console.log('JSON.stringify():');
        const obj = {name: 'Alice', age: 25};
        console.log('JSON.stringify(obj):', JSON.stringify(obj));
    },
    
    /**
     * 转换为数字
     */
    toNumber() {
        console.log('=== 显式转换为数字 ===');
        
        // Number() 函数
        console.log('Number() 函数:');
        console.log('Number("42"):', Number("42")); // 42
        console.log('Number("3.14"):', Number("3.14")); // 3.14
        console.log('Number(""):', Number("")); // 0
        console.log('Number(" "):', Number(" ")); // 0
        console.log('Number("hello"):', Number("hello")); // NaN
        console.log('Number(true):', Number(true)); // 1
        console.log('Number(false):', Number(false)); // 0
        console.log('Number(null):', Number(null)); // 0
        console.log('Number(undefined):', Number(undefined)); // NaN
        
        // parseInt() 和 parseFloat()
        console.log('parseInt() 和 parseFloat():');
        console.log('parseInt("42px"):', parseInt("42px")); // 42
        console.log('parseInt("3.14"):', parseInt("3.14")); // 3
        console.log('parseFloat("3.14px"):', parseFloat("3.14px")); // 3.14
        console.log('parseInt("ff", 16):', parseInt("ff", 16)); // 255
        console.log('parseInt("1010", 2):', parseInt("1010", 2)); // 10
        
        // 数学方法
        console.log('数学方法:');
        console.log('Math.floor(3.9):', Math.floor(3.9)); // 3
        console.log('Math.ceil(3.1):', Math.ceil(3.1)); // 4
        console.log('Math.round(3.5):', Math.round(3.5)); // 4
        console.log('Math.trunc(3.9):', Math.trunc(3.9)); // 3
    },
    
    /**
     * 转换为布尔值
     */
    toBoolean() {
        console.log('=== 显式转换为布尔值 ===');
        
        // Boolean() 函数
        console.log('Boolean() 函数:');
        const values = [0, 1, '', 'hello', null, undefined, [], {}];
        values.forEach(value => {
            const strValue = typeof value === 'object' ? JSON.stringify(value) : 
                           typeof value === 'string' ? `"${value}"` : value;
            console.log(`Boolean(${strValue}):`, Boolean(value));
        });
        
        // !! 双重否定
        console.log('!! 双重否定:');
        console.log('!!"hello":', !!"hello"); // true
        console.log('!!0:', !!0); // false
        console.log('!![]:', !![]); // true
    }
};

ExplicitConversion.toString();
ExplicitConversion.toNumber();
ExplicitConversion.toBoolean();
```

### 转换规则与机制

JavaScript类型转换遵循特定的规则和算法：

```javascript
/**
 * 类型转换的内部机制
 */
const ConversionMechanism = {
    /**
     * ToPrimitive 转换演示
     */
    toPrimitive() {
        console.log('=== ToPrimitive 转换机制 ===');
        
        // 对象转原始值的步骤：
        // 1. 如果对象有 Symbol.toPrimitive 方法，调用它
        // 2. 否则，如果是字符串上下文，先尝试 toString()，再尝试 valueOf()
        // 3. 否则，先尝试 valueOf()，再尝试 toString()
        
        const obj1 = {
            valueOf() {
                console.log('调用了 valueOf');
                return 42;
            },
            toString() {
                console.log('调用了 toString');
                return 'hello';
            }
        };
        
        console.log('数值上下文 +obj1:', +obj1); // 先调用valueOf()
        console.log('字符串上下文 obj1 + "":', obj1 + ''); // 先调用valueOf()
        console.log('字符串上下文 String(obj1):', String(obj1)); // 先调用toString()
        
        // 使用 Symbol.toPrimitive
        const obj2 = {
            [Symbol.toPrimitive](hint) {
                console.log('Symbol.toPrimitive called with hint:', hint);
                if (hint === 'number') return 42;
                if (hint === 'string') return 'hello';
                return 'default';
            }
        };
        
        console.log('+obj2:', +obj2); // hint: 'number'
        console.log('String(obj2):', String(obj2)); // hint: 'string'
        console.log('obj2 + "":', obj2 + ''); // hint: 'default'
    },
    
    /**
     * 相等性比较的转换规则
     */
    equalityComparison() {
        console.log('=== 相等性比较转换 ===');
        
        // == 操作符的转换规则（复杂）
        console.log('== 操作符:');
        console.log('1 == "1":', 1 == "1"); // true (字符串转数字)
        console.log('1 == true:', 1 == true); // true (布尔转数字)
        console.log('0 == false:', 0 == false); // true
        console.log('null == undefined:', null == undefined); // true
        console.log('0 == null:', 0 == null); // false
        console.log('"" == 0:', "" == 0); // true (空字符串转数字0)
        console.log('[1] == 1:', [1] == 1); // true (数组转原始值)
        
        // === 操作符（严格相等，不转换）
        console.log('=== 操作符:');
        console.log('1 === "1":', 1 === "1"); // false
        console.log('1 === true:', 1 === true); // false
        console.log('null === undefined:', null === undefined); // false
        
        // 特殊情况
        console.log('特殊情况:');
        console.log('[] == ![]:', [] == ![]); // true (复杂的转换过程)
        console.log('[] == 0:', [] == 0); // true
        console.log('[1,2] == "1,2":', [1,2] == "1,2"); // true
    },
    
    /**
     * 算术运算中的转换
     */
    arithmeticConversion() {
        console.log('=== 算术运算转换 ===');
        
        // 加法运算的特殊性
        console.log('加法运算:');
        console.log('1 + 2:', 1 + 2); // 3 (数值相加)
        console.log('"1" + 2:', "1" + 2); // "12" (字符串拼接)
        console.log('1 + "2":', 1 + "2"); // "12" (字符串拼接)
        console.log('true + 1:', true + 1); // 2 (布尔转数字)
        console.log('[] + {}:', [] + {}); // "[object Object]" (都转字符串)
        console.log('{} + []:', {} + []); // 0 (在某些情况下，{}被解析为代码块)
        
        // 其他算术运算（都转换为数字）
        console.log('其他运算:');
        console.log('"5" - 2:', "5" - 2); // 3
        console.log('"5" * 2:', "5" * 2); // 10
        console.log('"10" / "2":', "10" / "2"); // 5
        console.log('true - false:', true - false); // 1
        console.log('null + 1:', null + 1); // 1 (null转为0)
    }
};

ConversionMechanism.toPrimitive();
ConversionMechanism.equalityComparison();
ConversionMechanism.arithmeticConversion();
```

### 常见转换陷阱

了解常见的类型转换陷阱有助于避免Bug：

```javascript
/**
 * 类型转换的常见陷阱和解决方案
 */
const ConversionTraps = {
    /**
     * 数组转换陷阱
     */
    arrayTraps() {
        console.log('=== 数组转换陷阱 ===');
        
        // 空数组的转换
        console.log('+[]:', +[]); // 0
        console.log('[] == 0:', [] == 0); // true
        console.log('[] == "":', [] == ""); // true
        console.log('[] == ![]:', [] == ![]); // true (![]是false，[]转为""，""转为0，false转为0)
        
        // 单元素数组
        console.log('+[5]:', +[5]); // 5
        console.log('[5] == 5:', [5] == 5); // true
        console.log('+["5"]:', +["5"]); // 5
        console.log('["5"] == 5:', ["5"] == 5); // true
        
        // 多元素数组
        console.log('+[1,2]:', +[1,2]); // NaN
        console.log('[1,2] == "1,2":', [1,2] == "1,2"); // true
        
        /**
         * 安全的数组处理
         */
        function safeArrayToNumber(arr) {
            if (!Array.isArray(arr)) return NaN;
            if (arr.length !== 1) return NaN;
            return Number(arr[0]);
        }
        
        console.log('安全转换:');
        console.log('safeArrayToNumber([5]):', safeArrayToNumber([5])); // 5
        console.log('safeArrayToNumber([1,2]):', safeArrayToNumber([1,2])); // NaN
    },
    
    /**
     * 对象转换陷阱
     */
    objectTraps() {
        console.log('=== 对象转换陷阱 ===');
        
        // 普通对象
        console.log('{} + 1:', ({}) + 1); // "[object Object]1"
        console.log('+{}:', +({})); // NaN
        
        // 日期对象的特殊行为
        const date = new Date('2023-01-01');
        console.log('date + 0:', date + 0); // 字符串拼接
        console.log('+date:', +date); // 转换为时间戳
        console.log('date - 0:', date - 0); // 转换为时间戳
        
        // valueOf 和 toString 的优先级问题
        const confusingObj = {
            valueOf() { return 1; },
            toString() { return "2"; }
        };
        
        console.log('confusingObj + "":', confusingObj + ''); // "1" (valueOf优先)
        console.log('String(confusingObj):', String(confusingObj)); // "2" (toString优先)
    },
    
    /**
     * 比较操作陷阱
     */
    comparisonTraps() {
        console.log('=== 比较操作陷阱 ===');
        
        // 字符串vs数字比较
        console.log('"10" > "9":', "10" > "9"); // false (字符串比较)
        console.log('"10" > 9:', "10" > 9); // true (数字比较)
        console.log('10 > "9":', 10 > "9"); // true (数字比较)
        
        // null和undefined的比较
        console.log('null == undefined:', null == undefined); // true
        console.log('null === undefined:', null === undefined); // false
        console.log('null > 0:', null > 0); // false (null转为0)
        console.log('null == 0:', null == 0); // false (特殊规则)
        console.log('null >= 0:', null >= 0); // true (null转为0)
        
        // NaN的比较
        console.log('NaN == NaN:', NaN == NaN); // false
        console.log('NaN === NaN:', NaN === NaN); // false
        console.log('Object.is(NaN, NaN):', Object.is(NaN, NaN)); // true
        
        /**
         * 安全的比较函数
         * @param {*} a - 第一个值
         * @param {*} b - 第二个值
         * @returns {boolean} 是否相等
         */
        function safeEquals(a, b) {
            // 处理NaN
            if (Number.isNaN(a) && Number.isNaN(b)) return true;
            // 严格相等
            return a === b;
        }
        
        console.log('安全比较:');
        console.log('safeEquals(NaN, NaN):', safeEquals(NaN, NaN)); // true
        console.log('safeEquals(1, "1"):', safeEquals(1, "1")); // false
    },
    
    /**
     * 类型转换最佳实践
     */
    bestPractices() {
        console.log('=== 类型转换最佳实践 ===');
        
        /**
         * 推荐的转换方法
         */
        const SafeConversion = {
            /**
             * 安全的字符串转换
             * @param {*} value - 要转换的值
             */
            toString(value) {
                if (value === null || value === undefined) {
                    return String(value); // 'null' 或 'undefined'
                }
                return String(value);
            },
            
            /**
             * 安全的数字转换
             * @param {*} value - 要转换的值
             * @param {number} defaultValue - 默认值
             */
            toNumber(value, defaultValue = 0) {
                if (value === null || value === undefined || value === '') {
                    return defaultValue;
                }
                const num = Number(value);
                return Number.isNaN(num) ? defaultValue : num;
            },
            
            /**
             * 安全的布尔转换
             * @param {*} value - 要转换的值
             */
            toBoolean(value) {
                return Boolean(value);
            },
            
            /**
             * 安全的整数转换
             * @param {*} value - 要转换的值
             * @param {number} defaultValue - 默认值
             */
            toInteger(value, defaultValue = 0) {
                const num = this.toNumber(value, defaultValue);
                return Math.trunc(num);
            }
        };
        
        // 测试安全转换
        console.log('SafeConversion.toString(null):', SafeConversion.toString(null));
        console.log('SafeConversion.toNumber("abc", -1):', SafeConversion.toNumber("abc", -1));
        console.log('SafeConversion.toInteger(3.7):', SafeConversion.toInteger(3.7));
        
        /**
         * 类型检查 + 转换的组合
         * @param {*} value - 要处理的值
         * @param {string} expectedType - 期望类型
         * @param {*} defaultValue - 默认值
         */
        function safeCast(value, expectedType, defaultValue) {
            switch (expectedType) {
                case 'string':
                    return typeof value === 'string' ? value : SafeConversion.toString(value);
                case 'number':
                    return typeof value === 'number' ? value : SafeConversion.toNumber(value, defaultValue);
                case 'boolean':
                    return typeof value === 'boolean' ? value : SafeConversion.toBoolean(value);
                default:
                    return value;
            }
        }
        
        console.log('safeCast("123", "number"):', safeCast("123", "number"));
        console.log('safeCast(null, "string"):', safeCast(null, "string"));
    }
};

ConversionTraps.arrayTraps();
ConversionTraps.objectTraps();
ConversionTraps.comparisonTraps();
ConversionTraps.bestPractices();
```

---

## 5.6 JSON 的本质与应用

### JSON 数据格式

JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，基于JavaScript对象语法但独立于编程语言：

```javascript
/**
 * JSON 数据格式规范
 */
const JSONFormat = {
    /**
     * JSON 基本规则
     */
    basicRules() {
        console.log('=== JSON 基本规则 ===');
        
        // JSON支持的数据类型
        const supportedTypes = {
            // 1. 字符串（必须使用双引号）
            string: "hello world",
            
            // 2. 数字（整数或浮点数）
            number: 42,
            float: 3.14,
            scientific: 1.23e10,
            
            // 3. 布尔值
            boolean: true,
            
            // 4. null
            nullValue: null,
            
            // 5. 对象
            object: {
                name: "Alice",
                age: 25
            },
            
            // 6. 数组
            array: [1, 2, 3, "hello", true]
        };
        
        console.log('JSON支持的类型:', JSON.stringify(supportedTypes, null, 2));
        
        // JSON不支持的类型
        console.log('=== JSON 不支持的类型 ===');
        const unsupportedTypes = {
            // undefined会被忽略
            undefinedValue: undefined,
            
            // 函数会被忽略
            functionValue: function() { return 'hello'; },
            
            // Symbol会被忽略
            symbolValue: Symbol('test'),
            
            // 日期对象会被转换为字符串
            dateValue: new Date('2023-01-01'),
            
            // RegExp会被转换为空对象
            regexValue: /pattern/g,
            
            // BigInt不被支持（会抛出错误）
            // bigIntValue: 123n
        };
        
        console.log('包含不支持类型的对象:', JSON.stringify(unsupportedTypes));
    },
    
    /**
     * JSON 语法规范
     */
    syntaxRules() {
        console.log('=== JSON 语法规范 ===');
        
        // 正确的JSON格式
        const validJSON = `{
            "name": "John Doe",
            "age": 30,
            "isActive": true,
            "address": {
                "street": "123 Main St",
                "city": "New York",
                "zipCode": null
            },
            "hobbies": ["reading", "swimming", "coding"],
            "score": 95.5
        }`;
        
        console.log('有效的JSON字符串:');
        console.log(validJSON);
        
        // 常见的JSON格式错误
        const invalidExamples = [
            `{ name: "John" }`,                    // 属性名必须用双引号
            `{ "name": 'John' }`,                  // 值必须用双引号
            `{ "name": "John", }`,                 // 不能有尾随逗号
            `{ "comment": "// 这是注释" }`,        // 不支持注释
            `{ "undefined": undefined }`,          // 不支持undefined
            `{ "function": function(){} }`         // 不支持函数
        ];
        
        console.log('常见的JSON格式错误:');
        invalidExamples.forEach((example, index) => {
            console.log(`${index + 1}. ${example}`);
        });
    }
};

JSONFormat.basicRules();
JSONFormat.syntaxRules();
```

### JSON 序列化与反序列化

JavaScript提供了内置的JSON对象来处理JSON数据：

```javascript
/**
 * JSON 序列化与反序列化
 */
const JSONSerialization = {
    /**
     * 基本的序列化与反序列化
     */
    basicOperations() {
        console.log('=== 基本序列化与反序列化 ===');
        
        const originalObject = {
            name: 'Alice',
            age: 25,
            hobbies: ['reading', 'coding'],
            address: {
                city: 'Beijing',
                country: 'China'
            },
            isActive: true,
            score: null
        };
        
        // 序列化：JavaScript对象 → JSON字符串
        const jsonString = JSON.stringify(originalObject);
        console.log('序列化结果:', jsonString);
        
        // 反序列化：JSON字符串 → JavaScript对象
        const parsedObject = JSON.parse(jsonString);
        console.log('反序列化结果:', parsedObject);
        
        // 验证深拷贝效果
        console.log('是否为同一对象:', originalObject === parsedObject); // false
        console.log('内容是否相同:', JSON.stringify(originalObject) === JSON.stringify(parsedObject)); // true
    },
    
    /**
     * JSON.stringify 的高级用法
     */
    stringifyAdvanced() {
        console.log('=== JSON.stringify 高级用法 ===');
        
        const complexObject = {
            name: 'Bob',
            age: 30,
            password: 'secret123',
            createdAt: new Date('2023-01-01'),
            calculate: function() { return this.age * 2; },
            undefinedProp: undefined,
            symbolProp: Symbol('test')
        };
        
        // 1. 使用replacer函数
        const withReplacer = JSON.stringify(complexObject, (key, value) => {
            // 过滤敏感信息
            if (key === 'password') return undefined;
            // 转换日期格式
            if (value instanceof Date) return value.toISOString();
            // 处理函数
            if (typeof value === 'function') return '[Function]';
            return value;
        });
        
        console.log('使用replacer函数:', withReplacer);
        
        // 2. 使用replacer数组（属性白名单）
        const withWhitelist = JSON.stringify(complexObject, ['name', 'age', 'createdAt']);
        console.log('使用属性白名单:', withWhitelist);
        
        // 3. 使用space参数美化输出
        const prettyJSON = JSON.stringify(complexObject, null, 2);
        console.log('美化输出:');
        console.log(prettyJSON);
        
        // 4. 自定义toJSON方法
        const objectWithToJSON = {
            name: 'Charlie',
            age: 28,
            _private: 'secret',
            toJSON() {
                return {
                    name: this.name,
                    age: this.age,
                    serializedAt: new Date().toISOString()
                };
            }
        };
        
        console.log('自定义toJSON:', JSON.stringify(objectWithToJSON));
    },
    
    /**
     * JSON.parse 的高级用法
     */
    parseAdvanced() {
        console.log('=== JSON.parse 高级用法 ===');
        
        const jsonString = `{
            "name": "David",
            "age": "32",
            "salary": "50000.5",
            "birthDate": "2023-01-01T00:00:00.000Z",
            "isManager": "true"
        }`;
        
        // 使用reviver函数转换值
        const parsed = JSON.parse(jsonString, (key, value) => {
            // 转换数字字符串为数字
            if (key === 'age' || key === 'salary') {
                return Number(value);
            }
            // 转换日期字符串为Date对象
            if (key === 'birthDate') {
                return new Date(value);
            }
            // 转换布尔字符串
            if (key === 'isManager') {
                return value === 'true';
            }
            return value;
        });
        
        console.log('使用reviver函数转换:', parsed);
        console.log('类型检查:');
        console.log('age类型:', typeof parsed.age);
        console.log('salary类型:', typeof parsed.salary);
        console.log('birthDate类型:', parsed.birthDate instanceof Date);
        console.log('isManager类型:', typeof parsed.isManager);
    },
    
    /**
     * 错误处理
     */
    errorHandling() {
        console.log('=== JSON 错误处理 ===');
        
        const invalidJSONStrings = [
            '{ name: "John" }',          // 属性名没有引号
            '{ "name": "John", }',       // 尾随逗号
            '{ "name": undefined }',     // undefined值
            'function() { return 1; }',  // 函数
            'Hello World'                // 普通字符串
        ];
        
        /**
         * 安全的JSON解析函数
         * @param {string} jsonString - JSON字符串
         * @param {*} defaultValue - 解析失败时的默认值
         * @returns {*} 解析结果或默认值
         */
        function safeJSONParse(jsonString, defaultValue = null) {
            try {
                return JSON.parse(jsonString);
            } catch (error) {
                console.log(`JSON解析失败: ${error.message}`);
                return defaultValue;
            }
        }
        
        /**
         * 安全的JSON序列化函数
         * @param {*} object - 要序列化的对象
         * @param {*} defaultValue - 序列化失败时的默认值
         * @returns {string} JSON字符串或默认值
         */
        function safeJSONStringify(object, defaultValue = '{}') {
            try {
                return JSON.stringify(object);
            } catch (error) {
                console.log(`JSON序列化失败: ${error.message}`);
                return defaultValue;
            }
        }
        
        // 测试错误处理
        invalidJSONStrings.forEach((jsonStr, index) => {
            console.log(`测试 ${index + 1}: ${jsonStr}`);
            const result = safeJSONParse(jsonStr, { error: 'invalid json' });
            console.log('解析结果:', result);
        });
        
        // 测试包含BigInt的对象（会抛出错误）
        const objectWithBigInt = { value: 123n };
        console.log('BigInt序列化:', safeJSONStringify(objectWithBigInt, '{"error": "cannot serialize"}'));
    }
};

JSONSerialization.basicOperations();
JSONSerialization.stringifyAdvanced();
JSONSerialization.parseAdvanced();
JSONSerialization.errorHandling();
```

### JSON 与 JavaScript 对象的差异

尽管JSON基于JavaScript对象语法，但两者存在重要差异：

```javascript
/**
 * JSON 与 JavaScript 对象的差异
 */
const JSONVsJSObject = {
    /**
     * 语法差异
     */
    syntaxDifferences() {
        console.log('=== 语法差异 ===');
        
        // JavaScript 对象（更灵活）
        const jsObject = {
            // 属性名可以不用引号
            name: 'Alice',
            age: 25,
            
            // 可以使用单引号
            'city': 'Beijing',
            
            // 可以有尾随逗号
            hobbies: ['reading', 'coding'],
            
            // 可以有方法
            getName() {
                return this.name;
            },
            
            // 可以有注释
            /* 这是注释 */
            
            // 可以使用计算属性名
            ['computed' + 'Key']: 'computed value'
        };
        
        console.log('JavaScript对象:', jsObject);
        console.log('调用方法:', jsObject.getName());
        
        // JSON 格式（严格规范）
        const jsonString = `{
            "name": "Alice",
            "age": 25,
            "city": "Beijing",
            "hobbies": ["reading", "coding"]
        }`;
        
        console.log('等效的JSON字符串:', jsonString);
    },
    
    /**
     * 数据类型支持差异
     */
    dataTypeSupport() {
        console.log('=== 数据类型支持差异 ===');
        
        const jsObjectWithAllTypes = {
            // JSON支持的类型
            string: 'hello',
            number: 42,
            boolean: true,
            nullValue: null,
            object: { nested: true },
            array: [1, 2, 3],
            
            // JSON不支持的类型
            undefinedValue: undefined,
            functionValue: () => 'hello',
            symbolValue: Symbol('test'),
            dateValue: new Date(),
            regexpValue: /pattern/,
            nanValue: NaN,
            infinityValue: Infinity
        };
        
        console.log('原始对象:', jsObjectWithAllTypes);
        
        // 序列化时不支持的类型会被处理
        const serialized = JSON.stringify(jsObjectWithAllTypes);
        console.log('序列化后:', serialized);
        
        const parsed = JSON.parse(serialized);
        console.log('反序列化后:', parsed);
        
        // 对比差异
        console.log('=== 序列化前后的差异 ===');
        Object.keys(jsObjectWithAllTypes).forEach(key => {
            const original = jsObjectWithAllTypes[key];
            const afterSerialization = parsed[key];
            
            if (key in parsed) {
                console.log(`${key}: ${original} -> ${afterSerialization} (${typeof original} -> ${typeof afterSerialization})`);
            } else {
                console.log(`${key}: ${original} -> [已丢失] (${typeof original})`);
            }
        });
    },
    
    /**
     * 深拷贝与浅拷贝
     */
    copyBehavior() {
        console.log('=== 拷贝行为 ===');
        
        const originalObject = {
            name: 'Alice',
            hobbies: ['reading', 'coding'],
            address: {
                city: 'Beijing',
                details: {
                    zipCode: '100001'
                }
            },
            createdAt: new Date('2023-01-01')
        };
        
        // 浅拷贝方法
        const shallowCopy1 = { ...originalObject };
        const shallowCopy2 = Object.assign({}, originalObject);
        
        // JSON深拷贝方法（有限制）
        const jsonDeepCopy = JSON.parse(JSON.stringify(originalObject));
        
        // 修改嵌套对象测试
        originalObject.address.city = 'Shanghai';
        originalObject.hobbies.push('swimming');
        
        console.log('原始对象:', originalObject);
        console.log('浅拷贝1:', shallowCopy1); // 嵌套对象会被影响
        console.log('浅拷贝2:', shallowCopy2); // 嵌套对象会被影响
        console.log('JSON深拷贝:', jsonDeepCopy); // 不会被影响，但日期变成了字符串
        
        /**
         * 完整的深拷贝实现（处理JSON不支持的类型）
         * @param {*} obj - 要拷贝的对象
         * @returns {*} 深拷贝后的对象
         */
        function deepCopy(obj) {
            if (obj === null || typeof obj !== 'object') return obj;
            
            if (obj instanceof Date) return new Date(obj);
            if (obj instanceof Array) return obj.map(item => deepCopy(item));
            if (obj instanceof RegExp) return new RegExp(obj);
            
            if (typeof obj === 'object') {
                const copied = {};
                Object.keys(obj).forEach(key => {
                    copied[key] = deepCopy(obj[key]);
                });
                return copied;
            }
            
            return obj;
        }
        
        const realDeepCopy = deepCopy(originalObject);
        console.log('真正的深拷贝:', realDeepCopy);
        console.log('日期类型保持:', realDeepCopy.createdAt instanceof Date);
    }
};

JSONVsJSObject.syntaxDifferences();
JSONVsJSObject.dataTypeSupport();
JSONVsJSObject.copyBehavior();
```

### 实际应用场景

JSON在实际开发中有广泛的应用：

```javascript
/**
 * JSON 的实际应用场景
 */
const JSONApplications = {
    /**
     * AJAX/Fetch API 数据交换
     */
    apiCommunication() {
        console.log('=== API 数据交换 ===');
        
        /**
         * 模拟API请求
         * @param {string} url - API地址
         * @param {Object} data - 请求数据
         */
        async function apiRequest(url, data) {
            const response = {
                status: 200,
                data: JSON.stringify({
                    success: true,
                    message: '请求成功',
                    timestamp: new Date().toISOString(),
                    receivedData: data
                })
            };
            
            // 模拟网络延迟
            await new Promise(resolve => setTimeout(resolve, 100));
            
            return {
                json: () => JSON.parse(response.data)
            };
        }
        
        // 发送JSON数据
        const requestData = {
            userId: 12345,
            action: 'update_profile',
            data: {
                name: 'Alice Johnson',
                email: 'alice@example.com'
            }
        };
        
        console.log('发送数据:', JSON.stringify(requestData, null, 2));
        
        // 模拟API调用
        apiRequest('/api/user/update', requestData)
            .then(response => response.json())
            .then(data => {
                console.log('接收数据:', data);
            });
    },
    
    /**
     * 配置文件管理
     */
    configurationManagement() {
        console.log('=== 配置文件管理 ===');
        
        // 应用配置
        const appConfig = {
            name: 'MyApp',
            version: '1.0.0',
            api: {
                baseUrl: 'https://api.example.com',
                timeout: 5000,
                retries: 3
            },
            features: {
                authentication: true,
                notifications: true,
                analytics: false
            },
            theme: {
                primaryColor: '#007bff',
                secondaryColor: '#6c757d',
                darkMode: false
            }
        };
        
        /**
         * 配置管理器
         */
        class ConfigManager {
            constructor(config) {
                this.config = JSON.parse(JSON.stringify(config)); // 深拷贝
            }
            
            /**
             * 获取配置值
             * @param {string} path - 配置路径，如 'api.baseUrl'
             */
            get(path) {
                return path.split('.').reduce((obj, key) => obj?.[key], this.config);
            }
            
            /**
             * 设置配置值
             * @param {string} path - 配置路径
             * @param {*} value - 配置值
             */
            set(path, value) {
                const keys = path.split('.');
                const lastKey = keys.pop();
                const target = keys.reduce((obj, key) => obj[key] = obj[key] || {}, this.config);
                target[lastKey] = value;
            }
            
            /**
             * 导出配置为JSON
             */
            export() {
                return JSON.stringify(this.config, null, 2);
            }
            
            /**
             * 从JSON导入配置
             * @param {string} jsonString - JSON配置字符串
             */
            import(jsonString) {
                try {
                    this.config = JSON.parse(jsonString);
                    return true;
                } catch (error) {
                    console.error('配置导入失败:', error.message);
                    return false;
                }
            }
        }
        
        const configManager = new ConfigManager(appConfig);
        
        console.log('API基础URL:', configManager.get('api.baseUrl'));
        console.log('是否启用认证:', configManager.get('features.authentication'));
        
        // 修改配置
        configManager.set('theme.darkMode', true);
        configManager.set('api.timeout', 10000);
        
        console.log('导出的配置:');
        console.log(configManager.export());
    },
    
    /**
     * 数据存储和缓存
     */
    dataStorage() {
        console.log('=== 数据存储和缓存 ===');
        
        /**
         * 本地存储管理器
         */
        class StorageManager {
            /**
             * 存储数据
             * @param {string} key - 存储键
             * @param {*} data - 要存储的数据
             * @param {number} ttl - 过期时间（毫秒），0表示永不过期
             */
            static set(key, data, ttl = 0) {
                const item = {
                    data: data,
                    timestamp: Date.now(),
                    ttl: ttl
                };
                
                try {
                    localStorage.setItem(key, JSON.stringify(item));
                    console.log(`数据已存储: ${key}`);
                } catch (error) {
                    console.error('存储失败:', error.message);
                }
            }
            
            /**
             * 获取数据
             * @param {string} key - 存储键
             * @returns {*} 存储的数据，如果不存在或过期则返回null
             */
            static get(key) {
                try {
                    const itemStr = localStorage.getItem(key);
                    if (!itemStr) return null;
                    
                    const item = JSON.parse(itemStr);
                    
                    // 检查是否过期
                    if (item.ttl > 0 && Date.now() - item.timestamp > item.ttl) {
                        localStorage.removeItem(key);
                        console.log(`数据已过期并删除: ${key}`);
                        return null;
                    }
                    
                    return item.data;
                } catch (error) {
                    console.error('读取失败:', error.message);
                    return null;
                }
            }
            
            /**
             * 删除数据
             * @param {string} key - 存储键
             */
            static remove(key) {
                localStorage.removeItem(key);
                console.log(`数据已删除: ${key}`);
            }
            
            /**
             * 清空所有数据
             */
            static clear() {
                localStorage.clear();
                console.log('所有数据已清空');
            }
        }
        
        // 使用示例
        const userData = {
            id: 123,
            name: 'Alice',
            preferences: {
                theme: 'dark',
                language: 'zh-CN'
            },
            lastLogin: new Date().toISOString()
        };
        
        // 存储数据（30秒后过期）
        StorageManager.set('user_data', userData, 30000);
        
        // 读取数据
        const retrievedData = StorageManager.get('user_data');
        console.log('读取的用户数据:', retrievedData);
        
        // 缓存API响应
        const apiCache = {
            '/api/users': [
                { id: 1, name: 'Alice' },
                { id: 2, name: 'Bob' }
            ],
            '/api/config': {
                version: '1.0.0',
                features: ['auth', 'notifications']
            }
        };
        
        StorageManager.set('api_cache', apiCache, 300000); // 5分钟缓存
        console.log('API缓存已存储');
    },
    
    /**
     * 日志记录和调试
     */
    loggingAndDebugging() {
        console.log('=== 日志记录和调试 ===');
        
        /**
         * 结构化日志记录器
         */
        class Logger {
            constructor(appName) {
                this.appName = appName;
                this.logs = [];
            }
            
            /**
             * 记录日志
             * @param {string} level - 日志级别
             * @param {string} message - 日志消息
             * @param {Object} meta - 额外的元数据
             */
            log(level, message, meta = {}) {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    level: level.toUpperCase(),
                    app: this.appName,
                    message: message,
                    meta: meta,
                    stack: new Error().stack.split('\n').slice(2, 5) // 简化调用栈
                };
                
                this.logs.push(logEntry);
                
                // 输出到控制台
                console.log(JSON.stringify(logEntry, null, 2));
                
                // 可以发送到日志服务器
                // this.sendToServer(logEntry);
            }
            
            info(message, meta) { this.log('info', message, meta); }
            warn(message, meta) { this.log('warn', message, meta); }
            error(message, meta) { this.log('error', message, meta); }
            debug(message, meta) { this.log('debug', message, meta); }
            
            /**
             * 导出日志
             */
            exportLogs() {
                return JSON.stringify(this.logs, null, 2);
            }
            
            /**
             * 清空日志
             */
            clearLogs() {
                this.logs = [];
            }
        }
        
        const logger = new Logger('MyApp');
        
        // 记录不同级别的日志
        logger.info('应用启动', { version: '1.0.0', env: 'production' });
        logger.warn('API响应较慢', { endpoint: '/api/users', responseTime: 1500 });
        logger.error('数据库连接失败', { 
            error: 'Connection timeout',
            host: 'localhost:5432',
            attempts: 3
        });
        
        console.log('导出的日志数据:');
        console.log(logger.exportLogs());
    }
};

// 由于某些API在示例环境中不可用，这里只展示结构
console.log('=== JSON 应用场景演示 ===');
JSONApplications.apiCommunication();
JSONApplications.configurationManagement();
// JSONApplications.dataStorage(); // 需要localStorage支持
JSONApplications.loggingAndDebugging();
```

---

**本章总结**

第5章深入探讨了JavaScript的数据类型与类型系统：

1. **基本类型（七种）**：详细介绍了Number、String、Boolean、Null、Undefined、Symbol、BigInt的特性和使用方法
2. **引用类型**：深入讲解了Object、Array、Function、Date、RegExp等引用类型的创建和操作
3. **栈与堆**：解释了内存分配模式、深浅拷贝机制，以及内存管理和垃圾回收
4. **类型判断**：掌握typeof、instanceof等判断方法的原理、局限性和最佳实践
5. **类型转换**：理解隐式转换规则、掌握显式转换方法，避免常见转换陷阱
6. **JSON应用**：了解JSON格式规范、序列化反序列化机制，以及在实际开发中的应用

理解数据类型是JavaScript编程的基础，掌握类型系统有助于编写更可靠、更高效的代码。

**下一章预告**

第6章将探讨JavaScript的运算符与表达式，包括算术运算符、比较运算符、逻辑运算符、位运算符等的使用方法和运算优先级。

---

**本章总结**

**下一章预告**
