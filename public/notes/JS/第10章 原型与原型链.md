# 第10章　原型与原型链

原型与原型链是JavaScript面向对象编程的核心机制。理解原型链不仅有助于掌握JavaScript的继承体系，更是深入理解JavaScript运行机制的关键。

## 10.1 prototype 的本质

JavaScript中的每个函数都有一个prototype属性，这是原型继承的基础。

### 函数的prototype属性

每个函数都有一个prototype属性，它指向一个对象：

```javascript
/**
 * 函数prototype属性示例
 */
const FunctionPrototypeExamples = {
    /**
     * 基本prototype概念
     */
    basicPrototype() {
        console.log('=== 函数的prototype属性 ===');
        
        // 普通函数的prototype
        function Person(name) {
            this.name = name;
        }
        
        console.log('Person函数有prototype:', typeof Person.prototype);
        console.log('Person.prototype:', Person.prototype);
        
        // prototype是一个对象
        console.log('prototype是对象:', typeof Person.prototype === 'object');
        
        // prototype有constructor属性，指向函数本身
        console.log('constructor指向函数:', Person.prototype.constructor === Person);
        
        // 箭头函数没有prototype
        const ArrowFunc = () => {};
        console.log('箭头函数prototype:', ArrowFunc.prototype); // undefined
        
        // 内置构造函数也有prototype
        console.log('Array.prototype:', typeof Array.prototype);
        console.log('Object.prototype:', typeof Object.prototype);
    },
    
    /**
     * prototype vs __proto__
     */
    prototypeVsProto() {
        console.log('=== prototype vs __proto__ ===');
        
        function Animal(type) {
            this.type = type;
        }
        
        Animal.prototype.speak = function() {
            return `${this.type} makes a sound`;
        };
        
        const dog = new Animal('dog');
        
        // prototype是函数的属性
        console.log('函数的prototype:', Animal.prototype);
        
        // __proto__是实例的属性，指向构造函数的prototype
        console.log('实例的__proto__:', dog.__proto__);
        console.log('__proto__指向prototype:', dog.__proto__ === Animal.prototype);
        
        // 标准方法：Object.getPrototypeOf()
        console.log('标准获取原型:', Object.getPrototypeOf(dog) === Animal.prototype);
        
        // 实例可以访问原型上的方法
        console.log('访问原型方法:', dog.speak());
        
        // 方法查找：先实例，后原型
        console.log('dog有speak属性?:', dog.hasOwnProperty('speak')); // false
        console.log('原型有speak属性?:', Animal.prototype.hasOwnProperty('speak')); // true
    },
    
    /**
     * 动态修改prototype
     */
    dynamicPrototype() {
        console.log('=== 动态修改prototype ===');
        
        function Car(brand) {
            this.brand = brand;
        }
        
        const car1 = new Car('Toyota');
        console.log('car1方法数量:', Object.getOwnPropertyNames(Object.getPrototypeOf(car1)));
        
        // 动态添加方法
        Car.prototype.start = function() {
            return `${this.brand} is starting`;
        };
        
        const car2 = new Car('BMW');
        
        // 已存在的实例也能访问新添加的方法
        console.log('car1调用新方法:', car1.start());
        console.log('car2调用新方法:', car2.start());
        
        // 修改原型方法
        Car.prototype.start = function() {
            return `${this.brand} engine started!`;
        };
        
        console.log('修改后car1:', car1.start());
        console.log('修改后car2:', car2.start());
        
        // 替换整个prototype（不推荐）
        const originalProto = Car.prototype;
        Car.prototype = {
            constructor: Car,
            drive: function() {
                return `${this.brand} is driving`;
            }
        };
        
        const car3 = new Car('Tesla');
        
        console.log('car1能drive?:', 'drive' in car1); // false
        console.log('car3能drive?:', 'drive' in car3); // true
        console.log('car3能start?:', 'start' in car3); // false
        
        console.log('car1的原型:', Object.getPrototypeOf(car1) === originalProto);
        console.log('car3的原型:', Object.getPrototypeOf(car3) === Car.prototype);
    }
};

FunctionPrototypeExamples.basicPrototype();
FunctionPrototypeExamples.prototypeVsProto();
FunctionPrototypeExamples.dynamicPrototype();
```

### 原型对象的结构

理解原型对象的内部结构：

```javascript
/**
 * 原型对象结构示例
 */
const PrototypeStructureExamples = {
    /**
     * 原型对象的默认属性
     */
    defaultProperties() {
        console.log('=== 原型对象默认属性 ===');
        
        function MyConstructor() {}
        
        // 查看prototype的默认属性
        console.log('prototype属性:');
        console.log('constructor:', MyConstructor.prototype.constructor === MyConstructor);
        console.log('__proto__:', MyConstructor.prototype.__proto__ === Object.prototype);
        
        // 查看所有属性
        console.log('所有属性:', Object.getOwnPropertyNames(MyConstructor.prototype));
        console.log('可枚举属性:', Object.keys(MyConstructor.prototype));
        
        // constructor属性是不可枚举的
        const descriptor = Object.getOwnPropertyDescriptor(MyConstructor.prototype, 'constructor');
        console.log('constructor描述符:', descriptor);
        
        // 手动修改constructor
        MyConstructor.prototype.constructor = function() { return 'fake'; };
        console.log('修改后constructor:', MyConstructor.prototype.constructor());
    },
    
    /**
     * 原型链结构
     */
    prototypeChain() {
        console.log('=== 原型链结构 ===');
        
        function Shape() {}
        Shape.prototype.getType = function() {
            return 'shape';
        };
        
        const shape = new Shape();
        
        // 完整原型链路径
        console.log('原型链路径:');
        console.log('1. shape实例:', shape);
        console.log('2. Shape.prototype:', Object.getPrototypeOf(shape));
        console.log('3. Object.prototype:', Object.getPrototypeOf(Object.getPrototypeOf(shape)));
        console.log('4. null:', Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(shape))));
        
        // 使用isPrototypeOf检查
        console.log('Shape.prototype.isPrototypeOf(shape):', Shape.prototype.isPrototypeOf(shape));
        console.log('Object.prototype.isPrototypeOf(shape):', Object.prototype.isPrototypeOf(shape));
        
        // instanceof检查
        console.log('shape instanceof Shape:', shape instanceof Shape);
        console.log('shape instanceof Object:', shape instanceof Object);
        
        // 函数本身也是对象，有自己的原型链
        console.log('\n函数的原型链:');
        console.log('Shape函数的原型:', Object.getPrototypeOf(Shape));
        console.log('Function.prototype:', Object.getPrototypeOf(Shape) === Function.prototype);
        console.log('Shape instanceof Function:', Shape instanceof Function);
    },
    
    /**
     * 原型污染示例
     */
    prototypePollution() {
        console.log('=== 原型污染示例 ===');
        
        // ⚠️ 危险操作：修改内置原型
        // Object.prototype.customMethod = function() {
        //     return 'This is dangerous!';
        // };
        
        // 演示为什么危险
        const obj = {};
        // console.log('空对象有customMethod:', 'customMethod' in obj);
        
        // 安全的替代方案
        function createExtendedObject(proto) {
            const extended = Object.create(proto);
            extended.customMethod = function() {
                return 'This is safe!';
            };
            return extended;
        }
        
        const safeObj = createExtendedObject(Object.prototype);
        console.log('安全的扩展对象:', safeObj.customMethod());
        
        // 检查是否污染了全局原型
        const normalObj = {};
        console.log('普通对象不受影响:', 'customMethod' in normalObj);
        
        // 最佳实践：使用组合而非继承
        function addMethods(target, methods) {
            return Object.assign(target, methods);
        }
        
        const enhancedObj = addMethods({}, {
            greet: function() { return 'Hello!'; },
            farewell: function() { return 'Goodbye!'; }
        });
        
        console.log('增强对象:', enhancedObj.greet(), enhancedObj.farewell());
    }
};

PrototypeStructureExamples.defaultProperties();
PrototypeStructureExamples.prototypeChain();
PrototypeStructureExamples.prototypePollution();
```

---

## 10.2 原型链查找机制

原型链是JavaScript实现继承的核心机制，理解属性查找过程对掌握JavaScript至关重要。

### 属性查找过程

JavaScript引擎按照特定顺序查找属性：

```javascript
/**
 * 属性查找过程示例
 */
const PropertyLookupExamples = {
    /**
     * 基本查找顺序
     */
    basicLookup() {
        console.log('=== 属性查找顺序 ===');
        
        function Parent() {}
        Parent.prototype.parentProp = 'parent value';
        Parent.prototype.sharedProp = 'parent shared';
        
        function Child() {
            this.childProp = 'child value';
            this.sharedProp = 'child shared'; // 覆盖原型属性
        }
        
        Child.prototype = Object.create(Parent.prototype);
        Child.prototype.constructor = Child;
        Child.prototype.childProtoProp = 'child proto value';
        
        const instance = new Child();
        
        // 查找顺序测试
        console.log('1. 实例属性 childProp:', instance.childProp);
        console.log('2. 实例属性覆盖原型 sharedProp:', instance.sharedProp);
        console.log('3. 直接原型属性 childProtoProp:', instance.childProtoProp);
        console.log('4. 继承的原型属性 parentProp:', instance.parentProp);
        
        // 属性来源检查
        console.log('\n属性来源检查:');
        console.log('childProp在实例:', instance.hasOwnProperty('childProp'));
        console.log('sharedProp在实例:', instance.hasOwnProperty('sharedProp'));
        console.log('childProtoProp在原型:', 'childProtoProp' in instance && !instance.hasOwnProperty('childProtoProp'));
        console.log('parentProp在祖先原型:', 'parentProp' in instance && !Child.prototype.hasOwnProperty('parentProp'));
        
        // 删除实例属性后的查找
        delete instance.sharedProp;
        console.log('删除实例属性后 sharedProp:', instance.sharedProp);
    },
    
    /**
     * 复杂查找场景
     */
    complexLookup() {
        console.log('=== 复杂查找场景 ===');
        
        // 多级继承
        function GrandParent() {}
        GrandParent.prototype.level = 'grandparent';
        GrandParent.prototype.method = function() { return 'grandparent method'; };
        
        function Parent() {}
        Parent.prototype = Object.create(GrandParent.prototype);
        Parent.prototype.constructor = Parent;
        Parent.prototype.level = 'parent'; // 覆盖祖先属性
        
        function Child() {
            this.instanceProp = 'instance';
        }
        Child.prototype = Object.create(Parent.prototype);
        Child.prototype.constructor = Child;
        
        const child = new Child();
        
        console.log('多级继承中的属性查找:');
        console.log('level属性:', child.level); // 'parent'
        console.log('method方法:', child.method()); // 'grandparent method'
        console.log('instanceProp:', child.instanceProp); // 'instance'
        
        // 原型链路径
        let current = child;
        let level = 0;
        while (current) {
            console.log(`Level ${level}:`, current.constructor?.name || 'Object');
            current = Object.getPrototypeOf(current);
            level++;
            if (level > 5) break; // 防止无限循环
        }
        
        // 性能考虑：深度查找的代价
        console.time('属性查找性能');
        for (let i = 0; i < 100000; i++) {
            child.method(); // 需要沿着原型链查找
        }
        console.timeEnd('属性查找性能');
    },
    
    /**
     * 属性遮蔽
     */
    propertyShadowing() {
        console.log('=== 属性遮蔽 ===');
        
        function Base() {}
        Base.prototype.value = 'base';
        Base.prototype.getValue = function() {
            return `Base: ${this.value}`;
        };
        
        function Derived() {
            this.value = 'derived instance';
        }
        Derived.prototype = Object.create(Base.prototype);
        Derived.prototype.constructor = Derived;
        
        const obj = new Derived();
        
        console.log('遮蔽前原型值:', Base.prototype.value);
        console.log('实例值遮蔽原型:', obj.value);
        console.log('方法中的this.value:', obj.getValue());
        
        // 动态遮蔽
        obj.getValue = function() {
            return `Derived: ${this.value}`;
        };
        
        console.log('方法遮蔽后:', obj.getValue());
        
        // 访问被遮蔽的属性
        delete obj.value;
        console.log('删除实例属性后:', obj.value); // 'base'
        
        // 通过原型直接访问
        console.log('直接访问原型:', Base.prototype.value);
        console.log('调用原型方法:', Base.prototype.getValue.call(obj));
    }
};

PropertyLookupExamples.basicLookup();
PropertyLookupExamples.complexLookup();
PropertyLookupExamples.propertyShadowing();
```

### 方法继承

方法继承是原型链的重要应用：

```javascript
/**
 * 方法继承示例
 */
const MethodInheritanceExamples = {
    /**
     * 基本方法继承
     */
    basicMethodInheritance() {
        console.log('=== 基本方法继承 ===');
        
        // 基类
        function Animal(name) {
            this.name = name;
        }
        
        Animal.prototype.speak = function() {
            return `${this.name} makes a sound`;
        };
        
        Animal.prototype.move = function() {
            return `${this.name} is moving`;
        };
        
        // 派生类
        function Dog(name, breed) {
            Animal.call(this, name); // 调用父类构造函数
            this.breed = breed;
        }
        
        // 设置继承关系
        Dog.prototype = Object.create(Animal.prototype);
        Dog.prototype.constructor = Dog;
        
        // 重写方法
        Dog.prototype.speak = function() {
            return `${this.name} barks: Woof!`;
        };
        
        // 添加新方法
        Dog.prototype.wagTail = function() {
            return `${this.name} is wagging tail`;
        };
        
        const dog = new Dog('Buddy', 'Golden Retriever');
        
        console.log('继承的方法:', dog.move());
        console.log('重写的方法:', dog.speak());
        console.log('新增的方法:', dog.wagTail());
        
        // 方法查找路径
        console.log('speak方法来自:', dog.hasOwnProperty('speak') ? '实例' : '原型');
        console.log('move方法来自原型链:', 'move' in dog && !Dog.prototype.hasOwnProperty('move'));
    },
    
    /**
     * 方法调用与this绑定
     */
    methodCallAndThis() {
        console.log('=== 方法调用与this绑定 ===');
        
        function Vehicle(type) {
            this.type = type;
            this.speed = 0;
        }
        
        Vehicle.prototype.accelerate = function(delta) {
            this.speed += delta;
            return `${this.type} speed: ${this.speed}`;
        };
        
        Vehicle.prototype.getInfo = function() {
            return {
                type: this.type,
                speed: this.speed,
                toString: function() {
                    return `${this.type} @ ${this.speed}km/h`;
                }
            };
        };
        
        function Car(type, brand) {
            Vehicle.call(this, type);
            this.brand = brand;
        }
        
        Car.prototype = Object.create(Vehicle.prototype);
        Car.prototype.constructor = Car;
        
        // 重写方法，调用父类方法
        Car.prototype.accelerate = function(delta) {
            const result = Vehicle.prototype.accelerate.call(this, delta);
            return `${this.brand} ${result}`;
        };
        
        const car = new Car('sedan', 'Toyota');
        
        console.log('调用重写方法:', car.accelerate(50));
        console.log('调用继承方法:', car.getInfo().toString());
        
        // this绑定问题
        const accelerateMethod = car.accelerate;
        try {
            console.log('丢失this的调用:', accelerateMethod(10));
        } catch (e) {
            console.log('this绑定错误:', e.message);
        }
        
        // 正确的方法引用
        const boundAccelerate = car.accelerate.bind(car);
        console.log('绑定this的调用:', boundAccelerate(20));
    },
    
    /**
     * 方法组合与mixin
     */
    methodComposition() {
        console.log('=== 方法组合与mixin ===');
        
        // 定义功能模块
        const CanFly = {
            fly() {
                return `${this.name} is flying at ${this.altitude || 1000}m`;
            },
            
            land() {
                this.altitude = 0;
                return `${this.name} has landed`;
            }
        };
        
        const CanSwim = {
            swim() {
                return `${this.name} is swimming at ${this.depth || 5}m depth`;
            },
            
            dive(depth) {
                this.depth = depth;
                return `${this.name} dived to ${depth}m`;
            }
        };
        
        // mixin函数
        function mixin(target, ...sources) {
            sources.forEach(source => {
                Object.keys(source).forEach(key => {
                    if (typeof source[key] === 'function') {
                        target[key] = source[key];
                    }
                });
            });
            return target;
        }
        
        // 基类
        function Bird(name) {
            this.name = name;
            this.altitude = 0;
        }
        
        // 混入飞行能力
        mixin(Bird.prototype, CanFly);
        
        function Duck(name) {
            Bird.call(this, name);
            this.depth = 0;
        }
        
        Duck.prototype = Object.create(Bird.prototype);
        Duck.prototype.constructor = Duck;
        
        // 混入游泳能力
        mixin(Duck.prototype, CanSwim);
        
        const duck = new Duck('Daffy');
        
        console.log('飞行能力:', duck.fly());
        console.log('游泳能力:', duck.swim());
        console.log('潜水能力:', duck.dive(10));
        console.log('着陆:', duck.land());
        
        // 检查能力
        console.log('具有飞行能力:', typeof duck.fly === 'function');
        console.log('具有游泳能力:', typeof duck.swim === 'function');
    }
};

MethodInheritanceExamples.basicMethodInheritance();
MethodInheritanceExamples.methodCallAndThis();
MethodInheritanceExamples.methodComposition();
```

### 原型链的尽头

理解原型链如何终止：

```javascript
/**
 * 原型链终点示例
 */
const PrototypeChainEndExamples = {
    /**
     * Object.prototype是终点
     */
    objectPrototypeEnd() {
        console.log('=== Object.prototype是终点 ===');
        
        // 普通对象的原型链
        const obj = {};
        console.log('对象的原型:', Object.getPrototypeOf(obj) === Object.prototype);
        console.log('Object.prototype的原型:', Object.getPrototypeOf(Object.prototype)); // null
        
        // 数组的原型链
        const arr = [];
        console.log('数组原型链:');
        console.log('arr -> Array.prototype:', Object.getPrototypeOf(arr) === Array.prototype);
        console.log('Array.prototype -> Object.prototype:', Object.getPrototypeOf(Array.prototype) === Object.prototype);
        console.log('Object.prototype -> null:', Object.getPrototypeOf(Object.prototype) === null);
        
        // 函数的原型链
        function fn() {}
        console.log('函数原型链:');
        console.log('fn -> Function.prototype:', Object.getPrototypeOf(fn) === Function.prototype);
        console.log('Function.prototype -> Object.prototype:', Object.getPrototypeOf(Function.prototype) === Object.prototype);
        
        // 构造函数实例的原型链
        function MyClass() {}
        const instance = new MyClass();
        console.log('实例原型链:');
        console.log('instance -> MyClass.prototype:', Object.getPrototypeOf(instance) === MyClass.prototype);
        console.log('MyClass.prototype -> Object.prototype:', Object.getPrototypeOf(MyClass.prototype) === Object.prototype);
    },
    
    /**
     * 创建无原型对象
     */
    nullPrototypeObjects() {
        console.log('=== 无原型对象 ===');
        
        // 创建无原型对象
        const nullProtoObj = Object.create(null);
        
        console.log('无原型对象:', nullProtoObj);
        console.log('无原型对象的原型:', Object.getPrototypeOf(nullProtoObj)); // null
        
        // 无原型对象没有Object.prototype的方法
        console.log('有toString方法?:', nullProtoObj.toString); // undefined
        console.log('有hasOwnProperty方法?:', nullProtoObj.hasOwnProperty); // undefined
        
        // 添加属性
        nullProtoObj.name = 'null proto object';
        nullProtoObj.getValue = function() {
            return this.name;
        };
        
        console.log('调用自定义方法:', nullProtoObj.getValue());
        
        // 用途：创建纯净的字典对象
        const dictionary = Object.create(null);
        dictionary.toString = 'not a method'; // 不会与Object.prototype.toString冲突
        dictionary.hasOwnProperty = 'also not a method';
        
        console.log('字典对象:', dictionary);
        console.log('toString值:', dictionary.toString);
        
        // 对比普通对象
        const normalDict = {};
        try {
            normalDict.toString = 'this will work';
            console.log('普通对象toString:', normalDict.toString); // 'this will work'
            console.log('但调用toString()会出错:', typeof normalDict.toString());
        } catch (e) {
            console.log('普通对象toString方法被覆盖');
        }
    },
    
    /**
     * 原型链的遍历
     */
    prototypeChainTraversal() {
        console.log('=== 原型链遍历 ===');
        
        // 遍历原型链的工具函数
        function getPrototypeChain(obj) {
            const chain = [];
            let current = obj;
            
            while (current !== null) {
                chain.push({
                    object: current,
                    constructor: current.constructor?.name || 'Unknown',
                    isPrototype: current.constructor?.prototype === current
                });
                current = Object.getPrototypeOf(current);
            }
            
            return chain;
        }
        
        // 测试不同对象的原型链
        function TestClass() {
            this.prop = 'test';
        }
        TestClass.prototype.method = function() {};
        
        const testInstance = new TestClass();
        
        console.log('TestClass实例的原型链:');
        const chain = getPrototypeChain(testInstance);
        chain.forEach((item, index) => {
            console.log(`${index}: ${item.constructor} ${item.isPrototype ? '(prototype)' : '(instance)'}`);
        });
        
        // 内置对象的原型链
        console.log('\nDate实例的原型链:');
        const dateChain = getPrototypeChain(new Date());
        dateChain.forEach((item, index) => {
            console.log(`${index}: ${item.constructor}`);
        });
        
        // 检查原型链中是否包含特定构造函数
        function hasInPrototypeChain(obj, Constructor) {
            let current = obj;
            while (current !== null) {
                if (current.constructor === Constructor) {
                    return true;
                }
                current = Object.getPrototypeOf(current);
            }
            return false;
        }
        
        console.log('TestClass在原型链中?:', hasInPrototypeChain(testInstance, TestClass));
        console.log('Object在原型链中?:', hasInPrototypeChain(testInstance, Object));
        console.log('Array在原型链中?:', hasInPrototypeChain(testInstance, Array));
    }
};

PrototypeChainEndExamples.objectPrototypeEnd();
PrototypeChainEndExamples.nullPrototypeObjects();
PrototypeChainEndExamples.prototypeChainTraversal();
```

---

## 10.3 构造函数

构造函数是JavaScript中创建对象和实现继承的传统方式。

### 构造函数与new操作符

理解new操作符的工作机制：

```javascript
/**
 * 构造函数与new操作符示例
 */
const ConstructorExamples = {
    /**
     * new操作符的工作过程
     */
    newOperatorMechanism() {
        console.log('=== new操作符工作机制 ===');
        
        function Person(name, age) {
            console.log('1. 构造函数开始执行');
            console.log('2. this指向:', this.constructor.name);
            
            this.name = name;
            this.age = age;
            
            console.log('3. 设置实例属性');
            
            // 构造函数可以返回对象
            // return { custom: 'object' }; // 会替换默认返回的实例
        }
        
        Person.prototype.greet = function() {
            return `Hello, I'm ${this.name}`;
        };
        
        console.log('调用new Person():');
        const person = new Person('Alice', 25);
        
        console.log('4. 返回实例:', person);
        console.log('5. 实例类型:', person instanceof Person);
        console.log('6. 原型链连接:', Object.getPrototypeOf(person) === Person.prototype);
        console.log('7. 调用原型方法:', person.greet());
    },
    
    /**
     * 手动实现new操作符
     */
    implementNew() {
        console.log('=== 手动实现new ===');
        
        function myNew(Constructor, ...args) {
            // 1. 创建空对象
            const obj = {};
            
            // 2. 设置原型链
            Object.setPrototypeOf(obj, Constructor.prototype);
            
            // 3. 调用构造函数，绑定this
            const result = Constructor.apply(obj, args);
            
            // 4. 返回对象（如果构造函数返回对象，则返回该对象）
            return (typeof result === 'object' && result !== null) ? result : obj;
        }
        
        function Car(brand, model) {
            this.brand = brand;
            this.model = model;
        }
        
        Car.prototype.getInfo = function() {
            return `${this.brand} ${this.model}`;
        };
        
        // 使用自定义new
        const car1 = myNew(Car, 'Toyota', 'Camry');
        const car2 = new Car('Honda', 'Civic');
        
        console.log('自定义new创建:', car1.getInfo());
        console.log('原生new创建:', car2.getInfo());
        console.log('两者类型相同:', car1 instanceof Car, car2 instanceof Car);
        console.log('原型相同:', Object.getPrototypeOf(car1) === Object.getPrototypeOf(car2));
    },
    
    /**
     * 构造函数的边界情况
     */
    constructorEdgeCases() {
        console.log('=== 构造函数边界情况 ===');
        
        // 忘记使用new
        function User(name) {
            this.name = name;
            
            // 防御性检查
            if (!(this instanceof User)) {
                console.log('检测到直接调用，自动使用new');
                return new User(name);
            }
        }
        
        const user1 = new User('Alice');
        const user2 = User('Bob'); // 忘记new
        
        console.log('user1:', user1);
        console.log('user2:', user2);
        console.log('两者都是User实例:', user1 instanceof User, user2 instanceof User);
        
        // 构造函数返回对象
        function SpecialConstructor() {
            this.normal = 'property';
            
            return {
                special: 'returned object',
                getType: function() { return 'special'; }
            };
        }
        
        const special = new SpecialConstructor();
        console.log('返回对象的构造函数:', special);
        console.log('instanceof检查:', special instanceof SpecialConstructor); // false!
        
        // 构造函数返回基本类型（被忽略）
        function PrimitiveReturn() {
            this.value = 'instance';
            return 'primitive'; // 被忽略
        }
        
        const primitive = new PrimitiveReturn();
        console.log('返回基本类型被忽略:', primitive);
        
        // 箭头函数不能作为构造函数
        const ArrowConstructor = () => {
            this.value = 'arrow';
        };
        
        try {
            const arrow = new ArrowConstructor();
        } catch (e) {
            console.log('箭头函数构造错误:', e.message);
        }
    }
};

ConstructorExamples.newOperatorMechanism();
ConstructorExamples.implementNew();
ConstructorExamples.constructorEdgeCases();
```

### 实例属性vs原型属性

理解实例属性和原型属性的区别：

```javascript
/**
 * 实例属性vs原型属性示例
 */
const InstanceVsPrototypeExamples = {
    /**
     * 属性存储位置
     */
    propertyLocation() {
        console.log('=== 属性存储位置 ===');
        
        function Student(name, grade) {
            // 实例属性
            this.name = name;
            this.grade = grade;
            this.id = Math.random().toString(36).substr(2, 9);
        }
        
        // 原型属性
        Student.prototype.school = 'Default School';
        Student.prototype.getInfo = function() {
            return `${this.name} (Grade ${this.grade}) at ${this.school}`;
        };
        
        const student1 = new Student('Alice', 10);
        const student2 = new Student('Bob', 11);
        
        console.log('实例属性（每个对象独有）:');
        console.log('student1.name:', student1.name);
        console.log('student2.name:', student2.name);
        console.log('student1.id === student2.id:', student1.id === student2.id);
        
        console.log('原型属性（所有实例共享）:');
        console.log('student1.school:', student1.school);
        console.log('student2.school:', student2.school);
        console.log('共享同一个原型:', Object.getPrototypeOf(student1) === Object.getPrototypeOf(student2));
        
        // 修改原型属性影响所有实例
        Student.prototype.school = 'New School';
        console.log('修改原型后 student1.school:', student1.school);
        console.log('修改原型后 student2.school:', student2.school);
        
        // 实例属性遮蔽原型属性
        student1.school = 'Private School';
        console.log('student1遮蔽后:', student1.school);
        console.log('student2未受影响:', student2.school);
    },
    
    /**
     * 属性检查方法
     */
    propertyChecking() {
        console.log('=== 属性检查方法 ===');
        
        function Vehicle(type) {
            this.type = type;
            this.instanceProp = 'instance';
        }
        
        Vehicle.prototype.prototypeProp = 'prototype';
        Vehicle.prototype.sharedProp = 'shared';
        
        const car = new Vehicle('car');
        car.sharedProp = 'instance override';
        
        // 不同的属性检查方法
        console.log('属性存在性检查:');
        console.log('hasOwnProperty instanceProp:', car.hasOwnProperty('instanceProp'));
        console.log('hasOwnProperty prototypeProp:', car.hasOwnProperty('prototypeProp'));
        console.log('hasOwnProperty sharedProp:', car.hasOwnProperty('sharedProp'));
        
        console.log('in操作符检查:');
        console.log('instanceProp in car:', 'instanceProp' in car);
        console.log('prototypeProp in car:', 'prototypeProp' in car);
        console.log('nonExistent in car:', 'nonExistent' in car);
        
        // Object.hasOwn (ES2022)
        console.log('Object.hasOwn检查:');
        console.log('Object.hasOwn instanceProp:', Object.hasOwn(car, 'instanceProp'));
        console.log('Object.hasOwn prototypeProp:', Object.hasOwn(car, 'prototypeProp'));
        
        // 获取所有属性
        console.log('获取属性列表:');
        console.log('Object.keys(car):', Object.keys(car));
        console.log('Object.getOwnPropertyNames(car):', Object.getOwnPropertyNames(car));
        console.log('for...in遍历:', (() => {
            const props = [];
            for (let prop in car) {
                props.push(prop);
            }
            return props;
        })());
    },
    
    /**
     * 性能考虑
     */
    performanceConsiderations() {
        console.log('=== 性能考虑 ===');
        
        // 实例方法 vs 原型方法的性能差异
        function InstanceMethods(value) {
            this.value = value;
            
            // 每个实例都创建新的方法（浪费内存）
            this.getValue = function() {
                return this.value;
            };
            
            this.double = function() {
                return this.value * 2;
            };
        }
        
        function PrototypeMethods(value) {
            this.value = value;
        }
        
        // 所有实例共享方法（节省内存）
        PrototypeMethods.prototype.getValue = function() {
            return this.value;
        };
        
        PrototypeMethods.prototype.double = function() {
            return this.value * 2;
        };
        
        // 创建大量实例测试内存使用
        console.time('实例方法创建时间');
        const instanceObjects = [];
        for (let i = 0; i < 1000; i++) {
            instanceObjects.push(new InstanceMethods(i));
        }
        console.timeEnd('实例方法创建时间');
        
        console.time('原型方法创建时间');
        const prototypeObjects = [];
        for (let i = 0; i < 1000; i++) {
            prototypeObjects.push(new PrototypeMethods(i));
        }
        console.timeEnd('原型方法创建时间');
        
        // 方法调用性能（原型方法略慢，但差异很小）
        console.time('实例方法调用');
        for (let i = 0; i < 10000; i++) {
            instanceObjects[0].getValue();
        }
        console.timeEnd('实例方法调用');
        
        console.time('原型方法调用');
        for (let i = 0; i < 10000; i++) {
            prototypeObjects[0].getValue();
        }
        console.timeEnd('原型方法调用');
        
        console.log('建议：方法放在原型上，属性放在实例上');
    }
};

InstanceVsPrototypeExamples.propertyLocation();
InstanceVsPrototypeExamples.propertyChecking();
InstanceVsPrototypeExamples.performanceConsiderations();
```

### 构造函数的问题与优化

传统构造函数的问题和现代解决方案：

```javascript
/**
 * 构造函数优化示例
 */
const ConstructorOptimizationExamples = {
    /**
     * 传统构造函数的问题
     */
    traditionalProblems() {
        console.log('=== 传统构造函数问题 ===');
        
        // 问题1：忘记new导致全局污染
        function BadConstructor(name) {
            this.name = name; // 如果没有new，this指向window
        }
        
        // 问题2：每个实例都创建方法
        function WastefulConstructor(name) {
            this.name = name;
            this.greet = function() { // 每个实例都创建新函数
                return `Hello, ${this.name}`;
            };
        }
        
        const obj1 = new WastefulConstructor('Alice');
        const obj2 = new WastefulConstructor('Bob');
        console.log('方法是否相同:', obj1.greet === obj2.greet); // false
        
        // 问题3：原型链设置复杂
        function Parent() {}
        function Child() {}
        Child.prototype = Object.create(Parent.prototype);
        Child.prototype.constructor = Child; // 容易忘记
        
        console.log('传统构造函数存在的问题需要小心处理');
    },
    
    /**
     * 现代优化方案
     */
    modernSolutions() {
        console.log('=== 现代优化方案 ===');
        
        // 解决方案1：工厂函数
        function createUser(name, email) {
            const user = {
                name,
                email,
                greet() {
                    return `Hello, I'm ${this.name}`;
                },
                getEmail() {
                    return this.email;
                }
            };
            
            // 可以添加私有变量
            let loginCount = 0;
            user.login = function() {
                loginCount++;
                console.log(`${this.name} login count: ${loginCount}`);
            };
            
            return user;
        }
        
        const user1 = createUser('Alice', 'alice@example.com');
        const user2 = createUser('Bob', 'bob@example.com');
        
        user1.login();
        user1.login();
        user2.login();
        
        // 解决方案2：原型工厂
        function createPrototype(proto) {
            function Constructor() {}
            Constructor.prototype = proto;
            return Constructor;
        }
        
        const animalProto = {
            speak() { return `${this.name} speaks`; },
            move() { return `${this.name} moves`; }
        };
        
        const Animal = createPrototype(animalProto);
        const animal = new Animal();
        animal.name = 'Generic';
        console.log('原型工厂创建:', animal.speak());
        
        // 解决方案3：组合继承优化
        function inherit(Child, Parent) {
            Child.prototype = Object.create(Parent.prototype);
            Child.prototype.constructor = Child;
            
            // 添加静态方法继承
            Object.setPrototypeOf(Child, Parent);
        }
        
        function Shape(x, y) {
            this.x = x;
            this.y = y;
        }
        
        Shape.prototype.getPosition = function() {
            return `(${this.x}, ${this.y})`;
        };
        
        function Circle(x, y, radius) {
            Shape.call(this, x, y);
            this.radius = radius;
        }
        
        inherit(Circle, Shape);
        
        Circle.prototype.getArea = function() {
            return Math.PI * this.radius * this.radius;
        };
        
        const circle = new Circle(10, 20, 5);
        console.log('继承优化:', circle.getPosition(), 'Area:', circle.getArea());
    },
    
    /**
     * 混合模式
     */
    hybridPatterns() {
        console.log('=== 混合模式 ===');
        
        // 构造函数 + 原型 + 工厂的混合
        function FlexibleConstructor(config) {
            // 支持对象配置
            if (typeof config === 'object') {
                Object.assign(this, config);
            }
            
            // 支持多种初始化方式
            if (arguments.length > 1) {
                this.name = arguments[0];
                this.value = arguments[1];
            }
        }
        
        FlexibleConstructor.prototype.toString = function() {
            return `${this.name}: ${this.value}`;
        };
        
        // 添加工厂方法
        FlexibleConstructor.create = function(type, options) {
            const instance = new this(options);
            instance.type = type;
            return instance;
        };
        
        // 添加原型扩展方法
        FlexibleConstructor.extend = function(methods) {
            Object.assign(this.prototype, methods);
            return this;
        };
        
        // 使用示例
        const obj1 = new FlexibleConstructor({name: 'Object1', value: 100});
        const obj2 = new FlexibleConstructor('Object2', 200);
        const obj3 = FlexibleConstructor.create('special', {name: 'Object3', value: 300});
        
        console.log('混合模式结果:');
        console.log(obj1.toString());
        console.log(obj2.toString());
        console.log(obj3.toString(), 'Type:', obj3.type);
        
        // 动态扩展原型
        FlexibleConstructor.extend({
            double() {
                return this.value * 2;
            }
        });
        
        console.log('动态扩展后:', obj1.double());
    }
};

ConstructorOptimizationExamples.traditionalProblems();
ConstructorOptimizationExamples.modernSolutions();
ConstructorOptimizationExamples.hybridPatterns();
```

---

## 10.4 class 与 ES6 面向对象

ES6的class语法提供了更清晰的面向对象编程方式。

### class语法糖

class本质上是构造函数的语法糖：

```javascript
/**
 * class语法糖示例
 */
const ClassSyntaxExamples = {
    /**
     * class vs 构造函数对比
     */
    classVsConstructor() {
        console.log('=== class vs 构造函数 ===');
        
        // 传统构造函数方式
        function TraditionalPerson(name, age) {
            this.name = name;
            this.age = age;
        }
        
        TraditionalPerson.prototype.greet = function() {
            return `Hello, I'm ${this.name}`;
        };
        
        TraditionalPerson.prototype.getAge = function() {
            return this.age;
        };
        
        // ES6 class方式
        class ModernPerson {
            constructor(name, age) {
                this.name = name;
                this.age = age;
            }
            
            greet() {
                return `Hello, I'm ${this.name}`;
            }
            
            getAge() {
                return this.age;
            }
        }
        
        const traditional = new TraditionalPerson('Alice', 25);
        const modern = new ModernPerson('Bob', 30);
        
        console.log('传统方式:', traditional.greet());
        console.log('class方式:', modern.greet());
        
        // 本质相同
        console.log('class是函数:', typeof ModernPerson); // function
        console.log('有prototype:', ModernPerson.prototype);
        console.log('方法在原型上:', ModernPerson.prototype.greet);
        
        // 原型链相同
        console.log('原型链相同:', 
            Object.getPrototypeOf(traditional) === TraditionalPerson.prototype,
            Object.getPrototypeOf(modern) === ModernPerson.prototype
        );
    },
    
    /**
     * class的特性
     */
    classFeatures() {
        console.log('=== class特性 ===');
        
        class Example {
            constructor(value) {
                this.value = value;
            }
            
            // 方法定义（自动添加到原型）
            method() {
                return `Method called with ${this.value}`;
            }
            
            // getter
            get formattedValue() {
                return `Value: ${this.value}`;
            }
            
            // setter
            set formattedValue(newValue) {
                // 可以包含验证逻辑
                if (typeof newValue === 'string' && newValue.startsWith('Value: ')) {
                    this.value = newValue.substring(7);
                }
            }
            
            // 静态方法
            static createDefault() {
                return new Example('default');
            }
            
            // 静态属性
            static TYPE = 'Example';
        }
        
        const example = new Example('test');
        
        console.log('实例方法:', example.method());
        console.log('getter:', example.formattedValue);
        
        example.formattedValue = 'Value: new test';
        console.log('setter后:', example.value);
        
        console.log('静态方法:', Example.createDefault().value);
        console.log('静态属性:', Example.TYPE);
        
        // class不能直接调用
        try {
            Example('test');
        } catch (e) {
            console.log('class必须用new:', e.message);
        }
        
        // 方法不可枚举
        console.log('方法不可枚举:', Object.keys(example));
        console.log('方法存在:', Object.getOwnPropertyNames(Object.getPrototypeOf(example)));
    },
    
    /**
     * class表达式
     */
    classExpressions() {
        console.log('=== class表达式 ===');
        
        // 匿名class表达式
        const Rectangle = class {
            constructor(width, height) {
                this.width = width;
                this.height = height;
            }
            
            get area() {
                return this.width * this.height;
            }
        };
        
        // 命名class表达式
        const Circle = class CircleClass {
            constructor(radius) {
                this.radius = radius;
            }
            
            get area() {
                return Math.PI * this.radius ** 2;
            }
            
            // 内部可以使用CircleClass名称
            static createUnit() {
                return new CircleClass(1);
            }
        };
        
        const rect = new Rectangle(10, 5);
        const circle = new Circle(3);
        
        console.log('矩形面积:', rect.area);
        console.log('圆形面积:', circle.area.toFixed(2));
        console.log('单位圆:', Circle.createUnit().area.toFixed(2));
        
        // 动态class创建
        function createShapeClass(type) {
            return class {
                constructor(...args) {
                    this.type = type;
                    this.args = args;
                }
                
                getInfo() {
                    return `${this.type}: ${this.args.join(', ')}`;
                }
            };
        }
        
        const Triangle = createShapeClass('triangle');
        const triangle = new Triangle(3, 4, 5);
        console.log('动态创建:', triangle.getInfo());
    }
};

ClassSyntaxExamples.classVsConstructor();
ClassSyntaxExamples.classFeatures();
ClassSyntaxExamples.classExpressions();
```

### 实例方法与静态方法

class中的方法分类和使用场景：

```javascript
/**
 * 实例方法与静态方法示例
 */
const ClassMethodExamples = {
    /**
     * 方法类型对比
     */
    methodTypes() {
        console.log('=== 方法类型对比 ===');
        
        class MathUtils {
            constructor(value) {
                this.value = value;
            }
            
            // 实例方法（原型方法）
            square() {
                return this.value * this.value;
            }
            
            cube() {
                return this.value ** 3;
            }
            
            // 静态方法（类方法）
            static add(a, b) {
                return a + b;
            }
            
            static multiply(a, b) {
                return a * b;
            }
            
            static PI = Math.PI;
            
            // 静态方法中不能访问this.value
            static createSquare(side) {
                return new MathUtils(side);
            }
        }
        
        const math = new MathUtils(5);
        
        console.log('实例方法调用:');
        console.log('square:', math.square());
        console.log('cube:', math.cube());
        
        console.log('静态方法调用:');
        console.log('add:', MathUtils.add(10, 20));
        console.log('multiply:', MathUtils.multiply(3, 4));
        console.log('PI:', MathUtils.PI);
        
        console.log('静态工厂方法:');
        const square = MathUtils.createSquare(3);
        console.log('created square area:', square.square());
        
        // 实例不能访问静态方法
        console.log('实例访问静态方法:', math.add); // undefined
        console.log('类访问实例方法:', MathUtils.square); // undefined
    },
    
    /**
     * 高级方法模式
     */
    advancedMethodPatterns() {
        console.log('=== 高级方法模式 ===');
        
        class FluentAPI {
            constructor(value = 0) {
                this.value = value;
            }
            
            // 链式调用方法
            add(n) {
                this.value += n;
                return this; // 返回this支持链式调用
            }
            
            multiply(n) {
                this.value *= n;
                return this;
            }
            
            subtract(n) {
                this.value -= n;
                return this;
            }
            
            // 终结方法
            result() {
                return this.value;
            }
            
            // 静态链式创建
            static create(value) {
                return new FluentAPI(value);
            }
            
            // 条件方法
            if(condition, callback) {
                if (condition) {
                    callback(this);
                }
                return this;
            }
        }
        
        // 链式调用示例
        const result1 = FluentAPI
            .create(10)
            .add(5)
            .multiply(2)
            .subtract(3)
            .result();
        
        console.log('链式调用结果:', result1);
        
        // 条件链式调用
        const result2 = new FluentAPI(100)
            .if(true, api => api.add(50))
            .if(false, api => api.multiply(10))
            .multiply(2)
            .result();
        
        console.log('条件链式结果:', result2);
        
        // 方法装饰器模式
        class Logger {
            static methodLogger(target, propertyKey, descriptor) {
                const originalMethod = descriptor.value;
                
                descriptor.value = function(...args) {
                    console.log(`调用方法 ${propertyKey}，参数:`, args);
                    const result = originalMethod.apply(this, args);
                    console.log(`方法 ${propertyKey} 返回:`, result);
                    return result;
                };
                
                return descriptor;
            }
        }
        
        class Calculator {
            @Logger.methodLogger
            add(a, b) {
                return a + b;
            }
            
            // 手动应用装饰器（如果环境不支持decorator语法）
            multiply(a, b) {
                return a * b;
            }
        }
        
        // 手动应用装饰器
        Logger.methodLogger(Calculator.prototype, 'multiply', Object.getOwnPropertyDescriptor(Calculator.prototype, 'multiply'));
        
        const calc = new Calculator();
        console.log('装饰器示例:');
        calc.add(10, 5);
        calc.multiply(3, 4);
    }
};

ClassMethodExamples.methodTypes();
ClassMethodExamples.advancedMethodPatterns();
```

### getter/setter

属性访问器的高级用法：

```javascript
/**
 * getter/setter高级示例
 */
const GetterSetterExamples = {
    /**
     * 基本访问器
     */
    basicAccessors() {
        console.log('=== 基本访问器 ===');
        
        class Person {
            constructor(firstName, lastName) {
                this._firstName = firstName;
                this._lastName = lastName;
                this._age = 0;
            }
            
            // getter - 计算属性
            get fullName() {
                return `${this._firstName} ${this._lastName}`;
            }
            
            // setter - 解析并设置
            set fullName(value) {
                const parts = value.split(' ');
                this._firstName = parts[0] || '';
                this._lastName = parts[1] || '';
            }
            
            get age() {
                return this._age;
            }
            
            set age(value) {
                if (value < 0 || value > 150) {
                    throw new Error('年龄必须在0-150之间');
                }
                this._age = value;
            }
            
            // 只读属性
            get isAdult() {
                return this._age >= 18;
            }
        }
        
        const person = new Person('John', 'Doe');
        
        console.log('初始全名:', person.fullName);
        
        person.fullName = 'Jane Smith';
        console.log('设置后:', person._firstName, person._lastName);
        
        person.age = 25;
        console.log('年龄:', person.age);
        console.log('是否成年:', person.isAdult);
        
        try {
            person.age = -5;
        } catch (e) {
            console.log('年龄验证错误:', e.message);
        }
    },
    
    /**
     * 高级访问器模式
     */
    advancedAccessors() {
        console.log('=== 高级访问器模式 ===');
        
        class SmartCache {
            constructor() {
                this._cache = new Map();
                this._computeCount = 0;
            }
            
            // 懒加载getter
            get expensiveData() {
                if (!this._cache.has('expensiveData')) {
                    console.log('计算昂贵的数据...');
                    this._computeCount++;
                    
                    // 模拟复杂计算
                    const result = Array.from({length: 1000}, (_, i) => i * i);
                    this._cache.set('expensiveData', result);
                }
                
                return this._cache.get('expensiveData');
            }
            
            get computeCount() {
                return this._computeCount;
            }
            
            // 缓存清理
            clearCache() {
                this._cache.clear();
            }
        }
        
        const cache = new SmartCache();
        
        console.log('第一次访问计算次数:', cache.computeCount);
        const data1 = cache.expensiveData;
        console.log('计算后次数:', cache.computeCount);
        
        const data2 = cache.expensiveData; // 使用缓存
        console.log('再次访问后次数:', cache.computeCount);
        console.log('数据相同:', data1 === data2);
        
        // 代理模式的访问器
        class ValidatedObject {
            constructor() {
                this._data = {};
                this._validators = {};
            }
            
            addValidator(key, validator) {
                this._validators[key] = validator;
            }
            
            // 动态getter/setter
            defineProperty(key, initialValue) {
                this._data[key] = initialValue;
                
                Object.defineProperty(this, key, {
                    get() {
                        console.log(`Getting ${key}: ${this._data[key]}`);
                        return this._data[key];
                    },
                    set(value) {
                        console.log(`Setting ${key}: ${value}`);
                        
                        if (this._validators[key]) {
                            const isValid = this._validators[key](value);
                            if (!isValid) {
                                throw new Error(`Invalid value for ${key}: ${value}`);
                            }
                        }
                        
                        this._data[key] = value;
                    },
                    enumerable: true,
                    configurable: true
                });
            }
        }
        
        const validatedObj = new ValidatedObject();
        
        // 添加验证器
        validatedObj.addValidator('email', value => 
            typeof value === 'string' && value.includes('@')
        );
        
        // 定义属性
        validatedObj.defineProperty('email', 'test@example.com');
        validatedObj.defineProperty('name', 'John');
        
        console.log('访问email:', validatedObj.email);
        
        try {
            validatedObj.email = 'invalid-email';
        } catch (e) {
            console.log('验证失败:', e.message);
        }
        
        validatedObj.email = 'new@example.com';
        console.log('新email:', validatedObj.email);
    },
    
    /**
     * 访问器继承
     */
    accessorInheritance() {
        console.log('=== 访问器继承 ===');
        
        class BaseModel {
            constructor() {
                this._data = {};
                this._changed = new Set();
            }
            
            get(key) {
                return this._data[key];
            }
            
            set(key, value) {
                if (this._data[key] !== value) {
                    this._data[key] = value;
                    this._changed.add(key);
                }
            }
            
            get hasChanges() {
                return this._changed.size > 0;
            }
            
            get changedFields() {
                return Array.from(this._changed);
            }
            
            clearChanges() {
                this._changed.clear();
            }
        }
        
        class User extends BaseModel {
            constructor(name, email) {
                super();
                this.set('name', name);
                this.set('email', email);
                this.clearChanges(); // 初始化后清除变更标记
            }
            
            get name() {
                return this.get('name');
            }
            
            set name(value) {
                if (!value || value.trim().length === 0) {
                    throw new Error('名称不能为空');
                }
                this.set('name', value.trim());
            }
            
            get email() {
                return this.get('email');
            }
            
            set email(value) {
                if (!value || !value.includes('@')) {
                    throw new Error('无效的邮箱格式');
                }
                this.set('email', value.toLowerCase());
            }
            
            // 重写父类访问器
            get hasChanges() {
                const baseHasChanges = super.hasChanges;
                console.log(`检查用户 ${this.name} 是否有变更: ${baseHasChanges}`);
                return baseHasChanges;
            }
        }
        
        const user = new User('John Doe', 'JOHN@EXAMPLE.COM');
        
        console.log('初始用户:', user.name, user.email);
        console.log('初始是否有变更:', user.hasChanges);
        
        user.name = '  Jane Smith  ';
        console.log('修改姓名后:', user.name);
        console.log('变更字段:', user.changedFields);
        console.log('是否有变更:', user.hasChanges);
        
        user.email = 'JANE@EXAMPLE.COM';
        console.log('修改邮箱后:', user.email);
        console.log('变更字段:', user.changedFields);
    }
};

GetterSetterExamples.basicAccessors();
GetterSetterExamples.advancedAccessors();
GetterSetterExamples.accessorInheritance();
```

### 私有属性

JavaScript中的私有属性实现：

```javascript
/**
 * 私有属性示例
 */
const PrivatePropertyExamples = {
    /**
     * ES2022私有字段
     */
    es2022PrivateFields() {
        console.log('=== ES2022私有字段 ===');
        
        class BankAccount {
            // 私有字段
            #balance = 0;
            #accountNumber;
            #transactions = [];
            
            // 静态私有字段
            static #bankName = 'SecureBank';
            
            constructor(initialBalance, accountNumber) {
                if (initialBalance < 0) {
                    throw new Error('初始余额不能为负数');
                }
                this.#balance = initialBalance;
                this.#accountNumber = accountNumber;
                this.#addTransaction('开户', initialBalance);
            }
            
            // 私有方法
            #addTransaction(type, amount) {
                this.#transactions.push({
                    type,
                    amount,
                    timestamp: new Date(),
                    balance: this.#balance
                });
            }
            
            #validateAmount(amount) {
                if (amount <= 0) {
                    throw new Error('金额必须大于0');
                }
            }
            
            // 公共方法
            deposit(amount) {
                this.#validateAmount(amount);
                this.#balance += amount;
                this.#addTransaction('存款', amount);
                return this.#balance;
            }
            
            withdraw(amount) {
                this.#validateAmount(amount);
                if (amount > this.#balance) {
                    throw new Error('余额不足');
                }
                this.#balance -= amount;
                this.#addTransaction('取款', -amount);
                return this.#balance;
            }
            
            get balance() {
                return this.#balance;
            }
            
            get accountNumber() {
                // 返回脱敏的账号
                return this.#accountNumber.replace(/\d(?=\d{4})/g, '*');
            }
            
            getTransactionHistory() {
                // 返回交易历史的副本
                return this.#transactions.map(t => ({...t}));
            }
            
            // 静态方法访问静态私有字段
            static getBankName() {
                return this.#bankName;
            }
        }
        
        const account = new BankAccount(1000, '1234567890123456');
        
        console.log('账户余额:', account.balance);
        console.log('账号:', account.accountNumber);
        
        account.deposit(500);
        console.log('存款后余额:', account.balance);
        
        account.withdraw(200);
        console.log('取款后余额:', account.balance);
        
        // 尝试直接访问私有字段（会报错或返回undefined）
        console.log('尝试访问私有字段:', account.#balance); // SyntaxError
        
        console.log('银行名称:', BankAccount.getBankName());
        console.log('交易历史:', account.getTransactionHistory());
    },
    
    /**
     * 传统私有化方法
     */
    traditionalPrivacy() {
        console.log('=== 传统私有化方法 ===');
        
        // 方法1：闭包私有化
        function createCounter() {
            let count = 0;
            let step = 1;
            
            return {
                increment() {
                    count += step;
                    return count;
                },
                
                decrement() {
                    count -= step;
                    return count;
                },
                
                getCount() {
                    return count;
                },
                
                setStep(newStep) {
                    if (newStep > 0) {
                        step = newStep;
                    }
                },
                
                getStep() {
                    return step;
                }
            };
        }
        
        const counter = createCounter();
        
        console.log('初始计数:', counter.getCount());
        console.log('增加后:', counter.increment());
        console.log('增加后:', counter.increment());
        
        counter.setStep(5);
        console.log('设置步长为5后增加:', counter.increment());
        
        // 方法2：WeakMap私有化
        const privateData = new WeakMap();
        
        class SecureUser {
            constructor(username, password) {
                // 私有数据存储在WeakMap中
                privateData.set(this, {
                    username,
                    password,
                    loginAttempts: 0,
                    isLocked: false
                });
            }
            
            login(password) {
                const data = privateData.get(this);
                
                if (data.isLocked) {
                    throw new Error('账户已锁定');
                }
                
                if (data.password === password) {
                    data.loginAttempts = 0;
                    return true;
                } else {
                    data.loginAttempts++;
                    if (data.loginAttempts >= 3) {
                        data.isLocked = true;
                        throw new Error('登录失败次数过多，账户已锁定');
                    }
                    throw new Error(`登录失败，还有 ${3 - data.loginAttempts} 次机会`);
                }
            }
            
            getUsername() {
                return privateData.get(this).username;
            }
            
            changePassword(oldPassword, newPassword) {
                const data = privateData.get(this);
                
                if (data.password !== oldPassword) {
                    throw new Error('原密码错误');
                }
                
                if (newPassword.length < 6) {
                    throw new Error('新密码长度至少6位');
                }
                
                data.password = newPassword;
                return true;
            }
            
            unlock() {
                const data = privateData.get(this);
                data.isLocked = false;
                data.loginAttempts = 0;
            }
        }
        
        const user = new SecureUser('alice', 'secret123');
        
        console.log('用户名:', user.getUsername());
        
        try {
            user.login('wrong');
        } catch (e) {
            console.log('登录失败:', e.message);
        }
        
        console.log('正确登录:', user.login('secret123'));
        
        user.changePassword('secret123', 'newpassword');
        console.log('密码修改成功，新密码登录:', user.login('newpassword'));
        
        // 方法3：Symbol私有化（不是真正私有，但不容易被发现）
        const _balance = Symbol('balance');
        const _validateAmount = Symbol('validateAmount');
        
        class SymbolPrivateAccount {
            constructor(initialBalance) {
                this[_balance] = initialBalance;
            }
            
            [_validateAmount](amount) {
                if (amount <= 0) {
                    throw new Error('金额必须大于0');
                }
            }
            
            deposit(amount) {
                this[_validateAmount](amount);
                this[_balance] += amount;
                return this[_balance];
            }
            
            get balance() {
                return this[_balance];
            }
        }
        
        const symbolAccount = new SymbolPrivateAccount(1000);
        console.log('Symbol私有化账户余额:', symbolAccount.balance);
        symbolAccount.deposit(200);
        console.log('存款后余额:', symbolAccount.balance);
        
        // Symbol属性不会出现在正常枚举中
        console.log('可枚举属性:', Object.keys(symbolAccount));
        console.log('但可以通过Symbol访问:', Object.getOwnPropertySymbols(symbolAccount));
    }
};

PrivatePropertyExamples.es2022PrivateFields();
PrivatePropertyExamples.traditionalPrivacy();
```

---

## 10.5 super、继承、封装

JavaScript继承机制的完整实现。

### 原型继承

传统的原型继承模式：

```javascript
/**
 * 原型继承示例
 */
const PrototypeInheritanceExamples = {
    /**
     * 基本原型继承
     */
    basicInheritance() {
        console.log('=== 基本原型继承 ===');
        
        // 父类构造函数
        function Animal(name) {
            this.name = name;
            this.energy = 100;
        }
        
        Animal.prototype.eat = function() {
            this.energy += 10;
            return `${this.name} is eating. Energy: ${this.energy}`;
        };
        
        Animal.prototype.sleep = function() {
            this.energy += 20;
            return `${this.name} is sleeping. Energy: ${this.energy}`;
        };
        
        // 子类构造函数
        function Dog(name, breed) {
            Animal.call(this, name); // 调用父类构造函数
            this.breed = breed;
        }
        
        // 设置原型链
        Dog.prototype = Object.create(Animal.prototype);
        Dog.prototype.constructor = Dog;
        
        // 添加子类特有方法
        Dog.prototype.bark = function() {
            this.energy -= 5;
            return `${this.name} is barking! Woof! Energy: ${this.energy}`;
        };
        
        // 重写父类方法
        Dog.prototype.eat = function() {
            this.energy += 15; // 狗吃东西恢复更多能量
            return `${this.name} (${this.breed}) is eating dog food. Energy: ${this.energy}`;
        };
        
        const dog = new Dog('Buddy', 'Golden Retriever');
        
        console.log('狗的信息:', dog.name, dog.breed);
        console.log(dog.eat());
        console.log(dog.bark());
        console.log(dog.sleep());
        
        console.log('继承检查:', dog instanceof Dog, dog instanceof Animal);
    },
    
    /**
     * 多级继承
     */
    multiLevelInheritance() {
        console.log('=== 多级继承 ===');
        
        // 祖父类
        function LivingThing() {
            this.alive = true;
        }
        
        LivingThing.prototype.breathe = function() {
            return 'Breathing...';
        };
        
        // 父类
        function Animal(name) {
            LivingThing.call(this);
            this.name = name;
        }
        
        Animal.prototype = Object.create(LivingThing.prototype);
        Animal.prototype.constructor = Animal;
        
        Animal.prototype.move = function() {
            return `${this.name} is moving`;
        };
        
        // 子类
        function Mammal(name, warmBlooded = true) {
            Animal.call(this, name);
            this.warmBlooded = warmBlooded;
        }
        
        Mammal.prototype = Object.create(Animal.prototype);
        Mammal.prototype.constructor = Mammal;
        
        Mammal.prototype.regulateTemperature = function() {
            return this.warmBlooded ? `${this.name} maintains body temperature` : `${this.name} relies on environment`;
        };
        
        // 孙类
        function Dog(name, breed) {
            Mammal.call(this, name);
            this.breed = breed;
        }
        
        Dog.prototype = Object.create(Mammal.prototype);
        Dog.prototype.constructor = Dog;
        
        Dog.prototype.wagTail = function() {
            return `${this.name} is wagging tail`;
        };
        
        const dog = new Dog('Max', 'Labrador');
        
        console.log('多级继承测试:');
        console.log(dog.breathe()); // 来自LivingThing
        console.log(dog.move()); // 来自Animal
        console.log(dog.regulateTemperature()); // 来自Mammal
        console.log(dog.wagTail()); // 来自Dog
        
        console.log('instanceof检查:');
        console.log('Dog:', dog instanceof Dog);
        console.log('Mammal:', dog instanceof Mammal);
        console.log('Animal:', dog instanceof Animal);
        console.log('LivingThing:', dog instanceof LivingThing);
    }
};

PrototypeInheritanceExamples.basicInheritance();
PrototypeInheritanceExamples.multiLevelInheritance();
```

### class继承

ES6 class的继承机制：

```javascript
/**
 * class继承示例
 */
const ClassInheritanceExamples = {
    /**
     * 基本class继承
     */
    basicClassInheritance() {
        console.log('=== 基本class继承 ===');
        
        class Vehicle {
            constructor(make, model) {
                this.make = make;
                this.model = model;
                this.speed = 0;
            }
            
            accelerate(amount = 10) {
                this.speed += amount;
                return `${this.make} ${this.model} accelerated to ${this.speed} km/h`;
            }
            
            brake(amount = 10) {
                this.speed = Math.max(0, this.speed - amount);
                return `${this.make} ${this.model} slowed to ${this.speed} km/h`;
            }
            
            getInfo() {
                return `${this.make} ${this.model} - Speed: ${this.speed} km/h`;
            }
        }
        
        class Car extends Vehicle {
            constructor(make, model, doors = 4) {
                super(make, model); // 调用父类构造函数
                this.doors = doors;
                this.fuelLevel = 100;
            }
            
            // 重写父类方法
            accelerate(amount = 15) {
                if (this.fuelLevel > 0) {
                    this.fuelLevel -= 2;
                    return super.accelerate(amount) + ` (Fuel: ${this.fuelLevel}%)`;
                }
                return `${this.make} ${this.model} out of fuel!`;
            }
            
            // 新增方法
            refuel() {
                this.fuelLevel = 100;
                return `${this.make} ${this.model} refueled`;
            }
            
            // 重写getInfo
            getInfo() {
                return super.getInfo() + ` - Doors: ${this.doors} - Fuel: ${this.fuelLevel}%`;
            }
        }
        
        const car = new Car('Toyota', 'Camry', 4);
        
        console.log('汽车信息:', car.getInfo());
        console.log(car.accelerate());
        console.log(car.accelerate(20));
        console.log(car.brake(10));
        console.log(car.refuel());
    },
    
    /**
     * super的使用
     */
    superUsage() {
        console.log('=== super的使用 ===');
        
        class Shape {
            constructor(color) {
                this.color = color;
            }
            
            draw() {
                return `Drawing a ${this.color} shape`;
            }
            
            getArea() {
                return 0; // 基类默认实现
            }
        }
        
        class Rectangle extends Shape {
            constructor(color, width, height) {
                super(color); // 调用父类构造函数
                this.width = width;
                this.height = height;
            }
            
            draw() {
                return super.draw() + ` (Rectangle ${this.width}x${this.height})`;
            }
            
            getArea() {
                return this.width * this.height;
            }
        }
        
        class Square extends Rectangle {
            constructor(color, side) {
                super(color, side, side); // 调用Rectangle构造函数
            }
            
            draw() {
                return super.draw().replace('Rectangle', 'Square');
            }
            
            // 添加特有方法
            getDiagonal() {
                return this.width * Math.sqrt(2);
            }
        }
        
        const square = new Square('red', 5);
        
        console.log(square.draw());
        console.log('面积:', square.getArea());
        console.log('对角线:', square.getDiagonal().toFixed(2));
    }
};

ClassInheritanceExamples.basicClassInheritance();
ClassInheritanceExamples.superUsage();
```

---

**本章总结**

第10章深入探讨了JavaScript原型与原型链的核心机制：

1. **prototype的本质**：
   - 函数的prototype属性与实例的__proto__关系
   - 原型对象的默认结构和动态修改
   - 原型污染的风险和防范

2. **原型链查找机制**：
   - 属性查找的完整过程和性能影响
   - 方法继承和属性遮蔽现象
   - Object.prototype作为原型链终点

3. **构造函数**：
   - new操作符的工作机制
   - 实例属性vs原型属性的区别
   - 构造函数的问题与现代优化方案

4. **ES6 class**：
   - class作为构造函数的语法糖
   - 实例方法、静态方法和访问器
   - 私有属性的实现方式

5. **继承与封装**：
   - 原型继承的传统模式
   - class继承和super的使用
   - 多种封装模式的对比

**关键要点**：
- 原型链是JavaScript继承的基础机制
- 属性查找沿着原型链进行，理解查找顺序很重要
- class语法提供了更清晰的面向对象编程方式
- 私有属性有多种实现方案，ES2022的#语法最为标准

**下一章预告**

第11章将学习数组与高阶方法，包括数组的本质、常用数组方法、迭代器模式、map/filter/reduce等高阶方法，以及实际项目中的数组处理模式。
