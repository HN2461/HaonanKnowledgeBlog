# 第23章 执行上下文与作用域链

> 理解执行上下文与作用域链是掌握JavaScript运行机制的关键。这些概念解释了变量查找、函数调用、闭包原理等核心问题。

---

## 23.1 执行上下文创建

### 23.1.1 什么是执行上下文

```javascript
/**
 * 执行上下文的概念演示
 */

// 全局执行上下文
var globalVar = 'global';

function outer() {
    // outer 函数执行上下文
    var outerVar = 'outer';
    
    function inner() {
        // inner 函数执行上下文
        var innerVar = 'inner';
        console.log(globalVar); // 可以访问全局变量
        console.log(outerVar);  // 可以访问外层变量
        console.log(innerVar);  // 可以访问自己的变量
    }
    
    inner();
}

outer();

/**
 * 执行上下文栈（调用栈）
 */
console.log('1. 全局执行上下文创建');

function first() {
    console.log('2. first 函数执行上下文创建');
    second();
    console.log('5. first 函数执行上下文销毁');
}

function second() {
    console.log('3. second 函数执行上下文创建');
    third();
    console.log('4. second 函数执行上下文销毁');
}

function third() {
    console.log('4. third 函数执行上下文创建和销毁');
}

first(); // 函数调用链
console.log('6. 全局执行上下文继续执行');
```

### 23.1.2 执行上下文的组成

```javascript
/**
 * 执行上下文的内部结构
 */

// 执行上下文包含三个重要组件：
// 1. 变量环境（Variable Environment）
// 2. 词法环境（Lexical Environment）
// 3. this 绑定

function demonstrateContext() {
    // 变量环境：var 声明的变量和函数声明
    var varVariable = 'var declared';
    
    function functionDeclaration() {
        return 'function declaration';
    }
    
    // 词法环境：let/const 声明的变量
    let letVariable = 'let declared';
    const constVariable = 'const declared';
    
    console.log('执行上下文创建完成');
}

/**
 * 执行上下文创建过程
 */
console.log(typeof myFunction); // 'function' - 函数提升
console.log(myVar); // undefined - 变量提升但未初始化
// console.log(myLet); // ReferenceError - 暂时性死区

var myVar = 'Hello';
let myLet = 'World';

function myFunction() {
    return 'I am hoisted';
}

console.log(myFunction()); // 'I am hoisted'
console.log(myVar); // 'Hello'
console.log(myLet); // 'World'
```

### 23.1.3 执行上下文的生命周期

```javascript
/**
 * 执行上下文生命周期演示
 */

// 1. 创建阶段（Creation Phase）
function creationPhase() {
    console.log('=== 创建阶段 ===');
    
    // 此时变量环境和词法环境已创建
    // 但 let/const 变量在暂时性死区
    
    // console.log(letVar); // ReferenceError
    console.log(varVar); // undefined（已提升但未初始化）
    console.log(funcDecl()); // "function works"（已提升并初始化）
    
    var varVar = 'var value';
    let letVar = 'let value';
    
    function funcDecl() {
        return 'function works';
    }
}

// 2. 执行阶段（Execution Phase）
function executionPhase() {
    console.log('=== 执行阶段 ===');
    
    var step = 1;
    console.log('Step', step++); // 逐行执行代码
    
    let result = calculate(5, 3);
    console.log('Step', step++, 'Result:', result);
    
    function calculate(a, b) {
        return a + b;
    }
}

// 3. 销毁阶段（Destruction Phase）
function destructionPhase() {
    console.log('=== 销毁阶段 ===');
    
    var localVar = 'will be destroyed';
    
    return function() {
        // 闭包保持对外部变量的引用
        console.log('Closure access:', localVar);
    };
    
    // 函数执行完毕，执行上下文被销毁
    // 但由于闭包的存在，变量不会被立即回收
}

creationPhase();
executionPhase();
const closure = destructionPhase();
closure(); // 仍能访问已销毁上下文中的变量
```

---

## 23.2 变量环境与词法环境

### 23.2.1 变量环境（Variable Environment）

```javascript
/**
 * 变量环境的特点
 */

function variableEnvironmentDemo() {
    // 变量环境存储：
    // 1. var 声明的变量
    // 2. 函数声明
    // 3. 函数参数
    
    console.log('=== 变量环境 ===');
    
    // var 声明会被提升到函数顶部
    console.log(hoistedVar); // undefined
    var hoistedVar = 'I am hoisted';
    
    // 函数声明也会被提升
    console.log(hoistedFunction()); // "I am also hoisted"
    
    function hoistedFunction() {
        return 'I am also hoisted';
    }
    
    // 重复声明的处理
    var duplicateVar = 'first';
    var duplicateVar = 'second'; // 不会报错，后者覆盖前者
    console.log(duplicateVar); // 'second'
}

variableEnvironmentDemo();

/**
 * 函数参数在变量环境中
 */
function parameterDemo(param1, param2 = 'default') {
    // 参数存储在变量环境中
    console.log('Parameters:', param1, param2);
    
    // 参数可以被重新赋值
    param1 = 'modified';
    console.log('Modified param1:', param1);
    
    // arguments 对象也在变量环境中
    console.log('Arguments:', arguments.length);
}

parameterDemo('hello', 'world');
```

### 23.2.2 词法环境（Lexical Environment）

```javascript
/**
 * 词法环境的特点
 */

function lexicalEnvironmentDemo() {
    console.log('=== 词法环境 ===');
    
    // let/const 声明存储在词法环境中
    // 有暂时性死区（Temporal Dead Zone）
    
    // console.log(letVar); // ReferenceError: Cannot access before initialization
    
    let letVar = 'let variable';
    const constVar = 'const variable';
    
    console.log(letVar, constVar);
    
    // 块级作用域
    if (true) {
        let blockScoped = 'block scoped';
        const alsoBlockScoped = 'also block scoped';
        var functionScoped = 'function scoped';
        
        console.log('Inside block:', blockScoped, alsoBlockScoped, functionScoped);
    }
    
    // console.log(blockScoped); // ReferenceError
    console.log('Outside block:', functionScoped); // 可以访问
}

lexicalEnvironmentDemo();

/**
 * 词法环境的嵌套
 */
function outerLexical() {
    let outerLet = 'outer let';
    
    function innerLexical() {
        let innerLet = 'inner let';
        
        // 内层可以访问外层的词法环境
        console.log('Inner access outer:', outerLet);
        console.log('Inner access inner:', innerLet);
        
        // 创建更深层的词法环境
        {
            let blockLet = 'block let';
            console.log('Block access all:', outerLet, innerLet, blockLet);
        }
        
        // console.log(blockLet); // ReferenceError
    }
    
    innerLexical();
    // console.log(innerLet); // ReferenceError
}

outerLexical();
```

### 23.2.3 暂时性死区（TDZ）

```javascript
/**
 * 暂时性死区详解
 */

function temporalDeadZoneDemo() {
    console.log('=== 暂时性死区 ===');
    
    // TDZ 开始
    console.log('Before declaration');
    
    // 以下代码会报错
    // console.log(letVariable); // ReferenceError
    // console.log(constVariable); // ReferenceError
    
    // typeof 操作符也会触发 TDZ 错误
    // console.log(typeof letVariable); // ReferenceError
    
    let letVariable = 'let initialized';
    const constVariable = 'const initialized';
    // TDZ 结束
    
    console.log('After declaration:', letVariable, constVariable);
}

temporalDeadZoneDemo();

/**
 * TDZ 在不同作用域中的表现
 */
let globalLet = 'global';

function tdzScopes() {
    console.log('Function start, global let:', globalLet);
    
    // 以下代码会创建新的 TDZ
    // console.log(localLet); // ReferenceError
    
    let localLet = 'local';
    console.log('Local let declared:', localLet);
    
    {
        // 块级作用域的 TDZ
        // console.log(blockLet); // ReferenceError
        let blockLet = 'block';
        console.log('Block let:', blockLet);
    }
}

tdzScopes();

/**
 * 参数默认值与 TDZ
 */
function defaultValueTDZ(a = b, b = 2) {
    // 参数 a 的默认值引用了后面的参数 b
    // 这会导致 TDZ 错误
    return [a, b];
}

// defaultValueTDZ(); // ReferenceError: Cannot access 'b' before initialization

// 正确的方式
function correctDefaultValue(a = 1, b = a + 1) {
    return [a, b];
}

console.log(correctDefaultValue()); // [1, 2]
```

---

## 23.3 作用域链查找

### 23.3.1 作用域链的形成

```javascript
/**
 * 作用域链的基本概念
 */

var global = 'global variable';

function level1() {
    var level1Var = 'level1 variable';
    
    function level2() {
        var level2Var = 'level2 variable';
        
        function level3() {
            var level3Var = 'level3 variable';
            
            // 作用域链查找顺序：
            // level3 -> level2 -> level1 -> global
            console.log('From level3:');
            console.log('- level3Var:', level3Var); // 当前作用域
            console.log('- level2Var:', level2Var); // 上一级作用域
            console.log('- level1Var:', level1Var); // 上两级作用域
            console.log('- global:', global);       // 全局作用域
        }
        
        level3();
    }
    
    level2();
}

level1();

/**
 * 变量遮蔽（Shadowing）
 */
var name = 'Global Name';

function shadowingDemo() {
    var name = 'Function Name'; // 遮蔽全局变量
    
    console.log('Function scope name:', name); // 'Function Name'
    
    {
        let name = 'Block Name'; // 遮蔽函数变量
        console.log('Block scope name:', name); // 'Block Name'
        
        {
            const name = 'Inner Block Name'; // 遮蔽外层块变量
            console.log('Inner block name:', name); // 'Inner Block Name'
        }
        
        console.log('Back to block name:', name); // 'Block Name'
    }
    
    console.log('Back to function name:', name); // 'Function Name'
}

shadowingDemo();
console.log('Global name:', name); // 'Global Name'
```

### 23.3.2 静态作用域与动态查找

```javascript
/**
 * JavaScript 使用静态作用域（词法作用域）
 */

var value = 'global';

function staticScope() {
    var value = 'function';
    
    function inner() {
        console.log('Static scope value:', value);
    }
    
    return inner;
}

function dynamicCaller() {
    var value = 'dynamic';
    var innerFunc = staticScope();
    innerFunc(); // 输出 'function'，不是 'dynamic'
}

dynamicCaller();

/**
 * 词法作用域的查找机制
 */
function createCounter() {
    let count = 0;
    
    return {
        increment() {
            // 查找 count：当前作用域 -> createCounter 作用域
            count++;
            return count;
        },
        
        decrement() {
            count--;
            return count;
        },
        
        getCount() {
            return count;
        }
    };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount()); // 2

/**
 * 复杂的作用域链查找
 */
function complexScopeChain() {
    var a = 1;
    var b = 2;
    
    function middle() {
        var b = 20; // 遮蔽外层的 b
        var c = 3;
        
        function inner() {
            var c = 30; // 遮蔽中间层的 c
            var d = 4;
            
            console.log('作用域链查找结果:');
            console.log('a:', a); // 1（来自 complexScopeChain）
            console.log('b:', b); // 20（来自 middle，遮蔽了外层的 2）
            console.log('c:', c); // 30（来自 inner，遮蔽了中间的 3）
            console.log('d:', d); // 4（来自 inner）
        }
        
        inner();
    }
    
    middle();
}

complexScopeChain();
```

### 23.3.3 作用域链与性能

```javascript
/**
 * 作用域链查找对性能的影响
 */

// 性能较差的例子：深层作用域链查找
function deepScopeChain() {
    var global = window || global;
    
    function level1() {
        function level2() {
            function level3() {
                function level4() {
                    // 每次查找 global 都需要遍历整个作用域链
                    for (let i = 0; i < 1000000; i++) {
                        global.console; // 深层查找
                    }
                }
                level4();
            }
            level3();
        }
        level2();
    }
    level1();
}

// 性能优化：缓存外层变量
function optimizedScopeChain() {
    var global = window || global;
    
    function level1() {
        function level2() {
            function level3() {
                function level4() {
                    // 将经常使用的外层变量缓存到当前作用域
                    var console = global.console;
                    
                    for (let i = 0; i < 1000000; i++) {
                        console; // 本地查找，更快
                    }
                }
                level4();
            }
            level3();
        }
        level2();
    }
    level1();
}

/**
 * 作用域链优化实践
 */
function scopeOptimization() {
    // 1. 缓存全局变量
    var doc = document;
    var win = window;
    
    // 2. 缓存深层属性
    var body = doc.body;
    var style = body.style;
    
    // 3. 在循环中避免重复查找
    for (let i = 0; i < 100; i++) {
        // 差的做法
        // document.body.style.display = 'none';
        
        // 好的做法
        style.display = i % 2 ? 'block' : 'none';
    }
}

/**
 * 闭包与作用域链的关系
 */
function closureAndScope() {
    var outerVar = 'outer';
    
    function createClosure() {
        var middleVar = 'middle';
        
        return function() {
            var innerVar = 'inner';
            
            // 闭包保持了完整的作用域链
            return {
                inner: innerVar,    // 当前作用域
                middle: middleVar,  // 外层作用域
                outer: outerVar     // 更外层作用域
            };
        };
    }
    
    var closure = createClosure();
    return closure;
}

var myClosure = closureAndScope();
console.log(myClosure()); // { inner: 'inner', middle: 'middle', outer: 'outer' }
```

---

## 23.4 闭包的内部机制

### 23.4.1 闭包的形成原理

```javascript
/**
 * 闭包形成的内部机制
 */

function createClosure(x) {
    // 外部函数的执行上下文
    var outerVariable = `outer_${x}`;
    
    // 返回内部函数（闭包）
    return function(y) {
        // 内部函数可以访问外部函数的变量
        // 形成闭包，保持对外部变量的引用
        return outerVariable + `_inner_${y}`;
    };
}

// 创建闭包实例
var closure1 = createClosure('test1');
var closure2 = createClosure('test2');

console.log(closure1('a')); // 'outer_test1_inner_a'
console.log(closure2('b')); // 'outer_test2_inner_b'

// 每个闭包都有自己独立的变量环境
console.log(closure1 === closure2); // false

/**
 * 闭包的变量捕获
 */
function variableCapture() {
    var captured = 'initial value';
    
    function updateCapture(newValue) {
        captured = newValue;
    }
    
    function getCapture() {
        return captured;
    }
    
    // 返回多个函数，它们共享同一个变量环境
    return {
        update: updateCapture,
        get: getCapture
    };
}

var capturer = variableCapture();
console.log(capturer.get()); // 'initial value'
capturer.update('modified value');
console.log(capturer.get()); // 'modified value'
```

### 23.4.2 闭包的内存管理

```javascript
/**
 * 闭包与垃圾回收
 */

function memoryManagement() {
    var largeData = new Array(1000000).fill('data'); // 大量数据
    var smallData = 'small';
    
    return function() {
        // 只使用 smallData，但 largeData 也不会被回收
        // 因为整个外部函数的变量环境被保持
        return smallData;
    };
}

// 优化版本：只保留需要的变量
function optimizedMemoryManagement() {
    var largeData = new Array(1000000).fill('data');
    var smallData = 'small';
    
    // 显式清除不需要的大对象
    setTimeout(() => {
        largeData = null; // 帮助垃圾回收
    }, 0);
    
    return function() {
        return smallData;
    };
}

/**
 * 闭包内存泄漏的防范
 */
function preventMemoryLeaks() {
    var element = document.getElementById('button');
    var id = element.id;
    
    element.onclick = function() {
        alert(id);
    };
    
    // 清除对 DOM 元素的引用，防止内存泄漏
    element = null;
}

/**
 * 闭包的正确清理
 */
function createManager() {
    var resources = [];
    var listeners = [];
    
    function addResource(resource) {
        resources.push(resource);
    }
    
    function addListener(element, event, handler) {
        element.addEventListener(event, handler);
        listeners.push({ element, event, handler });
    }
    
    function cleanup() {
        // 清理所有资源
        resources.forEach(resource => {
            if (resource.cleanup) {
                resource.cleanup();
            }
        });
        
        // 清理所有事件监听器
        listeners.forEach(({ element, event, handler }) => {
            element.removeEventListener(event, handler);
        });
        
        // 清空数组
        resources.length = 0;
        listeners.length = 0;
    }
    
    return {
        addResource,
        addListener,
        cleanup
    };
}
```

### 23.4.3 闭包的高级应用

```javascript
/**
 * 模块模式
 */
var Module = (function() {
    // 私有变量和方法
    var privateVar = 'I am private';
    var privateCounter = 0;
    
    function privateMethod() {
        return 'Private method called';
    }
    
    // 公共接口
    return {
        publicMethod: function() {
            return privateMethod();
        },
        
        getCounter: function() {
            return privateCounter;
        },
        
        increment: function() {
            return ++privateCounter;
        },
        
        getPrivateVar: function() {
            return privateVar;
        }
    };
})();

console.log(Module.publicMethod()); // 'Private method called'
console.log(Module.increment()); // 1
console.log(Module.getCounter()); // 1

/**
 * 函数工厂
 */
function createValidator(type) {
    var validators = {
        email: function(value) {
            return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
        },
        phone: function(value) {
            return /^\d{10,11}$/.test(value);
        },
        number: function(value) {
            return !isNaN(value) && !isNaN(parseFloat(value));
        }
    };
    
    var validator = validators[type];
    
    if (!validator) {
        throw new Error('Unknown validator type: ' + type);
    }
    
    return function(value) {
        var result = validator(value);
        console.log(`Validating ${type}: ${value} -> ${result}`);
        return result;
    };
}

var emailValidator = createValidator('email');
var phoneValidator = createValidator('phone');

console.log(emailValidator('test@example.com')); // true
console.log(phoneValidator('1234567890')); // true

/**
 * 柯里化实现
 */
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return function(...nextArgs) {
                return curried.apply(this, args.concat(nextArgs));
            };
        }
    };
}

function add(a, b, c) {
    return a + b + c;
}

var curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6

/**
 * 防抖和节流
 */
function debounce(func, delay) {
    var timeoutId;
    
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

function throttle(func, delay) {
    var lastExecTime = 0;
    
    return function(...args) {
        var currentTime = Date.now();
        
        if (currentTime - lastExecTime > delay) {
            func.apply(this, args);
            lastExecTime = currentTime;
        }
    };
}

// 使用示例
var debouncedLog = debounce(console.log, 300);
var throttledLog = throttle(console.log, 300);
```

---

**本章总结**

第23章深入解析了JavaScript执行机制的核心概念：

1. **执行上下文创建**：
   - 全局执行上下文和函数执行上下文的区别
   - 创建阶段和执行阶段的详细过程
   - 执行栈的工作机制和调用顺序
   - 上下文切换和内存管理机制

2. **变量环境与词法环境**：
   - 变量环境中var声明和函数声明的提升行为
   - 词法环境中let/const的暂时性死区机制
   - 两种环境的创建时机和存储内容
   - 环境记录的查找和绑定过程

3. **作用域链查找**：
   - 词法作用域的静态确定原理
   - 作用域链的构建和遍历算法
   - 变量查找的完整路径和性能影响
   - 作用域嵌套和变量遮蔽现象

4. **闭包内部机制**：
   - 闭包形成的必要条件和识别方法
   - 外部变量引用的保持机制
   - 闭包在内存中的存储结构
   - 常见的闭包陷阱和解决方案

**关键要点**：
- 执行上下文是JavaScript代码执行的基础环境
- 作用域链决定了变量访问的查找路径
- 闭包是词法作用域和函数对象结合的产物
- 理解这些机制有助于避免常见错误和性能问题

**下一章预告**

第24章将全面解析this绑定机制，包括五种绑定方式、箭头函数的特殊性、以及bind/call/apply的本质原理。
