# 第三篇 现代布局：从弹性到网格

> 目标：掌握现代网页布局的两大主力——Flexbox 和 Grid。看完这一篇，你应该能：
>
> - 用 Flexbox 写出常见的一维布局：导航栏、卡片列表、左右结构等；
> - 用 Grid 写出二维布局：后台面板、多区域页面框架等；
> - 读懂别人写的现代布局代码，不再只会靠 `position: absolute` 硬拼页面。

****---

## 第7章 Flexbox：让盒子学会“自动排队”

> Flexbox 适合用来处理“一排”或“一列”的布局问题，比如：顶部导航、一行卡片、左右结构（左侧文字右侧图片）等。
>
> 记住一句话：**Flex 是一维布局（只关心一条主轴），Grid 是二维布局。**

### 7.1 容器与项目的角色

使用 Flexbox 的第一步：**先选中一个“容器”，再让其中的子元素变成“项目”。**

💡 **核心理解：Flexbox 是一种"父子关系"的布局模式**

- **父元素**：设置 `display: flex`，成为 Flex 容器（flex container）
- **子元素**：自动成为 Flex 项目（flex items），听从父元素的布局指挥

---

#### 7.1.1 如何创建 Flex 容器

**一行代码启动 Flexbox**：

```css
.container {
  display: flex;   /* 这行一写，.container 就变成 Flex 容器 */
}
```

**效果**：
- `.container` 本身变成 Flex 容器
- 它的**直接子元素**自动变成 Flex 项目
- 子元素的排列方式从"默认文档流"变成"Flex 布局"

---

#### 7.1.2 生活化比喻：队伍与队员

可以把 Flexbox 想象成**排队系统**：

```txt
🎯 Flex 容器 = 队伍的"排队区域"
   - 决定队伍怎么排（横排还是竖排）
   - 决定队员之间的间距
   - 决定队员的对齐方式

👥 Flex 项目 = 队伍中的"队员"
   - 听从排队区域的指挥
   - 可以设置自己占多少空间
   - 可以设置自己的特殊对齐方式
```

---

#### 7.1.3 基础示例：导航栏

**HTML 结构**：

```html
<ul class="nav">
  <li>首页</li>
  <li>产品</li>
  <li>关于我们</li>
</ul>
```

**不使用 Flexbox（默认效果）**：

```css
/* 不设置任何布局 */
.nav {
  /* 默认是 display: block */
}
```

**效果**：

```txt
┌─────────────┐
│ 首页        │  ← li 是块级元素，独占一行
├─────────────┤
│ 产品        │
├─────────────┤
│ 关于我们    │
└─────────────┘
```

---

**使用 Flexbox**：

```css
.nav {
  display: flex;
}
```

**效果**：

```txt
┌─────────────────────────────┐
│ [首页] [产品] [关于我们]    │  ← 自动横向排列
└─────────────────────────────┘
```

💡 **关键变化**：
- `li` 从"独占一行"变成"横向排列"
- 不需要设置 `float` 或 `inline-block`
- 一行代码搞定！

---

#### 7.1.4 容器与项目的关系图

**可视化理解**：

```txt
HTML 结构：
<div class="container">        ← Flex 容器
  <div class="item">项目1</div>  ← Flex 项目
  <div class="item">项目2</div>  ← Flex 项目
  <div class="item">项目3</div>  ← Flex 项目
</div>

CSS：
.container {
  display: flex;  ← 启动 Flexbox
}

效果：
┌─────────────── .container (Flex 容器) ───────────────┐
│                                                      │
│  ┌────────┐  ┌────────┐  ┌────────┐                │
│  │ 项目1  │  │ 项目2  │  │ 项目3  │  ← Flex 项目    │
│  └────────┘  └────────┘  └────────┘                │
│                                                      │
└──────────────────────────────────────────────────────┘
```

---

#### 7.1.5 ⚠️ 重要：只有直接子元素才是 Flex 项目

**示例**：

```html
<div class="container">
  <div class="item">
    <p>这是段落</p>  <!-- 这不是 Flex 项目！ -->
  </div>
  <div class="item">
    <p>另一段落</p>  <!-- 这也不是 Flex 项目！ -->
  </div>
</div>
```

```css
.container {
  display: flex;
}
```

**关系图**：

```txt
.container (Flex 容器)
  ├─ .item (Flex 项目) ✅
  │   └─ p (普通元素，不是 Flex 项目) ❌
  └─ .item (Flex 项目) ✅
      └─ p (普通元素，不是 Flex 项目) ❌
```

💡 **关键理解**：
- `.item` 是 `.container` 的直接子元素 → 是 Flex 项目 ✅
- `p` 是 `.item` 的子元素，不是 `.container` 的直接子元素 → 不是 Flex 项目 ❌

---

**如果想让 `p` 也使用 Flex 布局**：

```css
.container {
  display: flex;  /* 第一层 Flex */
}

.item {
  display: flex;  /* 第二层 Flex，嵌套使用 */
}
```

**关系图**：

```txt
.container (Flex 容器)
  ├─ .item (Flex 项目 + Flex 容器) ✅
  │   └─ p (Flex 项目) ✅
  └─ .item (Flex 项目 + Flex 容器) ✅
      └─ p (Flex 项目) ✅
```

---

#### 7.1.6 Flex 容器的默认行为

当你设置 `display: flex` 后，会发生以下变化：

**1. 子元素横向排列**

```txt
默认（block）：          Flex 后：
┌────┐                 ┌────┬────┬────┐
│ A  │                 │ A  │ B  │ C  │
├────┤       →         └────┴────┴────┘
│ B  │
├────┤
│ C  │
└────┘
```

**2. 子元素高度自动对齐**

```txt
不同高度的子元素：

┌────┐ ┌────┐ ┌────┐
│ A  │ │ B  │ │ C  │
│    │ │    │ │    │
│    │ └────┘ │    │
└────┘        │    │
              └────┘

Flex 后（默认 align-items: stretch）：

┌────┐ ┌────┐ ┌────┐
│ A  │ │ B  │ │ C  │
│    │ │    │ │    │
│    │ │    │ │    │  ← 高度自动拉伸对齐
└────┘ └────┘ └────┘
```

**3. 子元素宽度由内容决定**

```css
.container {
  display: flex;
}

.item {
  /* 不设置 width，宽度由内容决定 */
}
```

---

#### 7.1.7 常见问题

**问题1：为什么设置了 `display: flex`，子元素还是竖着排？**

```css
.container {
  display: flex;
  flex-direction: column;  /* ← 这行导致竖着排 */
}
```

**解决**：检查是否设置了 `flex-direction: column`，默认是 `row`（横排）

---

**问题2：为什么孙子元素不受 Flex 影响？**

```html
<div class="container">
  <div class="item">
    <p>我不受 Flex 影响</p>  <!-- 不是直接子元素 -->
  </div>
</div>
```

**解决**：只有直接子元素才是 Flex 项目，如果想控制孙子元素，需要在父元素上再设置 `display: flex`

---

**问题3：为什么子元素被压缩了？**

```css
.container {
  display: flex;
  width: 300px;
}

.item {
  width: 200px;  /* 3个子元素，总宽度 600px > 容器 300px */
}
```

**原因**：默认情况下，Flex 项目会自动缩小以适应容器

**解决**：
```css
.item {
  flex-shrink: 0;  /* 禁止缩小 */
}
```

---

#### 7.1.8 display: flex vs display: inline-flex

**两种 Flex 容器**：

```css
/* 块级 Flex 容器（常用） */
.container {
  display: flex;
}

/* 行内 Flex 容器（少用） */
.container {
  display: inline-flex;
}
```

**区别**：

| 特性 | `display: flex` | `display: inline-flex` |
|------|----------------|----------------------|
| 容器本身 | 块级元素，独占一行 | 行内元素，不独占一行 |
| 子元素布局 | 相同（都是 Flex 布局） | 相同（都是 Flex 布局） |
| 常用场景 | 大部分布局 | 行内的小组件 |

**可视化对比**：

```txt
display: flex（块级容器）：

┌─────────────────────────┐
│ [A][B][C]               │  ← 容器独占一行
└─────────────────────────┘
下一行内容

display: inline-flex（行内容器）：

文字 [A][B][C] 文字  ← 容器和文字在同一行
```

---

**💡 记忆要点**

```txt
✅ Flexbox 的核心：
1. 父元素设置 display: flex
2. 子元素自动成为 Flex 项目
3. 只有直接子元素才是 Flex 项目

✅ 默认行为：
1. 子元素横向排列
2. 子元素高度自动对齐
3. 子元素宽度由内容决定

✅ 常用场景：
1. 导航栏（横向排列）
2. 卡片列表（横向排列）
3. 左右布局（两列分布）
4. 垂直居中（对齐方式）
```

> 理解容器与项目的关系是学习 Flexbox 的第一步，后面所有的属性都是在这个基础上展开的。

### 7.2 主轴、交叉轴、排列方式

理解 Flex 的关键是**主轴（main axis）**和**交叉轴（cross axis）**这两个概念。

💡 **核心理解**：
- **主轴**：Flex 项目排列的方向
- **交叉轴**：垂直于主轴的方向
- 主轴方向由 `flex-direction` 决定

---

#### 7.2.1 主轴与交叉轴

**默认情况（flex-direction: row）**：

- **主轴**：水平方向（从左到右）→
- **交叉轴**：垂直方向（从上到下）↓

**可视化理解**：

```txt
主轴（main axis）：→ 水平方向
交叉轴（cross axis）：↓ 垂直方向

┌───────────────────────────── 容器 .row ─────────────────────────────┐
│                                                                      │
│  ┌──────┐  ┌──────┐  ┌──────┐                                      │
│  │ item │  │ item │  │ item │   ← 沿主轴从左到右排队                │
│  └──────┘  └──────┘  └──────┘                                      │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
     ↑
     交叉轴方向（垂直）
```

---

**当设置 flex-direction: column 时**：

- **主轴**：垂直方向（从上到下）↓
- **交叉轴**：水平方向（从左到右）→

**可视化理解**：

```txt
主轴（main axis）：↓ 垂直方向
交叉轴（cross axis）：→ 水平方向

┌───────────── 容器 .column ─────────────┐
│  ┌──────┐                              │
│  │ item │  ← 沿主轴从上到下排队        │
│  └──────┘                              │
│  ┌──────┐                              │
│  │ item │                              │
│  └──────┘                              │
│  ┌──────┐                              │
│  │ item │                              │
│  └──────┘                              │
└────────────────────────────────────────┘
      ↑
      交叉轴方向（水平）
```

---

#### 7.2.1.1 flex-direction：改变主轴方向

`flex-direction` 属性决定主轴的方向，有4个值：

**1. row（默认）**：主轴水平，从左到右

```css
.container {
  display: flex;
  flex-direction: row;
}
```

```txt
┌────────────────────────┐
│ [A] [B] [C]            │  ← 从左到右
└────────────────────────┘
```

---

**2. row-reverse**：主轴水平，从右到左

```css
.container {
  display: flex;
  flex-direction: row-reverse;
}
```

```txt
┌────────────────────────┐
│            [C] [B] [A] │  ← 从右到左（顺序反转）
└────────────────────────┘
```

💡 **应用场景**：阿拉伯语等从右到左的语言布局

---

**3. column**：主轴垂直，从上到下

```css
.container {
  display: flex;
  flex-direction: column;
}
```

```txt
┌──────┐
│ [A]  │  ← 从上到下
├──────┤
│ [B]  │
├──────┤
│ [C]  │
└──────┘
```

💡 **应用场景**：移动端垂直布局、侧边栏菜单

---

**4. column-reverse**：主轴垂直，从下到上

```css
.container {
  display: flex;
  flex-direction: column-reverse;
}
```

```txt
┌──────┐
│ [C]  │  ← 从下到上（顺序反转）
├──────┤
│ [B]  │
├──────┤
│ [A]  │
└──────┘
```

💡 **应用场景**：聊天界面（最新消息在底部）

---

**📊 flex-direction 对比表**

| 值 | 主轴方向 | 起点 | 终点 | 常用场景 |
|----|---------|------|------|---------|
| `row` | 水平 → | 左 | 右 | 导航栏、卡片列表 |
| `row-reverse` | 水平 ← | 右 | 左 | RTL 语言布局 |
| `column` | 垂直 ↓ | 上 | 下 | 移动端布局、侧边栏 |
| `column-reverse` | 垂直 ↑ | 下 | 上 | 聊天界面、时间线 |

---

**💡 记忆口诀**

```txt
主轴 = 元素排队的方向
交叉轴 = 垂直于主轴的方向

row（横排）：主轴 →，交叉轴 ↓
column（竖排）：主轴 ↓，交叉轴 →
```

---

**🔍 调试技巧：如何判断主轴方向**

```css
.container {
  display: flex;
  /* 看 flex-direction 的值 */
}
```

- 如果是 `row` 或 `row-reverse` → 主轴是水平的
- 如果是 `column` 或 `column-reverse` → 主轴是垂直的
- 如果没写 → 默认是 `row`（水平）

---

#### 7.2.1.2 主轴和交叉轴的实际应用

**示例1：水平导航栏**

```html
<nav class="nav">
  <a href="#">首页</a>
  <a href="#">产品</a>
  <a href="#">关于</a>
</nav>
```

```css
.nav {
  display: flex;
  flex-direction: row;  /* 主轴水平 */
}
```

**效果**：

```txt
主轴 →
┌─────────────────────────┐
│ [首页] [产品] [关于]    │  ← 沿主轴横向排列
└─────────────────────────┘
```

---

**示例2：垂直侧边栏**

```html
<aside class="sidebar">
  <a href="#">仪表盘</a>
  <a href="#">用户</a>
  <a href="#">设置</a>
</aside>
```

```css
.sidebar {
  display: flex;
  flex-direction: column;  /* 主轴垂直 */
}
```

**效果**：

```txt
主轴 ↓
┌──────────┐
│ 仪表盘   │  ← 沿主轴垂直排列
├──────────┤
│ 用户     │
├──────────┤
│ 设置     │
└──────────┘
```

---

> **关键理解**：**主轴 = 元素排队的方向**，交叉轴就是垂直于主轴的那条轴。后面所有的对齐属性都是基于主轴和交叉轴来工作的。

#### 7.2.2 沿主轴的排列：justify-content

`justify-content` 决定 **项目沿主轴方向的对齐方式**。

💡 **核心理解**：
- 控制项目在**主轴**上的分布
- 主轴是水平时，控制左右分布
- 主轴是垂直时，控制上下分布

---

**常用值（6个）**：

**1. flex-start（默认）**：靠近主轴起点

```css
.container {
  display: flex;
  justify-content: flex-start;
}
```

```txt
┌─────────────────────────────┐
│ [A][B][C]                   │  ← 靠左（主轴起点）
└─────────────────────────────┘
```

---

**2. flex-end**：靠近主轴终点

```css
.container {
  display: flex;
  justify-content: flex-end;
}
```

```txt
┌─────────────────────────────┐
│                   [A][B][C] │  ← 靠右（主轴终点）
└─────────────────────────────┘
```

---

**3. center**：居中

```css
.container {
  display: flex;
  justify-content: center;
}
```

```txt
┌─────────────────────────────┐
│         [A][B][C]           │  ← 居中
└─────────────────────────────┘
```

💡 **应用场景**：卡片居中、按钮居中

---

**4. space-between**：两端对齐，项目之间平均分配间距

```css
.container {
  display: flex;
  justify-content: space-between;
}
```

```txt
┌─────────────────────────────┐
│ [A]         [B]         [C] │  ← 两端贴边，中间均分
└─────────────────────────────┘
```

💡 **应用场景**：导航栏（Logo 左，菜单右）

---

**5. space-around**：项目两侧都有间距

```css
.container {
  display: flex;
  justify-content: space-around;
}
```

```txt
┌─────────────────────────────┐
│  [A]      [B]      [C]      │  ← 两端有间距，中间间距是两端的2倍
└─────────────────────────────┘
   ↑        ↑        ↑
   1份     2份      2份     1份
```

💡 **关键理解**：
- 每个项目左右各有 1 份间距
- 相邻项目之间的间距 = 1 + 1 = 2 份
- 两端的间距 = 1 份

---

**6. space-evenly**：项目之间和两端间距都相等

```css
.container {
  display: flex;
  justify-content: space-evenly;
}
```

```txt
┌─────────────────────────────┐
│   [A]     [B]     [C]       │  ← 所有间距相等
└─────────────────────────────┘
    ↑       ↑       ↑       ↑
    1份     1份     1份     1份
```

💡 **应用场景**：均匀分布的按钮组

---

**📊 justify-content 对比表**

| 值 | 效果 | 两端是否贴边 | 项目间距 | 常用场景 |
|----|------|------------|---------|---------|
| `flex-start` | 靠起点 | 起点贴边 | 无间距 | 默认布局 |
| `flex-end` | 靠终点 | 终点贴边 | 无间距 | 右对齐 |
| `center` | 居中 | 不贴边 | 无间距 | 居中布局 |
| `space-between` | 两端对齐 | 两端贴边 | 均分 | 导航栏 |
| `space-around` | 环绕分布 | 不贴边 | 中间是两端的2倍 | 卡片列表 |
| `space-evenly` | 均匀分布 | 不贴边 | 完全相等 | 按钮组 |

---

**🎨 可视化对比（完整版）**

```txt
容器宽度：400px，3个项目

flex-start:
┌────────────────────────────────────┐
│[A][B][C]                           │
└────────────────────────────────────┘

center:
┌────────────────────────────────────┐
│            [A][B][C]               │
└────────────────────────────────────┘

flex-end:
┌────────────────────────────────────┐
│                           [A][B][C]│
└────────────────────────────────────┘

space-between:
┌────────────────────────────────────┐
│[A]              [B]              [C]│
└────────────────────────────────────┘

space-around:
┌────────────────────────────────────┐
│  [A]          [B]          [C]     │
└────────────────────────────────────┘
  ↑1份       ↑2份        ↑2份      ↑1份

space-evenly:
┌────────────────────────────────────┐
│   [A]        [B]        [C]        │
└────────────────────────────────────┘
   ↑1份      ↑1份      ↑1份       ↑1份
```

---

**💡 实际应用示例**

**示例1：导航栏（Logo 左，菜单右）**

```html
<header class="header">
  <div class="logo">Logo</div>
  <nav class="nav">
    <a href="#">首页</a>
    <a href="#">产品</a>
    <a href="#">关于</a>
  </nav>
</header>
```

```css
.header {
  display: flex;
  justify-content: space-between;  /* Logo 和 nav 分居两端 */
  align-items: center;
}
```

**效果**：

```txt
┌──────────────────────────────────────┐
│ Logo              [首页][产品][关于] │
└──────────────────────────────────────┘
```

---

**示例2：按钮组居中**

```html
<div class="button-group">
  <button>取消</button>
  <button>确定</button>
</div>
```

```css
.button-group {
  display: flex;
  justify-content: center;  /* 按钮居中 */
  gap: 16px;
}
```

**效果**：

```txt
┌──────────────────────────────────────┐
│           [取消]  [确定]             │
└──────────────────────────────────────┘
```

---

#### 7.2.3 沿交叉轴的对齐：align-items

`align-items` 决定 **项目在交叉轴上的对齐方式**。

💡 **核心理解**：
- 控制项目在**交叉轴**上的对齐
- 主轴是水平时，控制上下对齐
- 主轴是垂直时，控制左右对齐

---

**常用值（5个）**：

**1. stretch（默认）**：拉伸填满容器

```css
.container {
  display: flex;
  align-items: stretch;  /* 默认值 */
  height: 200px;
}
```

```txt
┌─────────────────────────────┐
│ ┌───┐ ┌───┐ ┌───┐          │
│ │ A │ │ B │ │ C │          │  ← 高度自动拉伸
│ │   │ │   │ │   │          │     填满容器
│ │   │ │   │ │   │          │
│ └───┘ └───┘ └───┘          │
└─────────────────────────────┘
```

⚠️ **注意**：只有项目**没有设置高度**时才会拉伸

---

**2. flex-start**：靠交叉轴起点

```css
.container {
  display: flex;
  align-items: flex-start;
  height: 200px;
}
```

```txt
┌─────────────────────────────┐
│ ┌───┐ ┌───┐ ┌───┐          │  ← 靠顶部（交叉轴起点）
│ │ A │ │ B │ │ C │          │
│ └───┘ └───┘ └───┘          │
│                             │
│                             │
└─────────────────────────────┘
```

---

**3. flex-end**：靠交叉轴终点

```css
.container {
  display: flex;
  align-items: flex-end;
  height: 200px;
}
```

```txt
┌─────────────────────────────┐
│                             │
│                             │
│ ┌───┐ ┌───┐ ┌───┐          │  ← 靠底部（交叉轴终点）
│ │ A │ │ B │ │ C │          │
│ └───┘ └───┘ └───┘          │
└─────────────────────────────┘
```

---

**4. center**：居中

```css
.container {
  display: flex;
  align-items: center;
  height: 200px;
}
```

```txt
┌─────────────────────────────┐
│                             │
│ ┌───┐ ┌───┐ ┌───┐          │  ← 垂直居中
│ │ A │ │ B │ │ C │          │
│ └───┘ └───┘ └───┘          │
│                             │
└─────────────────────────────┘
```

💡 **应用场景**：垂直居中（最常用！）

---

**5. baseline**：按文本基线对齐

```css
.container {
  display: flex;
  align-items: baseline;
}
```

```txt
┌─────────────────────────────┐
│ ┌───┐ ┌─────┐ ┌───┐        │
│ │ A │ │  B  │ │ C │        │  ← 文字底部对齐
│ └───┘ │     │ └───┘        │
│       └─────┘              │
└─────────────────────────────┘
     ↑      ↑      ↑
     文字基线对齐
```

💡 **应用场景**：不同字号的文字对齐

---

**📊 align-items 对比表**

| 值 | 效果 | 是否拉伸 | 常用场景 |
|----|------|---------|---------|
| `stretch` | 拉伸填满 | ✅ 是 | 等高卡片 |
| `flex-start` | 靠起点 | ❌ 否 | 顶部对齐 |
| `flex-end` | 靠终点 | ❌ 否 | 底部对齐 |
| `center` | 居中 | ❌ 否 | 垂直居中（最常用） |
| `baseline` | 基线对齐 | ❌ 否 | 文字对齐 |

---

**🎨 可视化对比（完整版）**

```txt
容器高度：200px，3个不同高度的项目

stretch（默认）:
┌─────────────────────────────┐
│ ┌───┐ ┌───┐ ┌───┐          │
│ │ A │ │ B │ │ C │          │  ← 全部拉伸到200px
│ │   │ │   │ │   │          │
│ │   │ │   │ │   │          │
│ └───┘ └───┘ └───┘          │
└─────────────────────────────┘

flex-start:
┌─────────────────────────────┐
│ ┌───┐ ┌─┐ ┌─────┐          │  ← 靠顶部
│ │ A │ │B│ │  C  │          │
│ └───┘ └─┘ │     │          │
│            └─────┘          │
│                             │
└─────────────────────────────┘

center:
┌─────────────────────────────┐
│                             │
│ ┌───┐ ┌─┐ ┌─────┐          │  ← 垂直居中
│ │ A │ │B│ │  C  │          │
│ └───┘ └─┘ └─────┘          │
│                             │
└─────────────────────────────┘

flex-end:
┌─────────────────────────────┐
│                             │
│       ┌─┐                   │
│ ┌───┐ │B│ ┌─────┐          │  ← 靠底部
│ │ A │ └─┘ │  C  │          │
│ └───┘     └─────┘          │
└─────────────────────────────┘
```

---

**💡 实际应用示例**

**示例1：垂直居中（最常用）**

```html
<div class="card">
  <img src="icon.png" alt="图标">
  <h3>标题</h3>
</div>
```

```css
.card {
  display: flex;
  align-items: center;  /* 垂直居中 */
  gap: 16px;
}
```

**效果**：

```txt
┌──────────────────────┐
│ ┌────┐ 标题          │  ← 图标和文字垂直居中
│ │图标│               │
│ └────┘               │
└──────────────────────┘
```

---

**示例2：完美居中（水平+垂直）**

```html
<div class="center-box">
  <button>点击我</button>
</div>
```

```css
.center-box {
  display: flex;
  justify-content: center;  /* 水平居中 */
  align-items: center;      /* 垂直居中 */
  height: 300px;
}
```

**效果**：

```txt
┌──────────────────────┐
│                      │
│                      │
│      [点击我]        │  ← 完美居中
│                      │
│                      │
└──────────────────────┘
```

---

**💡 组合记忆**

```txt
justify-content：控制主轴方向的对齐
  - 主轴是水平 → 控制左右
  - 主轴是垂直 → 控制上下

align-items：控制交叉轴方向的对齐
  - 主轴是水平 → 控制上下
  - 主轴是垂直 → 控制左右

记忆口诀：
justify（正义）→ 主轴（main）→ 主要方向
align（对齐）→ 交叉轴（cross）→ 次要方向
```

---

**🔍 常见问题**

**问题1：为什么 align-items: center 不生效？**

```css
.container {
  display: flex;
  align-items: center;
  /* 没有设置高度！ */
}
```

**原因**：容器没有高度，无法垂直居中

**解决**：
```css
.container {
  display: flex;
  align-items: center;
  height: 200px;  /* 或 min-height: 200px */
}
```

---

**问题2：为什么 justify-content 和 align-items 搞混了？**

**记忆技巧**：
- `justify-content`：**j**ustify 的 **j** 像箭头 →，控制主轴（横向）
- `align-items`：**a**lign 的 **a** 像箭头 ↑，控制交叉轴（纵向）

（这只是记忆技巧，实际上取决于 flex-direction）

### 7.3 对齐、换行、伸缩规则

---

#### 7.3.1 是否允许换行：flex-wrap

默认情况下，如果项目太多，Flex 容器会把所有项目挤在同一行，导致项目被压缩。

💡 **核心理解**：
- `flex-wrap` 控制项目是否换行
- 默认是 `nowrap`（不换行）
- 设置 `wrap` 可以实现响应式布局

---

**常用值（3个）**：

**1. nowrap（默认）**：不换行，所有项目挤在一行

```css
.container {
  display: flex;
  flex-wrap: nowrap;  /* 默认值 */
  width: 400px;
}

.item {
  width: 150px;  /* 3个项目，总宽度 450px > 容器 400px */
}
```

**效果**：

```txt
容器宽度：400px
项目宽度：150px × 3 = 450px（超出容器）

┌──────────────────────────────┐
│ [A][B][C]                    │  ← 3个项目被压缩到一行
└──────────────────────────────┘
  ↑   ↑   ↑
  每个被压缩到约 133px
```

⚠️ **问题**：项目会被压缩，可能导致内容显示不全

---

**2. wrap**：允许换行

```css
.container {
  display: flex;
  flex-wrap: wrap;  /* 允许换行 */
  width: 400px;
}

.item {
  width: 150px;
}
```

**效果**：

```txt
容器宽度：400px
第一行：150px + 150px = 300px（放得下2个）
第二行：150px（剩余1个换行）

┌──────────────────────────────┐
│ [A] [B]                      │  ← 第一行放2个
│ [C]                          │  ← 第二行放1个
└──────────────────────────────┘
```

💡 **应用场景**：响应式卡片列表、标签云

---

**3. wrap-reverse**：换行，但交叉轴反向

```css
.container {
  display: flex;
  flex-wrap: wrap-reverse;  /* 反向换行 */
  width: 400px;
}

.item {
  width: 150px;
}
```

**效果**：

```txt
容器宽度：400px
换行顺序：从下往上

┌──────────────────────────────┐
│ [C]                          │  ← 第二行（在上面）
│ [A] [B]                      │  ← 第一行（在下面）
└──────────────────────────────┘
```

💡 **应用场景**：少用，特殊布局需求

---

**📊 flex-wrap 对比表**

| 值 | 是否换行 | 换行方向 | 常用场景 |
|----|---------|---------|---------|
| `nowrap` | ❌ 否 | - | 导航栏（固定一行） |
| `wrap` | ✅ 是 | 从上到下 | 响应式卡片列表 |
| `wrap-reverse` | ✅ 是 | 从下到上 | 特殊布局 |

---

**🎨 可视化对比（完整版）**

```txt
容器宽度：400px，5个项目，每个宽度 120px

nowrap（默认）:
┌──────────────────────────────┐
│ [A][B][C][D][E]              │  ← 全部挤在一行，每个被压缩到80px
└──────────────────────────────┘

wrap:
┌──────────────────────────────┐
│ [A] [B] [C]                  │  ← 第一行放3个（360px）
│ [D] [E]                      │  ← 第二行放2个（240px）
└──────────────────────────────┘

wrap-reverse:
┌──────────────────────────────┐
│ [D] [E]                      │  ← 第二行（在上面）
│ [A] [B] [C]                  │  ← 第一行（在下面）
└──────────────────────────────┘
```

---

**💡 实际应用示例**

**示例1：响应式卡片列表**

```html
<div class="card-list">
  <div class="card">卡片1</div>
  <div class="card">卡片2</div>
  <div class="card">卡片3</div>
  <div class="card">卡片4</div>
  <div class="card">卡片5</div>
</div>
```

```css
.card-list {
  display: flex;
  flex-wrap: wrap;  /* 允许换行 */
  gap: 16px;        /* 项目之间的间距 */
}

.card {
  width: 240px;     /* 固定宽度 */
  height: 200px;
  background: #f0f0f0;
  border-radius: 8px;
}
```

**效果**：

```txt
容器宽度：800px

┌────────────────────────────────────────────────────────┐
│ [卡片1] [卡片2] [卡片3]                                │  ← 第一行放3个
│ [卡片4] [卡片5]                                        │  ← 第二行放2个
└────────────────────────────────────────────────────────┘

容器宽度：500px（窗口缩小）

┌──────────────────────────────┐
│ [卡片1] [卡片2]              │  ← 第一行放2个
│ [卡片3] [卡片4]              │  ← 第二行放2个
│ [卡片5]                      │  ← 第三行放1个
└──────────────────────────────┘
```

💡 **关键理解**：
- 容器宽度改变时，卡片会自动调整换行
- 实现了响应式布局，不需要媒体查询

---

**示例2：标签云**

```html
<div class="tags">
  <span class="tag">HTML</span>
  <span class="tag">CSS</span>
  <span class="tag">JavaScript</span>
  <span class="tag">React</span>
  <span class="tag">Vue</span>
  <span class="tag">Node.js</span>
</div>
```

```css
.tags {
  display: flex;
  flex-wrap: wrap;  /* 允许换行 */
  gap: 8px;
}

.tag {
  padding: 6px 12px;
  background: #e0f2fe;
  border-radius: 4px;
  font-size: 14px;
}
```

**效果**：

```txt
┌──────────────────────────────────────────┐
│ [HTML] [CSS] [JavaScript] [React]       │  ← 第一行
│ [Vue] [Node.js]                          │  ← 第二行
└──────────────────────────────────────────┘
```

---

**🔍 常见问题**

**问题1：为什么设置了 flex-wrap: wrap，但还是不换行？**

```css
.container {
  display: flex;
  flex-wrap: wrap;
  /* 没有设置容器宽度！ */
}

.item {
  width: 200px;
}
```

**原因**：容器没有宽度限制，会自动扩展以容纳所有项目

**解决**：
```css
.container {
  display: flex;
  flex-wrap: wrap;
  width: 600px;  /* 或 max-width: 100% */
}
```

---

**问题2：换行后项目之间的间距怎么设置？**

**方法1：使用 gap（推荐，现代浏览器）**

```css
.container {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;  /* 行间距和列间距都是 16px */
}
```

**方法2：使用 margin（兼容性好）**

```css
.container {
  display: flex;
  flex-wrap: wrap;
  margin: -8px;  /* 负边距抵消子元素的 margin */
}

.item {
  margin: 8px;  /* 每个项目的间距 */
}
```

---

**💡 记忆要点**

```txt
✅ flex-wrap 的作用：
- 控制项目是否换行
- 默认 nowrap（不换行，会压缩）
- 设置 wrap（换行，响应式）

✅ 常用场景：
- 卡片列表（wrap）
- 标签云（wrap）
- 导航栏（nowrap）

✅ 配合使用：
- gap：设置间距
- align-content：控制多行对齐
```

#### 7.3.2 多行对齐：align-content

当 `flex-wrap: wrap` 时，会出现多行。这时 `align-content` 用来控制**多行整体在交叉轴上的分布**。

💡 **核心理解**：
- `align-content` 只在**多行**时生效
- 控制多行之间的间距和对齐
- 类似于 `justify-content`，但作用于交叉轴

---

**⚠️ 重要区别**

```txt
align-items：控制单行内项目的对齐
  ┌──────────────────┐
  │ [A] [B] [C]      │  ← 控制这一行内的对齐
  └──────────────────┘

align-content：控制多行之间的分布
  ┌──────────────────┐
  │ [A] [B] [C]      │  ← 第一行
  │                  │  ← 控制行与行之间的间距
  │ [D] [E]          │  ← 第二行
  └──────────────────┘
```

---

**常用值（6个）**：

**1. stretch（默认）**：拉伸填满容器

```css
.container {
  display: flex;
  flex-wrap: wrap;
  align-content: stretch;  /* 默认值 */
  height: 400px;
}
```

```txt
┌──────────────────┐
│ [A] [B] [C]      │  ← 第一行拉伸
│                  │
├──────────────────┤
│ [D] [E]          │  ← 第二行拉伸
│                  │
└──────────────────┘
```

---

**2. flex-start**：靠交叉轴起点

```css
.container {
  display: flex;
  flex-wrap: wrap;
  align-content: flex-start;
  height: 400px;
}
```

```txt
┌──────────────────┐
│ [A] [B] [C]      │  ← 第一行
│ [D] [E]          │  ← 第二行
│                  │
│                  │  ← 剩余空间
└──────────────────┘
```

---

**3. center**：居中

```css
.container {
  display: flex;
  flex-wrap: wrap;
  align-content: center;
  height: 400px;
}
```

```txt
┌──────────────────┐
│                  │
│ [A] [B] [C]      │  ← 第一行
│ [D] [E]          │  ← 第二行（整体居中）
│                  │
└──────────────────┘
```

---

**4. space-between**：两端对齐

```css
.container {
  display: flex;
  flex-wrap: wrap;
  align-content: space-between;
  height: 400px;
}
```

```txt
┌──────────────────┐
│ [A] [B] [C]      │  ← 第一行（贴顶部）
│                  │
│                  │  ← 中间均分空间
│                  │
│ [D] [E]          │  ← 第二行（贴底部）
└──────────────────┘
```

---

**5. space-around**：环绕分布

```css
.container {
  display: flex;
  flex-wrap: wrap;
  align-content: space-around;
  height: 400px;
}
```

```txt
┌──────────────────┐
│                  │  ← 1份间距
│ [A] [B] [C]      │  ← 第一行
│                  │  ← 2份间距
│ [D] [E]          │  ← 第二行
│                  │  ← 1份间距
└──────────────────┘
```

---

**6. space-evenly**：均匀分布

```css
.container {
  display: flex;
  flex-wrap: wrap;
  align-content: space-evenly;
  height: 400px;
}
```

```txt
┌──────────────────┐
│                  │  ← 1份间距
│ [A] [B] [C]      │  ← 第一行
│                  │  ← 1份间距
│ [D] [E]          │  ← 第二行
│                  │  ← 1份间距
└──────────────────┘
```

---

**📊 align-content vs align-items 对比**

| 属性 | 作用对象 | 何时生效 | 控制方向 |
|------|---------|---------|---------|
| `align-items` | 单行内的项目 | 单行或多行都生效 | 交叉轴（项目对齐） |
| `align-content` | 多行整体 | 只在多行时生效 | 交叉轴（行间分布） |

---

**💡 实际应用示例**

```html
<div class="gallery">
  <div class="photo">照片1</div>
  <div class="photo">照片2</div>
  <div class="photo">照片3</div>
  <div class="photo">照片4</div>
  <div class="photo">照片5</div>
</div>
```

```css
.gallery {
  display: flex;
  flex-wrap: wrap;
  align-content: flex-start;  /* 多行靠顶部 */
  gap: 16px;
  height: 600px;
}

.photo {
  width: 200px;
  height: 150px;
  background: #f0f0f0;
}
```

---

**🔍 常见问题**

**问题：为什么 align-content 不生效？**

```css
.container {
  display: flex;
  flex-wrap: nowrap;  /* ← 没有换行！ */
  align-content: center;  /* 不生效 */
}
```

**原因**：`align-content` 只在多行时生效，单行时无效

**解决**：
```css
.container {
  display: flex;
  flex-wrap: wrap;  /* 允许换行 */
  align-content: center;
}
```

---

#### 7.3.3 单个项目的对齐覆盖：align-self

有时候你希望某一个项目的对齐方式和其他兄弟不一样，可以使用 `align-self`。

💡 **核心理解**：
- `align-self` 作用于**单个项目**
- 覆盖容器的 `align-items` 设置
- 只影响当前项目，不影响其他项目

---

**常用值（5个）**：

- `auto`（默认）：继承父容器的 `align-items`
- `flex-start`：靠交叉轴起点
- `flex-end`：靠交叉轴终点
- `center`：居中
- `baseline`：基线对齐
- `stretch`：拉伸

---

**💡 实际应用示例**

**示例1：特殊项目单独对齐**

```html
<div class="nav">
  <a href="#" class="logo">Logo</a>
  <a href="#">首页</a>
  <a href="#">产品</a>
  <a href="#" class="login">登录</a>
</div>
```

```css
.nav {
  display: flex;
  align-items: center;  /* 所有项目居中 */
  height: 60px;
}

.login {
  align-self: flex-end;  /* 登录按钮靠底部 */
  margin-left: auto;     /* 推到最右边 */
}
```

**效果**：

```txt
┌──────────────────────────────────┐
│ Logo  首页  产品                 │  ← 其他项目居中
│                          登录    │  ← 登录按钮靠底部
└──────────────────────────────────┘
```

---

**示例2：卡片高度不同时的对齐**

```html
<div class="cards">
  <div class="card">短内容</div>
  <div class="card tall">长内容<br>第二行<br>第三行</div>
  <div class="card">短内容</div>
</div>
```

```css
.cards {
  display: flex;
  align-items: flex-start;  /* 默认靠顶部 */
}

.tall {
  align-self: center;  /* 高卡片居中 */
}
```

**效果**：

```txt
┌──────────────────────────────────┐
│ ┌────┐        ┌────┐             │
│ │短  │        │短  │             │
│ └────┘ ┌────┐ └────┘             │
│        │长  │                     │  ← 高卡片居中
│        │第二│                     │
│        │第三│                     │
│        └────┘                     │
└──────────────────────────────────┘
```

---

**📊 align-self vs align-items 对比**

| 属性 | 作用对象 | 设置位置 | 优先级 |
|------|---------|---------|-------|
| `align-items` | 所有项目 | 容器上 | 低 |
| `align-self` | 单个项目 | 项目上 | 高（覆盖 align-items） |

---

**💡 记忆要点**

```txt
✅ align-self 的作用：
- 单个项目的对齐方式
- 覆盖容器的 align-items
- 值和 align-items 相同

✅ 常用场景：
- 特殊项目需要不同对齐
- 某个项目需要突出显示
- 响应式布局中的特殊处理
```

#### 7.3.4 伸缩规则：flex-grow / flex-shrink / flex-basis

这是 Flexbox 最核心也是最难理解的部分。理解了这三个属性，你就掌握了 Flexbox 的精髓。

💡 **核心理解**：
 - `flex-grow`：空间有剩余时，如何**分配多余空间**（扩展系数），默认值为 0（不扩展）
- `flex-shrink`：空间不足时，如何**压缩项目**（收缩系数），默认值为 1（允许收缩）
- `flex-basis`：元素在主轴上的「基础尺寸」（类似 width，但用于 Flex 计算），默认值为 auto（使用项目自身尺寸））

通常我们用简写属性 `flex`：

```css
/* flex: grow shrink basis */
.item {
  flex: 1 1 200px;
}
```

常见方便写法：

- `flex: 1;` 等价于 `flex: 1 1 0;`，表示：
  - 允许扩展、允许缩小
  - 基础尺寸为 0（空间按比例分）

示例：

```css
.left {
  flex: 2;   /* 占两份 */
}
.right {
  flex: 1;   /* 占一份 */
}
```

占比示意：

```txt
|────────────── 父容器 ──────────────|

 [    left(2份)     ][ right(1份) ]

可以理解为：一共 3 份空间，left 占 2 份，right 占 1 份。
```

左右两部分会按 2:1 分摊剩余空间，非常适合做左右布局。

---

**📊 常用 flex 简写值对比**

| 值 | 等价于 | grow | shrink | basis | 含义 | 常用场景 |
|----|--------|------|--------|-------|------|---------|
| `flex: 1` | `flex: 1 1 0%` | 1 | 1 | 0% | 等分空间 | 等宽列 |
| `flex: auto` | `flex: 1 1 auto` | 1 | 1 | auto | 自适应内容 | 响应式 |
| `flex: none` | `flex: 0 0 auto` | 0 | 0 | auto | 固定尺寸 | Logo |
| `flex: 2` | `flex: 2 1 0%` | 2 | 1 | 0% | 占2份 | 2:1布局 |
| `flex: 0 0 200px` | - | 0 | 0 | 200px | 固定200px | 侧边栏 |

---

**💡 实际应用示例**

**示例1：等分布局（最常用）**

```html
<div class="container">
  <div class="col">列1</div>
  <div class="col">列2</div>
  <div class="col">列3</div>
</div>
```

```css
.container {
  display: flex;
}

.col {
  flex: 1;  /* 等分空间 */
}
```

**效果**：每列宽度完全相等

---

**示例2：固定侧边栏 + 自适应主内容**

```html
<div class="layout">
  <aside class="sidebar">侧边栏</aside>
  <main class="main">主内容</main>
</div>
```

```css
.layout {
  display: flex;
}

.sidebar {
  flex: 0 0 200px;  /* 固定 200px，不扩展不收缩 */
  background: #f0f0f0;
}

.main {
  flex: 1;  /* 占据剩余空间 */
}
```

**效果**：

```txt
┌──────────────────────────────────┐
│ [侧边栏] [      主内容      ]    │  ← 侧边栏固定 200px
│  200px    自动填充剩余空间       │
└──────────────────────────────────┘
```

---

**示例3：Logo + 导航 + 按钮**

```html
<header class="header">
  <div class="logo">Logo</div>
  <nav class="nav">
    <a href="#">首页</a>
    <a href="#">产品</a>
  </nav>
  <button class="btn">登录</button>
</header>
```

```css
.header {
  display: flex;
  align-items: center;
  gap: 16px;
}

.logo {
  flex: none;  /* 固定尺寸 */
}

.nav {
  flex: 1;  /* 占据中间所有空间 */
  display: flex;
  gap: 16px;
}

.btn {
  flex: none;  /* 固定尺寸 */
}
```

**效果**：

```txt
┌──────────────────────────────────────────┐
│ Logo [首页][产品]              [登录]   │
│      ← nav 占据中间所有空间              │
└──────────────────────────────────────────┘
```

---

**🔍 常见问题**

**问题1：为什么 flex: 1 和 flex: auto 不一样？**

```css
/* flex: 1 */
.item-1 {
  flex: 1;  /* flex: 1 1 0% */
}

/* flex: auto */
.item-2 {
  flex: auto;  /* flex: 1 1 auto */
}
```

**区别**：

```txt
flex: 1（basis: 0%）：
- 忽略内容尺寸，完全按比例分配
- 所有项目宽度相等

flex: auto（basis: auto）：
- 考虑内容尺寸，在此基础上分配剩余空间
- 内容多的项目会更宽
```

---

**问题2：为什么设置了 flex: 1，但宽度还是不相等？**

```css
.item {
  flex: 1;
  min-width: 200px;  /* ← 这行导致宽度不相等 */
}
```

**原因**：`min-width` 会限制最小宽度，即使 flex: 1 也无法缩小到 200px 以下

**解决**：
```css
.item {
  flex: 1;
  min-width: 0;  /* 重置 min-width */
}
```

---

**💡 心法总结**

多数时候你可以先记住：

- **等分**就写 `flex: 1;`
- **2:1** 就分别写 `flex: 2;` 和 `flex: 1;`
- **固定尺寸**就写 `flex: none;` 或 `flex: 0 0 200px;`

等更熟练时，再深入理解 `flex-basis` 的作用。

##### 7.3.4.1 “空间足够”和“空间不足”时会发生什么？

假设：

```css
.row {
  display: flex;
}
.row .item {
  flex: 1 1 200px;  /* grow:1, shrink:1, basis:200px */
}
```

- **空间足够时**（容器宽度 ≥ 3 × 200px）：

```txt
容器宽 800px，3 个 item，basis 总和 = 200×3 = 600px
剩余空间：800 - 600 = 200px

   200px     200px     200px
[ item1 ][ item2 ][ item3 ] + 200px 多余空间

因为 grow 都是 1，3 个 item 平分 200px：每个再分到 ~66px。
```

- **空间不足时**（容器宽度 < 3 × 200px）：

```txt
容器宽 500px，basis 总和 = 600px
需要“挤掉” 100px 才能塞下

因为 shrink 都是 1，每个 item 被等比例压缩：各减 ~33px。
```

> 记忆小结：
>
> - grow：决定“空间多时”谁长得快
> - shrink：决定“空间不够时”谁缩得多
> - basis：决定“起步时”的期望尺寸

### 7.4 实战：写出响应式导航栏

做一个常见的导航栏结构：左边 Logo，右边是导航链接。

#### 7.4.1 HTML 结构

```html
<header class="site-header">
  <div class="logo">MySite</div>
  <nav class="nav">
    <a href="#">首页</a>
    <a href="#">产品</a>
    <a href="#">价格</a>
    <a href="#">关于</a>
  </nav>
</header>
```

#### 7.4.2 基础 Flex 布局

```css
.site-header {
  display: flex;
  align-items: center;           /* 垂直居中 */
  justify-content: space-between;/* 左右两端对齐 */
  padding: 0 24px;
  height: 64px;
}

.nav {
  display: flex;
  gap: 16px;                     /* 项目之间的间距（现代浏览器支持） */
}
```

这里的关键点：

- 顶部容器 `.site-header` 使用 `display: flex`，Logo 和 nav 成为两个 flex 项目
- `justify-content: space-between` 让两者分居两端
- nav 内部再使用一层 flex，让超链接一行排开

#### 7.4.3 简单响应式思路

小屏幕下你可能希望导航折叠成一个菜单按钮，这就需要配合 JavaScript 或更高级的 CSS 技巧，这里只先点到：

- 用媒体查询（`@media`）在小屏幕下改变：
  - 导航从横排变成竖排
  - 显示/隐藏菜单图标

> 总结：Flexbox 非常适合一维布局，尤其是“一行内如何排队、如何分配空间”的问题。在写任何复杂布局之前，都先问：这一部分能不能先用 Flex 搞定？

---

## 第8章 Grid：二维布局的终极武器

> 当你需要同时在"行"和"列"两个方向上思考布局时，就轮到 Grid 登场了。
>
> - 典型场景：后台管理面板、复杂控制台、多区域页面框架（头、侧栏、主内容、底部）等。

**核心理解**：
- **Flexbox**：一维布局（一条线上排列，主轴方向）
- **Grid**：二维布局（同时控制行和列）

---

**Grid vs Flexbox 对比**

| 特性 | Flexbox | Grid |
|------|---------|------|
| 维度 | 一维（主轴） | 二维（行+列） |
| 适用场景 | 导航栏、按钮组、一行卡片 | 页面整体布局、复杂网格 |
| 控制方式 | 沿主轴排列 | 精确控制行列位置 |
| 响应式 | 通过 flex-wrap 换行 | 通过 auto-fit/fill 自适应 |
| 学习曲线 | 较简单 | 稍复杂 |

---

**什么时候用 Grid？**

**适合用 Grid**：
- 需要同时控制行和列
- 复杂的页面整体布局（头部、侧边栏、主内容、底部）
- 需要精确控制元素位置
- 卡片网格、相册布局、仪表盘

**适合用 Flexbox**：
- 一维排列（一行或一列）
- 导航栏、按钮组
- 简单的居中对齐
- 不确定项目数量的列表

**实用建议**：Grid 和 Flexbox 可以嵌套使用！外层用 Grid 控制整体布局，内层用 Flexbox 控制细节排列。

---

### 8.1 网格轨道、模板、区域

#### 8.1.0 核心概念

先认识几个核心术语：

**基础术语**：

- **网格容器（Grid Container）**：设置了 `display: grid` 的元素
- **网格项目（Grid Items）**：网格容器的直接子元素
- **网格线（Grid Lines）**：分隔网格的线（行线和列线）
- **网格轨道（Grid Tracks）**：两条相邻网格线之间的空间（行或列）
- **网格单元格（Grid Cell）**：行与列交叉的一个小方格
- **网格区域（Grid Area）**：由多个单元格合并组成的更大区域

---

**可视化理解**：

```txt
网格线（Grid Lines）：
  列线1  列线2  列线3  列线4
    ↓      ↓      ↓      ↓
行线1 ┌──────┬──────┬──────┐
      │      │      │      │
行线2 ├──────┼──────┼──────┤  ← 网格线分隔网格
      │      │      │      │
行线3 ├──────┼──────┼──────┤
      │      │      │      │
行线4 └──────┴──────┴──────┘

网格轨道（Grid Tracks）：
┌──────┬──────┬──────┐
│ 列1  │ 列2  │ 列3  │  ← 列轨道（垂直方向）
└──────┴──────┴──────┘
  ↑
  行轨道（水平方向）

网格单元格（Grid Cell）：
┌──────┬──────┬──────┐
│ [1]  │ [2]  │ [3]  │  ← 每个方格是一个单元格
├──────┼──────┼──────┤
│ [4]  │ [5]  │ [6]  │
└──────┴──────┴──────┘

网格区域（Grid Area）：
┌──────────────┬──────┐
│ [A A A A A]  │ [B]  │  ← 区域A占据多个单元格
├──────┬───────┼──────┤
│ [C]  │ [D D] │ [E]  │  ← 区域D横跨2列
└──────┴───────┴──────┘
```

---

**生活化比喻：Excel 表格**

Grid 布局就像 Excel 表格：
- **行和列**：表格有明确的行和列
- **单元格**：行列交叉形成单元格
- **合并单元格**：可以合并多个单元格形成更大区域
- **调整大小**：可以调整每行每列的大小

```txt
Excel 表格：
┌─────┬─────┬─────┐
│  A1 │  B1 │  C1 │
├─────┼─────┼─────┤
│  A2 │  B2 │  C2 │
├─────┼─────┼─────┤
│  A3 │  B3 │  C3 │
└─────┴─────┴─────┘

Grid 布局：
┌─────┬─────┬─────┐
│ 项目1│ 项目2│ 项目3│
├─────┼─────┼─────┤
│ 项目4│ 项目5│ 项目6│
├─────┼─────┼─────┤
│ 项目7│ 项目8│ 项目9│
└─────┴─────┴─────┘
```

#### 8.1.1 最基本的 Grid 容器

```css
.grid {
  display: grid;
  grid-template-columns: 200px 1fr 200px;  /* 定义三列 */
  grid-template-rows: 100px 200px;         /* 定义两行 */
}
```

**核心属性**：
- `grid-template-columns`：定义列的数量和宽度
- `grid-template-rows`：定义行的数量和高度

---

**示例1：三列布局**

```css
.grid {
  display: grid;
  grid-template-columns: 200px 1fr 200px;
}
```

**解释**：
- 第 1 列：固定 200px（侧边栏）
- 第 2 列：`1fr`（主内容，自适应剩余空间）
- 第 3 列：固定 200px（右侧栏）

**可视化**：

```txt
容器宽度：800px
列宽计算：200px + (800-200-200)px + 200px

┌────────┬────────────────────┬────────┐
│ 200px  │      400px         │ 200px  │
│ 侧边栏 │    主内容区        │ 右侧栏 │
└────────┴────────────────────┴────────┘
```

---

**示例2：网格系统**

```html
<div class="grid">
  <div>1</div>
  <div>2</div>
  <div>3</div>
  <div>4</div>
  <div>5</div>
  <div>6</div>
</div>
```

```css
.grid {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;  /* 三等分列 */
  grid-template-rows: 100px 100px;     /* 两行，每行100px */
  gap: 10px;
}
```

**可视化布局**：

```txt
┌─────┬─────┬─────┐
│  1  │  2  │  3  │  100px
├─────┼─────┼─────┤
│  4  │  5  │  6  │  100px
└─────┴─────┴─────┘
 1fr   1fr   1fr
```

---

#### 8.1.1.1 fr 单位详解

`fr` 是 Grid 布局专用单位，表示"剩余空间的份额"。

💡 **核心理解**：
- `fr` = fraction（分数/份额）
- 先计算固定尺寸，再将剩余空间按 fr 比例分配

**计算过程示例**：

```css
.grid {
  display: grid;
  grid-template-columns: 200px 1fr 2fr;
  /* 容器宽度：900px */
}
```

**计算步骤**：
1. 固定部分：200px
2. 剩余空间：900px - 200px = 700px
3. fr 总和：1fr + 2fr = 3fr
4. 每份大小：700px ÷ 3 = 233.33px
5. 最终宽度：
   - 第1列：200px（固定）
   - 第2列：233.33px（1fr）
   - 第3列：466.67px（2fr）

**可视化**：

```txt
容器 900px
┌────────┬──────────┬────────────────────┐
│ 200px  │  233px   │      467px         │
│ 固定   │   1fr    │       2fr          │
└────────┴──────────┴────────────────────┘
          ← 剩余 700px 按 1:2 分配 →
```

---

**fr 与其他单位混合使用**：

```css
.grid {
  display: grid;
  grid-template-columns: 200px 1fr 2fr 100px;
}
```

**效果**：
- 固定列：200px + 100px = 300px
- 剩余空间按 1:2 分配给中间两列

---

**常用 fr 模式**：

```css
/* 等分布局 */
.equal {
  grid-template-columns: 1fr 1fr 1fr;  /* 三等分 */
}

/* 黄金比例 */
.golden {
  grid-template-columns: 1.618fr 1fr;  /* 黄金比例 */
}

/* 2-8 分布 */
.sidebar {
  grid-template-columns: 2fr 8fr;  /* 侧边栏占20% */
}

/* 固定-自适应-固定 */
.layout {
  grid-template-columns: 240px 1fr 240px;
}
```

---

**💡 记忆要点**

```txt
✅ fr 单位特点：
- 只在 Grid 中使用
- 表示剩余空间的份额
- 可以使用小数（如 0.5fr）
- 先算固定，后分剩余

✅ 常用比例：
- 1fr 1fr 1fr = 三等分
- 2fr 1fr = 2:1 布局
- 1fr 2fr 1fr = 中间宽两边窄
```

#### 8.1.2 repeat() 简化写法

`repeat()` 函数用于重复定义网格轨道，避免重复书写。

**语法**：
```css
repeat(次数, 轨道大小)
```

---

**基础示例**：

```css
/* 手动写法 */
.grid-manual {
  grid-template-columns: 1fr 1fr 1fr 1fr 1fr;  /* 很啰嗦 */
}

/* 使用 repeat() */
.grid-repeat {
  grid-template-columns: repeat(5, 1fr);  /* 简洁明了 */
}
```

---

**repeat() 的多种用法**：

**1. 重复单一值**：

```css
.grid {
  display: grid;
  grid-template-columns: repeat(3, 200px);  /* 3列，每列200px */
}
```

**效果**：
```txt
┌────────┬────────┬────────┐
│ 200px  │ 200px  │ 200px  │
└────────┴────────┴────────┘
```

---

**2. 重复模式**：

```css
.grid {
  display: grid;
  grid-template-columns: repeat(2, 100px 200px);  
  /* 重复2次"100px 200px"模式，共4列 */
}
```

**效果**：
```txt
┌──────┬────────┬──────┬────────┐
│100px │ 200px  │100px │ 200px  │
└──────┴────────┴──────┴────────┘
  ← 第1组 →    ← 第2组 →
```

---

**3. 混合使用**：

```css
.grid {
  display: grid;
  grid-template-columns: 200px repeat(3, 1fr) 200px;
  /* 固定-重复-固定 */
}
```

**效果**：
```txt
┌────────┬────┬────┬────┬────────┐
│ 200px  │ 1fr│ 1fr│ 1fr│ 200px  │
│ 固定   │ 均分均分均分│ 固定    │
└────────┴────┴────┴────┴────────┘
```

---

**4. 12列栅格系统**：

```css
.grid-12 {
  display: grid;
  grid-template-columns: repeat(12, 1fr);  /* 经典12列栅格 */
}

/* 项目可以跨越多列 */
.col-4 { grid-column: span 4; }  /* 占4列（1/3宽度）*/
.col-6 { grid-column: span 6; }  /* 占6列（1/2宽度）*/
.col-12 { grid-column: span 12; } /* 占12列（全宽）*/
```

**可视化**：
```txt
12列栅格：
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│1│2│3│4│5│6│7│8│9│10│11│12│
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘

span 4 = 占4列：
┌───────┬─┬─┬─┬─┬─┬─┬─┬─┐
│  占4列 │ │ │ │ │ │ │ │ │
└───────┴─┴─┴─┴─┴─┴─┴─┴─┘
```

---

**💡 记忆要点**

```txt
✅ repeat() 用法：
- repeat(3, 1fr) = 三等分
- repeat(12, 1fr) = 12列栅格
- repeat(2, 100px 200px) = 重复模式
- 200px repeat(3, 1fr) 200px = 混合使用

✅ 优势：
- 代码更简洁
- 便于维护
- 减少出错
```

---

#### 8.1.3 网格间距：gap

`gap` 用于设置网格项目之间的间距（不影响外边缘）。

**语法变化**：
- 旧版：`grid-gap`（已废弃但仍有效）
- 新版：`gap`（推荐，Flex 和 Grid 通用）

---

**基础用法**：

```css
.grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;  /* 行间距和列间距都是 20px */
}
```

**可视化**：
```txt
无 gap：                  有 gap (20px)：
┌───┬───┬───┐            ┌───┐ ┌───┐ ┌───┐
│ 1 │ 2 │ 3 │            │ 1 │ │ 2 │ │ 3 │
├───┼───┼───┤     →      └───┘ └───┘ └───┘
│ 4 │ 5 │ 6 │            
└───┴───┴───┘            ┌───┐ ┌───┐ ┌───┐
                         │ 4 │ │ 5 │ │ 6 │
                         └───┘ └───┘ └───┘
```

---

**分别设置行列间距**：

```css
.grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  /* 方法1：简写 */
  gap: 10px 20px;  /* row-gap column-gap */
  
  /* 方法2：分开写 */
  row-gap: 10px;     /* 行间距 */
  column-gap: 20px;  /* 列间距 */
}
```

**效果对比**：
```txt
gap: 10px 20px
┌───┐←20px→┌───┐←20px→┌───┐
│ 1 │      │ 2 │      │ 3 │
└───┘      └───┘      └───┘
  ↑
 10px
  ↓
┌───┐      ┌───┐      ┌───┐
│ 4 │      │ 5 │      │ 6 │
└───┘      └───┘      └───┘
```

---

**实际应用示例**：

**1. 卡片网格**：

```css
.card-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 24px;  /* 卡片之间的间距 */
  padding: 24px;  /* 容器内边距 */
}
```

**2. 图片画廊**：

```css
.gallery {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 4px;  /* 小间距，紧凑布局 */
}
```

**3. 表单布局**：

```css
.form {
  display: grid;
  grid-template-columns: 120px 1fr;
  gap: 16px 8px;  /* 行间距大，列间距小 */
}
```

---

**gap vs margin 的区别**：

```css
/* 使用 gap（推荐） */
.grid-gap {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;  /* 只影响项目之间 */
}

/* 使用 margin（不推荐） */
.grid-margin {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
}
.grid-margin > * {
  margin: 10px;  /* 会影响外边缘，需要负边距修正 */
}
```

**对比图**：
```txt
使用 gap：                使用 margin：
┌─────────────┐          ┌───────────────┐
│ ┌─┐ ┌─┐ ┌─┐ │          │  ┌─┐ ┌─┐ ┌─┐  │
│ └─┘ └─┘ └─┘ │          │  └─┘ └─┘ └─┘  │
│ ┌─┐ ┌─┐ ┌─┐ │          │  ┌─┐ ┌─┐ ┌─┐  │
│ └─┘ └─┘ └─┘ │          │  └─┘ └─┘ └─┘  │
└─────────────┘          └───────────────┘
 ↑             ↑           ↑              ↑
没有外边距              有外边距（需要处理）
```

---

**💡 记忆要点**

```txt
✅ gap 的优势：
- 只影响内部间距
- 不影响外边缘
- Flex 和 Grid 通用
- 语义清晰

✅ 常用值：
- gap: 16px（统一间距）
- gap: 8px 16px（行小列大）
- gap: 24px（卡片布局）
- gap: 4px（紧凑画廊）
```

---

**🔍 常见问题**

**问题：为什么 gap 在某些浏览器不生效？**

**原因**：旧版浏览器不支持

**解决**：
```css
.grid {
  display: grid;
  grid-gap: 20px;  /* 旧版浏览器 */
  gap: 20px;       /* 新版浏览器 */
}
```

#### 8.1.4 网格区域命名：grid-template-areas

对于复杂的整体页面布局，可以用“文字画图”的方式定义布局：

```css
.layout {
  display: grid;
  grid-template-columns: 240px 1fr;
  grid-template-rows: 64px 1fr 48px;
  grid-template-areas:
    "header header"
    "sidebar main"
    "footer footer";
}

.header  { grid-area: header; }
.sidebar { grid-area: sidebar; }
.main    { grid-area: main; }
.footer  { grid-area: footer; }
```

上面的定义，对应的布局草图可以画成：

```txt
行1:  header  header
行2:  sidebar main
行3:  footer  footer

┌───────────────────────────────┐
│            header             │ 64px 高
├───────────────┬───────────────┤
│    sidebar    │      main     │ 自适应高度
├───────────────┴───────────────┤
│            footer             │ 48px 高
└───────────────────────────────┘
列宽: 240px          剩余空间 1fr
```

配合 HTML：

```html
<div class="layout">
  <header class="header">Header</header>
  <aside class="sidebar">Sidebar</aside>
  <main class="main">Main</main>
  <footer class="footer">Footer</footer>
</div>
```

`grid-template-areas` 像是在画一个布局草图：哪块写什么名字，对应区域就会自动占据相应格子。

💡 **核心理解**：
- 像画图一样设计布局
- 使用命名区域代替数字定位
- 让布局代码自解释

---

**基础示例：经典布局**

```css
.layout {
  display: grid;
  grid-template-columns: 240px 1fr;
  grid-template-rows: 64px 1fr 48px;
  grid-template-areas:
    "header header"    /* 第1行：header 跨2列 */
    "sidebar main"     /* 第2行：sidebar和main各占1列 */
    "footer footer";   /* 第3行：footer 跨2列 */
}

.header  { grid-area: header; }
.sidebar { grid-area: sidebar; }
.main    { grid-area: main; }
.footer  { grid-area: footer; }
```

**可视化对应关系**：

```txt
CSS 中的文字画：          实际布局：
"header header"     →   ┌───────────────────────────────┐
                       │         header (64px)         │
"sidebar main"      →   ├───────────────┬───────────────┤
                       │ sidebar(240px)│ main (1fr)    │
"footer footer"     →   ├───────────────┴───────────────┤
                       │         footer (48px)         │
                       └───────────────────────────────┘
```

配合 HTML：

```html
<div class="layout">
  <header class="header">Header</header>
  <aside class="sidebar">Sidebar</aside>
  <main class="main">Main</main>
  <footer class="footer">Footer</footer>
</div>
```

---

**进阶用法**：

**1. 使用点号（.）表示空白区域**：

```css
.grid {
  grid-template-areas:
    "header header ."      /* 第3列空白 */
    "sidebar main main"
    "footer footer footer";
}
```

**效果**：
```txt
┌──────────────┬───┐
│   header     │ . │  ← 空白区域
├──────┬───────┴───┤
│sidebar│   main    │
├──────┴───────────┤
│     footer       │
└──────────────────┘
```

**2. 响应式布局（配合媒体查询）**：

```css
/* 移动端：单列布局 */
.responsive {
  display: grid;
  grid-template-areas:
    "header"
    "main"
    "sidebar"
    "footer";
}

/* 桌面端：多列布局 */
@media (min-width: 768px) {
  .responsive {
    grid-template-areas:
      "header  header  header"
      "sidebar main    main"
      "footer  footer  footer";
    grid-template-columns: 240px 1fr 1fr;
  }
}
```

---

**⚠️ 注意事项**：

1. **区域必须是矩形**：
```css
/* ❌ 错误：L形区域 */
"a a b"
"a c c"  /* a 不是矩形！ */

/* ✅ 正确：矩形区域 */
"a a b"
"a a c"  /* a 是矩形 */
```

2. **每行列数必须相同**：
```css
/* ❌ 错误 */
"header header"     /* 2列 */
"sidebar main nav"  /* 3列 */

/* ✅ 正确 */
"header header header"
"sidebar main nav"
```

---

**💡 记忆要点**

```txt
✅ 优势：
- 直观易懂，代码即文档
- 便于维护和修改
- 适合复杂布局

✅ 语法规则：
- 区域名用空格分隔
- 每行用引号包裹
- 空白区用点号（.）
- 区域必须是矩形
```

`grid-template-areas` 像是在画一个布局草图：哪块写什么名字，对应区域就会自动占据相应格子。

### 8.2 repeat()、minmax()、auto-fit

这一节讲一些在实战中非常好用的“自动栅格”写法。

#### 8.2.1 minmax()：最小/最大尺寸

`minmax(min, max)` 用于定义一条轨道（列或行）的最小和最大尺寸：

```css
.grid {
  display: grid;
  grid-template-columns: repeat(3, minmax(200px, 1fr));
}
```

含义：

- 每列至少 200px
- 宽度可以伸展到至多 `1fr` 以平分剩余空间

#### 8.2.2 auto-fit 与 auto-fill：自适应列数

做响应式卡片网格时，有一个非常常见的写法：

```css
.cards {
  display: grid;
  grid-template-columns: repeat(
    auto-fit,
    minmax(240px, 1fr)
  );
  gap: 16px;
}
```

这个组合可以理解为：

- 容器宽度够，就多放几列
- 容器变窄，就自动减少列数
- 每个卡片最小 240px，最多平分剩余宽度

可视化想象：

```txt
宽屏时（可以容纳 4 列）：

┌ cards 容器 ──────────────────────┐
│ [card][card][card][card]        │
└─────────────────────────────────┘

变窄后（只能容纳 2 列）：

┌ cards 容器 ──────────────┐
│ [card][card]             │
│ [card][card]             │
└──────────────────────────┘

再窄一点（只能 1 列）：

┌ cards 容器 ───────┐
│ [card]            │
│ [card]            │
│ [card]            │
└───────────────────┘
```

`auto-fit` 与 `auto-fill` 的差别较细：

- 在大多数常见场景下，可以优先记住 `auto-fit`，让空轨道“收缩”，看起来更自然

> 这套 `repeat(auto-fit, minmax())` 写法几乎是“自适应网格”的标准答案，建议熟悉并多练习几次。

##### 8.2.2.1 auto-fit 自适应列数直观图

以：

```css
grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
```

为例，可以这样想：

```txt
容器很宽时（足够 4 个 240px）：
┌───────────────────────────────┐
│ [card][card][card][card]      │
└───────────────────────────────┘

宽度变窄，只能放下 2 个：
┌───────────────────────┐
│ [card][card]           │
│ [card][card]           │
└───────────────────────┘

再窄一点，只能 1 个：
┌───────────────┐
│ [card]         │
│ [card]         │
│ [card]         │
└───────────────┘

每个卡片的最小宽度就是 240px，最多可以拉伸到 1fr 填满行。
```

一个简化记忆：

```txt
repeat(auto-fit, minmax(最小宽度, 1fr))
→ 先保证每个元素至少多宽，再自动决定这一行能摆几列。
```

### 8.3 grid-area 的常见布局模式

除了用 `grid-template-areas` 做整体布局，还可以在单个元素上精细控制它跨多少行、多少列。

#### 8.3.1 使用 grid-column 与 grid-row

```css
.item-a {
  grid-column: 1 / 3;  /* 从第 1 列跨到第 3 列（不含 3），即占 1、2 两列 */
  grid-row: 1 / 2;     /* 占第 1 行 */
}
```

也可用 `span`：

```css
.item-b {
  grid-column: span 2;  /* 占 2 列 */
}
```

#### 8.3.2 实战示例：杂志式卡片布局

```css
.grid-magazine {
  display: grid;
  grid-template-columns: 2fr 1fr;
  grid-template-rows: auto auto;
  gap: 16px;
}

.feature {
  grid-column: 1 / 2;  /* 左侧大卡片 */
  grid-row: 1 / 3;     /* 占据两行 */
}

.card-1 { grid-column: 2 / 3; grid-row: 1 / 2; }
.card-2 { grid-column: 2 / 3; grid-row: 2 / 3; }
```

HTML：

```html
<div class="grid-magazine">
  <article class="feature">大卡片</article>
  <article class="card-1">右上卡片</article>
  <article class="card-2">右下卡片</article>
</div>
```

这样就做出类似新闻首页的布局：左边一块大图，右边上下两个小卡片。

### 8.4 实战：做一个通用管理后台布局

目标：做出一个典型的后台布局：

- 顶部：导航栏
- 左侧：侧边栏
- 中间：主内容区
- 底部：页脚

#### 8.4.1 HTML 结构

```html
<div class="dashboard-layout">
  <header class="header">Dashboard Header</header>
  <aside class="sidebar">Sidebar</aside>
  <main class="main">Main Content</main>
  <footer class="footer">Footer</footer>
</div>
```

#### 8.4.2 Grid 布局代码

```css
.dashboard-layout {
  display: grid;
  grid-template-columns: 240px 1fr;
  grid-template-rows: 64px 1fr 48px;
  grid-template-areas:
    "header header"
    "sidebar main"
    "footer footer";
  min-height: 100vh;
}

.header  { grid-area: header; }
.sidebar { grid-area: sidebar; }
.main    { grid-area: main; }
.footer  { grid-area: footer; }
```

你可以再加上一些基础样式美化：背景色、边距、阴影等，这里就不展开。

> 思考：如果要在小屏幕上把侧边栏变成顶部抽屉式菜单，只需要在媒体查询中改一下 `grid-template-areas` 和行列设置即可，这样的改造比绝对定位方案要清晰、可维护得多。

---

> 本篇中，我们用 Flexbox 解决了一维布局（“一排怎么排队”）的问题，用 Grid 解决了二维布局（“网格里每块怎么摆”）的问题。在后面的篇章中，我们会把这些布局能力和组件化、响应式、变量等概念结合起来，完成一套真正可维护的 CSS 架构。
