{
  "allNotes": [
    {
      "title": "前端开发者必掌握的 HTTP 请求全攻略",
      "path": "常用缺易忘/常识/网络/前端开发者必掌握的 HTTP 请求全攻略.md",
      "category": "常用缺易忘",
      "tags": [],
      "date": null,
      "description": "在前端开发中，HTTP 请求是连接客户端与服务器的核心桥梁 —— 从页面数据获取、用户登录提交，到文件上传，几乎所有与后端交互的场景都依赖 HTTP 请求。本文结合前端开发实际需求，系统梳理 HTTP 请求的核心知识、工具使用、问题解决及最佳实践，帮助开发者高效处理接口交互。\n\n\nHTTP 请求是客户端向服务器发起数据交互的 “指令”，其结构遵循严格的协议规范，是前端正确发起请求的基础。\n\n\n一个",
      "content": "在前端开发中，HTTP 请求是连接客户端与服务器的核心桥梁 —— 从页面数据获取、用户登录提交，到文件上传，几乎所有与后端交互的场景都依赖 HTTP 请求。本文结合前端开发实际需求，系统梳理 HTTP 请求的核心知识、工具使用、问题解决及最佳实践，帮助开发者高效处理接口交互。 一、HTTP 请求基础：理解核心结构与规则 HTTP 请求是客户端向服务器发起数据交互的 “指令”，其结构遵循严格的协议规范，是前端正确发起请求的基础。 请求的三大部分与强制规则 一个完整的 HTTP 请求由请求行、请求头、请求体三部分组成，三者按固定顺序排列，且存在不可替代的格式规则： 关键规则：请求头与请求体之间的空行（\\r\\n\\r\\n） 是 HTTP 协议的强制语法，用于明确分隔 “元数据” 与 “实际数据”。若替换为其他字符（如---、###），服务器会因无法解析请求结构返回400 Bad Request错误，这是前端开发者必须牢记的协议底线。 核心请求方法：语义与场景匹配 不同请求方法对应不同的业务语义，前端需根据场景选择，避免混用导致逻辑错误或安全风险： | 方法 | 核心语义 | 是否需请求体 | 前端典型场景 | 注意事项 | | --- | --- | --- | --- | --- | | GET | 读取 / 查询资源 | 否（参数拼 URL） | 列表查询（如商品列表）、详情获取（如用户信息） | URL 参数有长度限制（约 2KB），不可传敏感数据（如密码） | | POST | 提交 / 创建资源 | 是 | 登录提交、表单提交（如注册）、文件上传 | 支持复杂数据（JSON / 表单 / 文件），数据在请求体中，安全性更高 | | PUT | 全量更新资源 | 是 | 完整修改用户信息（如改昵称 + 手机号） | 幂等操作（多次请求结果一致） | | PATCH | 部分更新资源 | 是 | 单独修改用户头像（不改动其他信息） | 比 PUT 更灵活，减少数据传输量 | | DELETE | 删除资源 | 通常否 | 删除订单、删除收藏 | 幂等操作，需确保接口权限校验 | <font style=\"color:rgb(100, 106, 115);\">语义化原则：GET 仅用于 “读”，POST/PUT/PATCH/DELETE 用于 “写”，这不仅是协议规范，也便于后端接口维护与前端代码可读性提升。</font> 二、请求配置核心：头信息与体数据处理 前端发起请求时，需精准配置请求头（Headers） 与请求体（Body），确保后端能正确解析数据，这是接口交互成功的关键。 必掌握的请求头（Headers） 请求头是客户端向服务器传递的 “附加说明”，前端需重点关注以下高频头信息，部分需手动配置： | 头信息键名 | 作用 | 前端配置场景 | 示例 | | --- | --- | --- | --- | | Content-Type | 声明请求体数据格式（后端据此解析） | POST/PUT/PATCH 请求必配 | application/json（JSON 格式）、multipart/form-data（文件上传） | | Authorization | 身份验证（证明客户端权限） | 登录后访问需权限的接口（如个人中心） | Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...（Token 放在此处） | | Cookie | 携带客户端 Cookie（保持登录状态） | 浏览器自动携带，无需手动配置 | session_id=abc123; theme=light | | Accept | 声明客户端可接收的响应格式 | 需指定响应数据类型时配置 | application/json, text/html | <font style=\"color:rgb(100, 106, 115);\">易错点：Content-Type需与请求体数据格式严格匹配，如用application/json时，请求体必须是 JSON 字符串（需用JSON.stringify()转换），否则后端会解析失败。</font> 请求体（Body）：数据格式与处理方式 请求体仅在 “需提交数据” 的请求（POST/PUT/PATCH）中存在，前端需根据业务场景选择正确的数据格式与处理方式： （1）JSON 格式（最常用） 适用于复杂数据（如嵌套对象），是前后端接口交互的主流格式： （2）表单格式（application/x-www-form-urlencoded） 适用于简单键值对数据，如普通表单提交： （3）文件格式（multipart/form-data） 仅用于文件上传（如头像、文档），需用FormData对象处理，且无需手动设置Content-Type（浏览器会自动添加正确格式及边界符）： 三、前端请求工具：从原生到主流库 前端发起 HTTP 请求的工具分为 “原生 API” 与 “第三方库”，需根据场景选择，其中第三方库（如 Axios）是生产环境的首选。 原生 API：理解底层逻辑 原生 API 虽不如库灵活，但能帮助开发者理解请求本质，主要包括XMLHttpRequest与Fetch API。 （1）Fetch API（现代浏览器推荐） 基于 Promise，语法简洁，支持异步 /await，是原生 API 的首选： （2）XMLHttpRequest（兼容性备用） 兼容性覆盖所有浏览器（包括旧版 IE），但语法较繁琐，主要用于兼容场景： 第三方库：Axios（前端必备） Axios 是前端最主流的 HTTP 请求库，基于 Promise，封装了请求拦截、响应拦截、取消请求等实用功能，极大提升开发效率，是生产环境的首选。 （1）核心用法：基础请求 （2）关键特性：拦截器（统一处理逻辑） 拦截器分为 “请求拦截器” 与 “响应拦截器”，可实现全局 Token 添加、错误统一处理等功能，避免重复代码： （3）实用功能：取消请求（防止重复提交） 在表单提交、搜索等场景中，可通过 Axios 取消重复请求，避免后端处理重复数据： 四、前端高频问题：跨域与错误处理 HTTP 请求中，前端最常遇到的问题是 “跨域” 与 “请求错误”，需掌握对应的解决方案。 跨域问题：原因与前端解决方案 跨域是浏览器 “同源策略” 导致的限制 —— 当请求的协议、域名、端口三者任一与当前页面不同时，浏览器会阻止前端获取响应数据（但请求已到达后端）。 （1）前端可落地的 3 种解决方案 | 方案 | 原理 | 适用场景 | 前端配置示例 | | --- | --- | --- | --- | | CORS（推荐） | 后端设置允许跨域的响应头，浏览器放行 | 生产环境、后端可控场景 | 前端无需配置，后端需返回Access-Control-Allow-Origin: *（或指定前端域名） | | 开发环境代理 | 通过 Webpack/Vite 代理转发请求，规避同源限制 | 本地开发（如 Vue/React 项目） | Vite 配置：server: { proxy: { '/api': { target: 'http://backend.com', changeOrigin: true } } } | | JSONP | 利用<script>标签不受同源限制的特性 | 仅支持 GET 请求、后端需适配 | <script src=\"http://backend.com/api/data?callback=handleData\"></script> | <font style=\"color:rgb(100, 106, 115);\">注意：开发环境代理仅用于本地调试，生产环境需依赖 CORS（后端配置），避免前端直接暴露后端真实地址。</font> 请求错误处理：状态码与场景应对 HTTP 状态码是服务器反馈请求结果的 “信号”，前端需根据状态码区分错误类型，给出合理的用户反馈。 （1）常见状态码与前端处理策略 | 状态码 | 含义 | 前端处理逻辑 | | --- | --- | --- | | 200 | 请求成功 | 解析响应数据，更新页面 UI（如渲染列表） | | 201 | 资源创建成功（如 POST 新增数据） | 提示用户 “创建成功”，跳转对应页面（如订单详情） | | 400 | 请求参数错误 | 提示 “参数有误”（如 “手机号格式不正确”），允许用户重新输入 | | 401 | 未登录 / Token 失效 | 清除本地 Token，跳转登录页，提示 “请先登录” | | 403 | 权限不足（如普通用户访问管理员接口） | 提示 “无权限操作”，禁止进入对应页面 | | 404 | 接口地址不存在 | 排查接口 URL 是否正确（前端常见错误：路径拼写错误） | | 500 | 服务器内部错误 | 提示 “服务器繁忙，请稍后重试”，避免暴露技术细节给用户 | （2）错误处理原则 区分 “网络错误”（如断网、请求超时）与 “业务错误”（如 400、401），前者提示 “网络异常”，后者提示具体业务问题； 避免直接将错误信息（如500 Internal Server Error）展示给用户，需转化为友好的提示（如 “系统暂时不稳定，请稍后再试”）； 关键错误（如 401、500）需记录日志（如上报到监控平台），便于排查问题。 五、请求优化：提升性能与用户体验 合理的请求优化能减少网络开销、加快页面加载速度，提升用户体验，前端需从 “减少请求”“优化请求”“缓存利用” 三方面入手。 减少请求次数 接口合并：将多个关联请求合并为一个（如同时获取用户信息与用户订单，后端提供一个/api/user-with-orders接口），减少网络往返； 资源合并：开发环境将多个 JS/CSS 文件合并为一个（通过 Webpack/Vite 打包），减少静态资源请求次数。 优化请求时机与方式 懒加载：非首屏数据（如滚动加载的列表）、非即时需要的资源（如图片），待用户触发时再发起请求（如scroll事件监听）； 避免重复请求： 提交按钮添加loading状态（点击后禁用按钮，直到请求完成）； 搜索输入框使用 “防抖”（输入停止 1 秒后再发请求，避免输入过程中频繁请求）。 利用缓存减少重复请求 HTTP 缓存：后端设置Cache-Control（如max-age=3600）、ETag等响应头，浏览器会自动缓存请求结果，有效期内无需重复请求（适用于不常变的数据，如商品分类）； 前端本地缓存：将不常变的数据（如用户基本信息）存储在localStorage或sessionStorage中，下次使用时直接读取，避免重复请求。 安全性优化 敏感数据传输：密码、银行卡号等敏感信息必须用 POST 请求，且通过 HTTPS 传输（防止数据被拦截篡改）； 避免 URL 暴露敏感信息：GET 请求的 URL 参数会被记录在浏览器历史、服务器日志中，不可传递密码、Token 等敏感数据； Token 安全：登录 Token 存储在localStorage或sessionStorage中，避免存储在cookie中（防止 CSRF 攻击，需后端配合防护）。 总结 HTTP 请求是前端与后端交互的核心，掌握其结构、方法、工具及问题解决方案，是前端开发者的必备技能。从 “正确发起请求” 到 “优雅处理错误”，再到 “优化请求性能”，每一步都直接影响产品的功能稳定性与用户体验。 日常开发中，建议多利用浏览器Network面板（F12 打开）观察请求详情 —— 查看请求头、请求体是否正确，响应状态码是否正常，这是定位接口问题的最快方式。同时，结合 Axios 等工具的拦截器、取消请求等特性，可大幅提升开发效率，让 HTTP 请求的处理更高效、更健壮。"
    },
    {
      "title": "文件上传与 HTTP 请求全解析",
      "path": "常用缺易忘/常识/网络/文件上传与 HTTP 请求全解析.md",
      "category": "常用缺易忘",
      "tags": [],
      "date": null,
      "description": "作为前端初学者，面对 “文件上传” 时，是不是常困惑 “请求头、请求体是什么”“FormData 怎么用”“数据该放哪”？这篇文章用 “寄快递” 类比，带你从基础概念到实战代码，彻底搞懂这些知识点。\n\n\n你给后端发请求，就像给快递公司寄包裹 —— 要明确 “寄到哪、怎么处理、寄的是什么”，对应 HTTP 请求的 4 个核心部分：\n\n| 请求组成 | 类比快递场景 | 核心作用 |\n| --- | ",
      "content": "作为前端初学者，面对 “文件上传” 时，是不是常困惑 “请求头、请求体是什么”“FormData 怎么用”“数据该放哪”？这篇文章用 “寄快递” 类比，带你从基础概念到实战代码，彻底搞懂这些知识点。 一、先打通基础：HTTP 请求到底是什么？ 你给后端发请求，就像给快递公司寄包裹 —— 要明确 “寄到哪、怎么处理、寄的是什么”，对应 HTTP 请求的 4 个核心部分： | 请求组成 | 类比快递场景 | 核心作用 | | --- | --- | --- | | 请求行 | 收件地址 + 寄件方式（顺丰 / 中通） | 告诉后端 “接口地址 + 请求方法（GET/POST）” | | 请求头（Headers） | 快递单备注（易碎品 / 本人签收） | 告诉后端 “处理规则”（权限、数据格式） | | 请求体（Body） | 包裹里的东西（衣服 / 文件） | 传给后端的 “核心数据”（文件、表单信息） | | params/query | 收件人电话后 4 位 | 告诉后端 “筛选 / 定位数据”（小信息） | 请求头（Headers）：后端的 “处理提示” 相当于快递单上的 “备注”，不用打开包裹就知道注意事项，常见需加的内容： 权限（Authorization）：比如 Bearer 123456，像 “凭身份证取件”，后端确认你有权限才办事； Cookie：像 “收件人常用地址”，后端通过它记住你的状态（比如登录状态，不用每次输账号）； Content-Type：像 “包裹内是易碎品”，告诉后端 “数据格式”（文件上传用multipart/form-data，普通文字用application/json）。 <font style=\"color:rgb(100, 106, 115);\">注意：文件上传时，Axios 会自动设置Content-Type，不用手动加，手动加反而容易错！</font> 请求体（Body）：后端要的 “核心数据” 就是包裹里 “真正要寄的东西”，只有 POST/PUT 请求有（GET 请求没有 Body），比如： 上传文件时的 “文件数据”； 注册时的 “用户名 / 密码”（像{username: \"小明\", password: \"123\"}）； 表单里的 “用户填写信息”。 params/query：URL 里的 “小信息” 跟在接口地址后面，用来 “筛选 / 定位数据”，肉眼可见： query（查询参数）：用?开头、&分隔，比如https://xxx.com/api/user?name=小明&age=20，作用是 “筛选数据”（查名字是小明、年龄 20 的用户）； params（路径参数）：嵌在 URL 中间，用:标识，比如https://xxx.com/api/user/123，作用是 “定位唯一数据”（查 ID 为 123 的用户）。 二、文件上传的关键：FormData 数据格式 JSON 格式（像{name: \"小明\"}）只能传文字，装不了文件 —— 而 FormData 是浏览器专门设计的 “万能容器”，就像 “带标签的分层文件袋”，既能装文件，又能装普通文字。 FormData 的 “通俗样子” 想象一个分层文件袋，每个分层都有 “标签名”（即后端给的 “字段名”），后端靠标签找数据： FormData 的 3 步用法 不用记复杂语法，核心就 3 个动作： 步骤 1：创建 “空文件袋” 步骤 2：往 “文件袋” 里加数据 用append(标签名, 内容)添加，标签名必须和后端一致（比如后端说 “文件字段名叫 file”，就不能写成 uploadFile）： 步骤 3：把 “文件袋” 发往后端 用 Axios 发 POST 请求，直接把 FormData 作为data传，不用手动设Content-Type： 三、文件上传完整实战：从 HTML 到 JS 准备 HTML（让用户选文件） 完整 JS 代码（含请求逻辑） 四、新手必避的 4 个坑 字段名和后端对不上：比如后端要file，你写成uploadFile，后端会 “找不到文件”—— 这是最常见的错，一定要反复确认字段名； 手动设置 Content-Type：文件上传时，Axios 会自动加multipart/form-data，手动加反而可能错； 没拿对文件：用fileInput.files[0]拿文件，别用fileInput.value（那是文件路径，没用）； 用 GET 请求传 FormData：FormData 是 “大包裹”，GET 请求的 URL 装不下，必须用 POST。 五、核心知识点总结 数据该放哪？ 处理规则（权限、格式）→ 请求头（Headers）； 核心数据（文件、表单）→ 请求体（Body，用 FormData）； 筛选 / 定位小信息→ params/query； 文件上传必用 FormData，因为它能同时装文件和文字； 关键是 “字段名和后端一致”“用 POST 请求”“别手动设 Content-Type”。 只要记住 “寄快递” 的类比，再跟着实战代码走一遍，文件上传和 HTTP 请求就再也不是难题啦！"
    },
    {
      "title": "Fetch、Axios、XHR",
      "path": "常用缺易忘/常识/网络/Fetch、Axios、XHR.md",
      "category": "常用缺易忘",
      "tags": [],
      "date": null,
      "description": "在前端开发中，“获取后端数据”是贯穿项目始终的核心需求——就像我们在餐厅点餐时需要服务员传递需求，前端也需要“网络请求工具”作为桥梁，连接前端页面与后端服务器。今天，我们就来系统梳理前端网络请求的三大核心工具：XMLHttpRequest（XHR）、Fetch API 和 Axios，带你掌握它们的用法、特性与适用场景，轻松应对不同项目需求。\r\n\r\n\r\n\r\n用“餐厅点餐”的场景类比，网络请求的流程",
      "content": "前端网络请求三大利器：从基础到实战的全面解析 在前端开发中，“获取后端数据”是贯穿项目始终的核心需求——就像我们在餐厅点餐时需要服务员传递需求，前端也需要“网络请求工具”作为桥梁，连接前端页面与后端服务器。今天，我们就来系统梳理前端网络请求的三大核心工具：XMLHttpRequest（XHR）、Fetch API 和 Axios，带你掌握它们的用法、特性与适用场景，轻松应对不同项目需求。 一、先搞懂：什么是网络请求？ 用“餐厅点餐”的场景类比，网络请求的流程其实很直观： 你（前端页面）：告诉服务员“想要一份番茄炒蛋”（发起数据请求，比如“获取用户列表”）； 服务员（网络请求工具）：将需求传递给厨房（后端服务器）； 厨房（后端服务器）：按照需求做好菜（处理请求，查询数据库并生成数据）； 服务员（网络请求工具）：把做好的菜端给你（将后端返回的数据传递给前端，完成页面渲染）。 简单来说，网络请求工具就是前端与后端的“沟通使者”，负责处理“发送请求”和“接收响应”的全部细节。而前端开发中，最常用的“使者”就是 XHR、Fetch 和 Axios。 二、老牌使者：XMLHttpRequest（XHR） 作为前端网络请求的“初代工具”，XHR 已经存在多年，就像一位经验丰富但做事略显繁琐的“老服务员”——兼容性极强，功能全面，但写法不够简洁。 XHR 是什么？ XHR 是浏览器原生提供的 API，是最早实现“异步请求数据”的工具（也就是常说的“AJAX”核心）。无论是早期的 jQuery AJAX，还是一些老项目，底层都依赖 XHR。 怎么用 XHR？ （1）GET 请求：获取数据 比如“获取用户列表”，步骤分为“创建实例→配置请求→处理响应→发送请求”： （2）POST 请求：提交数据 比如“创建新用户”，需要额外设置“请求头”（告诉后端数据格式）和“请求体”（要提交的数据）： XHR 的优缺点 | 优点 | 缺点 | | ------------------------------------------ | --------------------------------------------------------- | | ✅兼容所有浏览器（包括 IE 等老浏览器） | ❌代码繁琐，需要手动写“创建→配置→处理”全流程 | | ✅功能全面（支持进度监控、请求取消等） | ❌回调函数嵌套多，可读性差（容易出现“回调地狱”） | | ✅无需额外引入依赖（浏览器原生支持） | ❌数据解析、错误判断都需要手动处理（比如 JSON.parse） | 三、现代使者：Fetch API 随着 ES6 标准的推出，浏览器原生提供了 Fetch API——就像一位年轻、高效的“新服务员”，基于 Promise 设计，语法简洁，更符合现代前端开发习惯。 Fetch 是什么？ Fetch 是 XHR 的“升级版”，解决了 XHR 回调嵌套的问题，同时保持原生支持的优势（无需装依赖）。但它只兼容现代浏览器（IE 不支持），更适合新项目。 怎么用 Fetch？ （1）最简 GET 请求 一行代码发起请求，配合 <span class=\"ne-text\">then</span> 链式调用处理数据，逻辑更清晰： （2）完整 POST 请求 支持配置“请求方法、请求头、请求体”，还能添加身份验证（如 Token）： （3）用 async/await 简化代码 Fetch 基于 Promise，所以可以配合 <span class=\"ne-text\">async/await</span> 语法，彻底告别“链式调用”： Fetch 的优缺点 | 优点 | 缺点 | | --------------------------------------------------- | ------------------------------------------------------------ | | ✅语法简洁，基于 Promise，支持 async/await | ❌错误处理不智能（HTTP 错误需手动判断 response.ok） | | ✅浏览器原生支持（现代浏览器），无需装依赖 | ❌不支持超时控制（需要额外写代码实现） | | ✅代码可读性高，避免回调地狱 | ❌默认不发送 Cookie（需手动配置 credentials: 'include'） | | ✅支持多种响应格式（json()、text()、blob() 等） | ❌不兼容 IE 浏览器（需引入 polyfill） | 四、全能使者：Axios Axios 是基于 XHR 封装的第三方库，就像一支“专业服务团队”——不仅继承了 XHR 的兼容性，还整合了 Fetch 的简洁语法，同时增加了大量实用功能，是企业级项目的首选。 Axios 是什么？ Axios 不是浏览器原生工具，需要通过 npm 安装（或引入 CDN），但它解决了 XHR 和 Fetch 的诸多痛点（如自动错误处理、拦截器、请求取消），功能全面且易用。 怎么用 Axios？ （1）基础使用：GET 与 POST Axios 会自动处理“数据解析”和“请求头”，无需手动配置： （2）高级功能：请求配置与拦截器 Axios 的核心优势是“灵活配置”和“拦截器”，比如统一设置基础地址、添加全局 Token： （3）其他实用功能 请求取消：比如用户切换页面时，取消未完成的请求，避免资源浪费； 并发请求：同时发起多个请求，等待所有请求完成后统一处理； 自动转换数据：请求体自动转为 JSON，响应体自动解析为 JS 对象。 Axios 的优缺点 | 优点 | 缺点 | | -------------------------------------------------------- | ------------------------------------------------ | | ✅功能全面（拦截器、超时控制、请求取消等） | ❌需要额外安装（非浏览器原生，增加项目体积） | | ✅错误处理完善（自动捕获网络错误和 HTTP 错误） | ❌简单项目用 Axios 会显得“过度设计” | | ✅自动处理 JSON 数据（无需手动 parse/stringify） | - | | ✅兼容所有浏览器（包括 IE，需配合 Promise polyfill） | - | | ✅支持请求/响应拦截器，便于全局配置 | - | 五、三大利器对比：该选哪一个？ 很多前端开发者会纠结“到底用哪个工具”，其实核心看项目需求。以下是三者的关键特性对比： | 特性 | XHR | Fetch | Axios | | ---------------- | ------------------ | -------------------- | -------------------- | | 语法简洁度 | ❌复杂 | ✅简洁 | ✅很简洁 | | 浏览器支持 | ✅所有浏览器 | ✅现代浏览器 | ✅所有浏览器 | | Promise 支持 | ❌需手动封装 | ✅原生支持 | ✅完美支持 | | 拦截器 | ❌无 | ❌无 | ✅有（核心优势） | | 取消请求 | ✅有 | ⚠️需额外代码 | ✅有 | | JSON 处理 | ❌手动处理 | ✅需调用 .json() | ✅自动处理 | | 错误处理 | ⚠️需手动判断 | ⚠️不完善 | ✅很完善 | | 额外依赖 | ❌无 | ❌无 | ✅需安装 | 六、场景选择建议 简单项目 + 现代浏览器：选 Fetch API 比如个人博客、静态页面，不需要兼容老浏览器，且请求逻辑简单——Fetch 语法简洁，无需额外依赖，足够满足需求。 复杂企业项目：选 Axios 比如管理系统、电商平台，需要全局配置（如统一 Token）、错误处理、请求取消等功能——Axios 的拦截器和全能特性能大幅提升开发效率，减少重复代码。 需兼容老浏览器（如 IE）：选 XHR 或 Axios 如果项目必须兼容 IE，且不想引入依赖，就用 XHR；如果想兼顾开发效率，就用 Axios + Promise polyfill（解决 IE 不支持 Promise 的问题）。 七、学习建议与实战 学习顺序：先掌握 Fetch（入门快，语法简洁）→ 再学 Axios（企业级项目常用，实用性强）→ 最后了解 XHR（知其原理，应对老项目维护）。 实战练习：用三种工具实现同一个功能（比如“获取用户列表并渲染页面”），对比写法差异，加深理解。 避坑提示： Fetch 记得手动判断 <span class=\"ne-text\">response.ok</span>，否则 404、500 不会进入 catch； Axios 拦截器要记得返回配置/数据，否则会导致请求“卡住”； XHR 处理 POST 请求时，必须设置 <span class=\"ne-text\">Content-Type: application/json</span>，否则后端无法解析数据。 总结 XHR 是“基础”，见证了前端网络请求的发展；Fetch 是“现代”，代表了原生 API 的进步；Axios 是“实用”，整合了前两者的优点，成为企业级项目的首选。作为前端开发者，不需要“死磕”某一个工具，而是要根据项目需求灵活选择——理解它们的核心特性，才能在开发中高效解决“数据请求”问题，让前端与后端的沟通更顺畅。"
    },
    {
      "title": "从输入URL到页面显示全过程",
      "path": "常用缺易忘/常识/URL到页面显示/从输入URL到页面显示全过程.md",
      "category": "常用缺易忘",
      "tags": [],
      "date": null,
      "description": "> 前端必会！面试高频题详解 🚀\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n输入：https://www.example.com:443/path/index.html?id=123section\r\n\r\n浏览器做什么：\r\n1. 检查协议（http/https）\r\n2. 解析域名（www.example.com）\r\n3. 解析端口（443，https默认443，http默认80）\r\n4.",
      "content": "从输入URL到页面显示的完整过程 前端必会！面试高频题详解 🚀 快速概览（背这个就够了） --- 详细步骤（面试答题版） 第1步：URL解析 输入：https://www.example.com:443/path/index.html?id=123#section 浏览器做什么： 检查协议（http/https） 解析域名（www.example.com） 解析端口（443，https默认443，http默认80） 解析路径（/path/index.html） 解析参数（?id=123） 解析锚点（#section） 前端知识点： 可以通过 window.location 对象获取当前页面URL信息 协议决定了后续的连接方式（HTTP/HTTPS） --- 第2步：DNS域名解析（重点） 目的：把域名（www.example.com）转换成IP地址（192.168.1.1） 查找顺序（从快到慢）： DNS域名解析：互联网的“地址翻译官” DNS（Domain Name System，域名系统）是互联网的核心基础设施之一，其核心功能“域名解析”本质是将人类易记的域名（如www.baidu.com）翻译成计算机可识别的IP地址（如180.101.49.12） 的过程。 简单来说，IP地址是互联网中设备的“身份证号”（如192.168.1.1），但一串数字难以记忆；而域名是为方便人类使用设计的“别名”，DNS则承担了“别名→身份证号”的翻译工作，让我们无需记住复杂的IP，只需输入域名就能访问网站。 实际例子： 前端优化： DNS预解析：<link rel=\"dns-prefetch\" href=\"//www.example.com\"> 减少不同域名数量，降低DNS查询次数 面试加分项： DNS查询是UDP协议，不是TCP DNS查询可能很慢（几十到几百毫秒） CDN就是通过DNS解析返回最近的服务器IP --- 第3步：建立TCP连接（三次握手） 为什么需要TCP：保证数据可靠传输 三次握手过程： 通俗解释（面试可以这样说）： 客户端：\"你好，我想和你建立连接\"（SYN） 服务器：\"收到，我也想和你连接\"（SYN+ACK） 客户端：\"好的，那我们开始传数据吧\"（ACK） 为什么是3次不是2次： 2次握手无法确认客户端的接收能力 防止已失效的请求到达服务器（服务器不知道客户端是否真的在线） HTTPS额外步骤： 三次握手后，还有SSL/TLS握手（加密协商） 大约需要2个RTT（往返时间） 前端优化： HTTP/2多路复用，一个TCP连接传输多个请求 Keep-Alive保持连接，避免重复握手 --- 第4步：发送HTTP请求 请求报文结构： 请求方法： GET：获取资源（查询） POST：提交数据（新增） PUT：更新资源（修改） DELETE：删除资源 OPTIONS：预检请求（CORS） HEAD：只要响应头，不要响应体 前端常见请求头： --- 第5步：服务器处理请求 服务器做什么： 接收请求报文 解析请求（方法、路径、参数） 查询数据库/读取文件 执行业务逻辑 生成响应内容 返回响应报文 前端不需要关心的： 服务器内部怎么处理 但要知道服务器可能做的优化（缓存、负载均衡） --- 第6步：返回HTTP响应 响应报文结构： 常见状态码（面试必问）： | 状态码 | 含义 | 说明 | |-------|------|------| | 2xx 成功 | | 200 | OK | 请求成功 | | 201 | Created | 资源已创建（POST成功） | | 204 | No Content | 成功但无内容返回（DELETE成功） | | 3xx 重定向 | | 301 | Moved Permanently | 永久重定向（SEO会转移权重） | | 302 | Found | 临时重定向 | | 304 | Not Modified | 协商缓存命中，用本地缓存 | | 4xx 客户端错误 | | 400 | Bad Request | 请求参数错误 | | 401 | Unauthorized | 未授权（需要登录） | | 403 | Forbidden | 禁止访问（没权限） | | 404 | Not Found | 资源不存在 | | 5xx 服务器错误 | | 500 | Internal Server Error | 服务器内部错误 | | 502 | Bad Gateway | 网关错误 | | 503 | Service Unavailable | 服务不可用（服务器过载） | 重要响应头： --- 第7步：浏览器解析渲染（核心重点）⭐ 这是前端最关心的部分！ 7.1 解析HTML，构建DOM树 浏览器做什么： 字节流 → 字符流（根据charset编码） 字符流 → Token令牌（词法分析） Token → Node节点（语法分析） Node → DOM树（构建树结构） 7.2 解析CSS，构建CSSOM树 遇到 <link> 或 <style> 时： 下载CSS文件（如果是外部） 解析CSS规则 构建CSSOM树（CSS对象模型） 重要： CSS会阻塞渲染（必须等CSS加载完才能渲染） 但不阻塞DOM解析（DOM和CSS可以同时解析） 7.3 遇到JavaScript 情况1：普通 <script> ❌ 阻塞HTML解析 ❌ 阻塞页面渲染 必须等JS下载并执行完，才继续解析HTML 情况2：async 异步脚本 ✅ 不阻塞HTML解析（并行下载） ❌ 下载完立即执行，会阻塞HTML解析 执行顺序不确定 情况3：defer 延迟脚本 ✅ 不阻塞HTML解析（并行下载） ✅ 等HTML解析完再执行 按顺序执行 最佳实践： 7.4 合成渲染树（Render Tree） DOM树 + CSSOM树 = 渲染树 注意： display: none 的元素不在渲染树中 visibility: hidden 的元素在渲染树中（占位但不可见） <head> 等不可见标签不在渲染树中 7.5 布局（Layout / Reflow） 计算每个节点的位置和大小 触发重排的操作（性能杀手）： 添加/删除DOM元素 改变元素位置/尺寸（width/height/left/top等） 改变窗口大小 获取某些属性（offsetTop/scrollTop/clientWidth等） 7.6 绘制（Paint） 把元素绘制成像素 触发重绘的操作（比重排轻）： 改变颜色（color/background） 改变阴影（box-shadow） 改变边框样式（border-style） 7.7 合成（Composite） 把多个图层合成最终画面 用GPU加速 某些属性只触发合成，不触发重排/重绘（性能最好） transform opacity filter 优化技巧： --- 第8步：资源加载 并行加载优化： 资源加载优先级（浏览器内部）： 最高：HTML、CSS、字体 高：图片（视口内）、脚本 中：图片（视口外）、音视频 低：预加载资源 --- 完整流程总结（面试答题模板） 简洁版（30秒） 当我在浏览器输入URL后，首先进行DNS解析获得服务器IP，然后通过TCP三次握手建立连接，接着发送HTTP请求，服务器处理后返回HTTP响应。浏览器收到HTML后，开始解析HTML构建DOM树，同时解析CSS构建CSSOM树，两者合成渲染树。然后进行布局计算元素位置，绘制成像素，最后合成显示页面。 详细版（3-5分钟） 1. URL解析：浏览器解析URL，提取协议、域名、端口、路径等信息 2. DNS解析：将域名转换成IP地址，查找顺序是浏览器缓存→系统缓存→hosts文件→DNS服务器递归查询 3. 建立TCP连接：通过三次握手与服务器建立可靠连接。如果是HTTPS还需要TLS握手 4. 发送HTTP请求：包含请求行（方法、路径、协议版本）、请求头（Cookie、User-Agent等）、请求体 5. 服务器处理：服务器接收请求，查询数据库或读取文件，执行业务逻辑，生成响应 6. 返回HTTP响应：包含状态行（状态码）、响应头（Content-Type、Cache-Control等）、响应体（HTML内容） 7. 浏览器渲染： - 解析HTML构建DOM树 - 解析CSS构建CSSOM树 - 遇到script会阻塞解析（除非有async/defer） - 合成渲染树（DOM+CSSOM） - 布局（计算位置尺寸） - 绘制（转成像素） - 合成（GPU加速，显示到屏幕） 8. 加载子资源：图片、JS、CSS等资源并行加载 9. 执行JavaScript：修改DOM、绑定事件等 10. 页面可交互：用户可以操作页面 --- 高频追问题 Q1：为什么CSS要放head，JS要放body底部？ CSS放head： CSS会阻塞渲染 放head可以尽早下载，避免页面闪烁（FOUC） 用户看到的是完整样式的页面 JS放body底部： JS会阻塞HTML解析 放底部可以让DOM先渲染，用户更快看到内容 或者用defer，效果一样 Q2：重排（Reflow）和重绘（Repaint）的区别？ 重排（Reflow）： 元素位置、尺寸改变 需要重新计算布局 性能开销大 例：改width、添加DOM 重绘（Repaint）： 元素样式改变，但位置尺寸不变 不需要重新计算布局 性能开销小 例：改color、background 优化： Q3：async 和 defer 的区别？ | 特性 | 普通script | async | defer | |-----|-----------|-------|-------| | 阻塞HTML解析 | ✅ | ❌ | ❌ | | 下载完立即执行 | ✅ | ✅ | ❌ | | 按顺序执行 | ✅ | ❌ | ✅ | | DOMContentLoaded | 等待 | 可能在前 | 等待 | 使用场景： async：独立脚本（统计代码、广告） defer：依赖DOM的脚本（操作DOM、依赖顺序） Q4：HTTP/1.1 和 HTTP/2 的区别？ HTTP/1.1： 一个TCP连接一次只能发一个请求（队头阻塞） 需要多个TCP连接并行加载资源 头部不压缩 HTTP/2： 多路复用，一个TCP连接可以同时发多个请求 头部压缩（HPACK） 服务器推送（Server Push） 二进制分帧 Q5：强缓存和协商缓存的区别？ 强缓存（不向服务器发请求）： 协商缓存（询问服务器是否可用缓存）： --- 性能优化总结 DNS优化 TCP优化 HTTP/2多路复用 Keep-Alive保持连接 HTTP优化 启用Gzip/Brotli压缩 设置合理缓存策略 减少请求数量（合并文件） 渲染优化 资源优化 代码优化 --- 记忆技巧 🎯 口诀： 关键数字： DNS解析：4层缓存 TCP握手：3次 HTTP状态码：2xx/3xx/4xx/5xx 浏览器渲染：7步（解析HTML→解析CSS→合成渲染树→布局→绘制→合成→显示） --- 💡 面试建议： 先说简洁版，面试官有兴趣再展开 重点说浏览器渲染部分（前端最关心） 提到性能优化加分 准备好追问（重排重绘、async/defer、HTTP/2、缓存） 📚 扩展阅读： Chrome DevTools Performance面板 《浏览器工作原理与实践》 《高性能网站建设指南》"
    },
    {
      "title": "浏览器渲染原理详解",
      "path": "常用缺易忘/常识/URL到页面显示/浏览器渲染原理详解.md",
      "category": "常用缺易忘",
      "tags": [],
      "date": null,
      "description": "浏览器渲染的目标：将服务器返回的代码文本（HTML/CSS/JS）转换成用户能看到的可视化页面。\r\n\r\n过程类比：\r\n\r\n\r\n\r\n- 性能优化：知道哪些操作会触发重排/重绘，避免性能杀手\r\n- 调试技巧：明白为什么页面\"闪烁\"、\"白屏\"、\"卡顿\"\r\n- 面试加分：前端高频考点，体现技术深度\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\nHTML（HyperText Markup Langua",
      "content": "浏览器渲染原理详解 一、为什么需要理解渲染原理？ 渲染的核心使命 浏览器渲染的目标：将服务器返回的代码文本（HTML/CSS/JS）转换成用户能看到的可视化页面。 过程类比： 理解渲染的价值 性能优化：知道哪些操作会触发重排/重绘，避免性能杀手 调试技巧：明白为什么页面\"闪烁\"、\"白屏\"、\"卡顿\" 面试加分：前端高频考点，体现技术深度 二、渲染流程的5个核心步骤 --- 三、步骤1：解析HTML，构建DOM树 HTML是什么？ HTML（HyperText Markup Language）是网页的\"骨架\"，用标签（Tag）描述页面结构。 DOM树（Document Object Model） 浏览器把HTML转成树状结构的\"对象模型\"，JavaScript可以操作这棵树。 解析过程： DOM树示例： 渐进式渲染 浏览器边解析边渲染，不会等整个HTML下载完。 优化技巧： 把重要内容放前面（首屏优化） 用骨架屏、Loading动画占位 四、步骤2：解析CSS，构建CSSOM树 CSS是什么？ CSS（Cascading Style Sheets）是网页的\"外观\"，定义颜色、大小、布局等。 CSSOM树（CSS Object Model） 浏览器把CSS规则转成树状结构，计算每个元素的最终样式。 CSSOM树示例： CSS的层叠（Cascade）和优先级 层叠规则：多个CSS规则作用于同一元素时，优先级决定最终生效的规则。 优先级从高到低： 示例： 实际应用： CSS阻塞渲染（重要） 关键点：CSS会阻塞渲染，但不阻塞DOM解析。 原因：浏览器必须等CSS加载完，才能知道元素的样式，避免\"页面闪烁\"（FOUC，Flash of Unstyled Content）。 优化建议： CSS放<head>，尽早开始下载 内联关键CSS（首屏样式直接写在HTML里，避免网络请求） 非关键CSS异步加载： 五、步骤3：遇到JavaScript的处理 JavaScript的特殊性 JS是\"动态的\"，可以修改DOM和CSSOM，所以默认会阻塞HTML解析和渲染。 三种script加载方式 (1) 普通script（默认） ❌ 阻塞HTML解析 ❌ 阻塞页面渲染 流程：下载JS → 执行JS → 继续解析HTML 时间线： (2) async（异步加载） ✅ 不阻塞HTML解析（并行下载） ❌ 下载完立即执行，执行时会阻塞解析 ⚠️ 多个async脚本执行顺序不确定（谁先下载完谁先执行） 适用场景： 独立的第三方脚本（如Google Analytics统计代码） 不依赖DOM的脚本 时间线： (3) defer（延迟执行） ✅ 不阻塞HTML解析（并行下载） ✅ 等HTML解析完再执行 ✅ 多个defer脚本按顺序执行 适用场景： 需要操作DOM的脚本 有依赖关系的脚本 时间线： 对比表格 | 特性 | 普通script | async | defer | |------|-----------|-------|-------| | 阻塞HTML解析 | ✅ | ❌ | ❌ | | 下载完立即执行 | ✅ | ✅ | ❌ | | 执行时机 | 下载完立即执行 | 下载完立即执行 | HTML解析完执行 | | 执行顺序 | 按顺序 | 不确定 | 按顺序 | | 适用场景 | 必须立即执行的脚本 | 独立脚本（统计） | 操作DOM的脚本 | 最佳实践 六、步骤4：合成渲染树（Render Tree） 渲染树 = DOM树 + CSSOM树 过程： 哪些元素不在渲染树中？ display: none 的元素（不占位，不渲染） <head>、<script>、<meta> 等不可见元素 visibility: hidden 在渲染树中（占位，但不可见） 示例： 七、步骤5：布局（Layout / Reflow） 布局的任务 计算每个元素的位置和大小（坐标、宽高）。 过程： 布局计算示例 计算过程： 什么操作会触发重排（Reflow）？ 重排：重新计算布局（性能开销大💸） 触发条件： 添加/删除DOM元素 改变元素位置/尺寸： 改变窗口大小：window.resize() 读取某些属性（触发强制同步布局）： 重排优化技巧 (1) 批量修改样式 (2) 离线操作DOM (3) 避免频繁读取布局属性 八、步骤6：绘制（Paint） 绘制的任务 把元素\"画\"成像素，填充颜色、绘制文字、边框、阴影等。 绘制顺序（从后到前）： 什么操作会触发重绘（Repaint）？ 重绘：重新绘制像素，但不改变布局（性能开销中💸） 触发条件： 改变颜色： 改变阴影/圆角： 改变可见性： 重绘优化 九、步骤7：合成（Composite） 图层合成 现代浏览器把页面分成多个图层（Layer），GPU并行合成。 图层分层条件： 3D或透视变换：transform: translateZ(0)、perspective 视频、Canvas、iframe CSS动画或过渡：will-change position: fixed GPU加速的属性（只触发合成，性能最佳🚀） will-change提示浏览器优化 注意：不要滥用will-change（占用内存）。 十、性能优化总结 性能开销对比 优化原则 | 操作 | 触发 | 优化方案 | |------|------|---------| | 改变位置 | 重排 | 用transform: translate()代替left/top | | 改变尺寸 | 重排 | 用transform: scale()代替width/height | | 隐藏元素 | 重排 | 用opacity: 0代替display: none（如果可以占位） | | 批量DOM操作 | 多次重排 | 用DocumentFragment或先display:none再操作 | | 动画 | 重排/重绘 | 只用transform和opacity | Chrome DevTools查看性能 十一、核心总结 渲染7步： 记忆口诀： 性能优化金科玉律： CSS放<head>，JS放<body>底部或用defer 避免重排：用transform代替left/top 避免重绘：用opacity代替visibility 批量操作：DocumentFragment、cssText 动画只用transform和opacity"
    },
    {
      "title": "DNS域名解析详解",
      "path": "常用缺易忘/常识/URL到页面显示/DNS域名解析详解.md",
      "category": "常用缺易忘",
      "tags": [],
      "date": null,
      "description": "互联网的通信依赖IP地址（IPv4如xxx.xxx.xxx.xxx，IPv6如8组十六进制数），所有设备（电脑、手机、服务器）必须通过IP地址才能互相定位和传输数据。但存在两个关键问题：\r\n\r\n1. 人类记忆成本高：记住“www.taobao.com”远比记住“140.205.140.241”容易；\r\n2. IP地址可能变化：网站服务器的IP可能因迁移、扩容等原因更换，若直接使用IP访问，一旦IP",
      "content": "一、为什么需要DNS域名解析？ 互联网的通信依赖IP地址（IPv4如xxx.xxx.xxx.xxx，IPv6如8组十六进制数），所有设备（电脑、手机、服务器）必须通过IP地址才能互相定位和传输数据。但存在两个关键问题： 人类记忆成本高：记住“www.taobao.com”远比记住“140.205.140.241”容易； IP地址可能变化：网站服务器的IP可能因迁移、扩容等原因更换，若直接使用IP访问，一旦IP变更，用户就无法找到网站；而域名可以绑定新IP，通过DNS实时更新解析结果，用户无需感知变化。 DNS的存在，本质是在“人类友好的域名”和“机器依赖的IP”之间搭建了一座桥梁，降低了互联网的使用门槛。 二、DNS域名解析的核心原理：分层查询 DNS系统并非单一服务器，而是由全球分布式的分层服务器集群组成，解析过程遵循“从顶层到底层”的递归查询逻辑，类似“查字典找生僻字”——先查部首目录，再查具体页码。 DNS的分层结构（从顶层到底层） DNS域名采用“倒树状结构”，越靠右的后缀层级越高，例如“www.baidu.com”的层级为： 根域名（.）：最高层级，全球仅13组根服务器（由不同机构管理），负责指向顶级域名服务器； 顶级域名（TLD）：根域名下的第一层，如“.com”（商业）、“.cn”（中国国家域名）、“.org”（非盈利）、“.edu”（教育），由专门机构管理（如“.cn”由中国互联网络信息中心CNNIC管理）； 二级域名（SLD）：顶级域名下的自定义部分，如“baidu”（在“.com”下）、“gov.cn”（中国政府域名，“.cn”下的二级域名）； 主机记录（Host）：二级域名下的具体服务标识，如“www”（网页服务）、“mail”（邮件服务，如mail.qq.com）、“ftp”（文件传输服务）。 完整解析流程（以访问www.baidu.com为例） 本地缓存查询：先查用户设备（电脑/手机）的本地DNS缓存（系统已保存的近期解析结果），若有则直接返回IP，无需联网（最快，耗时<1ms）； 本地DNS服务器查询：若本地缓存无结果，设备会向“本地DNS服务器”（通常由运营商如电信、联通分配，或用户手动设置如8.8.8.8）发送查询请求； 本地DNS服务器也有缓存，若命中则直接返回结果； 根服务器查询：若本地DNS无缓存，会先向“根服务器”发送请求，根服务器不存储具体IP，仅返回“.com”顶级域名服务器的地址； 顶级域名服务器查询：本地DNS向“.com”顶级域名服务器发送请求，其返回“baidu.com”二级域名服务器的地址； 权威DNS服务器查询：本地DNS向“baidu.com”的权威DNS服务器（百度自己管理的DNS服务器，是该域名的“最终数据源”）发送请求，权威DNS返回“www.baidu.com”对应的IP地址； 结果返回与缓存：本地DNS将IP地址返回给用户设备，同时将结果缓存（避免下次重复查询），设备最终通过IP访问百度服务器。 三、常见的DNS记录类型（解析的“规则”） DNS解析并非只有“域名→IP”一种，不同场景需要不同的“解析规则”，这些规则通过“DNS记录类型”定义，常见类型如下： | 记录类型 | 作用说明 | 示例 | | --------- | ------------------------------------------------------------------------- | ---------------------------------------------------------------- | | A记录 | 将域名解析为IPv4地址（最常用，如网页、APP访问） | www.baidu.com → 180.101.49.12 | | AAAA记录 | 将域名解析为IPv6地址（应对IPv4地址耗尽，逐步普及） | www.baidu.com → 240e:ff:f101:100::12 | | CNAME记录 | 将域名“别名”解析到另一个域名（而非直接解析到IP），常用于CDN、服务器迁移 | blog.baidu.com → baidu-blog.cdn.com | | MX记录 | 用于邮件服务，指定域名对应的邮件服务器地址 | @.qq.com（QQ邮箱）→ mx.qq.com | | TXT记录 | 存储域名的附加文本信息，常用于验证域名归属（如网站备案、邮箱反垃圾邮件） | @.baidu.com → \"v=spf1 include:baidu.com ~all\"（反垃圾邮件配置） | | NS记录 | 指定管理该域名的“权威DNS服务器”（域名解析的“数据源地址”） | baidu.com → ns1.baidu.com、ns2.baidu.com | 四、DNS的关键特性 分布式与容错性：DNS服务器全球分布式部署，无单点故障（如根服务器有13组镜像，权威DNS有多台备份），确保解析服务稳定； 缓存机制：从本地设备到本地DNS服务器，各环节都有缓存（缓存时间由“TTL值”控制，单位为秒），大幅减少重复查询，提升解析速度； 灵活性：通过修改权威DNS的记录，可快速变更域名对应的IP（如服务器迁移时，修改A记录即可，用户无需改域名）； 安全性：存在DNS安全扩展（DNSSEC），通过数字签名防止解析结果被篡改（避免“DNS劫持”——即恶意将域名解析到虚假IP，导致用户访问钓鱼网站）。 五、常见问题：DNS解析的“痛点”与解决方式 DNS劫持：恶意篡改解析结果，将域名指向钓鱼网站或广告页面。 解决：使用支持DNSSEC的公共DNS（如谷歌8.8.8.8、阿里223.5.5.5），或开启设备的DNS安全验证； 解析延迟：本地DNS服务器性能差或距离远，导致解析耗时过长（影响网站打开速度）。 解决：手动更换为优质公共DNS（如国内：阿里223.5.5.5、腾讯119.29.29.29；国外：谷歌8.8.8.8、Cloudflare 1.1.1.1）； 解析失效：修改DNS记录后，因缓存未过期，新记录未生效（TTL未到，旧缓存仍在）。 解决：修改记录时可临时降低TTL值（如从86400秒改为300秒），生效后再改回；或手动清除本地设备和本地DNS的缓存。 总之，DNS域名解析是互联网“可访问性”的基石——没有DNS，我们将陷入“记IP才能上网”的困境，而正是这个看不见的“翻译官”，让我们能轻松通过域名畅游互联网。"
    },
    {
      "title": "HTTP缓存机制详解",
      "path": "常用缺易忘/常识/URL到页面显示/HTTP缓存机制详解.md",
      "category": "常用缺易忘",
      "tags": [],
      "date": null,
      "description": "想象你每天上班都要从家里拿一份文件到公司，有两种方式：\r\n- 方式A（无缓存）：每天早上回家拿文件，路上花1小时\r\n- 方式B（有缓存）：提前把文件复印一份放办公室，需要时直接用（只花1秒）\r\n\r\nHTTP缓存就是\"方式B\"——把资源（HTML/CSS/JS/图片等）的副本存在本地，下次需要时直接用，避免重复下载。\r\n\r\n\r\n| 受益方 | 好处 |\r\n|-------|------|\r\n| 用户",
      "content": "HTTP缓存机制详解 一、为什么需要缓存？ 缓存的核心价值 想象你每天上班都要从家里拿一份文件到公司，有两种方式： 方式A（无缓存）：每天早上回家拿文件，路上花1小时 方式B（有缓存）：提前把文件复印一份放办公室，需要时直接用（只花1秒） HTTP缓存就是\"方式B\"——把资源（HTML/CSS/JS/图片等）的副本存在本地，下次需要时直接用，避免重复下载。 缓存的好处 | 受益方 | 好处 | |-------|------| | 用户 | 页面打开更快（几十毫秒vs几秒），节省流量 | | 服务器 | 减少带宽消耗，降低服务器压力 | | 开发者 | 提升性能指标，用户体验更好 | 缓存的挑战 核心矛盾：缓存提升速度，但可能导致用户看到\"旧版本\"内容。 场景： 解决方案：合理设置缓存策略，平衡\"速度\"和\"新鲜度\"。 二、缓存的两大类型 核心区别 | 对比 | 强缓存 | 协商缓存 | |------|--------|---------| | 是否发请求 | ❌ 不发（直接用缓存） | ✅ 发请求（询问服务器） | | 速度 | 最快（0ms网络耗时） | 较快（有网络耗时，但不传输内容） | | 状态码 | 200（from disk cache） | 304 Not Modified | | 流量消耗 | 0（不联网） | 少（只传输HTTP头，不传内容） | | 适用场景 | 不常变的资源（如logo、库文件） | 可能变化的资源（如HTML、API数据） | 三、强缓存详解 Cache-Control（现代标准，优先级高） 基础用法： 表示：资源在3600秒（1小时）内直接用缓存，不向服务器发请求。 完整指令： | 指令 | 含义 | 示例 | |------|------|------| | max-age=秒数 | 缓存有效期（秒） | max-age=86400（缓存1天） | | public | 任何缓存都可存（浏览器、CDN） | public, max-age=3600 | | private | 只有浏览器可存，CDN不可存 | private, max-age=3600 | | no-cache | 不是\"不缓存\"！而是\"协商缓存\"（每次都问服务器） | no-cache | | no-store | 真正的\"不缓存\"（敏感信息） | no-store | | must-revalidate | 缓存过期后必须验证 | max-age=3600, must-revalidate | | immutable | 资源永不变化（如CDN上的带hash的文件） | max-age=31536000, immutable | 实际案例： Expires（旧标准，优先级低） 格式： 表示：资源在这个时间点之前都可以用缓存。 缺点： 依赖客户端时间，如果用户手动改了系统时间，缓存就失效了 已被Cache-Control取代（但为了兼容老浏览器，通常两者都设置） 强缓存的工作流程 Chrome DevTools查看强缓存 打开开发者工具（F12） → Network面板： Status: 200（成功） Size: (disk cache) 或 (memory cache)（从缓存读取） Time: 0ms（无网络耗时） 四、协商缓存详解 核心思想 强缓存过期后，不是直接重新下载，而是先问服务器\"资源变了吗？\" 如果没变：服务器回304 Not Modified，浏览器用缓存 如果变了：服务器回200 OK，并返回新资源 两种协商方式 (1) ETag / If-None-Match（基于内容） 第一次请求： 第二次请求（强缓存已过期）： ETag生成方式（服务器实现）： 基于文件内容的MD5哈希值 基于文件修改时间+大小 Nginx默认：inode-size-mtime 优点： 精确（内容变了才认为变了） 适合频繁修改的文件 缺点： 服务器需要计算哈希值（消耗CPU） (2) Last-Modified / If-Modified-Since（基于时间） 第一次请求： 第二次请求： 缺点： 精度只到秒（1秒内多次修改，检测不出变化） 文件内容没变但修改时间变了，也会重新下载（如touch命令） ETag vs Last-Modified | 对比 | ETag | Last-Modified | |------|------|---------------| | 判断依据 | 内容哈希值 | 修改时间 | | 精确度 | 高（内容真的变了才算变） | 低（时间变了就算变） | | 服务器开销 | 高（需计算哈希） | 低（直接读文件时间） | | 优先级 | 高（ETag存在时优先用） | 低 | | 适用场景 | 频繁变化的资源 | 不常变的资源 | 最佳实践：两者都设置，浏览器优先用ETag。 协商缓存的工作流程 五、缓存位置（存在哪里？） 浏览器缓存有多个存储位置，优先级从高到低： Memory Cache（内存缓存） 存储位置：浏览器进程的内存中 速度：最快（几毫秒） 容量：小（几十MB） 生命周期：关闭标签页就清空 存储内容：当前页面的资源（JS/CSS/图片） Disk Cache（磁盘缓存） 存储位置：硬盘 速度：较快（几十毫秒） 容量：大（几百MB到几GB） 生命周期：持久化（关浏览器也在） 存储内容：所有资源 Service Worker Cache 存储位置：Service Worker控制的缓存空间 特点：完全由开发者控制（离线应用、PWA） 使用：需要手动编写Service Worker代码 Push Cache（推送缓存） HTTP/2的特性，服务器主动推送资源 了解即可，实际应用较少 六、实战：常见资源的缓存策略 HTML文件（入口页面） 原因： HTML是入口，经常更新（添加新功能、改文案） 必须每次询问服务器，确保用户看到最新版 用协商缓存：没变就304，节省流量 CSS/JS文件（带hash的） 原因： 文件名带hash（如Webpack打包），内容变了文件名就变 可以永久缓存（1年），提升性能 HTML更新时会引用新的文件名，自动失效旧缓存 打包后的文件示例： 图片/字体（不常变） 原因： Logo、字体等不常更新 缓存1个月（2592000秒），平衡速度和新鲜度 API数据（动态内容） 原因： 用户数据实时变化（如余额、订单状态） 绝不缓存，每次都重新请求 第三方库（CDN） 原因： 版本号固定（@3.2.0），内容永不变 CDN全球分发，强缓存1年 七、缓存失效策略（如何更新缓存？） 问题场景 解决方案 (1) 文件名hash（最推荐） 优点： 旧文件继续缓存（老用户不受影响） 新文件自动下载（新用户看到新版） Webpack/Vite等工具自动生成hash Webpack配置： (2) 版本号查询参数 缺点：部分CDN可能忽略查询参数 (3) 手动清除缓存（不推荐） 让用户按 Ctrl + F5 强制刷新？ ❌ 用户体验差，不可控 八、常见问题与调试 如何查看缓存？ Chrome DevTools： 查看缓存文件： 如何清除缓存？ 开发者： 用户： 为什么改了代码，用户还是看到旧版？ 原因： HTML被强缓存了（不应该！） CSS/JS文件名没变（应该用hash） 解决： HTML设置Cache-Control: no-cache CSS/JS用hash文件名 九、核心总结 缓存类型对比 | 类型 | 发请求 | 状态码 | 速度 | 适用场景 | |------|--------|--------|------|---------| | 强缓存 | ❌ | 200 (from cache) | 最快 | 不常变的资源（CSS/JS/图片） | | 协商缓存 | ✅ | 304 Not Modified | 较快 | 可能变化的资源（HTML） | | 不缓存 | ✅ | 200 OK | 慢 | 动态数据（API） | 缓存策略推荐 记忆口诀 一句话总结：缓存是性能优化的核心，合理设置Cache-Control、ETag等响应头，让浏览器智能决定\"用缓存\"还是\"重新下载\"，在速度和新鲜度之间找到平衡。"
    },
    {
      "title": "HTTP协议详解",
      "path": "常用缺易忘/常识/URL到页面显示/HTTP协议详解.md",
      "category": "常用缺易忘",
      "tags": [],
      "date": null,
      "description": "HTTP（HyperText Transfer Protocol，超文本传输协议）是互联网的\"通用语言\"，规定了浏览器与服务器之间如何交流的规则。\r\n\r\n通俗类比：想象你去餐厅点餐：\r\n- 你（客户端）：用\"菜单语言\"告诉服务员\"我要一份宫保鸡丁\"（HTTP请求）\r\n- 服务员（服务器）：用\"菜单语言\"回复\"好的，您的菜来了\"并端上菜（HTTP响应）\r\n\r\n如果你说英语、服务员说中文，就无法沟通。",
      "content": "HTTP协议详解 一、什么是HTTP协议？ HTTP的本质定义 HTTP（HyperText Transfer Protocol，超文本传输协议）是互联网的\"通用语言\"，规定了浏览器与服务器之间如何交流的规则。 通俗类比：想象你去餐厅点餐： 你（客户端）：用\"菜单语言\"告诉服务员\"我要一份宫保鸡丁\"（HTTP请求） 服务员（服务器）：用\"菜单语言\"回复\"好的，您的菜来了\"并端上菜（HTTP响应） 如果你说英语、服务员说中文，就无法沟通。HTTP就是这个\"统一的菜单语言\"，让全球的浏览器和服务器都能互相理解。 HTTP的核心特点 | 特点 | 说明 | 类比 | |------|------|------| | 无状态 | 每次请求都是独立的，服务器不记得你上次请求了什么 | 你每次进餐厅，服务员都当你是新客户，不记得你上次点了什么 | | 基于请求-响应 | 客户端主动发请求，服务器被动回应（服务器不会主动推送） | 你不点菜，服务员不会主动给你上菜 | | 明文传输（HTTP） | 数据在网络中\"裸奔\"，易被窃听 | 你的订单写在明信片上寄出，邮递员能看到 | | 加密传输（HTTPS） | 数据加密，防止窃听和篡改 | 订单装在密码箱里寄出，只有收件人能打开 | 二、HTTP请求报文详解 请求报文的结构（3部分） 请求行：说明\"要做什么\" 格式：方法 路径 协议版本 组成部分： 请求方法：GET（获取数据）、POST（提交数据）、PUT（更新）、DELETE（删除）等 请求路径：/api/users?page=1（资源位置 + 查询参数） 协议版本：HTTP/1.1（目前主流）、HTTP/2（更快） 常见请求方法（RESTful风格） | 方法 | 作用 | 是否有请求体 | 是否幂等* | 实际例子 | |------|------|------------|----------|---------| | GET | 获取资源（查询） | 否 | 是 | 获取商品列表：GET /api/goods | | POST | 创建资源（新增） | 是 | 否 | 用户注册：POST /api/user/register | | PUT | 更新资源（全量修改） | 是 | 是 | 修改用户信息：PUT /api/user/123 | | PATCH | 更新资源（部分修改） | 是 | 是 | 只改密码：PATCH /api/user/123 | | DELETE | 删除资源 | 否 | 是 | 删除订单：DELETE /api/order/456 | | OPTIONS | 查询服务器支持的方法（CORS预检） | 否 | 是 | 跨域预检：OPTIONS /api/data | | HEAD | 只获取响应头，不要响应体 | 否 | 是 | 检查资源是否存在：HEAD /image.jpg | 幂等性：多次执行同一操作，结果一样。例如： GET /user/1 查10次，结果都一样（幂等） POST /order 提交10次，会创建10个订单（非幂等） 请求头：携带附加信息 常见请求头及作用： | 请求头 | 作用 | 示例值 | |-------|------|--------| | Host | 目标服务器的域名（必需） | www.baidu.com | | User-Agent | 浏览器信息（用于服务器识别客户端类型） | Mozilla/5.0 (Windows NT 10.0) Chrome/120.0 | | Accept | 客户端能接收的数据类型 | text/html, application/json | | Accept-Language | 期望的语言 | zh-CN,zh;q=0.9,en;q=0.8 | | Accept-Encoding | 支持的压缩方式 | gzip, deflate, br | | Content-Type | 请求体的数据格式 | application/json（JSON）、application/x-www-form-urlencoded（表单） | | Content-Length | 请求体的字节长度 | 1234 | | Cookie | 携带的Cookie信息 | sessionId=abc123; token=xyz | | Authorization | 身份认证令牌 | Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6... | | Referer | 从哪个页面跳转来的 | https://www.google.com/search?q=xxx | | Origin | 请求源（跨域时必需） | https://www.example.com | | Cache-Control | 缓存策略 | no-cache（不用缓存）、max-age=3600（缓存1小时） | | If-None-Match | 协商缓存（ETag值） | \"abc123\" | | If-Modified-Since | 协商缓存（最后修改时间） | Wed, 21 Oct 2015 07:28:00 GMT | 前端如何设置请求头： 请求体：携带数据 常见数据格式： (1) JSON格式（最常用） (2) 表单格式（传统表单提交） (3) 文件上传（multipart） 三、HTTP响应报文详解 响应报文的结构（3部分） 状态行：说明\"处理结果\" 格式：协议版本 状态码 状态描述 HTTP状态码详解（面试重点） (1) 1xx 信息性状态码（了解即可） 100 Continue：服务器已收到请求头，客户端可以继续发送请求体 101 Switching Protocols：服务器正在切换协议（如HTTP升级到WebSocket） (2) 2xx 成功 | 状态码 | 含义 | 使用场景 | |-------|------|---------| | 200 OK | 请求成功 | 最常见，GET/POST/PUT/DELETE都可能返回 | | 201 Created | 资源已创建 | POST创建用户、订单等成功后返回 | | 204 No Content | 成功但无内容返回 | DELETE删除成功，不需要返回数据 | | 206 Partial Content | 部分内容（断点续传） | 下载大文件时，支持从中间位置继续下载 | (3) 3xx 重定向 | 状态码 | 含义 | 区别 | |-------|------|------| | 301 Moved Permanently | 永久重定向 | SEO权重转移，浏览器会缓存，以后直接访问新地址 | | 302 Found | 临时重定向 | SEO权重不转移，浏览器不缓存，每次都访问原地址 | | 303 See Other | 重定向到另一个资源（强制GET） | POST后重定向，防止刷新重复提交 | | 304 Not Modified | 协商缓存命中 | 资源未修改，用本地缓存（节省流量） | | 307 Temporary Redirect | 临时重定向（方法不变） | 与302类似，但保证请求方法不变（POST不会变GET） | 301 vs 302 实战： (4) 4xx 客户端错误（你的问题） | 状态码 | 含义 | 原因 | |-------|------|------| | 400 Bad Request | 请求参数错误 | 参数格式不对、缺少必需参数 | | 401 Unauthorized | 未授权（需要登录） | 没有提供token或token过期 | | 403 Forbidden | 禁止访问（有token但没权限） | 普通用户访问管理员接口 | | 404 Not Found | 资源不存在 | 接口路径错误、资源已删除 | | 405 Method Not Allowed | 请求方法不允许 | 接口只支持POST，你用了GET | | 408 Request Timeout | 请求超时 | 客户端发送太慢，服务器等不及了 | | 413 Payload Too Large | 请求体过大 | 上传文件超过服务器限制 | | 429 Too Many Requests | 请求过于频繁 | 触发限流（如API每分钟只能调100次） | (5) 5xx 服务器错误（服务器的问题） | 状态码 | 含义 | 原因 | |-------|------|------| | 500 Internal Server Error | 服务器内部错误 | 代码bug、数据库连接失败、空指针异常等 | | 502 Bad Gateway | 网关错误 | Nginx等代理服务器无法连接到后端服务 | | 503 Service Unavailable | 服务不可用 | 服务器过载、正在维护、数据库宕机 | | 504 Gateway Timeout | 网关超时 | 后端服务响应太慢，Nginx等待超时 | 响应头：携带附加信息 | 响应头 | 作用 | 示例值 | |-------|------|--------| | Content-Type | 响应体的数据类型 | text/html（网页）、application/json（JSON）、image/jpeg（图片） | | Content-Length | 响应体的字节长度 | 1234 | | Content-Encoding | 压缩方式 | gzip（Gzip压缩）、br（Brotli压缩） | | Set-Cookie | 设置Cookie | sessionId=xyz; HttpOnly; Secure; Max-Age=3600 | | Cache-Control | 缓存策略（强缓存） | max-age=3600（缓存1小时）、no-cache（协商缓存）、no-store（不缓存） | | ETag | 资源标识（协商缓存） | \"abc123\" | | Last-Modified | 最后修改时间（协商缓存） | Wed, 21 Oct 2015 07:28:00 GMT | | Location | 重定向地址 | https://www.baidu.com | | Access-Control-Allow-Origin | 跨域设置（CORS） | *（允许所有域）、https://www.example.com（允许特定域） | | Access-Control-Allow-Methods | 允许的跨域方法 | GET, POST, PUT, DELETE | | Access-Control-Allow-Headers | 允许的跨域请求头 | Content-Type, Authorization | | Transfer-Encoding | 分块传输 | chunked（数据分块发送，边生成边传输） | 响应体：实际数据 常见格式： 四、HTTP/1.1 vs HTTP/2 vs HTTP/3 | 特性 | HTTP/1.1 | HTTP/2 | HTTP/3 | |------|----------|--------|--------| | 发布时间 | 1997年 | 2015年 | 2022年 | | 传输层 | TCP | TCP | QUIC（基于UDP） | | 数据格式 | 文本 | 二进制 | 二进制 | | 多路复用 | ❌（一个连接一次一个请求） | ✅（一个连接同时多个请求） | ✅ | | 头部压缩 | ❌ | ✅（HPACK） | ✅（QPACK） | | 服务器推送 | ❌ | ✅（服务器主动推送资源） | ✅ | | 队头阻塞 | 严重（TCP层也会阻塞） | 应用层解决，但TCP层仍阻塞 | 完全解决 | | 握手耗时 | 1-2 RTT（TCP握手） | 1-2 RTT | 0 RTT（快速握手） | HTTP/1.1的问题： HTTP/2多路复用： 五、HTTPS：HTTP的安全升级版 HTTP的安全问题 明文传输：数据在网络中\"裸奔\"，WiFi嗅探可窃取密码、Cookie 无法验证身份：无法确认服务器是真的淘宝，可能是钓鱼网站 内容可能被篡改：运营商可能插入广告 HTTPS的解决方案 HTTPS = HTTP + SSL/TLS加密 | 安全特性 | 实现方式 | |---------|---------| | 加密 | 数据用AES等算法加密，窃听者看到的是乱码 | | 身份验证 | 服务器提供CA机构颁发的数字证书（如Let's Encrypt、DigiCert） | | 防篡改 | 数据用哈希算法（如SHA-256）生成摘要，篡改会被发现 | HTTPS的代价 速度慢：TLS握手需要额外2-3个RTT 服务器压力大：加密解密消耗CPU 证书成本：商业证书需要购买（免费证书如Let's Encrypt可用） 六、Cookie详解（HTTP的\"记忆术\"） 为什么需要Cookie？ HTTP是无状态协议，服务器不记得你。 Cookie让服务器\"记住你\"： Cookie的工作流程 Cookie的属性 | 属性 | 作用 | 示例 | |------|------|------| | Domain | 哪些域名可以访问这个Cookie | .example.com（主域名和子域名都能用） | | Path | 哪些路径可以访问 | /api（只有/api开头的路径才能用） | | Max-Age | 有效期（秒） | 3600（1小时后过期） | | Expires | 过期时间（旧版） | Wed, 21 Oct 2025 07:28:00 GMT | | HttpOnly | 禁止JavaScript访问（防XSS攻击） | HttpOnly | | Secure | 只在HTTPS下传输（防中间人攻击） | Secure | | SameSite | 防止CSRF攻击 | Strict（只有同站请求才携带）、Lax（大部分跨站不携带）、None（都携带） | 七、核心总结 HTTP协议本质：浏览器与服务器的\"通信规则手册\"，定义了请求和响应的格式。 请求三要素： 请求行（做什么）：方法 + 路径 请求头（怎么做）：Content-Type、Cookie等 请求体（带什么数据）：JSON、表单等 响应三要素： 状态行（结果如何）：状态码 响应头（附加信息）：缓存、跨域设置等 响应体（实际数据）：HTML、JSON等 记忆技巧： 2xx你真棒（成功） 3xx你走吧（重定向） 4xx你错了（客户端错误） 5xx我错了（服务器错误）"
    },
    {
      "title": "TCP三次握手详解",
      "path": "常用缺易忘/常识/URL到页面显示/TCP三次握手详解.md",
      "category": "常用缺易忘",
      "tags": [],
      "date": null,
      "description": "TCP（Transmission Control Protocol，传输控制协议）是互联网的\"可靠快递员\"，负责在网络中可靠地传输数据。与UDP（用户数据报协议，类似\"普通邮政\"——快但不保证送达）不同，TCP承诺：\r\n- 数据不丢失：确保发出的每个数据包都能送达；\r\n- 数据不乱序：数据按发送顺序到达；\r\n- 数据不重复：同一份数据不会被接收多次。\r\n\r\n但网络环境复杂（数据可能在传输中丢失、延",
      "content": "TCP三次握手详解 一、为什么需要TCP三次握手？ TCP的核心使命 TCP（Transmission Control Protocol，传输控制协议）是互联网的\"可靠快递员\"，负责在网络中可靠地传输数据。与UDP（用户数据报协议，类似\"普通邮政\"——快但不保证送达）不同，TCP承诺： 数据不丢失：确保发出的每个数据包都能送达； 数据不乱序：数据按发送顺序到达； 数据不重复：同一份数据不会被接收多次。 但网络环境复杂（数据可能在传输中丢失、延迟、乱序），TCP如何实现\"可靠\"？答案是在传输前先建立\"可靠的连接通道\"——这就是\"三次握手\"的目的。 为什么不能直接发数据，必须先\"握手\"？ 想象你要给陌生人打电话商量事情，你会： 先确认对方能听到你说话（对方接电话了吗？） 确认你能听到对方说话（对方说话你能听清吗？） 确认双方都准备好了（开始谈正事） TCP也是同理：客户端和服务器在互联网这个\"噪音环境\"中，必须先通过三次通信确认双方的\"发送能力\"和\"接收能力\"都正常，才能开始传输真正的数据，否则可能出现： 客户端发的数据，服务器根本收不到（服务器不在线或网络不通）； 服务器发的数据，客户端收不到（客户端发完请求就断网了）。 二、三次握手的完整流程（打电话类比） 通俗版：打电话确认流程 假设你（客户端）要给客服（服务器）打电话： 技术版：TCP报文交互流程 每次握手的核心含义 | 握手次数 | 发送方 | 核心内容 | 接收方确认了什么 | |---------|--------|---------|----------------| | 第1次 | 客户端 → 服务器 | SYN（请求连接） | 服务器确认：客户端的发送能力正常 | | 第2次 | 服务器 → 客户端 | SYN+ACK（同意连接+确认） | 客户端确认：服务器的发送能力和接收能力都正常 | | 第3次 | 客户端 → 服务器 | ACK（最终确认） | 服务器确认：客户端的接收能力正常 | 关键点：三次握手后，双方都确认了对方的\"收发能力\"，且双方都知道\"对方已经准备好了\"，连接才算真正建立。 三、为什么必须是3次，不能是2次或4次？ 为什么不能2次握手？（核心问题） 场景：假设只有2次握手，会出现什么问题？ 问题案例： 客户端发送了SYN请求，但网络延迟严重，这个SYN迟迟未到服务器； 客户端以为请求丢了，超时重发了一个新的SYN； 新SYN很快到达服务器，服务器回复SYN+ACK，连接建立，数据传输完毕，连接关闭； 此时，第一个\"失效的SYN\"姗姗来迟到达服务器； 服务器以为客户端又要建立新连接，回复SYN+ACK，然后傻等客户端发数据； 但客户端根本不知道这回事（它早就传完数据关闭了），服务器白白占用资源等待。 2次握手的致命缺陷：服务器无法判断收到的SYN是\"有效的新请求\"还是\"网络延迟的旧请求\"，导致可能建立无效连接，浪费资源。 3次握手如何解决： 客户端收到服务器的SYN+ACK后，如果发现\"这不是我最近发的请求\"（序列号对不上），会拒绝发送第3次ACK； 服务器收不到第3次ACK，连接就不会建立，避免了资源浪费。 为什么不需要4次握手？ 3次握手已经足够确认双方的\"收发能力\"： 第1次：服务器确认客户端能发送； 第2次：客户端确认服务器能收能发； 第3次：服务器确认客户端能接收。 4次握手纯属多余，增加通信开销（多一次RTT往返时间）。 四、三次握手的关键参数详解 SYN（Synchronize，同步序列号） 作用：请求建立连接，并告知对方自己的\"初始序列号\"（用于后续数据包的顺序标记）； 值：SYN=1 表示这是握手报文； 序列号seq：随机生成的初始值（如x），后续数据包序号会在此基础上递增（如x+1, x+2...），用于保证数据按序到达。 ACK（Acknowledgment，确认） 作用：确认收到对方的数据； 值：ACK=1 表示确认报文； 确认号ack：期望收到的下一个序列号（如收到seq=x，回复ack=x+1，表示\"x收到了，下次发x+1\"）。 序列号机制的意义 防止数据乱序：数据包在网络中可能走不同路径，到达顺序打乱，序列号可让接收方重新排序； 检测数据丢失：如收到seq=100、102，发现缺了101，就请求重传101； 防止重复：相同seq的数据包收到多次，只处理一次。 五、HTTPS的额外握手：TLS/SSL握手 HTTP是明文传输（数据在网络中\"裸奔\"，易被窃听篡改），HTTPS通过加密保护数据。HTTPS在TCP三次握手后，还需要TLS/SSL握手（约4次通信）协商加密参数： 总耗时：TCP握手约1-2个RTT（往返时间），TLS握手约2-3个RTT，HTTPS建立连接比HTTP慢3-5倍，但安全性大幅提升。 六、常见问题与优化 三次握手很慢，如何优化？ 问题：每次请求都要握手，频繁建立连接耗时长； 解决： HTTP Keep-Alive：一个TCP连接复用，传输多个HTTP请求（不用每次都握手）； HTTP/2多路复用：一个TCP连接同时传输多个请求（彻底解决HTTP/1.1的队头阻塞）。 三次握手能被攻击吗？ SYN洪水攻击： 原理：攻击者伪造大量客户端IP，疯狂发送SYN请求，服务器回复SYN+ACK后等第3次ACK，但攻击者不回复，导致服务器积累大量\"半连接\"，耗尽资源； 解决： SYN Cookie：服务器不立即分配资源，而是在收到第3次ACK时才分配（无效请求不占资源）； 限制SYN队列大小：超过阈值拒绝新连接； 防火墙过滤：识别并拦截异常SYN请求。 七、核心总结 | 对比维度 | TCP三次握手 | UDP（无握手） | |---------|------------|--------------| | 可靠性 | 高（确保连接建立） | 低（直接发数据，不管对方是否在线） | | 速度 | 慢（需1-2个RTT） | 快（无握手开销） | | 适用场景 | 网页访问、文件下载、邮件发送等需保证数据完整性的场景 | 视频直播、语音通话等对实时性要求高、容忍少量丢包的场景 | 一句话总结：TCP三次握手是互联网\"可靠通信\"的基石——就像打电话前先确认\"喂，能听见吗\"，确保双方都在线且能正常收发信息，才开始传输关键数据，避免\"对着空气说话\"的尴尬。"
    },
    {
      "title": "时间戳完全指南",
      "path": "常用缺易忘/技术/时间戳完全指南.md",
      "category": "常用缺易忘",
      "tags": [],
      "date": null,
      "description": "> 一次搞懂时间戳，再也不混乱！🕐\r\n\r\n\r\n\r\n\r\n时间戳：从 1970年1月1日 00:00:00 UTC 到现在经过的时间\r\n\r\n就像一个计时器，从1970年开始计数，每过1秒（或1毫秒）就+1。\r\n\r\n\r\n\r\n\r\n这是计算机的\"元年\"，叫做 Unix纪元（Unix Epoch）。\r\n所有编程语言都统一用这个标准，方便全球交流。\r\n\r\n\r\n\r\n| 类型 | 说明 | 长度 | 示例 |\r\n",
      "content": "JavaScript 时间戳完全指南 一次搞懂时间戳，再也不混乱！🕐 一、什么是时间戳？ 1.1 通俗解释 时间戳：从 1970年1月1日 00:00:00 UTC 到现在经过的时间 就像一个计时器，从1970年开始计数，每过1秒（或1毫秒）就+1。 1.2 为什么是1970年？ 这是计算机的\"元年\"，叫做 Unix纪元（Unix Epoch）。 所有编程语言都统一用这个标准，方便全球交流。 1.3 时间戳的两种单位 | 类型 | 说明 | 长度 | 示例 | |-----|------|------|------| | 秒时间戳 | 从1970年到现在的秒数 | 10位 | 1700123456 | | 毫秒时间戳 | 从1970年到现在的毫秒数 | 13位 | 1700123456789 | --- 二、如何获取时间戳 2.1 获取当前时间戳（3种方法） 2.2 获取指定时间的时间戳 2.3 秒时间戳 ↔ 毫秒时间戳转换 --- 三、时间戳转日期格式 3.1 基础转换（原生方法） 3.2 手写格式化函数（通用） 3.3 使用 Day.js 库（推荐）⭐ --- 四、日期格式转时间戳 4.1 字符串转时间戳 4.2 Date对象转时间戳 --- 五、时间计算 5.1 计算时间差 5.2 实用工具函数 5.3 倒计时实现 --- 六、常见场景实战 6.1 显示\"刚刚\"、\"3分钟前\"等 6.2 后端接口对接（重点）⭐⭐⭐ 6.3 时间选择器值处理 6.4 判断时间是否过期 --- 七、常见坑点总结 ⚠️ 坑点1：秒和毫秒搞混 坑点2：月份从0开始 坑点3：Safari浏览器兼容性 坑点4：时区问题 坑点5：取整问题 --- 八、快速记忆卡片 🎯 九、实用代码片段（直接复制用） --- 十、调试技巧 --- 📚 推荐资源 Day.js (轻量级时间库)：https://day.js.org/ MDN Date文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date 时间戳在线转换工具：https://tool.lu/timestamp/ --- 💡 学习建议： 记住JavaScript用毫秒，后端大多用秒 常用的就是 Date.now() 和 new Date(timestamp).getTime() 月份从0开始，记得+1 实在搞不清就用 Day.js 库，省心！ 把常用工具函数保存到自己的代码片段库 🎯 一句话总结：前端用毫秒（13位），后端用秒（10位），互相转换记得 ×1000 或 ÷1000！"
    },
    {
      "title": "Canvas标签",
      "path": "常用缺易忘/技术/Canvas标签.md",
      "category": "常用缺易忘",
      "tags": [],
      "date": null,
      "description": "你可以把 <span class=\"ne-text\"><canvas></span> 标签理解成一块电子画板：  \r\n\r\n 它本身只是一块“空白画布”（在HTML里是个矩形区域），不能直接画画；  \r\n 必须用 JavaScript“画笔” 才能在上面绘图；\r\n 能画的东西很多：直线、方块、圆圈、文字、图片，甚至能做动画和交互（比如用鼠标在上面“涂鸦”）。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n <spa",
      "content": "HTML5 Canvas 超详细入门笔记（通俗易懂版） 一、把 Canvas 想象成「数字画板」 你可以把 <span class=\"ne-text\"><canvas></span> 标签理解成一块电子画板： 它本身只是一块“空白画布”（在HTML里是个矩形区域），不能直接画画； 必须用 JavaScript“画笔” 才能在上面绘图； 能画的东西很多：直线、方块、圆圈、文字、图片，甚至能做动画和交互（比如用鼠标在上面“涂鸦”）。 二、准备工作：让“画板”和“画笔”就位 先摆好“画板”（写 Canvas 标签） <span class=\"ne-text\">id</span>：给画板起个名字，方便后续用JS找到它； <span class=\"ne-text\">width</span> 和 <span class=\"ne-text\">height</span>：必须写在标签里（别用CSS！），决定画板的实际大小（比如400px宽，200px高）； 不写大小的话，默认是300×150px的小画板。 拿起“画笔”（获取绘图上下文） 有了画板，还得有“画笔”——JS里叫「绘图上下文」（可以理解成“握着画笔的手”）。 画布的“坐标系”：别画跑偏了 Canvas的坐标系和数学里不太一样，新手容易搞混： 原点(0,0) 在画布的左上角（不是左下角！）； 向右移动，x坐标变大； 向下移动，y坐标变大； 比如 <span class=\"ne-text\">(50, 30)</span> 表示：从左上角向右移50px，向下移30px的位置。 三、基础绘图：从“画方块”到“画圆圈” 画矩形：最简单的图形（像盖房子的砖块） 效果：左边一个蓝色实心方块，右边一个红色边框的空心方块。 画路径：自由画线条（像用铅笔勾轮廓） 路径是Canvas的核心，复杂图形（三角形、多边形）都靠它画。 步骤：起笔 → 移动/画线 → 闭合 → 上色 效果：一个黄色填充、黑色描边的三角形。 画圆形：用“圆规”画圆（比路径简单） 角度用“弧度”计算：<span class=\"ne-text\">Math.PI</span> 是180度，<span class=\"ne-text\">Math.PI2</span> 是360度； 想画半圆？把最后一个参数改成 <span class=\"ne-text\">Math.PI</span>（180度）就行。 四、美化图形：给画加点“样式” 颜色：换支“彩笔” <span class=\"ne-text\">fillStyle</span>：填充颜色（图形内部）； <span class=\"ne-text\">strokeStyle</span>：描边颜色（图形边缘）； 支持：颜色名（<span class=\"ne-text\">red</span>）、十六进制（<span class=\"ne-text\">#F59E0B</span>）、RGB（<span class=\"ne-text\">rgb(245,158,11)</span>）、RGBA（带透明度，<span class=\"ne-text\">rgba(245,158,11,0.5)</span>）。 线条：调整“画笔粗细”和“笔尖形状” 效果：一条紫色、5px粗、两端圆钝、拐角圆润的直线。 渐变：让颜色“慢慢过渡”（像彩虹） 线性渐变：从一个点到另一个点的颜色过渡（比如从左到右变红）； 径向渐变：从中心向外的颜色过渡（比如太阳从黄到橙）。 五、画文字：在画布上“写字” 两种文字：实心字和空心字 文字对齐：让文字“站整齐” <span class=\"ne-text\">textAlign</span> 可选：<span class=\"ne-text\">left</span>（左对齐）、<span class=\"ne-text\">center</span>（居中）、<span class=\"ne-text\">right</span>（右对齐）。 六、放图片：把图片“贴”到画布上 效果：画布上会有3张图——原图、缩小图、裁剪后的局部图。 七、高级操作：让画“动起来”“能互动” 变换：移动、旋转、缩放图形（像玩橡皮泥） 想象你在操作画板本身： 平移：把画板挪个位置； 旋转：把画板转个角度； 缩放：用放大镜看画板。 一定要用 <span class=\"ne-text\">save()</span> 和 <span class=\"ne-text\">restore()</span> 包裹变换！否则变换会影响所有后续绘图。 动画：让图形“动起来”（像翻动画片） 原理：快速切换画面（每帧更新图形位置），人眼会觉得是连续的动画。 效果：一个绿色小球在画布内来回反弹，像弹球一样。 交互：用鼠标“画画”（像在画板上涂鸦） 原理：监听鼠标事件，跟着鼠标轨迹画线。 效果：按住鼠标在画布上拖动，会画出连续的线条，像手写板一样。 八、实际能做什么？（学了有用！） 数据可视化：画图表（柱状图、折线图），比如疫情数据统计； 小游戏：贪吃蛇、俄罗斯方块、五子棋（用Canvas画棋子，检测输赢）； 电子签名：让用户用鼠标签字，保存成图片（合同、表单常用）； 图片编辑器：简单的裁剪、滤镜（比如把图片变成黑白）； 动态背景：网页上的粒子动画、流动的渐变效果。 总结：Canvas 学习路径 先掌握基础：画矩形、圆形、路径，设置颜色和样式； 再学进阶：文字、图片、渐变； 最后挑战：变换、动画、交互； 关键：多动手！哪怕是画个会动的方块，也能帮你理解原理。 Canvas 就像一块万能的电子画板，只要你能想到的2D图形效果，几乎都能实现——动手试试吧！以下是一个基于Canvas的签名板实现，支持鼠标/触摸签名并保存为图片，包含完整代码和详细注释： 签名板实现代码（HTML+CSS+JavaScript） 功能说明与核心原理 签名功能实现 画布初始化：通过<span class=\"ne-text\">getContext('2d')</span>获取绘图上下文，设置线条样式（颜色、粗细、端点形状），确保签名流畅自然。 绘制逻辑： 鼠标/触摸按下时（<span class=\"ne-text\">mousedown</span>/<span class=\"ne-text\">touchstart</span>）：记录起点，开始绘制状态 移动时（<span class=\"ne-text\">mousemove</span>/<span class=\"ne-text\">touchmove</span>）：从上次记录的点绘制到当前点，形成连续线条 松开时（<span class=\"ne-text\">mouseup</span>/<span class=\"ne-text\">touchend</span>）：结束绘制状态 坐标处理：兼容PC端（鼠标坐标）和移动端（触摸坐标），通过<span class=\"ne-text\">getBoundingClientRect()</span>计算触摸点在Canvas中的相对位置。 保存图片功能 Canvas转图片：使用<span class=\"ne-text\">canvas.toDataURL('image/png')</span>将画布内容转换为Base64格式的图片URL，支持PNG/JPG等格式。 下载实现：动态创建<span class=\"ne-text\"><a></span>标签，将图片URL赋值给<span class=\"ne-text\">href</span>，设置<span class=\"ne-text\">download</span>属性指定文件名，触发点击事件完成下载。 其他功能 清除签名：通过<span class=\"ne-text\">fillRect()</span>绘制白色矩形覆盖整个画布，实现清空效果。 跨设备兼容：同时支持鼠标（PC）和触摸（手机/平板）操作，满足不同场景需求。 使用方法 在画布区域用鼠标拖动或触摸屏幕进行签名 点击「清除签名」可重新签名 点击「保存签名」会将签名以PNG格式下载到本地 这个实现轻量高效，无需依赖外部库，可直接嵌入到网页或应用中，适合电子合同、表单签署等场景。"
    },
    {
      "title": "Markdown完全指南",
      "path": "提高效率的技术/Markdown完全指南.md",
      "category": "提高效率的技术",
      "tags": [],
      "date": null,
      "description": "> 📚 这是一份全面的 Markdown 语法参考手册，涵盖了日常写作和技术文档所需的所有格式。\r\n\r\n\r\n1. 基础语法\r\n2. 进阶语法\r\n3. 扩展语法\r\n4. 实用技巧\r\n5. 常用场景模板\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n效果预览：\r\n\r\n\r\n\r\n\r\n💡 使用建议：\r\n- 文章标题用 H1（）\r\n- 主要章节用 H2（）\r\n- 子章节用 H3-H4（ ）\r\n- 避免跳级使",
      "content": "Markdown 完全指南 - 从入门到精通 📚 这是一份全面的 Markdown 语法参考手册，涵盖了日常写作和技术文档所需的所有格式。 目录 基础语法 进阶语法 扩展语法 实用技巧 常用场景模板 --- 基础语法 标题（Headers） 效果预览： 一级标题 二级标题 三级标题 💡 使用建议： 文章标题用 H1（#） 主要章节用 H2（##） 子章节用 H3-H4（### ####） 避免跳级使用 文本格式（Text Formatting） 效果预览： 粗体文本 斜体文本 粗斜体 删除线文本 行内代码 列表（Lists） 无序列表 有序列表 任务列表 效果预览： [x] 已完成的任务 [ ] 待完成的任务 链接（Links） 图片（Images） 引用（Blockquotes） 效果预览： 这是一段引用 >> 嵌套引用 代码块（Code Blocks） 行内代码 代码块（带语法高亮） javascript function hello() { console.log(\"Hello, World!\"); } python def hello(): print(\"Hello, World!\") css .container { width: 100%; padding: 20px; } 分隔线（Horizontal Rules） 效果： --- 表格（Tables） 效果预览： | 姓名 | 年龄 | 职业 | | :--- | :---: | ---: | | 张三 | 25 | 工程师 | | 李四 | 30 | 设计师 | --- 进阶语法 脚注（Footnotes） 定义列表（Definition Lists） 缩略语（Abbreviations） 数学公式（LaTeX） 键盘按键（Keyboard Keys） 效果： <kbd>Ctrl</kbd> + <kbd>C</kbd> 上标和下标 效果： X<sup>2</sup> 和 H<sub>2</sub>O --- 扩展语法 折叠内容（Details） 效果预览： <details> <summary>点击展开详情</summary> 这里是隐藏的内容 </details> 高亮文本 对齐文本 颜色文本 嵌入内容 嵌入视频 嵌入音频 嵌入 iframe --- 实用技巧 转义字符 如果要显示 Markdown 特殊字符，使用反斜杠 \\ 转义： 可转义的字符： 空格和换行 注释 锚点链接（页内跳转） 徽章（Badges） --- 常用场景模板 项目 README 模板 bash npm install project-name \\ javascript const project = require('project-name'); project.init(); \\ 技术笔记模板 javascript // 代码示例 \\ 会议记录模板 学习计划模板 --- 💡 快速参考卡片 最常用语法速查 | 功能 | 语法 | 示例 | | --- | --- | --- | | 标题 | # 标题 | # 一级标题 | | 粗体 | 文本 | 粗体 | | 斜体 | 文本 | 斜体 | | 链接 | 文本 | 链接 | | 图片 | !描述 | !图片 | | 代码 | 代码 | code | | 列表 | - 项目 | - 项目 | | 引用 | > 引用 | > 引用 | | 分隔线 | ---` | --- | 表情符号（Emoji） 在 Markdown 中可以直接使用 emoji： 特殊符号 --- 🛠 工具推荐 编辑器 Typora - 所见即所得 VS Code - 强大的扩展支持 Obsidian - 知识管理 Notion - 在线协作 MarkText - 开源免费 VS Code 插件 Markdown All in One - 全能插件 Markdown Preview Enhanced - 增强预览 Markdownlint - 语法检查 Markdown PDF - 导出 PDF 在线工具 StackEdit - 在线编辑器 Dillinger - 实时预览 Markdown Tables Generator - 表格生成器 --- 📝 最后的建议 循序渐进：先掌握基础语法，再学习进阶功能 多加练习：实践是最好的学习方式 保持简洁：Markdown 的核心是简洁，不要过度使用复杂语法 统一风格：在同一文档中保持一致的格式风格 善用工具：选择适合自己的编辑器，提高效率 💡 记住：Markdown 的目的是让你专注于内容，而不是格式！ --- 最后更新：2024年"
    },
    {
      "title": "第一篇_认识CSS_风格的起点",
      "path": "CSS/第一篇_认识CSS_风格的起点.md",
      "category": "CSS",
      "tags": [],
      "date": null,
      "description": "> 目标：知道 CSS 是什么、能做什么、如何把 CSS 引入到页面，以及浏览器如何处理样式。看完即可开始为页面做基础的上色与排版。\n\n---\n\n\n\n\n\nCSS 是什么？\n\nCSS 的全称是 Cascading Style Sheets（层叠样式表），是一种用来描述网页外观和格式的样式语言。\n\n- Cascading（层叠）：当多个样式规则应用到同一个元素时，CSS 会按照特定的规则决定哪个样式生",
      "content": "第一篇 认识 CSS：风格的起点 目标：知道 CSS 是什么、能做什么、如何把 CSS 引入到页面，以及浏览器如何处理样式。看完即可开始为页面做基础的上色与排版。 --- 第1章 什么是 CSS：让页面长出灵魂的语言 1.1 CSS 的工作方式 CSS 是什么？ CSS 的全称是 Cascading Style Sheets（层叠样式表），是一种用来描述网页外观和格式的样式语言。 Cascading（层叠）：当多个样式规则应用到同一个元素时，CSS 会按照特定的规则决定哪个样式生效。就像多层透明纸叠在一起，最上面的会覆盖下面的，但如果上面的纸有透明部分，下面的内容还能透出来。 举例：如果你给 <p> 标签设置了红色，又在某个特定的 <p> 上设置了蓝色，最终会显示蓝色（更具体的规则覆盖更通用的规则） Style Sheets（样式表）：把所有样式规则组织在一起的\"表格\"或\"清单\" 💡 为什么需要 CSS？ 在 CSS 出现之前，网页的样式都直接写在 HTML 标签里（如 <font color=\"red\">），导致代码混乱、难以维护 CSS 让内容（HTML）和样式（CSS）分离，就像文章内容和排版设计分开一样 核心分工 HTML：结构与内容 CSS：样式与视觉 JavaScript：交互与逻辑 CSS 能做什么 文本样式（字体、大小、颜色、行高、对齐） 视觉外观（背景、边框、圆角、阴影） 布局排版（位置、尺寸、排列） 动效特效（过渡、动画、变换、滤镜） 响应式（不同屏幕一致好看） 基本工作流 写 HTML → 写 CSS → 浏览器将样式应用到元素 → 渲染页面 示例： --- 1.2 HTML 与 CSS 的合作关系 分离的好处 维护性：一处改样式，处处生效 复用性：多个页面共享同一套样式 可读性：HTML 干净语义化，有利可访问性与 SEO 实践建议 用 class 作为样式钩子；id 标识唯一元素或锚点 避免将样式写进陈旧的 HTML 表现性标签 💡 什么是\"表现性标签\"？ 表现性标签是指那些直接控制外观的 HTML 标签，它们在 HTML5 中已被废弃或不推荐使用： | 废弃标签 | 作用 | 应该用什么代替 | |---------|------|---------------| | <font> | 设置字体、颜色、大小 | CSS 的 font-family、color、font-size | | <center> | 居中对齐 | CSS 的 text-align: center | | <b> | 加粗（仅视觉） | <strong>（语义化）+ CSS font-weight | | <i> | 斜体（仅视觉） | <em>（语义化）+ CSS font-style | | <u> | 下划线 | CSS 的 text-decoration: underline | ❌ 不推荐的旧写法： ✅ 推荐的现代写法： 💡 class 和 id 的命名规范 class 命名（可复用，一个元素可以有多个 class）： kebab-case（推荐）：用短横线连接，如 btn-primary、nav-item、user-profile BEM 命名法（大型项目）：块__元素--修饰符 例：card__title--large（card 块中的 title 元素的 large 修饰） 避免：拼音、无意义的名称（如 a1、box1） id 命名（全局唯一，一个元素只能有一个 id）： 用于唯一标识：#site-header、#main-content、#user-123 用于锚点跳转：#section-about、#contact-form 命名规则同 class，但要确保整个页面唯一 示例（推荐写法）： --- 1.3 CSS 的三种引入方式 内联样式（Inline） 写在标签的 style 属性里 示例： 优点：优先级高、调试方便 缺点：不可复用，污染 HTML，不利维护 用途：快速试验、邮件 HTML、JS 动态样式 ℹ️ 邮件 HTML 说明：指用于构建电子邮件内容的 HTML 代码。由于不同邮件客户端（如 Gmail、Outlook、苹果邮件等）对 HTML 和 CSS 的支持差异很大，很多现代 CSS 特性（如外部样式表、复杂选择器等）在邮件中可能无法正常生效，因此常用内联样式。 内部样式表（Internal） 写在页面 <head> 中的 <style> 标签里 示例： 用途：单页/原型/页面独有样式 外部样式表（External）⭐ 推荐 写在 .css 文件，用 <link> 引入 示例： 优点：可复用、可缓存、协作友好、维护成本低 @import 在 CSS 内引入其它 CSS 写法: 缺点: 串行加载，阻塞渲染（<link> 可并行） 浏览器解析到 @import 时，会先停下当前 CSS 的加载，去下载导入的 CSS，下完再继续（串行加载） 而用 <link> 标签引入多个 CSS 时，浏览器可以同时下载（并行加载），更快 必须写在所有规则之前 如果 @import 写在其他样式后面，可能会失效（浏览器不识别） 增加请求层级深度 如果 A.css 导入 B.css，B.css 又导入 C.css，浏览器要一层一层下载，更耗时 适用场景:组织大型项目的 CSS 模块(但现代构建工具更优) 小结与加载顺序 优先级:内联 > 内部/外部(内部和外部取决于在 HTML 中的书写顺序,后者覆盖前者) 示例: 生产环境优先使用外部样式表 --- 1.4 浏览器如何解析你的样式（渲染流程） 五步流程（简化） 解析 HTML → 生成 DOM 浏览器先读 HTML，把标签（比如 <div>、<p>）变成一个\"节点树\"（DOM） 就像先搭好房子的框架，记录每个房间（元素）的位置和层级关系 解析 CSS → 生成 CSSOM 再读所有 CSS（包括内联、<style>、外部 CSS），生成一个\"样式规则树\"（CSSOM） 就像整理好一本\"装修手册\"，记录每个房间该刷什么颜色、用什么尺寸的家具 合并 DOM + CSSOM → 渲染树 把\"框架（DOM）\"和\"装修手册（CSSOM）\"结合，只保留需要显示的元素 比如 <head> 里的内容不显示，就会被剔除 得到\"渲染树\"—— 明确每个要显示的元素该用什么样式 布局（Layout）→ 计算尺寸位置 根据渲染树，计算每个元素的具体尺寸（宽高）、位置（在屏幕的 x/y 坐标） 比如确定\"这个 <div> 宽 200px，左上角在 (100px, 200px) 的位置\" 绘制与合成（Paint/Composite）→ 显示到屏幕 最后一步，浏览器按照布局结果，把元素画在屏幕上（比如给 <div> 涂红色、画边框） 再把分层的内容合成到一起，就是我们看到的完整页面 层叠（Cascade）与冲突解决 💡 冲突场景：当多个样式规则\"打架\"（比如两个规则都给同一个元素设置 color），浏览器按以下规则选一个生效 层叠来源优先级（从高到低） 用户代理（浏览器）的 !important 声明 浏览器自带样式 + !important（极少用，比如浏览器强制让按钮不可改颜色） 用户自定义的 !important 声明 用户自己在浏览器里设置的样式 + !important（比如用户手动改了字体大小并强制生效） 作者（开发者）的 !important 声明 我们写的 CSS + !important（比如 p {color: red !important;}） 作者的正常声明 ⭐ 我们写的 CSS 我们写的普通 CSS（最常用，比如 p {color: red;}） 用户自定义的正常声明 用户在浏览器里设置的普通样式（比如用户改了默认字体） 用户代理的默认样式 浏览器自带的默认样式（比如 <p> 标签默认有上下边距） 同一来源内的冲突解决：!important > 特异性 > 书写顺序（后者覆盖前者） 继承（Inheritance） 会继承：color、font-family、font-size、line-height、text-align 等 不继承：margin、padding、border、width/height、position、background 等 选择器匹配 引擎从选择器\"最后一段\"开始匹配，再向上确认父/祖先条件 💡 从右到左匹配原理： 浏览器找\"哪个元素该用哪个样式\"时，不是从左到右读选择器，而是从右到左 比如选择器 div .box p（找 <div> 里带 box 类的元素中的 <p> 标签） 浏览器会先找所有 <p> 标签，再检查这些 <p> 的父元素有没有 class=\"box\"，最后看它们的祖先有没有 <div> 这样做是为了更快匹配（先缩小范围，再逐层验证） DevTools 调试要点 Styles 面板看\"命中规则与覆盖关系（删除线）\" Computed 面板看\"最终生效值与盒模型\" --- 第2章 CSS 选择器基础：我想改谁？ 2.1 标签、类、ID 选择器 标签选择器（Element Selector） 作用：选择所有同名的 HTML 标签 语法：直接写标签名 示例：h1 { font-size: 32px; } 影响页面上所有 <h1> 标签 适用场景：设置全局默认样式（如所有段落的行高、所有链接的颜色） 类选择器（Class Selector） ⭐ 最常用 作用：选择所有带有指定 class 的元素 语法：.类名 { ... } 示例：.btn { padding: 10px 16px; } 特点： 可复用：同一个 class 可以用在多个元素上 可组合：一个元素可以有多个 class（用空格分隔） 💡 多类名的使用场景： 通过组合多个 class，可以灵活地复用样式，避免重复代码。这是一种非常强大的设计模式。 ID 选择器（ID Selector） ⚠️ 慎用 作用：选择带有指定 id 的元素 语法：#id名 { ... } 示例：#site-header { background:#111; } 特点： 页面内必须唯一：一个 id 只能用在一个元素上 优先级非常高：比 class 选择器高，容易导致样式难以覆盖 ⚠️ 为什么 ID 选择器要慎用？ 优先级过高：ID 选择器的权重是 0-1-0-0，比类选择器 0-0-1-0 高很多。如果用 ID 写样式，后期想覆盖会很困难。 不可复用：ID 必须唯一，无法在多个元素上复用，违背了 CSS 的复用原则。 难以维护：大型项目中如果到处用 ID，样式会变得难以管理和覆盖。 💡 ID 的正确用途： 用于 JavaScript 选择元素：document.getElementById('user-form') 用于页面内锚点跳转：<a href=\"#section-about\">关于我们</a> 用于唯一标识：<header id=\"site-header\">（但样式还是用 class 写） 建议：大多数样式用 class 组织；ID 用于唯一标识或锚点，样式尽量不用 ID 选择器 示例： --- 2.2 通配符、后代、子代选择器 通配符（*） 作用：选择页面上的所有元素 多用于 CSS Reset 或统一盒模型 示例： ⚠️ 性能提示：现代浏览器优化已很好，但避免 * { ... } 写过多复杂样式 推荐用法：仅用于盒模型重置等基础设置 💡 什么是 box-sizing: border-box？为什么要设置？ 这是 CSS 中最重要的属性之一，它改变了元素宽高的计算方式。 默认的盒模型（content-box）： 元素的 width 和 height 只包含内容区域 实际占据的空间 = width + padding + border 问题：设置 width: 200px; padding: 20px; border: 1px; 后，元素实际宽度是 242px（200 + 20×2 + 1×2） border-box 盒模型（推荐）： 元素的 width 和 height 包含 padding 和 border 实际占据的空间 = width（已包含 padding 和 border） 好处：设置 width: 200px 后，无论 padding 和 border 多大，元素总宽度始终是 200px 💡 为什么推荐全局设置 border-box？ 更符合直觉：设置多宽就是多宽，不用计算 padding 和 border 布局更容易：不用担心加了 padding 就把布局撑破 响应式更友好：百分比宽度不会因为 padding 而溢出 后代选择器（空格） 语法：祖先 后代 作用：匹配任意层级的后代元素（不管隔了多少层） 示例：.card p { color:#475569; } 应用场景： 子代选择器（>） 语法：父 > 子 作用：仅匹配直接子元素（只选一层） 示例：.card > p { color:#ef4444; } 应用场景： 💡 后代选择器 vs 子代选择器的选择： 用后代选择器：当你想影响所有嵌套的元素时（如文章内所有段落） 用子代选择器：当你只想影响直接子元素时（如导航菜单的第一层项目） 实际案例： --- 2.3 同级、相邻兄弟选择器 相邻兄弟（+） A + B：A 后紧邻的第一个同级 B 示例： 通用兄弟（~） A ~ B：A 后所有同级 B（不要求紧邻） 示例： 表单联动示例： 表单联动的本质是 “状态驱动变化”： 用 CSS 伪类（:checked / :focus / :valid 等）捕捉元素状态 用选择器（+ / ~ / > 等）关联目标元素 简单场景纯 CSS 搞定，复杂逻辑（如数据联动）配合 JS 监听 change / input 事件 --- 2.3.1 属性选择器 基本语法 [attr] 存在该属性（不管属性值是什么） [attr=\"value\"] 属性值完全匹配（大小写敏感） [attr^=\"value\"] 属性值以 value 开头 [attr$=\"value\"] 属性值以 value 结尾 [attr*=\"value\"] 属性值包含 value（任意位置） [attr~=\"value\"] 属性值是空格分隔的词列表，其中一个是 value 实用示例： --- 2.3.2 伪类与伪元素 什么是伪类（Pseudo-classes）？ 伪类是用来选择元素的特定状态的选择器，比如鼠标悬停、获得焦点、第一个子元素等。它们以单冒号 : 开头。 💡 为什么叫\"伪类\"？ 因为它们不是真正的 HTML class，而是元素的一种\"状态\"或\"位置\" 比如 :hover 表示\"鼠标悬停时的状态\"，:first-child 表示\"作为第一个子元素的位置\" 常用伪类分类 交互伪类（用户操作触发的状态） :hover：鼠标悬停时 应用场景：按钮悬停效果、链接高亮、卡片浮起 :active：鼠标按下时（点击瞬间） 应用场景：按钮按下效果 :focus：元素获得焦点时（如输入框被点击） 应用场景：表单输入框焦点样式、键盘导航可访问性 :focus-visible：仅键盘导航时显示焦点样式 好处：鼠标点击不显示焦点框，键盘导航才显示（更好的用户体验） 链接伪类（仅用于 <a> 标签） :link：未访问过的链接 :visited：已访问过的链接 ⚠️ 注意：:visited 只能设置颜色相关属性（出于隐私保护） 结构伪类（根据元素在 DOM 中的位置选择） :first-child：作为父元素的第一个子元素 :last-child：作为父元素的最后一个子元素 :nth-child(n)：选择第 n 个子元素 应用场景：表格斑马纹、列表样式 :first-of-type / :last-of-type：同类型元素中的第一个/最后一个 :only-child：父元素中唯一的子元素 表单伪类（表单元素的状态） :checked：被选中的单选框或复选框 :disabled：被禁用的表单元素 :enabled：未被禁用的表单元素 :required：必填的表单元素 :optional：非必填的表单元素 :valid / :invalid：验证通过/失败的表单元素 否定伪类 :not(selector)：排除某些元素 其他常用伪类 :empty：没有子元素的元素 :target：URL 锚点指向的元素 --- 什么是伪元素（Pseudo-elements）？ 伪元素用于创建不存在于 DOM 中的元素，或者选择元素的特定部分。它们以双冒号 :: 开头（CSS3 规范，但单冒号也兼容）。 💡 伪类 vs 伪元素的区别： 伪类：选择元素的状态（单冒号 :） 伪元素：创建虚拟元素（双冒号 ::） 常用伪元素 ::before 和 ::after：在元素内容前后插入内容 最常用的伪元素，可以在元素内部的开头或结尾插入内容。 💡 实际应用场景： 添加装饰图标： 清除浮动（经典技巧）： 创建几何图形： 引号包裹： ::first-letter：选择元素的第一个字母 应用场景：杂志式首字母下沉效果 ::first-line：选择元素的第一行 ::selection：用户选中的文本 应用场景：自定义文本选中颜色 ::placeholder：输入框占位符文本 --- 伪类和伪元素的组合使用 可以将伪类和伪元素组合使用，创建更复杂的效果： --- 实战示例：按钮悬停效果 --- 常见问题 Q1: 为什么 ::before 和 ::after 不显示？ ✅ 必须设置 content 属性（哪怕是空字符串 content: \"\"） ✅ 默认是 display: inline，可能需要改为 block 或 inline-block Q2: 伪元素可以嵌套吗？ ❌ 不可以。伪元素不能再有伪元素（如 ::before::after 无效） Q3: 伪类的顺序重要吗？ ✅ 链接伪类有顺序要求：:link → :visited → :hover → :active（记忆口诀：LoVe HAte） --- 2.4 选择器优先级与覆盖规则 层叠顺序（同来源） !important > 特异性 > 书写顺序 特异性记忆法：a-b-c-d a：是否内联（有则 1） b：ID 个数 c：类/属性/伪类 个数 d：标签/伪元素 个数 常见等级（高→低） 内联 > #id > .class/[attr]/:hover > div/::before :not()/:is()/:where() :not(X) 不增自身权重，但计入 X 的特异性 :is(A,B) 取参数中最高特异性 :where(A,B) 特异性恒 0，适合写“可被覆盖的基础规则” 常见不生效原因 特异性不足、顺序在前、来源不同、未命中、被覆盖 调试流程 用 DevTools 看删除线与 Computed 来源，再决定是否调整选择器或顺序 练习：谁决定颜色？ 2.4.1 特异性速查表 💡 核心概念：CSS 选择器的\"特异性\"（也叫\"权重\"）规则——当多个选择器给同一个元素设置样式时，浏览器根据权重高低决定哪个样式生效。 权重梯度表：可以把权重想象成一个\"四位数密码\" a-b-c-d，每一位代表不同类型选择器的\"分量\"，数字越大，权重越高： | 选择器类型 | 权重密码 | 说明 | |--------------------|------------|----------------------------------------------------------------------| | 内联样式 style=\"\" | 1-0-0-0 | 直接写在标签里的样式，权重最高（比如 <div style=\"color:red\">） | | ID 选择器 #id | 0-1-0-0 | 用 # 定义的选择器（比如 #box { ... }） | | 类/属性/伪类 | 0-0-1-0 | 类（.class）、属性（[type=\"text\"]）、伪类（:hover）都算这一档 | | 标签/伪元素 | 0-0-0-1 | 标签（div、p）、伪元素（::before）都算这一档 | | 通配符 * | 0-0-0-0 | 匹配所有元素，但权重几乎为 0，可忽略 | 比较规则：从左到右\"比大小\" 比较两个选择器的权重时，像比较四位数大小一样，从左到右依次看每一位，只要某一位的数字更大，就直接判定这个选择器权重更高，后面的位不用看了。 实战举例： ID vs 多个类 #main（权重 0-1-0-0） vs .a.b.c（权重 0-0-3-0） → 先看第一位 a（都是 0）→ 再看第二位 b（1 > 0）→ #main 胜出 标签+ID vs 多个类 div#box（权重 0-1-0-1） vs .nav .item（权重 0-0-2-0） → 比较第二位 b（1 > 0）→ div#box 胜出 权重相同看顺序 .box p（权重 0-0-1-1） vs div .text（权重 0-0-1-1） → 四位数字完全相同 → 后面写的样式覆盖前面的（\"后来者居上\"） 关键结论： ⚠️ 权重只看\"类型\"，不看\"数量\"：1 个 ID 选择器（0-1-0-0）永远比 100 个类选择器（0-0-100-0）强 ⚠️ 内联样式几乎无敌：1-0-0-0 除非加 !important（但尽量少用，容易打乱权重逻辑） 💡 最佳实践：尽量用\"刚好够用\"的权重（比如能用类选择器就不用 ID），避免后期样式覆盖困难 2.4.2 几个典型“小剧场” 场景 1：同一个元素被标签和类同时选中 类的权重大于标签，所以最终是绿色。 场景 2：两个类 vs 一个 ID ID 的“b 位”更大，所以红色获胜。 注：.btn.primary 表示同时拥有 btn 和 primary 两个类的元素，实际项目中更常用 .btn-primary 这种单类名的 BEM 命名方式。 场景 3：权重相同，看书写顺序 相同选择器、相同来源、没有 !important 时，后写的覆盖先写的。 2.4.3 !important 不是“万能钥匙” !important 会把某条声明拉到“重要层”，常见写法： 它可以临时“救火”，但副作用是： 降低样式可维护性：以后再想覆盖它，只能写更高来源或继续叠 !important 容易形成“优先级军备竞赛”：到处都是 !important 经验建议： 优先通过合理的选择器和结构来解决覆盖问题 只有在确实需要“强制覆盖第三方样式”时，再考虑使用 !important --- 第3章 CSS 常用属性初体验 目标：掌握常用的文字、背景、边框与阴影属性，能快速做出舒适的基础视觉。 3.1 字体与文字基础样式 字体与字号 font-family：指定字体（关键是“回退序列”） 💡 为什么要写“回退序列”？ 不同设备安装的字体不同（比如有的电脑没有“苹方”，有的没有“微软雅黑”） 按顺序写多个字体，浏览器会从左到右找第一个已安装的字体来用 示例： font-size：指定字号 单位选择： px（固定像素）：直观但不灵活（比如用户放大页面时，文字可能不变） rem（相对根元素）：相对根元素（html）的字号，响应式友好 💡 rem 计算示例：html { font-size: 16px; } → 1rem = 16px，那么 2rem 就是 32px 示例： font-weight：控制文字粗细，400 常规，700 加粗 数值范围：100-900（100 的倍数） 常用值：400 = 常规（normal），700 = 加粗（bold） ⚠️ 中文字体注意：大多数中文字体只提供 Regular(400) 和 Bold(700) 两个字重，设置其他值（如 300、600）可能无效或被浏览器模拟渲染（效果不佳） line-height：控制行间距（推荐\"无单位数字\"，随字号等比缩放） 文字行与行之间的距离，影响阅读舒适度（太密或太疏都不好） 💡 为什么用无单位数字（如 1.7）？ 它会自动随 font-size 等比缩放 比如字号 16px 时，行高是 16×1.7=27.2px；字号变大到 20px，行高自动变成 34px，不用手动调整 示例： 文本呈现 color：文字颜色，支持多种写法 十六进制：#333、#334155 rgb()：rgb(51, 65, 85) hsl()：hsl(210, 25%, 27%)（方便调整明暗/饱和度） text-align：控制文本对齐方式（left / center / right / justify） text-decoration：加下划线（underline）、删除线（line-through）等 letter-spacing：字符间距（字母或汉字之间的距离） 作用：调整文字之间的间隔，影响视觉密度 值：可以是正值（增加间距）或负值（减少间距） 示例： 使用场景： 英文标题：增加间距显得高级（如 0.05em ~ 0.1em） 中文正文：一般不需要调整（默认 0 即可） Logo 文字：可以适当调整营造品牌感 word-spacing：单词间距（仅对英文空格分隔的单词有效） 作用：调整单词之间的间距 中文无效：因为中文没有空格分隔单词 示例：p { word-spacing: 0.2em; } text-transform：文本大小写转换 作用：自动转换英文字母的大小写 值： uppercase：全部大写（HELLO WORLD） lowercase：全部小写（hello world） capitalize：每个单词首字母大写（Hello World） none：不转换（默认） 示例： font-style：字体样式（斜体） 值： normal：正常（默认） italic：斜体（使用字体自带的斜体版本） oblique：倾斜（强制倾斜，即使字体没有斜体版本） 示例：.quote { font-style: italic; } / 引用文字用斜体 / text-indent：首行缩进，中文段落常用 2em（缩进两个字） 换行控制： 💡 换行控制详解（中英文混排必看） overflow-wrap: break-word（推荐）：优先在单词间隙换行，只有当单词太长（超过容器宽度）时，才从单词中间打断 word-break: break-all（谨慎用）：不管是不是单词，直接在容器边缘打断，可能把英文单词切得乱七八糟（比如 \"hello\" 切成 \"hel\" 和 \"lo\"） white-space: nowrap：强制不换行，文字会超出容器（适合小标签、按钮文字） 文本溢出省略号（超实用技巧） 当文本内容过长时，用省略号（...）代替，常用于卡片标题、列表项等。 单行文本溢出省略： 多行文本溢出省略（限制显示行数）： ⚠️ 兼容性说明： 单行省略：所有现代浏览器都支持 多行省略：-webkit-line-clamp 是 WebKit 私有属性，但主流浏览器（Chrome、Safari、Edge、Firefox）都已支持 IE 浏览器不支持多行省略，需要用 JavaScript 实现 💡 实际应用场景： 新闻列表标题（单行省略） 商品卡片描述（2-3行省略） 用户评论预览（多行省略） 综合示例 font 简写属性详解 作用：把 font-weight、font-size、line-height、font-family 等合并成一行写，简化代码 语法：font: [style] [variant] [weight] size/line-height family 必须包含：size 和 family，其他可选 示例： ⚠️ 注意：使用简写会重置所有未指定的字体属性为默认值（比如没写 font-style，会被重置为默认的 normal），慎用 --- 3.2 背景颜色与背景图 基础属性 background-color：设置背景颜色 作用：给元素填充纯色背景 示例：background-color: #f3f4f6;（浅灰色背景） background-image：设置背景图片或渐变 作用：在元素背景显示图片或渐变效果 值：url(\"图片路径\") 或 linear-gradient() / radial-gradient() 示例：background-image: url(\"/bg.jpg\"); background-repeat：控制背景图片是否重复 no-repeat：不重复（图片只显示一次） repeat：水平和垂直都重复（默认值） repeat-x：只水平重复 repeat-y：只垂直重复 background-position：设置背景图片的位置 作用：控制背景图在元素中的显示位置 关键词：center（居中）/ top（顶部）/ bottom（底部）/ left（左侧）/ right（右侧） 精确值：left 20px top 10px（距离左边20px，距离顶部10px） 百分比：50% 50%（居中，等同于 center） background-size：控制背景图片的尺寸 cover：铺满整个容器（可能裁切图片，但不留白） contain：完整显示图片（可能留白，但不裁切） 具体值：100px 200px（宽100px，高200px） 百分比：100% auto（宽度100%，高度自动） background-attachment：控制背景图片是否随页面滚动 scroll（默认）：背景随元素滚动 fixed：背景固定在视口，产生视差效果 ⚠️ 兼容性：iOS Safari 不支持 fixed，会回退为 scroll 移动端视差效果建议使用 JavaScript 或 CSS transform 实现 Hero 背景示例 渐变类型与语法 线性渐变 linear-gradient()：沿直线方向的颜色过渡 作用：创建从一个颜色平滑过渡到另一个颜色的背景 基础语法：linear-gradient(方向, 颜色1, 颜色2, ...) 方向参数： 关键词：to right（向右）/ to bottom（向下，默认）/ to top left（向左上） 角度：45deg（45度）/ 135deg（135度）/ 90deg（向右） 示例： 径向渐变 radial-gradient()：从中心点向外辐射的颜色过渡 作用：创建圆形或椭圆形的渐变效果 基础语法：radial-gradient(形状 at 位置, 颜色1, 颜色2, ...) 形状参数： circle：圆形渐变 ellipse：椭圆形渐变（默认） 位置参数： center（中心，默认）/ top left（左上）/ 50% 50%（百分比） 示例： background 简写属性 可以把多个背景属性合并成一行，简化代码。 语法顺序（不强制，但推荐）： 示例： ⚠️ 注意事项： size 必须紧跟在 position 后面，用 / 分隔（如 center / cover） 简写会重置所有未指定的背景属性为默认值 如果需要精确控制，建议分开写 多重背景（高级技巧） CSS 允许给一个元素设置多个背景图层，按照从上到下的顺序叠加。 语法：用逗号分隔多个背景，第一个在最上层，最后一个在最下层。 💡 层叠顺序： 第一个背景在最上层（最先看到） 最后一个背景在最下层（被其他层覆盖） 纯色背景通常放在最后，作为兜底 💡 实际应用场景： 渐变 + 图片：给图片加一层半透明渐变蒙版 多个图案叠加：创建复杂的纹理效果 光晕 + 纹理 + 底色：现代 UI 设计常用 示例：给图片加深色蒙版： 性能提示：大图需压缩与缓存；为小屏提供更小资源 --- 3.3 边框与圆角 边框 border：给元素添加边框线 三要素：宽度 / 样式 / 颜色（缺一不可） 简写语法：border: 宽度 样式 颜色; 示例：border: 1px solid #e5e7eb;（1像素实线浅灰色边框） 边框样式值： solid：实线（最常用） dashed：虚线 dotted：点线 double：双线 none：无边框 单边设置：只给某一边加边框 border-top：上边框 border-right：右边框 border-bottom：下边框 border-left：左边框 示例：border-bottom: 2px solid #3b82f6;（只给底部加蓝色边框） 圆角 border-radius：让元素的四个角变圆润 作用：控制元素边框的圆角程度 单值：四个角相同 示例：border-radius: 8px;（四个角都是8px圆角） 四值：分别设置四个角（顺时针：左上 → 右上 → 右下 → 左下） 示例：border-radius: 8px 16px 8px 16px; 椭圆角：水平半径 / 垂直半径 示例：border-radius: 24px / 12px;（所有角的水平半径24px，垂直半径12px） 复杂组合：border-radius: 24px 8px / 8px 24px; 特殊形状： 圆形：正方形元素 + border-radius: 50%; 胶囊形：border-radius: 高度的一半; 或 border-radius: 9999px; 轮廓 outline 与 border 的区别 作用：在元素外围绘制一条线，常用于焦点状态提示 与 border 的区别： outline 不占据布局空间（不会影响元素尺寸和位置） outline 不会被 border-radius 裁切（始终是矩形） outline 不能单独设置某一边 常用场景：表单元素获得焦点时的可视化提示 语法：outline: 宽度 样式 颜色; outline-offset：控制轮廓与元素边缘的距离 示例： 卡片示例 --- 3.4 盒子阴影与文字阴影 盒子阴影 box-shadow 语法：offset-x offset-y blur-radius [spread-radius] color [inset] offset-x：水平偏移（正值向右，负值向左） offset-y：垂直偏移（正值向下，负值向上） blur-radius：模糊半径（越大越模糊，0 为实边） spread-radius：扩散半径（正值阴影扩大，负值缩小） inset：内阴影（默认外阴影） 可多重阴影，用逗号分隔 示例： 文字阴影 text-shadow：给文字添加阴影效果 作用：让文字更有立体感或发光效果 语法：offset-x offset-y blur-radius color offset-x：水平偏移（正值向右，负值向左） offset-y：垂直偏移（正值向下，负值向上） blur-radius：模糊半径（可选，越大越模糊） color：阴影颜色 与 box-shadow 的区别： text-shadow 没有扩散半径（spread-radius）参数 text-shadow 没有 inset 关键字（文字阴影只能在外部） 示例： 💡 设计建议： 阴影用于表现层级与悬浮感 轻量柔和优先（过重的阴影显得廉价） 文本阴影谨慎使用（容易影响可读性） --- 学习总结与实践建议 🎯 本篇核心要点回顾 第1章：CSS 基础认知 ✅ CSS = Cascading Style Sheets（层叠样式表），用于控制网页外观 ✅ 三种引入方式：内联（快速测试）、内部（单页）、外部（推荐） ✅ 浏览器渲染流程：HTML → DOM，CSS → CSSOM，合并 → 渲染树 → 布局 → 绘制 ✅ 层叠规则：!important > 特异性 > 书写顺序 第2章：选择器基础 ✅ 标签选择器：影响所有同名标签 ✅ 类选择器（最常用）：可复用、可组合 ✅ ID 选择器（慎用）：优先级过高，不可复用 ✅ 后代 vs 子代：空格选所有层级，> 只选直接子元素 ✅ 兄弟选择器：+ 选紧邻的，~ 选后面所有的 ✅ 属性选择器：根据 HTML 属性选择元素 ✅ 伪类：选择元素的特定状态（:hover、:focus、:first-child、:checked 等） ✅ 伪元素：创建虚拟元素（::before、::after、::placeholder 等） ✅ 权重计算：a-b-c-d 四位数密码，从左到右比大小 第3章：常用属性 ✅ 字体：font-family（回退序列）、font-size（推荐 rem）、font-weight、line-height（无单位） ✅ 文本：color、text-align、letter-spacing、text-transform、文本省略号 ✅ 背景：background-color、background-image、渐变、多重背景 ✅ 边框：border（三要素）、border-radius（圆角）、outline（不占空间） ✅ 阴影：box-shadow（盒子阴影）、text-shadow（文字阴影） 💡 给小白的学习建议 动手实践最重要 不要只看不练：每学一个属性，立刻在浏览器里试一试 使用开发者工具（F12）：实时修改样式，看效果 建议：创建一个 practice.html 文件，把本文的所有示例都敲一遍 循序渐进，不要贪多 第一周：掌握选择器和文本样式（能给页面上色、调字体） 第二周：掌握背景和边框（能做出好看的卡片、按钮） 第三周：理解盒模型和布局（为下一篇做准备） 建立自己的\"样式库\" 把常用的样式保存下来：按钮样式、卡片样式、文本省略等 遇到好看的网站，用开发者工具看它的 CSS，学习借鉴 遇到问题怎么办？ 样式不生效：检查选择器是否正确、权重是否足够、有没有拼写错误 效果不理想：用开发者工具调试，边改边看 不知道怎么实现：搜索\"CSS + 你想要的效果\"（如\"CSS 渐变按钮\"） 常见新手误区 ❌ 到处用 ID 选择器 → ✅ 优先用 class ❌ 到处用 !important → ✅ 通过合理的选择器解决 ❌ 不写注释 → ✅ 复杂样式要写注释说明 ❌ 样式写得很乱 → ✅ 按模块组织，相关样式放一起 🚀 下一步学习方向 学完本篇后，你已经掌握了 CSS 的基础语法和常用属性。接下来可以学习： CSS 盒模型与布局（第二篇） margin、padding、border 的关系 display 属性（block、inline、flex、grid） 定位（position）和浮动（float） Flexbox 弹性布局（第三篇） 现代布局的核心技术 轻松实现水平垂直居中、等高列等 响应式设计（第四篇） 媒体查询（@media） 移动端适配 断点设计 CSS 动画与过渡（第五篇） transition（过渡） animation（动画） transform（变换） 📚 推荐练习项目 用本篇学到的知识，尝试做这些小项目： 个人名片页：练习字体、颜色、背景 按钮组件库：不同颜色、尺寸的按钮 卡片列表：新闻卡片、商品卡片 简单导航栏：练习选择器和伪类 --- 参考资料（拓展阅读）： MDN 学习 CSS（中文）：https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps CSS 优先级（特异性）：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity Can I Use（查询 CSS 属性兼容性）：https://caniuse.com/"
    },
    {
      "title": "第二篇_CSS核心_盒子_布局_视觉",
      "path": "CSS/第二篇_CSS核心_盒子_布局_视觉.md",
      "category": "CSS",
      "tags": [],
      "date": null,
      "description": "> 目标：搞懂「盒模型」「视觉基础」「布局基础」这三个 CSS 的核心支柱。看完这一篇，你应该能读懂浏览器开发者工具的盒模型面板，知道一个元素到底占多大空间、为什么会“挤下去”，并且能写出不那么混乱的基础布局。\r\n\r\n---\r\n\r\n\r\n\r\n> 这一章解决的核心问题：\r\n>\r\n> - 一个元素在页面上到底有多宽、多高？\r\n> - 为什么明明写了 width: 100px，看起来却更宽？\r\n> - 元",
      "content": "第二篇 CSS 核心：盒子、布局、视觉 目标：搞懂「盒模型」「视觉基础」「布局基础」这三个 CSS 的核心支柱。看完这一篇，你应该能读懂浏览器开发者工具的盒模型面板，知道一个元素到底占多大空间、为什么会“挤下去”，并且能写出不那么混乱的基础布局。 --- 第4章 盒模型：前端世界的物理规则 这一章解决的核心问题： - 一个元素在页面上到底有多宽、多高？ - 为什么明明写了 width: 100px，看起来却更宽？ - 元素与元素之间的「空隙」到底是 margin 还是 padding ？ 只要你想在页面上「放盒子」「排盒子」，就离不开盒模型。 4.1 content、padding、border、margin 先记住一句话：在浏览器眼里，每一个元素都是一个盒子。 这个盒子由 4 层组成（从里到外）： content：内容区域 padding：内边距，在内容和边框之间的留白 border：边框 margin：外边距，盒子和其它盒子之间的距离 4.1.1 直观图示（心里建立模型） 💡 生活化比喻：把盒子想象成一个快递包裹 content（内容）：包裹里的商品本身 padding（内边距）：商品周围的泡沫填充物（保护商品，让它不会直接碰到盒子边缘） border（边框）：快递盒子的纸板（可以看见的边界） margin（外边距）：这个快递盒和其他快递盒之间的距离（放在仓库里时，盒子之间要留点空隙） 用一个文字图来帮助你记忆： 💡 关键理解： 背景色（background-color） 会填充 content + padding 区域，但不包括 margin 边框（border） 是盒子的\"外壳\"，有颜色、有宽度 margin 是透明的，用来和其他盒子保持距离 实际示例： 在浏览器中，这个盒子会： 内容区域：200px × 100px（蓝色背景） 加上 padding：内容周围有 20px 的蓝色留白 加上 border：外面有 5px 的蓝色边框线 加上 margin：整个盒子和其他元素保持 30px 的距离（透明的） 4.1.2 四个方向的写法 多数盒模型相关属性都有“四个方向”的写法：top、right、bottom、left。 padding：内边距 简写方式（从上开始，顺时针）： margin：外边距（语法与 padding 类似） border：边框 4.1.3 它们分别“算不算宽度”？ 这是很多同学一开始最容易乱的地方。 在默认情况下（box-sizing: content-box，后面会详细讲）： width / height 描述的是 content 区域 的宽高 padding、border 会 额外增加 盒子的可见大小 margin 不算在盒子本身的宽高里，它是「盒子外面」的距离 来看一个例子： 内容区宽度：200px 左右 padding 共：10px + 10px = 20px 左右 border 共：5px + 5px = 10px 盒子整体的可见宽度 = 200 + 20 + 10 = 230px margin 只是把盒子和周围元素「推开」，不计入这 230px 里面。 记忆口诀： width 写的是「内容」宽度（默认） 看起来的实际宽度 = content + padding + border margin 是“社交距离”，不算在自己身体里 4.2 box-sizing 的两种世界 有了上面的理解，你应该会问： 我就想让这个盒子“对外来说”始终是 200px 宽，为什么要去心算 padding 和 border？ 这就是 box-sizing 要解决的问题。 4.2.1 两种主流模式 content-box（默认） width / height 只表示 content 大小 padding 和 border 会把盒子撑大 border-box（推荐用） width / height 表示 整个盒子 的大小（包含 content + padding + border） 你加 padding 或 border，内容区会变小，但对外尺寸不变 4.2.2 直观对比示例 .content-box-example 实际可见宽度： 200（content） + 40（左右 padding） + 10（左右 border） = 250px .border-box-example 实际可见宽度： 固定为 200px，浏览器会在内部「挤」内容区，让总宽度不变。 可以用一张对比图来理解两者差别（横向只画宽度）： 4.2.3 为什么现代项目几乎都用 border-box？ 更符合「人类直觉」：width: 200px 就真的对外就是 200px 布局更稳定：加个边框、改个 padding，不会把布局整个挤坏 方便做响应式：元素在不同屏幕下更好控制 因此，在大多数项目里，你会看到这样的“全局设置”： 含义是：所有元素及其伪元素都使用 border-box 模式。 4.2.4 实战小练习 你可以用浏览器 DevTools 做一个小实验： 随便在页面上放一个 div，设置 width: 200px; padding: 20px; border: 5px solid; 切换 box-sizing 为 content-box 与 border-box 观察 DevTools 里的盒模型图，实际宽度是怎么变的 这个实验做一遍，你对盒模型的感觉会立刻清晰很多。 4.2.5 再用一张“横向对比图”巩固一下 假设写的代码完全一样： 只改 box-sizing 的取值： 在脑中可以想象成两条水平线： 面向布局的直觉用法： 如果你更关心“这个格子占多宽”，就用 border-box（大多数现代布局这样） 如果你更关心“里面内容有多宽”，并可以手算，把 padding/border 算在外面，那就保留 content-box 4.3 外边距折叠（margin collapse） margin 有一个经常让人抓狂的行为：外边距折叠（Margin Collapse）。 简单说：某些情况下，两个 margin 不会相加，而是「合并成一个更大的值」。 💡 生活化比喻：想象两个人背靠背站着 第一个人说：\"我要和你保持 40cm 的距离\"（margin-bottom: 40px） 第二个人说：\"我要和你保持 20cm 的距离\"（margin-top: 20px） 你可能以为他们之间的距离是 40 + 20 = 60cm 但实际上，他们之间的距离只有 40cm（取较大值） 这就是 margin 折叠！两个 margin 不是相加，而是\"比大小\"，取较大的那个。 为什么会有这个设计？ 这是 CSS 规范有意为之的，主要是为了让文章排版更自然： 比如两个段落 <p>，每个都有 margin: 16px 0; 如果不折叠，段落之间的距离就是 32px（太大了） 折叠后，段落之间的距离是 16px（刚刚好） ⚠️ 重要：margin 折叠只发生在垂直方向（上下），不会发生在水平方向（左右）！ 4.3.1 哪些情况下会折叠？ 常见的三种： 上下相邻的兄弟块级元素 父块级元素与第一个/最后一个子元素之间 空块级元素自身上下 margin 先看最典型的：相邻兄弟元素。 很多同学直觉会以为：A 和 B 之间的距离 = 40px + 20px = 60px。 但实际上，这两个垂直方向的 margin 会发生「折叠」： 两个 margin 取 较大值 40px 所以最后 A 和 B 之间的距离是 40px，而不是 60px 口诀：兄弟之间，上下 margin 会“比大小”。 4.3.2 父元素与子元素的 margin 折叠 这是一个非常容易踩的坑，很多新手会在这里困惑很久。 问题场景：父容器内的第一个或最后一个子元素的 margin-top / margin-bottom 会和父元素折叠。 示例代码： 💡 你的期望： <p> 元素距离 .wrapper 的上边缘有 20px 的空白 .wrapper 的背景色从顶部开始，<p> 在里面往下 20px 😱 实际效果： 整个 .wrapper 盒子自己也被往下推了 20px .wrapper 内部顶部没有空白，<p> 紧贴着父元素顶部 看起来像是 .wrapper 本身有了 margin-top: 20px --- 🤔 为什么会这样？ 这是 CSS 规范的设计： 当父元素和子元素之间没有任何\"阻隔\"（没有 padding、border、内容等） 子元素的 margin 会\"穿透\"父元素，和父元素的 margin 折叠 最终表现为父元素整体被推下去 💡 生活化比喻： 想象你（子元素）站在一个透明玻璃房（父元素）里： 你说：\"我要和房顶保持 20cm 距离\"（margin-top: 20px） 但因为玻璃房是透明的，没有实体边界（没有 padding/border） 结果整个玻璃房被抬高了 20cm，而你仍然紧贴着房顶 从外面看，是房子被抬高了，而不是你在房子里往下移 --- ✅ 解决方案 核心思路：在父子元素之间制造\"阻隔\"，阻止 margin 折叠 方案1：给父元素加 padding（最常用） ✅ 优点：简单直观，符合直觉 ⚠️ 注意：如果父元素设置了 box-sizing: border-box，padding 会占用内部空间 方案2：给父元素加 border ✅ 优点：子元素的 margin 能正常工作 ❌ 缺点：多了 1px 的高度（虽然透明） 方案3：让父元素形成 BFC（块格式化上下文） ✅ 优点：不增加额外的 padding 或 border ⚠️ 注意：overflow: hidden 会裁剪溢出内容 其他触发 BFC 的方式： 方案4：给父元素加一点内容 ✅ 优点：不影响布局，不增加高度 ❌ 缺点：代码稍复杂 --- 📊 解决方案对比表 | 方案 | 代码 | 优点 | 缺点 | 推荐度 | |------|------|------|------|--------| | padding | padding-top: 20px | 简单直观 | 占用空间 | ⭐⭐⭐⭐⭐ | | border | border-top: 1px solid transparent | margin 正常工作 | 多 1px 高度 | ⭐⭐⭐ | | overflow | overflow: hidden | 不增加尺寸 | 裁剪溢出 | ⭐⭐⭐⭐ | | display: flow-root | display: flow-root | 无副作用 | 兼容性稍差 | ⭐⭐⭐⭐⭐ | | display: flex | display: flex | 现代布局 | 改变布局方式 | ⭐⭐⭐⭐⭐ | | ::before | ::before + display: table | 不影响布局 | 代码复杂 | ⭐⭐⭐ | 💡 新手建议： 简单场景：直接用 padding 现代项目：用 display: flex 或 display: flow-root 需要保持 margin 语义：用 overflow: hidden 或 border --- 🎨 可视化对比 期望的样子（不折叠时）： 实际折叠后的效果（❌ 错误）： 加了 padding 后（✅ 正确）： --- ⚠️ 同样的问题也会发生在底部 结果：整个 .wrapper 下方会多出 30px 的空白（margin 折叠到父元素外面了） 解决方法相同： 给父元素加 padding-bottom 或者用上面提到的任何一种方案 --- 🔍 如何判断是否发生了父子 margin 折叠？ 方法1：用 DevTools 查看 打开浏览器开发者工具（F12） 选中父元素，查看盒模型面板 如果父元素的 margin 区域显示了子元素的 margin 值，说明发生了折叠 方法2：给父元素加背景色 如果背景色顶部没有空白，说明子元素的 margin 没有在父元素内部生效 如果整个盒子被往下推，说明发生了折叠 方法3：用 outline 调试 如果红框顶部紧贴着子元素，说明 margin 没有在内部生效 --- 💡 记忆口诀 本质理解： margin 折叠的设计初衷是为了让文章排版更自然 但在做布局时，这个特性经常会造成困扰 记住：padding 是内部留白，margin 是外部距离 当你想要\"内部留白\"时，用 padding 更符合语义 4.3.3 空块级元素的 margin 折叠 如果一个块级元素： 没有 border 没有 padding 没有内容 没有设定 height/min-height 则它自己的 margin-top 和 margin-bottom 也会折叠成一个（取较大值）。 这一点在实际开发中比较少刻意用到，但在调试怪异空隙时要有这个心理准备。 4.3.4 什么时候最容易被坑？ 做文章页面时，用 p { margin: 16px 0; }， 再在每个 section 外套一层容器，结果发现外层和内层的间距「对不上直觉」。 做卡片时，以为卡片内部元素的 margin-top 只会影响内部，结果整体卡片被往下挤。 调试建议： 打开 DevTools，选中元素 看「Computed」或「Layout」中的 margin 显示 把 margin 改为 padding 看看效果是否更符合预期 一般来说： - 内部的间距（内容与边框之间的放松空间）用 padding - 组件与组件之间的距离用 margin 4.4 盒子调试技巧 学会盒模型的概念后，会用工具调试同样非常关键。 4.4.1 利用浏览器 DevTools 的盒模型面板 以 Chrome 为例： 打开页面 → F12 / 右键「检查」 在元素面板中选中某个元素 右侧有一个「Layout」或「Computed → Box Model」区域 你会看到一个类似这样的图： 每一块都有具体的数值： 可以直接在面板中 点击数值修改试验 鼠标悬停在 margin / padding 上，页面会高亮对应的区域 建议多做几次： 选中文章中的一个段落 改它的 margin-top / padding-top 观察界面和盒模型图的变化 4.4.2 给盒子临时加“调试边框” 有时候你分不清到底是哪个元素占了空间，可以给所有元素加一个临时的调试样式： 或更常见地，只给你关心的元素加： outline 不会影响布局，只是一个视觉辅助 这招在排查“看不见但占了空间的盒子”时非常有用 4.4.3 用背景色帮助理解内外间距 如果你经常分不清 padding 和 margin： 设置一个明显的 background-color 然后分别修改 padding 和 margin 看效果 示例： 观察： 改 padding：背景色区域跟着变大/变小 改 margin：背景色区域大小不变，只是整体盒子和其它元素的距离变了 4.4.4 小结：盒模型心智模型 你可以用下面这套思考方式来检查一个元素： 先看 content：文字/图片本身多大？有没有 width / height？ 再看 padding：内容周围要留多少“呼吸空间”？ 再看 border：要不要加边框？会不会影响整体宽度？ 最后看 margin：这个盒子和旁边盒子的距离是多少？ 同时记住： 默认是 content-box，实际宽度 = 内容宽度 + padding + border 一般项目会全局改成 border-box，更符合直觉 上下 margin 可能会发生折叠，这是很多“莫名其妙空隙”的来源 --- 第4章到这里先告一段落。接下来的第5章，我们会在盒模型的基础上，进一步讲「颜色、单位、图像」等视觉基础，让你的盒子不仅尺寸合理，而且好看、灵活、适配不同屏幕。 第5章 视觉表现：颜色、单位、图像 这一章解决的核心问题： - 颜色代码一堆（#fff、rgb()、hsl()、渐变），到底该用哪个？ - px、%、em、rem、vw、vh 看起来都能写宽度，有什么区别？ - 背景图总是拉伸、变形、重复，怎么才能既铺满又好看？ 5.1 RGB、HSL、透明度与渐变 5.1.1 常见颜色表示方式 CSS 里常见的几种颜色写法： 十六进制（Hexadecimal） 最常见的颜色写法，格式：#RRGGBB（红绿蓝三个通道，每个通道 00-FF） 💡 简写规则：如果每个通道的两位数字相同，可以简写 #000000 → #000（黑色） #ffffff → #fff（白色） #336699 → #369（蓝灰色） RGB（Red Green Blue） 用三个数字（0-255）分别表示红、绿、蓝的强度 RGBA（RGB + Alpha） 在 RGB 基础上增加透明度（Alpha），范围 0-1 💡 透明度说明： 0：完全透明（看不见） 0.5：半透明 1：完全不透明（等同于 rgb） HSL（Hue Saturation Lightness） HSL 是一种更符合人类直觉的颜色表示方式，特别适合做颜色调整和主题系统。 💡 为什么 HSL 更直观？ RGB：rgb(37, 99, 235) → 你很难想象这是什么颜色 HSL：hsl(221, 83%, 53%) → 221度的蓝色，很鲜艳，中等亮度 基本语法： 示例： --- 📐 参数详解 H（Hue 色相）：0-360 度，表示色环上的位置 色相就是\"什么颜色\"，用角度表示： 实际示例： 💡 记忆技巧： 0° 是红色（起点） 每隔 60° 是一个主要颜色（红→黄→绿→青→蓝→紫） 360° 又回到红色（一个完整的圆） --- S（Saturation 饱和度）：0%-100%，表示颜色的鲜艳程度 饱和度就是\"颜色有多鲜艳\"： 0%：完全没有色彩，变成灰色 50%：柔和的颜色 100%：最鲜艳、最纯的颜色 可视化对比（以蓝色为例）： 💡 应用场景： 做主题色的\"淡色版本\"：降低饱和度（如 hsl(221, 30%, 53%)） 做灰度图：饱和度设为 0% 做鲜艳按钮：饱和度设为 100% --- L（Lightness 亮度）：0%-100%，表示颜色的明暗 亮度就是\"颜色有多亮\"： 0%：纯黑色（无论色相和饱和度是多少） 50%：正常颜色（最能体现色相的状态） 100%：纯白色（无论色相和饱和度是多少） 可视化对比（以红色为例）： 💡 应用场景： 做悬停变暗效果：降低亮度（如 hsl(221, 83%, 40%)） 做浅色背景：提高亮度（如 hsl(221, 83%, 95%)） 做深色模式：降低亮度到 20%-30% --- 🎨 HSL 三个参数的联合作用 --- 💡 HSL 的实际应用场景 场景1：做主题色系统 从一个主色生成一系列变体： 场景2：做悬停效果 场景3：做渐变色 场景4：做灰度图 --- 🆚 HSL vs RGB 对比 | 需求 | RGB | HSL | |------|-----|-----| | 让颜色变亮 | rgb(37, 99, 235) → rgb(?, ?, ?) 😵 | hsl(221, 83%, 53%) → hsl(221, 83%, 70%) ✅ | | 让颜色变淡 | rgb(37, 99, 235) → rgb(?, ?, ?) 😵 | hsl(221, 83%, 53%) → hsl(221, 30%, 53%) ✅ | | 换个颜色但保持亮度 | rgb(37, 99, 235) → rgb(?, ?, ?) 😵 | hsl(221, 83%, 53%) → hsl(120, 83%, 53%) ✅ | | 做主题色系统 | 需要手动计算每个值 😵 | 只改 H/S/L 其中一个 ✅ | 结论： RGB：适合精确指定颜色（设计稿给的颜色值） HSL：适合颜色调整和主题系统（程序化生成颜色） --- ⚠️ HSL 的常见误区 误区1：以为 L=50% 就是\"中等亮度\" ❌ 错误理解：L=50% 是灰色 ✅ 正确理解：L=50% 是正常颜色，最能体现色相 误区2：以为改色相就能得到\"相近的颜色\" ❌ 错误：hsl(220, 83%, 53%) 和 hsl(230, 83%, 53%) 差别不大 ✅ 正确：色相差 10° 可能颜色差别很明显（取决于色相区域） 误区3：忽略饱和度的影响 ❌ 错误：只调亮度，忽略饱和度 ✅ 正确：做浅色背景时，要同时降低饱和度和提高亮度 HSLA（HSL + Alpha） 颜色关键词（了解即可） CSS 预定义了一些颜色名称： --- 💡 新手选择建议： 从新人上手难度 & 调色方便程度来说： 记固定颜色：用十六进制（如 #2563eb） 优点：简洁、直观、设计师常用 缺点：不好调整透明度 做透明效果：用 rgba() 或 hsla() 优点：可以精确控制透明度 场景：半透明背景、阴影、遮罩层 需要细调色相、明暗：用 hsl()（非常适合做设计系统） 优点：调整颜色更直观（改 L 值就能变亮/变暗） 场景：主题色系统、悬停变色 示例： 5.1.2 HSL 为什么更适合做主题色？ HSL 三个维度： H（Hue）：色相，0–360 度，对应色环（0=红，120=绿，240=蓝） S（Saturation）：饱和度，0%–100%，越高越「艳」 L（Lightness）：亮度，0% 黑，100% 白，中间为不同明暗程度 它的好处是「一眼能看懂」： 要同一颜色更亮/更暗？调 L 要更灰、更柔和？调 S 例子： 5.1.3 透明度：整体透明 vs 颜色透明 两种常见写法： opacity: 0.5; 让整个元素（包含文字、图标）都半透明 rgba() / hsla() 只让「背景颜色」有透明度，内容保持不变 区别示意： 一般设计系统中，更推荐用 rgba()/hsla() 做透明背景，而不是直接调元素 opacity。 5.1.4 渐变基础：linear-gradient 渐变本质上也是一种「背景图」，只是由浏览器算出来而已： 语法解读： 135deg：渐变角度（从左上到右下） 后面是若干个颜色节点：可以写 2 个，也可以写更多 常见用法： 按钮渐变背景 页面顶部横幅（banner）背景 渐变细节（重复渐变、径向渐变等）在视觉进阶篇可以进一步扩展，这里先掌握「会用」。 5.2 px、%、em、rem、vw、vh CSS 单位非常多，但在实际开发中常用的主要就这几个。 💡 为什么需要这么多单位？ 因为不同场景有不同需求： 有时候需要固定大小（如边框 1px） 有时候需要相对父元素（如两列布局各占 50%） 有时候需要随字体大小变化（如按钮内边距） 有时候需要随屏幕大小变化（如全屏背景） 单位对比速查表： | 单位 | 类型 | 相对于 | 常用场景 | 响应式 | |------|------|--------|----------|--------| | px | 绝对 | 固定像素 | 边框、阴影、小图标 | ❌ | | % | 相对 | 父元素尺寸 | 布局宽度、两列分栏 | ✅ | | em | 相对 | 当前元素字号 | 按钮内边距、首行缩进 | ✅ | | rem | 相对 | 根元素字号 | 全局字号、组件尺寸 | ✅ | | vw | 相对 | 视口宽度 | 全屏宽度、响应式字号 | ✅ | | vh | 相对 | 视口高度 | 全屏高度、Hero 区域 | ✅ | --- 5.2.1 px：像素单位（绝对单位） 特点： 绝对直观：width: 200px; 就是 200 像素宽 不会随其他因素变化 页面初学阶段，可以放心使用 优点： 精确控制，所见即所得 不会出现\"意外变化\" 缺点： 在不同屏幕/缩放下不够「相对」，不利于响应式 用户放大页面时，px 不会跟着放大（可访问性问题） 示例： 适用场景： ✅ 边框宽度（border: 1px solid） ✅ 阴影偏移（box-shadow: 2px 2px 4px） ✅ 小图标尺寸（width: 24px） ✅ 不需要随屏幕放大缩小的细节 ❌ 大面积布局（不够灵活） ❌ 字体大小（不利于可访问性） 5.2.2 百分比 %：相对于父元素（相对单位） 特点： 相对于父元素的对应属性 宽度：相对于父元素的宽度 高度：相对于父元素的高度（但父元素必须有明确高度） 示例： ⚠️ 高度百分比的坑： 要让高度百分比生效，父元素必须有明确高度： 适用场景： ✅ 两列/三列布局（width: 33.33%） ✅ 图片自适应宽度（width: 100%） ✅ 相对父容器的尺寸 ❌ 高度（除非父元素有明确高度） --- 5.2.3 em：相对于当前元素的字体大小（相对单位） 特点： 1em = 当前元素的 font-size 会继承和累积（嵌套时要小心） 💡 为什么叫 em？ em 来自印刷术语，原本指字母 \"M\" 的宽度。在 CSS 中，1em 就是当前字号的大小。 示例： ⚠️ 嵌套累积问题： 适用场景： ✅ 首行缩进（text-indent: 2em） ✅ 按钮内边距（随字号自动调整） ✅ 与文字大小相关的间距 ❌ 复杂嵌套布局（容易累积出错） --- 5.2.4 rem：相对于根元素 html 的字体大小（相对单位） 特点： 1rem = html 元素的 font-size 不会累积（永远相对于根元素） 现代响应式布局的首选单位 💡 rem vs em 的关键区别： 示例： 响应式应用： 只需改变根字号，整个页面等比缩放： 适用场景： ✅ 全局字体大小 ✅ 组件尺寸和间距 ✅ 布局宽度（max-width: 72rem） ✅ 响应式设计 ✅ 任何需要整体缩放的场景 5.2.5 vw / vh：相对于视口（窗口）（相对单位） 特点： 1vw = 视口宽度的 1%（Viewport Width） 1vh = 视口高度的 1%（Viewport Height） 视口 = 浏览器窗口的可视区域 💡 什么是视口？ 视口就是浏览器窗口中实际显示网页内容的区域（不包括地址栏、工具栏等）。 在桌面浏览器：视口 = 浏览器窗口大小 在手机浏览器：视口 = 屏幕大小 计算示例： 假设浏览器窗口宽度 1200px，高度 800px： 1vw = 1200px × 1% = 12px 10vw = 1200px × 10% = 120px 100vw = 1200px × 100% = 1200px（整个屏幕宽度） 1vh = 800px × 1% = 8px 100vh = 800px × 100% = 800px（整个屏幕高度） 示例： ⚠️ 移动端的坑：100vh 问题 在移动端浏览器中，100vh 可能会包含地址栏的高度，导致内容被遮挡： 配合 clamp() 使用： clamp(min, preferred, max) 可以让值在一个范围内自适应变化： 适用场景： ✅ 全屏 Hero 区域（height: 100vh） ✅ 响应式字号（font-size: 4vw） ✅ 全宽布局（width: 100vw） ✅ 固定宽高比的元素 ⚠️ 移动端高度要小心（地址栏问题） --- 💡 单位选择总结： 5.2.6 新人建议的单位选择策略 字体大小：用 rem 为主，部分局部可用 em 宽度/布局：用 px + % + rem 结合 全屏区域：用 vh/vw 为辅 细边距/阴影：px 最直观 先用你最舒服、看得懂的单位（比如 px），等熟练后再逐步引入 rem 和 vw 等做更精细的适配。 5.2.7 “我现在该用什么单位？”速查图 可以稍微用一个决策小图来帮助你快速判断： 可以把这个思路简化成几句话： 布局整体比例：rem / % / clamp + vw 和文字绑得很紧的东西（例如首行缩进、按钮内边距）：em / rem 特别细节（边框、线条、阴影）：px 需要“至少一屏大”的区域：vh / vw 5.3 背景图像全攻略（cover、contain、repeat） 背景图的本质：一块贴在盒子背后的图片，受 background-* 一系列属性控制。 💡 背景图 vs <img> 标签的区别： <img>：是 HTML 内容的一部分，占据文档流位置 background-image：是 CSS 装饰，不占据文档流，贴在元素背后 --- 5.3.1 基础属性详解 background-image（背景图片） 指定背景图片的 URL： 💡 多重背景：可以叠加多张背景图 background-repeat（重复方式） 控制背景图是否平铺： background-position（位置） 控制背景图在容器中的位置：语法上可以接收 1~2 个值（分别对应水平方向和垂直方向的位置）。如果只指定一个值，另一个方向默认是 center。 💡 百分比的工作原理： background-size（尺寸，重点！） 控制背景图的缩放方式： --- 完整示例： 5.3.2 cover 与 contain 的深度对比 这两个值是背景图最常用的缩放方式，理解它们的区别非常重要。 background-size: cover（铺满容器） 特点：图片会被等比放大，直到完全覆盖容器 结果：容器没有留白，但图片可能被裁切 适用场景：横幅、Hero 区域、大面积背景 background-size: contain（完整显示） 特点：图片会被等比缩放，直到完整显示在容器内 结果：图片不会被裁切，但容器可能有留白 适用场景：Logo、产品图、不能裁切的图片 --- 📊 可视化对比 假设有一张 1200×600 的横向图片，容器是 400×400 的正方形： cover 的效果： contain 的效果： --- 💡 记忆口诀： cover：容器优先好看，图片可以被裁一点（像被子盖住床，被子可能垂下来） contain：图片必须完整，容器可以有空白（像相框装画，画必须完整，相框可以大一点） --- 🎯 实际应用场景对比 | 场景 | 推荐 | 原因 | |------|------|------| | 网站 Hero 横幅 | cover | 需要填满整个区域，裁切无所谓 | | 产品展示图 | contain | 产品必须完整显示 | | 文章配图 | cover | 美观优先 | | Logo 背景 | contain | Logo 不能被裁切 | | 全屏背景 | cover | 铺满屏幕 | | 图标背景 | contain | 图标要完整 | | 卡片缩略图 | cover | 统一尺寸，美观 | | 证书/文档预览 | contain | 必须看到全部内容 | --- ⚠️ 常见问题 问题1：cover 裁切了重要内容怎么办？ 用 background-position 调整焦点位置： 问题2：contain 留白太多，不好看怎么办？ 方案1：给容器加背景色 方案2：用渐变填充留白 问题3：图片比例和容器比例差太多 --- 🔍 调试技巧 用 DevTools 查看背景图： 打开开发者工具（F12） 选中元素 在 Styles 面板中，background 属性旁边有个小图标 点击可以预览背景图和调整位置 临时切换 cover/contain 对比效果： 5.3.3 background-position 常用写法 关键词：left、center、right、top、bottom 组合：center center（默认）、center top、right bottom 百分比：50% 20% 等，适合精细控制「焦点在画面中的位置」。 例子：把主视觉人物尽量放在可见区域： 5.3.4 repeat 与 精致平铺 background-repeat: repeat; 默认，会在两个方向平铺 只横向：repeat-x 只纵向：repeat-y 不平铺：no-repeat 适合平铺的图：小图案、纹理、噪点背景等。 5.3.5 背景图 vs img 标签 什么时候用 background-image，什么时候用 <img>？ 语义上是「内容」的一部分（产品图、文章插图）：用 <img> 只是「装饰」：用 background-image 对 SEO 和可访问性来说，重要图片应该用 <img> 并配 alt 文本。 5.4 现代图像处理（滤镜、混合模式） 这一节简单打开一个门，让你知道 CSS 也可以做一些「简单修图」的事情。 💡 为什么要用 CSS 滤镜？ 不需要 Photoshop 就能调整图片效果 可以动态改变（如悬停时变灰） 减少图片资源（一张图多种效果） --- 5.4.1 filter 滤镜详解 filter 属性可以对元素应用图形效果，类似 Photoshop 的滤镜。 常见滤镜函数： blur()（模糊） 💡 应用场景： 背景模糊（毛玻璃效果） 图片加载前的占位符 失焦效果 实际示例：毛玻璃卡片 --- brightness()（亮度） 💡 应用场景： Hero 区域压暗背景，让文字更清晰 悬停时图片变亮 夜间模式调暗图片 实际示例：悬停变亮 --- contrast()（对比度） 💡 应用场景： 增强图片视觉冲击力 配合亮度调整，改善文字可读性 --- grayscale()（灰度） 💡 应用场景： 已售罄商品 不可用状态 悼念模式 悬停前的默认状态 实际示例：悬停恢复彩色 --- saturate()（饱和度） 💡 应用场景： 让图片更鲜艳 做复古效果（降低饱和度） --- hue-rotate()（色相旋转） 💡 应用场景： 从一张图生成多种配色 主题切换（如蓝色主题 → 绿色主题） --- invert()（反色） 💡 应用场景： 深色模式（让浅色图片变深色） 特殊视觉效果 --- opacity()（透明度） ⚠️ 注意：filter: opacity() 和 opacity 属性效果相同，但 filter 可以和其他滤镜组合。 --- drop-shadow()（投影） 💡 drop-shadow vs box-shadow： box-shadow：给盒子加阴影（矩形） drop-shadow：跟随元素轮廓（包括透明部分） 示例：PNG 图片阴影 --- 💡 组合使用多个滤镜 --- 🎯 实战应用场景 场景1：Hero 区域压暗背景 场景2：图片加载前的模糊占位 场景3：深色模式图片调整 场景4：禁用状态 --- ⚠️ 性能注意事项 滤镜会触发重绘，不要在大量元素上使用复杂滤镜 动画时优先用 transform 和 opacity，少用 filter 移动端慎用 blur()（性能消耗大） 5.4.2 mix-blend-mode 混合模式 mix-blend-mode 可以让一个元素的颜色与底下元素发生「混色」，类似于 PS 里的图层混合模式。 常见模式： multiply：叠加，常用于加深 screen：变亮 overlay：对比增强 简单示例（做带混色效果的文字）： 混合模式的视觉效果会受到背景颜色很大影响，更多用在视觉设计型页面，不是基础必备，但知道它存在即可。 --- 第5章带你对「颜色、单位、图像」有了整体感觉。接下来第6章，我们会正式进入布局，从最基础的 display 开始，让元素不再「乱飘」。 第6章 布局基础：让页面从混乱到清晰 这一章解决的核心问题： - 为什么有的元素独占一行，有的元素跟文字排在一行？ - display: block/inline/inline-block 有什么区别？ - 不设置任何布局属性时，浏览器是怎么把东西排到页面上的？ - float 和 position 这些经典属性，在现代布局里还扮演什么角色？ 6.1 display 全解：block、inline、inline-block display 决定了一个元素「在文档流中的表现形式」。这是 CSS 布局的基础中的基础。 💡 为什么要理解 display？ 每个 HTML 元素都有一个默认的 display 值： <div>、<p>、<h1> 默认是 block（块级） <span>、<a>、<strong> 默认是 inline（行内） 理解它们的区别，才能知道为什么有的元素独占一行，有的元素挤在一起 三种基础 display 对比表： | 特性 | block | inline | inline-block | |------|---------|----------|----------------| | 是否独占一行 | ✅ 是 | ❌ 否 | ❌ 否 | | 能否设置宽高 | ✅ 能 | ❌ 不能 | ✅ 能 | | 默认宽度 | 撑满父容器 | 由内容决定 | 由内容决定 | | 上下 margin | ✅ 生效 | ❌ 不生效 | ✅ 生效 | | 左右 margin | ✅ 生效 | ✅ 生效 | ✅ 生效 | | 上下 padding | ✅ 生效 | ⚠️ 部分生效 | ✅ 生效 | | 常见元素 | div, p, h1 | span, a, em | button, img | --- 6.1.1 block 块级元素 典型特征： 独占一行（前后自动换行） 默认宽度撑满父容器（若未设置 width） 可以设置宽高、内外边距 垂直排列（一个接一个从上往下） 常见块级元素： 容器：div、section、article、header、footer、nav 文本：p、h1~h6、blockquote 列表：ul、ol、li 示例： 效果：三个盒子会从上往下排列，每个独占一行。 💡 块级元素的\"霸道\"特性： 即使你设置了 width: 200px，块级元素仍然会独占一行，后面的内容会被\"挤\"到下一行。 --- 6.1.2 inline 行内元素 典型特征： 不独占一行，会在同一行内和文字一起排布 宽高由内容决定，不能直接设置 width、height 上下 margin 不生效（左右 margin 生效） 上下 padding 部分生效（会影响行高，但不会撑开上下空间） 常见行内元素： 文本：span、a、strong、em、code 表单：input、label、select 示例： 效果：高亮文字和链接会和普通文字排在同一行，不会换行。 ⚠️ inline 元素的\"温和\"特性： 它们像文字一样流动，不会强行换行 设置 width/height 无效（因为大小由内容决定） 上下 margin 不生效（但可以用 line-height 调整行间距） --- 6.1.3 inline-block 行内块元素 典型特征： 可以理解为：结合了 block 和 inline 的优点 像 inline 一样，可以和文字排在同一行（不独占一行） 像 block 一样，可以设置宽高、内外边距 元素之间会有间隙（来自 HTML 中的空格/换行） 常见场景： 按钮、徽章、标签 水平排列的小卡片 导航菜单项 示例： 效果：三个按钮会排在同一行（如果宽度够），每个按钮可以设置宽高。 ⚠️ inline-block 的间隙问题： 由于 HTML 中的换行和空格，inline-block 元素之间会有 4-5px 的间隙。 解决方法： --- 💡 三种 display 的选择建议： 后面 Flexbox 和 Grid 出现后，我们做布局更多依赖它们，但理解这三种最基础的 display，能帮你看懂很多老项目的写法，也有助于理解浏览器的默认行为。 可以用一张行内/块级/行内块的「占行」示意图来记忆： 6.2 流式布局与文档流 在不写任何复杂布局前，浏览器默认会采用一种「从上到下、从左到右」的 普通文档流（Normal Flow）来排布元素。 💡 什么是文档流？ 文档流就是浏览器默认的元素排列方式，就像水流一样，元素按照 HTML 的顺序自然流动排列。 文档流的核心规则： 块级元素：从上到下垂直排列，每个独占一行 行内元素：从左到右水平排列，一行装不下就换行 元素占据空间：在文档流中的元素会占据空间，影响其他元素的位置 --- 6.2.1 块级元素的排列规则 特点： 从上到下依次排列 每个块级元素都独占一整行 宽度默认是父元素的可用宽度（100%） 高度由内容决定（或显式设置） 示例： 可视化效果： 💡 关键理解： 即使你给 .box-a 设置了 width: 200px，它仍然独占一行 后面的 .box-b 不会跑到 .box-a 右侧，而是在下一行 块级元素的宽度计算： --- 6.2.2 行内元素的排列规则 特点： 在一行内从左到右排列，直到装不下为止 换行后继续排（遵从文字的换行规则） 宽度由内容决定 多个行内元素会紧挨着排列 示例： 可视化效果： 💡 行内元素的换行规则： 当容器宽度不够时： --- 6.2.3 块级和行内元素的混合排列 示例： 排列效果： 💡 关键理解： 块级元素会\"打断\"行内元素的排列 块级元素前后会自动换行 --- 6.2.4 理解「文档流」对调试非常重要 什么是\"在文档流中\"？ 在文档流中的元素： ✅ 占据空间，影响其他元素的位置 ✅ 遵循从上到下、从左到右的排列规则 ✅ 会被父元素的高度计算包含 什么是\"脱离文档流\"？ 脱离文档流的元素： ❌ 不占据原本的空间 ❌ 不影响其他元素的排列 ❌ 不被父元素的高度计算包含 哪些情况会脱离文档流？ position: absolute position: fixed float: left/right（部分脱离） --- 🔍 调试技巧：判断元素是否在文档流中 方法1：看后面的元素是否\"顶上来\" 方法2：看父元素高度是否包含该元素 --- 💡 常见问题 问题1：为什么我的元素突然\"飞\"走了？ 解决：检查是否使用了 absolute 或 fixed 问题2：为什么后面的内容\"顶上来\"了？ 解决：清除浮动，或改用 Flexbox 问题3：为什么父元素高度是 0？ 原因：子元素脱离文档流，父元素认为内部没有内容 解决： 给父元素设置明确高度 或者不要让子元素脱离文档流 --- 📊 文档流 vs 脱离文档流对比 | 特性 | 在文档流中 | 脱离文档流 | |------|-----------|-----------| | 占据空间 | ✅ 是 | ❌ 否 | | 影响其他元素 | ✅ 是 | ❌ 否 | | 被父元素包含 | ✅ 是 | ❌ 否 | | 遵循排列规则 | ✅ 是 | ❌ 否 | | 典型属性 | static, relative | absolute, fixed, float | --- 💡 记忆口诀 核心理解： 文档流是浏览器的默认排列方式 大部分情况下，让元素待在文档流中 只有特殊需求（如固定导航、浮层）才脱离文档流 脱离文档流要特别注意对布局的影响 6.3 float 与清除浮动（历史遗留但必须懂） 在 Flex 和 Grid 出现之前，float 一度是网页布局的主力，现在虽然不再推荐用它做复杂布局，但你会经常在旧项目/文章中看到它，因此仍然需要理解基础概念。 💡 为什么要学 float？ 旧项目中大量使用 理解\"脱离文档流\"的概念 图文混排仍然有用 --- 6.3.1 float 是什么？ float 最初是为了实现图文混排而设计的，就像报纸杂志中图片周围环绕文字的效果。 浮动元素会脱离普通文档流（导致后续块级元素占据其原有位置），但未完全脱离文档流（仍会影响文本和内联元素的排列，形成环绕效果）。 基本语法： 经典应用：图文混排 可视化效果： 💡 float 的特点： 图片向左浮动 文字环绕在图片右侧和下方 这是 float 的原始设计用途 --- 6.3.2 float 对布局的副作用 当一个元素设置 float 后，会发生以下变化： 部分脱离文档流 ✅ 元素仍然占据一定空间（文字会环绕） ❌ 但不再占据原本的\"行\"（后面的块级元素会顶上来） ❌ 父元素不会自动根据它计算高度 变成类似 inline-block 父元素高度塌陷 这是 float 最经典的问题： 问题效果： 💡 为什么会这样？ 因为浮动元素\"部分脱离\"了文档流： 父元素 .wrapper 认为内部没有正常流的内容 所以高度计算为 0 后面的 .footer 就\"顶上来\"了 --- 6.3.3 清除浮动 clearfix 目标：让父元素正确包裹住浮动子元素，恢复正常高度。 原因：当父元素的子元素设置了 float 后，父元素默认不会计算浮动子元素的高度，导致高度为 0（塌陷），这些方法的核心是让父元素 “感知” 到浮动子元素的存在，从而正常包裹它们。 方法1：在浮动元素后面加空标签（不推荐） ❌ 缺点：增加了无意义的 HTML 标签 --- 方法2：clearfix 伪元素（经典方法） ✅ 优点： 不增加 HTML 标签 用 CSS 解决 CSS 的问题 这是最常见的 clearfix 写法 工作原理： --- 方法3：给父元素触发 BFC（块格式化上下文） ✅ 优点：代码简洁 ⚠️ 注意：overflow: hidden 会裁剪溢出内容 其他触发 BFC 的方式： --- 方法4：现代方案 - 用 Flexbox（最推荐） ✅ 优点： 不需要清除浮动 代码更简洁 功能更强大（对齐、间距等） --- 📊 清除浮动方法对比 | 方法 | 代码 | 优点 | 缺点 | 推荐度 | |------|------|------|------|--------| | 空标签 | <div style=\"clear: both;\"> | 简单 | 增加无意义标签 | ⭐ | | clearfix | ::after + clear: both | 不增加标签 | 需要记住写法 | ⭐⭐⭐⭐ | | overflow | overflow: hidden | 代码简洁 | 可能裁剪内容 | ⭐⭐⭐ | | display: flow-root | display: flow-root | 无副作用 | 兼容性稍差 | ⭐⭐⭐⭐ | | Flexbox | display: flex | 现代布局 | 改变布局方式 | ⭐⭐⭐⭐⭐ | --- 💡 clear 属性详解 clear 属性用于指定元素的哪一侧不允许有浮动元素。 示例： 效果： --- ⚠️ float 的常见问题 问题1：浮动元素重叠 问题2：浮动元素覆盖文字 问题3：父元素高度塌陷 --- 💡 现代布局建议 替代方案： 在现代布局里，我们更推荐用 Flex 和 Grid 来完成多列布局，但理解 float 可以帮助你维护旧代码，也有助于理解「脱离文档流」和「清除」这些概念。 6.4 position：relative、absolute、fixed、sticky position 决定了元素的定位方式和是否脱离文档流。常见取值有： static：默认值，不做特殊定位 relative：相对定位 absolute：绝对定位 fixed：固定定位 sticky：粘性定位 6.4.1 relative：相对自身的偏移 特点： 元素 仍然保留在文档流中，占据原本位置 设置 top/right/bottom/left 会在原位置基础上微调显示位置 常与 absolute 一起用，作为后者的参照容器 6.4.2 absolute：相对最近的定位祖先 特点： 元素 脱离文档流，不再占据原本位置 通过 top/right/bottom/left 定位 位置是相对于「最近的一个 position 不为 static 的祖先元素」 典型场景：在卡片右上角放一个角标。 6.4.3 fixed：固定在视口上 特点： 相对 浏览器视口 定位 滚动页面时位置不变 典型用法：右下角回到顶部按钮、固定导航栏等。 6.4.4 sticky：粘性定位 sticky 是一种介于 relative 和 fixed 之间的模式： 元素一开始像 relative 一样正常排布 当滚动到某个阈值（如 top: 0）时，变成类似 fixed，吸附在指定位置 常用于：表头吸顶、小标题导航等。 可以用一个纵向滚动的小示意来帮你区分几种定位： 6.4.5 使用 position 的注意事项 absolute/fixed 元素脱离文档流，要特别注意它们是否遮挡/被遮挡 多个定位元素重叠时，要结合 z-index 一起使用（后面进阶篇会讲「层叠上下文」） 不要滥用绝对定位来做整个页面布局，这样会非常难维护和响应式适配 --- 本章带你从 display、文档流、float 到 position，建立起对「布局基础规则」的直觉。接下来的第三篇，我们会正式上手 Flexbox 和 Grid，让你用更现代、更优雅的方式排版页面。 --- 学习总结与实践建议 🎯 本篇核心要点回顾 第4章：盒模型 ✅ 盒子四层结构：content → padding → border → margin（从里到外） ✅ 背景色填充 content + padding 区域，不包括 margin ✅ box-sizing: content-box（默认）：width 只算内容，padding/border 额外增加 ✅ box-sizing: border-box（推荐）：width 包含 content + padding + border ✅ margin 折叠：垂直方向的 margin 会\"比大小\"，取较大值 ✅ margin 折叠只发生在垂直方向，不发生在水平方向 ✅ 使用 DevTools 的盒模型面板调试 第5章：视觉表现 ✅ 颜色格式：十六进制（简洁）、rgba（透明）、hsl（调色方便） ✅ 单位选择： px：固定细节（边框、阴影） %：相对父元素（布局宽度） em：相对当前字号（会累积） rem：相对根字号（不累积，推荐） vw/vh：相对视口（全屏、响应式） ✅ 背景图：cover（铺满可能裁切）vs contain（完整可能留白） ✅ 渐变：linear-gradient()（线性）、radial-gradient()（径向） ✅ 滤镜：filter（模糊、亮度、灰度等） 第6章：布局基础 ✅ display: block：独占一行，可设宽高 ✅ display: inline：不独占一行，不可设宽高 ✅ display: inline-block：不独占一行，可设宽高 ✅ 文档流：浏览器默认从上到下、从左到右排列元素 ✅ float：图文混排（现代布局少用） ✅ position： relative：相对自身偏移，不脱离文档流 absolute：相对定位祖先，脱离文档流 fixed：相对视口，脱离文档流 sticky：粘性定位，滚动到阈值时固定 💡 给小白的学习建议 盒模型是重中之重 ✅ 打开 DevTools（F12），选中任意元素，看盒模型面板 ✅ 修改 padding/margin/border，观察变化 ✅ 切换 box-sizing，理解两种模式的区别 ✅ 给元素加背景色，理解 padding 和 margin 的区别 单位选择的实践建议 初学阶段： 先用 px 写，直观好理解 熟练后逐步引入 rem（字号、间距） 需要响应式时用 %、vw、vh 进阶阶段： 全局字号用 rem 布局用 rem + % 结合 细节用 px（边框、阴影） 全屏用 vh/vw 布局学习路径 常见问题排查 | 问题 | 可能原因 | 解决方法 | |------|---------|---------| | 元素宽度不对 | box-sizing 是 content-box | 改为 border-box | | 元素间距不对 | margin 折叠 | 改用 padding 或 Flexbox gap | | inline 元素设置宽高无效 | inline 不支持宽高 | 改为 inline-block 或 block | | 高度百分比不生效 | 父元素没有明确高度 | 给父元素设置高度 | | 元素\"飞\"走了 | 使用了 absolute 或 fixed | 检查 position 属性 | | inline-block 有间隙 | HTML 空格导致 | 用 Flexbox 或 font-size: 0 | 调试技巧 🚀 实战练习项目 用本篇学到的知识，尝试做这些小项目： 卡片组件（练习盒模型） 按钮组（练习 display 和单位） Hero 区域（练习背景和单位） 固定导航栏（练习 position） 卡片列表（练习综合布局） 📚 常见误区 误区1：到处用 px ❌ 字号用 px（不利于可访问性） ✅ 字号用 rem，边框用 px 误区2：不理解 box-sizing ❌ 设置 width: 100% 后又加 padding，导致溢出 ✅ 全局设置 box-sizing: border-box 误区3：滥用 position: absolute ❌ 用 absolute 做整个页面布局 ✅ absolute 只用于特殊定位（角标、浮层等） 误区4：不会用 DevTools ❌ 样式不对就瞎改 ✅ 用 DevTools 查看盒模型、计算值、覆盖关系 误区5：忽略 margin 折叠 ❌ 以为两个 margin 会相加 ✅ 记住垂直 margin 会折叠，取较大值 🎓 进阶方向 学完本篇后，你已经掌握了 CSS 的核心基础。接下来可以学习： 第三篇：Flexbox 弹性布局 一维布局的现代解决方案 轻松实现水平/垂直居中 等高列、自适应宽度 第四篇：Grid 网格布局 二维布局的强大工具 复杂页面布局 响应式网格系统 第五篇：响应式设计 媒体查询（@media） 移动端适配 断点设计策略 第六篇：CSS 动画与过渡 transition（过渡） animation（动画） transform（变换） 💪 学习检查清单 完成本篇学习后，你应该能够： [ ] 解释盒模型的四层结构 [ ] 说出 content-box 和 border-box 的区别 [ ] 理解 margin 折叠的原理和场景 [ ] 选择合适的 CSS 单位（px/rem/em/%/vw/vh） [ ] 区分 block、inline、inline-block [ ] 使用 DevTools 调试盒模型 [ ] 理解文档流和脱离文档流 [ ] 使用 position 做简单定位 [ ] 做出一个基础的卡片组件 [ ] 做出一个固定导航栏 如果这些都能做到，恭喜你！你已经掌握了 CSS 布局的核心基础，可以开始学习 Flexbox 和 Grid 了！🎉 --- 参考资料： MDN 盒模型：https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model MDN display：https://developer.mozilla.org/zh-CN/docs/Web/CSS/display MDN position：https://developer.mozilla.org/zh-CN/docs/Web/CSS/position CSS Tricks 完整指南：https://css-tricks.com/"
    },
    {
      "title": "第三篇_现代布局_从弹性到网格",
      "path": "CSS/第三篇_现代布局_从弹性到网格.md",
      "category": "CSS",
      "tags": [],
      "date": null,
      "description": "> 目标：掌握现代网页布局的两大主力——Flexbox 和 Grid。看完这一篇，你应该能：\r\n>\r\n> - 用 Flexbox 写出常见的一维布局：导航栏、卡片列表、左右结构等；\r\n> - 用 Grid 写出二维布局：后台面板、多区域页面框架等；\r\n> - 读懂别人写的现代布局代码，不再只会靠 position: absolute 硬拼页面。\r\n\r\n---\r\n\r\n\r\n\r\n> Flexbox 适合",
      "content": "第三篇 现代布局：从弹性到网格 目标：掌握现代网页布局的两大主力——Flexbox 和 Grid。看完这一篇，你应该能： - 用 Flexbox 写出常见的一维布局：导航栏、卡片列表、左右结构等； - 用 Grid 写出二维布局：后台面板、多区域页面框架等； - 读懂别人写的现代布局代码，不再只会靠 position: absolute 硬拼页面。 --- 第7章 Flexbox：让盒子学会“自动排队” Flexbox 适合用来处理“一排”或“一列”的布局问题，比如：顶部导航、一行卡片、左右结构（左侧文字右侧图片）等。 记住一句话：Flex 是一维布局（只关心一条主轴），Grid 是二维布局。 7.1 容器与项目的角色 使用 Flexbox 的第一步：先选中一个“容器”，再让其中的子元素变成“项目”。 💡 核心理解：Flexbox 是一种\"父子关系\"的布局模式 父元素：设置 display: flex，成为 Flex 容器（flex container） 子元素：自动成为 Flex 项目（flex items），听从父元素的布局指挥 --- 7.1.1 如何创建 Flex 容器 一行代码启动 Flexbox： 效果： .container 本身变成 Flex 容器 它的直接子元素自动变成 Flex 项目 子元素的排列方式从\"默认文档流\"变成\"Flex 布局\" --- 7.1.2 生活化比喻：队伍与队员 可以把 Flexbox 想象成排队系统： --- 7.1.3 基础示例：导航栏 HTML 结构： 不使用 Flexbox（默认效果）： 效果： --- 使用 Flexbox： 效果： 💡 关键变化： li 从\"独占一行\"变成\"横向排列\" 不需要设置 float 或 inline-block 一行代码搞定！ --- 7.1.4 容器与项目的关系图 可视化理解： --- 7.1.5 ⚠️ 重要：只有直接子元素才是 Flex 项目 示例： 关系图： 💡 关键理解： .item 是 .container 的直接子元素 → 是 Flex 项目 ✅ p 是 .item 的子元素，不是 .container 的直接子元素 → 不是 Flex 项目 ❌ --- 如果想让 p 也使用 Flex 布局： 关系图： --- 7.1.6 Flex 容器的默认行为 当你设置 display: flex 后，会发生以下变化： 子元素横向排列 子元素高度自动对齐 子元素宽度由内容决定 --- 7.1.7 常见问题 问题1：为什么设置了 display: flex，子元素还是竖着排？ 解决：检查是否设置了 flex-direction: column，默认是 row（横排） --- 问题2：为什么孙子元素不受 Flex 影响？ 解决：只有直接子元素才是 Flex 项目，如果想控制孙子元素，需要在父元素上再设置 display: flex --- 问题3：为什么子元素被压缩了？ 原因：默认情况下，Flex 项目会自动缩小以适应容器 解决： --- 7.1.8 display: flex vs display: inline-flex 两种 Flex 容器： 区别： | 特性 | display: flex | display: inline-flex | |------|----------------|----------------------| | 容器本身 | 块级元素，独占一行 | 行内元素，不独占一行 | | 子元素布局 | 相同（都是 Flex 布局） | 相同（都是 Flex 布局） | | 常用场景 | 大部分布局 | 行内的小组件 | 可视化对比： --- 💡 记忆要点 理解容器与项目的关系是学习 Flexbox 的第一步，后面所有的属性都是在这个基础上展开的。 7.2 主轴、交叉轴、排列方式 理解 Flex 的关键是主轴（main axis）和交叉轴（cross axis）这两个概念。 💡 核心理解： 主轴：Flex 项目排列的方向 交叉轴：垂直于主轴的方向 主轴方向由 flex-direction 决定 --- 7.2.1 主轴与交叉轴 默认情况（flex-direction: row）： 主轴：水平方向（从左到右）→ 交叉轴：垂直方向（从上到下）↓ 可视化理解： --- 当设置 flex-direction: column 时： 主轴：垂直方向（从上到下）↓ 交叉轴：水平方向（从左到右）→ 可视化理解： --- 7.2.1.1 flex-direction：改变主轴方向 flex-direction 属性决定主轴的方向，有4个值： row（默认）：主轴水平，从左到右 --- row-reverse：主轴水平，从右到左 💡 应用场景：阿拉伯语等从右到左的语言布局 --- column：主轴垂直，从上到下 💡 应用场景：移动端垂直布局、侧边栏菜单 --- column-reverse：主轴垂直，从下到上 💡 应用场景：聊天界面（最新消息在底部） --- 📊 flex-direction 对比表 | 值 | 主轴方向 | 起点 | 终点 | 常用场景 | |----|---------|------|------|---------| | row | 水平 → | 左 | 右 | 导航栏、卡片列表 | | row-reverse | 水平 ← | 右 | 左 | RTL 语言布局 | | column | 垂直 ↓ | 上 | 下 | 移动端布局、侧边栏 | | column-reverse | 垂直 ↑ | 下 | 上 | 聊天界面、时间线 | --- 💡 记忆口诀 --- 🔍 调试技巧：如何判断主轴方向 如果是 row 或 row-reverse → 主轴是水平的 如果是 column 或 column-reverse → 主轴是垂直的 如果没写 → 默认是 row（水平） --- 7.2.1.2 主轴和交叉轴的实际应用 示例1：水平导航栏 效果： --- 示例2：垂直侧边栏 效果： --- 关键理解：主轴 = 元素排队的方向，交叉轴就是垂直于主轴的那条轴。后面所有的对齐属性都是基于主轴和交叉轴来工作的。 7.2.2 沿主轴的排列：justify-content justify-content 决定 项目沿主轴方向的对齐方式。 💡 核心理解： 控制项目在主轴上的分布 主轴是水平时，控制左右分布 主轴是垂直时，控制上下分布 --- 常用值（6个）： flex-start（默认）：靠近主轴起点 --- flex-end：靠近主轴终点 --- center：居中 💡 应用场景：卡片居中、按钮居中 --- space-between：两端对齐，项目之间平均分配间距 💡 应用场景：导航栏（Logo 左，菜单右） --- space-around：项目两侧都有间距 💡 关键理解： 每个项目左右各有 1 份间距 相邻项目之间的间距 = 1 + 1 = 2 份 两端的间距 = 1 份 --- space-evenly：项目之间和两端间距都相等 💡 应用场景：均匀分布的按钮组 --- 📊 justify-content 对比表 | 值 | 效果 | 两端是否贴边 | 项目间距 | 常用场景 | |----|------|------------|---------|---------| | flex-start | 靠起点 | 起点贴边 | 无间距 | 默认布局 | | flex-end | 靠终点 | 终点贴边 | 无间距 | 右对齐 | | center | 居中 | 不贴边 | 无间距 | 居中布局 | | space-between | 两端对齐 | 两端贴边 | 均分 | 导航栏 | | space-around | 环绕分布 | 不贴边 | 中间是两端的2倍 | 卡片列表 | | space-evenly | 均匀分布 | 不贴边 | 完全相等 | 按钮组 | --- 🎨 可视化对比（完整版） --- 💡 实际应用示例 示例1：导航栏（Logo 左，菜单右） 效果： --- 示例2：按钮组居中 效果： --- 7.2.3 沿交叉轴的对齐：align-items align-items 决定 项目在交叉轴上的对齐方式。 💡 核心理解： 控制项目在交叉轴上的对齐 主轴是水平时，控制上下对齐 主轴是垂直时，控制左右对齐 --- 常用值（5个）： stretch（默认）：拉伸填满容器 ⚠️ 注意：只有项目没有设置高度时才会拉伸 --- flex-start：靠交叉轴起点 --- flex-end：靠交叉轴终点 --- center：居中 💡 应用场景：垂直居中（最常用！） --- baseline：按文本基线对齐 💡 应用场景：不同字号的文字对齐 --- 📊 align-items 对比表 | 值 | 效果 | 是否拉伸 | 常用场景 | |----|------|---------|---------| | stretch | 拉伸填满 | ✅ 是 | 等高卡片 | | flex-start | 靠起点 | ❌ 否 | 顶部对齐 | | flex-end | 靠终点 | ❌ 否 | 底部对齐 | | center | 居中 | ❌ 否 | 垂直居中（最常用） | | baseline | 基线对齐 | ❌ 否 | 文字对齐 | --- 🎨 可视化对比（完整版） --- 💡 实际应用示例 示例1：垂直居中（最常用） 效果： --- 示例2：完美居中（水平+垂直） 效果： --- 💡 组合记忆 --- 🔍 常见问题 问题1：为什么 align-items: center 不生效？ 原因：容器没有高度，无法垂直居中 解决： --- 问题2：为什么 justify-content 和 align-items 搞混了？ 记忆技巧： justify-content：justify 的 j 像箭头 →，控制主轴（横向） align-items：align 的 a 像箭头 ↑，控制交叉轴（纵向） （这只是记忆技巧，实际上取决于 flex-direction） 7.3 对齐、换行、伸缩规则 --- 7.3.1 是否允许换行：flex-wrap 默认情况下，如果项目太多，Flex 容器会把所有项目挤在同一行，导致项目被压缩。 💡 核心理解： flex-wrap 控制项目是否换行 默认是 nowrap（不换行） 设置 wrap 可以实现响应式布局 --- 常用值（3个）： nowrap（默认）：不换行，所有项目挤在一行 效果： ⚠️ 问题：项目会被压缩，可能导致内容显示不全 --- wrap：允许换行 效果： 💡 应用场景：响应式卡片列表、标签云 --- wrap-reverse：换行，但交叉轴反向 效果： 💡 应用场景：少用，特殊布局需求 --- 📊 flex-wrap 对比表 | 值 | 是否换行 | 换行方向 | 常用场景 | |----|---------|---------|---------| | nowrap | ❌ 否 | - | 导航栏（固定一行） | | wrap | ✅ 是 | 从上到下 | 响应式卡片列表 | | wrap-reverse | ✅ 是 | 从下到上 | 特殊布局 | --- 🎨 可视化对比（完整版） --- 💡 实际应用示例 示例1：响应式卡片列表 效果： 💡 关键理解： 容器宽度改变时，卡片会自动调整换行 实现了响应式布局，不需要媒体查询 --- 示例2：标签云 效果： --- 🔍 常见问题 问题1：为什么设置了 flex-wrap: wrap，但还是不换行？ 原因：容器没有宽度限制，会自动扩展以容纳所有项目 解决： --- 问题2：换行后项目之间的间距怎么设置？ 方法1：使用 gap（推荐，现代浏览器） 方法2：使用 margin（兼容性好） --- 💡 记忆要点 7.3.2 多行对齐：align-content 当 flex-wrap: wrap 时，会出现多行。这时 align-content 用来控制多行整体在交叉轴上的分布。 💡 核心理解： align-content 只在多行时生效 控制多行之间的间距和对齐 类似于 justify-content，但作用于交叉轴 --- ⚠️ 重要区别 --- 常用值（6个）： stretch（默认）：拉伸填满容器 --- flex-start：靠交叉轴起点 --- center：居中 --- space-between：两端对齐 --- space-around：环绕分布 --- space-evenly：均匀分布 --- 📊 align-content vs align-items 对比 | 属性 | 作用对象 | 何时生效 | 控制方向 | |------|---------|---------|---------| | align-items | 单行内的项目 | 单行或多行都生效 | 交叉轴（项目对齐） | | align-content | 多行整体 | 只在多行时生效 | 交叉轴（行间分布） | --- 💡 实际应用示例 --- 🔍 常见问题 问题：为什么 align-content 不生效？ 原因：align-content 只在多行时生效，单行时无效 解决： --- 7.3.3 单个项目的对齐覆盖：align-self 有时候你希望某一个项目的对齐方式和其他兄弟不一样，可以使用 align-self。 💡 核心理解： align-self 作用于单个项目 覆盖容器的 align-items 设置 只影响当前项目，不影响其他项目 --- 常用值（5个）： auto（默认）：继承父容器的 align-items flex-start：靠交叉轴起点 flex-end：靠交叉轴终点 center：居中 baseline：基线对齐 stretch：拉伸 --- 💡 实际应用示例 示例1：特殊项目单独对齐 效果： --- 示例2：卡片高度不同时的对齐 效果： --- 📊 align-self vs align-items 对比 | 属性 | 作用对象 | 设置位置 | 优先级 | |------|---------|---------|-------| | align-items | 所有项目 | 容器上 | 低 | | align-self | 单个项目 | 项目上 | 高（覆盖 align-items） | --- 💡 记忆要点 7.3.4 伸缩规则：flex-grow / flex-shrink / flex-basis 这是 Flexbox 最核心也是最难理解的部分。理解了这三个属性，你就掌握了 Flexbox 的精髓。 💡 核心理解： flex-grow：空间有剩余时，如何分配多余空间（扩展系数），默认值为 0（不扩展） flex-shrink：空间不足时，如何压缩项目（收缩系数），默认值为 1（允许收缩） flex-basis：元素在主轴上的「基础尺寸」（类似 width，但用于 Flex 计算），默认值为 auto（使用项目自身尺寸）） 通常我们用简写属性 flex： 常见方便写法： flex: 1; 等价于 flex: 1 1 0;，表示： 允许扩展、允许缩小 基础尺寸为 0（空间按比例分） 示例： 占比示意： 左右两部分会按 2:1 分摊剩余空间，非常适合做左右布局。 --- 📊 常用 flex 简写值对比 | 值 | 等价于 | grow | shrink | basis | 含义 | 常用场景 | |----|--------|------|--------|-------|------|---------| | flex: 1 | flex: 1 1 0% | 1 | 1 | 0% | 等分空间 | 等宽列 | | flex: auto | flex: 1 1 auto | 1 | 1 | auto | 自适应内容 | 响应式 | | flex: none | flex: 0 0 auto | 0 | 0 | auto | 固定尺寸 | Logo | | flex: 2 | flex: 2 1 0% | 2 | 1 | 0% | 占2份 | 2:1布局 | | flex: 0 0 200px | - | 0 | 0 | 200px | 固定200px | 侧边栏 | --- 💡 实际应用示例 示例1：等分布局（最常用） 效果：每列宽度完全相等 --- 示例2：固定侧边栏 + 自适应主内容 效果： --- 示例3：Logo + 导航 + 按钮 效果： --- 🔍 常见问题 问题1：为什么 flex: 1 和 flex: auto 不一样？ 区别： --- 问题2：为什么设置了 flex: 1，但宽度还是不相等？ 原因：min-width 会限制最小宽度，即使 flex: 1 也无法缩小到 200px 以下 解决： --- 💡 心法总结 多数时候你可以先记住： 等分就写 flex: 1; 2:1 就分别写 flex: 2; 和 flex: 1; 固定尺寸就写 flex: none; 或 flex: 0 0 200px; 等更熟练时，再深入理解 flex-basis 的作用。 7.3.4.1 “空间足够”和“空间不足”时会发生什么？ 假设： 空间足够时（容器宽度 ≥ 3 × 200px）： 空间不足时（容器宽度 < 3 × 200px）： 记忆小结： - grow：决定“空间多时”谁长得快 - shrink：决定“空间不够时”谁缩得多 - basis：决定“起步时”的期望尺寸 7.4 实战：写出响应式导航栏 做一个常见的导航栏结构：左边 Logo，右边是导航链接。 7.4.1 HTML 结构 7.4.2 基础 Flex 布局 这里的关键点： 顶部容器 .site-header 使用 display: flex，Logo 和 nav 成为两个 flex 项目 justify-content: space-between 让两者分居两端 nav 内部再使用一层 flex，让超链接一行排开 7.4.3 简单响应式思路 小屏幕下你可能希望导航折叠成一个菜单按钮，这就需要配合 JavaScript 或更高级的 CSS 技巧，这里只先点到： 用媒体查询（@media）在小屏幕下改变： 导航从横排变成竖排 显示/隐藏菜单图标 总结：Flexbox 非常适合一维布局，尤其是“一行内如何排队、如何分配空间”的问题。在写任何复杂布局之前，都先问：这一部分能不能先用 Flex 搞定？ --- 第8章 Grid：二维布局的终极武器 当你需要同时在\"行\"和\"列\"两个方向上思考布局时，就轮到 Grid 登场了。 - 典型场景：后台管理面板、复杂控制台、多区域页面框架（头、侧栏、主内容、底部）等。 核心理解： Flexbox：一维布局（一条线上排列，主轴方向） Grid：二维布局（同时控制行和列） --- Grid vs Flexbox 对比 | 特性 | Flexbox | Grid | |------|---------|------| | 维度 | 一维（主轴） | 二维（行+列） | | 适用场景 | 导航栏、按钮组、一行卡片 | 页面整体布局、复杂网格 | | 控制方式 | 沿主轴排列 | 精确控制行列位置 | | 响应式 | 通过 flex-wrap 换行 | 通过 auto-fit/fill 自适应 | | 学习曲线 | 较简单 | 稍复杂 | --- 什么时候用 Grid？ 适合用 Grid： 需要同时控制行和列 复杂的页面整体布局（头部、侧边栏、主内容、底部） 需要精确控制元素位置 卡片网格、相册布局、仪表盘 适合用 Flexbox： 一维排列（一行或一列） 导航栏、按钮组 简单的居中对齐 不确定项目数量的列表 实用建议：Grid 和 Flexbox 可以嵌套使用！外层用 Grid 控制整体布局，内层用 Flexbox 控制细节排列。 --- 8.1 网格轨道、模板、区域 8.1.0 核心概念 先认识几个核心术语： 基础术语： 网格容器（Grid Container）：设置了 display: grid 的元素 网格项目（Grid Items）：网格容器的直接子元素 网格线（Grid Lines）：分隔网格的线（行线和列线） 网格轨道（Grid Tracks）：两条相邻网格线之间的空间（行或列） 网格单元格（Grid Cell）：行与列交叉的一个小方格 网格区域（Grid Area）：由多个单元格合并组成的更大区域 --- 可视化理解： --- 生活化比喻：Excel 表格 Grid 布局就像 Excel 表格： 行和列：表格有明确的行和列 单元格：行列交叉形成单元格 合并单元格：可以合并多个单元格形成更大区域 调整大小：可以调整每行每列的大小 8.1.1 最基本的 Grid 容器 核心属性： grid-template-columns：定义列的数量和宽度 grid-template-rows：定义行的数量和高度 --- 示例1：三列布局 解释： 第 1 列：固定 200px（侧边栏） 第 2 列：1fr（主内容，自适应剩余空间） 第 3 列：固定 200px（右侧栏） 可视化： --- 示例2：网格系统 可视化布局： --- 8.1.1.1 fr 单位详解 fr 是 Grid 布局专用单位，表示\"剩余空间的份额\"。 💡 核心理解： fr = fraction（分数/份额） 先计算固定尺寸，再将剩余空间按 fr 比例分配 计算过程示例： 计算步骤： 固定部分：200px 剩余空间：900px - 200px = 700px fr 总和：1fr + 2fr = 3fr 每份大小：700px ÷ 3 = 233.33px 最终宽度： 第1列：200px（固定） 第2列：233.33px（1fr） 第3列：466.67px（2fr） 可视化： --- fr 与其他单位混合使用： 效果： 固定列：200px + 100px = 300px 剩余空间按 1:2 分配给中间两列 --- 常用 fr 模式： --- 💡 记忆要点 8.1.2 repeat() 简化写法 repeat() 函数用于重复定义网格轨道，避免重复书写。 语法： --- 基础示例： --- repeat() 的多种用法： 重复单一值： 效果： --- 重复模式： 效果： --- 混合使用： 效果： --- 12列栅格系统： 可视化： --- 💡 记忆要点 --- 8.1.3 网格间距：gap gap 用于设置网格项目之间的间距（不影响外边缘）。 语法变化： 旧版：grid-gap（已废弃但仍有效） 新版：gap（推荐，Flex 和 Grid 通用） --- 基础用法： 可视化： --- 分别设置行列间距： 效果对比： --- 实际应用示例： 卡片网格： 图片画廊： 表单布局： --- gap vs margin 的区别： 对比图： --- 💡 记忆要点 --- 🔍 常见问题 问题：为什么 gap 在某些浏览器不生效？ 原因：旧版浏览器不支持 解决： 8.1.4 网格区域命名：grid-template-areas 对于复杂的整体页面布局，可以用“文字画图”的方式定义布局： 上面的定义，对应的布局草图可以画成： 配合 HTML： grid-template-areas 像是在画一个布局草图：哪块写什么名字，对应区域就会自动占据相应格子。 💡 核心理解： 像画图一样设计布局 使用命名区域代替数字定位 让布局代码自解释 --- 基础示例：经典布局 可视化对应关系： 配合 HTML： --- 进阶用法： 使用点号（.）表示空白区域： 效果： 响应式布局（配合媒体查询）： --- ⚠️ 注意事项： 区域必须是矩形： 每行列数必须相同： --- 💡 记忆要点 grid-template-areas 像是在画一个布局草图：哪块写什么名字，对应区域就会自动占据相应格子。 8.2 repeat()、minmax()、auto-fit 这一节讲一些在实战中非常好用的“自动栅格”写法。 8.2.1 minmax()：最小/最大尺寸 minmax(min, max) 用于定义一条轨道（列或行）的最小和最大尺寸： 含义： 每列至少 200px 宽度可以伸展到至多 1fr 以平分剩余空间 8.2.2 auto-fit 与 auto-fill：自适应列数 做响应式卡片网格时，有一个非常常见的写法： 这个组合可以理解为： 容器宽度够，就多放几列 容器变窄，就自动减少列数 每个卡片最小 240px，最多平分剩余宽度 可视化想象： auto-fit 与 auto-fill 的差别较细： 在大多数常见场景下，可以优先记住 auto-fit，让空轨道“收缩”，看起来更自然 这套 repeat(auto-fit, minmax()) 写法几乎是“自适应网格”的标准答案，建议熟悉并多练习几次。 8.2.2.1 auto-fit 自适应列数直观图 以： 为例，可以这样想： 一个简化记忆： 8.3 grid-area 的常见布局模式 除了用 grid-template-areas 做整体布局，还可以在单个元素上精细控制它跨多少行、多少列。 8.3.1 使用 grid-column 与 grid-row 也可用 span： 8.3.2 实战示例：杂志式卡片布局 HTML： 这样就做出类似新闻首页的布局：左边一块大图，右边上下两个小卡片。 8.4 实战：做一个通用管理后台布局 目标：做出一个典型的后台布局： 顶部：导航栏 左侧：侧边栏 中间：主内容区 底部：页脚 8.4.1 HTML 结构 8.4.2 Grid 布局代码 你可以再加上一些基础样式美化：背景色、边距、阴影等，这里就不展开。 思考：如果要在小屏幕上把侧边栏变成顶部抽屉式菜单，只需要在媒体查询中改一下 grid-template-areas 和行列设置即可，这样的改造比绝对定位方案要清晰、可维护得多。 --- 本篇中，我们用 Flexbox 解决了一维布局（“一排怎么排队”）的问题，用 Grid 解决了二维布局（“网格里每块怎么摆”）的问题。在后面的篇章中，我们会把这些布局能力和组件化、响应式、变量等概念结合起来，完成一套真正可维护的 CSS 架构。"
    },
    {
      "title": "第四篇_强化视觉_字体_动画_变换",
      "path": "CSS/第四篇_强化视觉_字体_动画_变换.md",
      "category": "CSS",
      "tags": [],
      "date": null,
      "description": "> 目标：在掌握盒模型和布局之后，进一步提升页面的“质感”。看完这一篇，你应该能：\r\n> - 为不同场景选择合适的字体、字号、行高和字重；\r\n> - 使用过渡和动画让交互变得自然、不突兀；\r\n> - 用 2D/3D 变换给元素增加层次感，而不是简单粗暴地“放大缩小”。\r\n\r\n---\r\n\r\n\r\n\r\n> 这一章解决的核心问题：\r\n> - 中文 Web 项目里应该选哪些字体？怎么写回退字体？\r\n> - ",
      "content": "第四篇 强化视觉：字体、动画、变换 目标：在掌握盒模型和布局之后，进一步提升页面的“质感”。看完这一篇，你应该能： - 为不同场景选择合适的字体、字号、行高和字重； - 使用过渡和动画让交互变得自然、不突兀； - 用 2D/3D 变换给元素增加层次感，而不是简单粗暴地“放大缩小”。 --- 第9章 字体：让文字拥有自己的个性 这一章解决的核心问题： - 中文 Web 项目里应该选哪些字体？怎么写回退字体？ - 字号、行高、字重如何搭配才舒服？ - @font-face 怎么加载自定义字体？加载不出来时会发生什么？ 用一句话概括：让页面上的文字既好看又好读。 9.1 字体族与字体文件 9.1.1 字体族（font-family）基础 CSS 中的 font-family 就是用来指定字体的。常见写法： 这里包含几类字体： 具体字体：\"PingFang SC\"（苹方）、\"Microsoft YaHei\"（微软雅黑）、\"Noto Sans SC\" 等 西文字体：Arial 泛型字体族（generic family）：sans-serif（无衬线）、serif（衬线）、monospace（等宽） 浏览器的选择流程大致是： 按顺序找你写的字体 找到第一个当前系统有的 如果都没有，就退回到泛型字体族 可以用一个小图来理解： 实战建议： 中文环境下，推荐写一个「中文 + 西文 + 泛型」的链条 不要只写 Microsoft YaHei 或 SimSun 之类单个字体，这样在 macOS / Linux 上效果会很差 9.1.2 常用中文 Web 字体组合 一个通用、比较稳妥的组合： 含义大致是： 优先使用系统 UI 字体（iOS/macOS 上的系统字体） 再退到常见的中文无衬线字体 最后至少还有一个通用的 sans-serif 你可以根据项目受众（Windows 为主还是移动端为主）去微调这份列表，但整体思路类似：先系统，后常见中文，再兜底。 9.1.3 字体文件格式与兼容性 在 Web 上常见的字体文件格式： ttf / otf：传统桌面字体格式 woff：为 Web 优化的字体格式，压缩率更高 woff2：更现代的压缩，更省流量（现代浏览器支持好） 在实际项目里，通常建议： 优先提供 woff2 + woff 必要时提供 ttf 作为兜底 注意：字体文件很大，乱用自定义字体会严重拖慢首屏加载，这一点在后面性能部分会再强调。 9.2 @font-face 的加载 @font-face 允许你引入自定义字体（如品牌专用字体或图标字体）。 9.2.1 基本用法 关键点解释： font-family：给这套字体起一个名字（CSS 内部用） src：列出字体文件及格式 font-weight / font-style：声明这是哪个粗细、哪种风格的字形 font-display：控制字体加载时的行为（非常重要） 9.2.2 font-display 的几种策略 常见取值： auto：浏览器自己决定 swap：推荐，先用系统字体显示，字体加载完再“无缝切换”成目标字体 fallback：短暂空白后，如果加载超时就不再换成目标字体 block：在一小段时间内会「空白」，等字体下来再全部渲染 可以用一个时间轴来感受： 大多数内容型网站，建议使用 swap，这样用户不会看到空白的文字区域，最多是“字体风格稍后变一下”。 9.2.3 字体加载失败时会怎样？ 如果网络很差或字体路径错误： 浏览器会按 font-family 列表继续向后找 找不到时会退到泛型族（比如 sans-serif） 这也是为什么即使用 @font-face 也要在 font-family 中写好“备用字体链”。 9.3 字体渲染、行高、字距 这一节更多是「排版手感」，不是单纯记忆属性，而是建立一个舒服的默认排版模板。 9.3.1 字号与层级（Typographic Scale） 一个常见且好用的标题层级（以根字号 16px 为例）： 把它画成「标题梯度」： 关键是： 标题层级之间要有明显差别，但不要夸张到“像海报” 正文字号在中文环境下，16px 是一个比较舒服的起点 9.3.2 行高（line-height） 常见写法： 不带单位的倍数：line-height: 1.5;、1.6;、1.75; 不推荐为正文用 px 行高（容易在不同字号组合时出现割裂感） 一个常见的正文排版设置： 直观感觉可以想成： 行高太小：文字挤在一起难读； 行高太大：行与行之间像断开一样，也不好阅读。 经验值： 正文段落：1.6 ~ 1.8 标题：可以略小，如 1.2 ~ 1.4 9.3.3 字距与段落间距 几个相关属性： letter-spacing：字母/字距 word-spacing：单词间距（对中文不常用） text-indent：首行缩进 margin-top / margin-bottom：控制段落之间的距离 中文常用设置示例： 9.3.4 字体渲染差异（粗细与抗锯齿） 不同系统和浏览器对同一个字体的渲染可能不一样，例如： macOS 上文字更圆润、抗锯齿更明显 Windows 上有时会显得更锐利甚至偏“糊” 你可以在 DevTools 中对同一段文本： 切换不同 font-weight（400 / 500 / 600 / 700） 观察不同系统下的效果，挑选自己觉得舒服的档位 在设计系统中，常见的做法是只用少数几个字重： 正文：400 强调：500 或 600 标题：600 或 700 9.4 中文字体的选择与性能 中文字体的一个现实问题是：文件更大。 9.4.1 尽量优先使用系统字体 对于大多数内容型网站，推荐策略是： 优先使用系统自带字体（体积为 0，不需要下载） 只在品牌要求很强时，才引入额外的 Web 字体 示例策略： system-ui 是一个较新的泛型族，代表系统默认 UI 字体，现代浏览器支持较好。 9.4.2 如果必须用 Web 中文字体 要考虑几个问题： 子集化（Subsetting）： 一套完整中文字体可能有几万个字形，文件轻松上 MB 若只需部分字符（如 Logo 或标题语），可以做子集字体，只包含必要字符 分权重加载： 不要一次性加载 300/400/500/600/700 等很多个字重 优先加载正文用的 400 和标题用的 600 即可 懒加载： 某些不重要的装饰字体，可以在首屏之后再加载 9.4.3 使用字体服务 市面上有多种字体服务（如 Google Fonts、一些国内商用字体平台），它们会帮助你： 处理多格式（woff2/woff/ttf） 做 CDN 加速 一定程度的子集化 但要注意： 商用项目必须确认字体的授权 一些境外字体 CDN 可能在国内网络环境下速度不稳定 --- 第9章到这里，你应该已经可以为页面做一套看起来「舒服」的文字系统：合理的字体族、字号梯度、行高、段落间距，并且知道自定义字体加载会带来什么影响。接下来第10章，我们会从静态视觉转向「动态」——用过渡和动画让页面动起来。 第10章 过渡与动画：让页面动起来 这一章解决的核心问题： - hover 时元素“突然跳变”很生硬，如何让变化变得柔和？ - transition 要写哪些参数？顺序有什么讲究？ - transform 缩放、旋转、位移这些变换如何组合？ - animation + keyframes 和 transition 有什么区别，各自适合什么场景？ 10.1 transition 的四要素 transition 用来在「状态 A」和「状态 B」之间加一条“缓冲曲线”。典型场景：按钮 hover、折叠面板展开等。 10.1.1 四个核心参数 语法可以拆解为四个部分： 各参数详解： property（过渡属性）：指定哪个CSS属性需要过渡效果 all - 所有属性都过渡 opacity - 透明度 transform - 变换（缩放/旋转/位移等） background-color - 背景颜色 width/height - 宽高（性能较差，慎用） duration（持续时间）：动画执行的时长 0.2s - 200毫秒 300ms - 300毫秒 建议范围：150ms-350ms（太快看不清，太慢显得卡顿） timing-function（缓动函数）：控制动画的速度变化曲线 ease - 默认值，先快后慢 linear - 匀速 ease-in - 慢速开始，加速结束 ease-out - 快速开始，减速结束 ease-in-out - 慢速开始和结束 cubic-bezier() - 自定义贝塞尔曲线 delay（延迟时间）：动画开始前的等待时间 0s - 立即开始 0.1s - 延迟100毫秒开始 最常见的写法： 小建议：尽量只对 少数关键属性 做过渡，比如 opacity、transform，它们通常性能较好。 10.1.2 从“生硬跳变”到“柔和过渡” 没有 transition 时： 大脑中的感受大概是： 10.1.3 常见 timing-function 曲线 几个常用曲线的感觉： linear：匀速，机械感强，多用于进度条 ease：先快后慢，比线性自然（默认值） ease-in：慢慢启动，适合“出现” ease-out：慢慢停下，适合“消失” ease-in-out：两头慢，中间快，更流畅 你可以在 DevTools 的动画面板里直观看到这些曲线，也可以用 cubic-bezier() 自定义，例如： 这类自定义曲线经常被称为“手感更像 App 的动效曲线”。 10.2 transform：缩放、旋转、位移、倾斜 transform 决定元素在 2D/3D 空间中的几何变换。常见的有： translateX/Y：位移 scale：缩放 rotate：旋转 skew：倾斜 10.2.1 位移：translate 与 left/top 的区别： left/top 会影响布局（通常需要配合 position） transform: translate 不改变文档流占位，更适合做动效 left/top 属于定位属性，需要配合 position（如 relative、absolute 等）使用，会改变元素在文档流中的位置，可能影响其他元素的布局。 transform: translate 只是视觉上移动元素，不会改变元素在文档流中的原始占位，其他元素的布局不会受到影响。 10.2.2 缩放：scale 配合 transition，可以做卡片 hover 的轻微放大： 10.2.3 旋转与倾斜：rotate、skew 旋转常用在图标按钮（比如刷新、关闭）上；倾斜适合作为装饰效果，慎用在正文内容上，以免影响可读性。 10.2.4 transform 原点：transform-origin 默认情况下，变换的原点是元素的中心： 示意： 这在做折叠菜单（从上往下展开）时非常常见： 10.3 animation 与 keyframes transition 是在两个状态之间自动补间，而 animation + @keyframes 可以定义多帧动画，更适合： 循环动画（如加载动画） 独立于交互事件的装饰性动效 10.3.1 基本结构 animation 简写参数顺序一般为： 常用参数详解： name（动画名称）：引用@keyframes定义的动画 例：pulse、fade-in、slide-up duration（持续时间）：动画播放一次的时长 例：1s、200ms、2.5s timing-function（缓动函数）：与transition相同 ease、linear、ease-in-out 等 delay（延迟时间）：动画开始前的等待时间 例：0s、0.5s iteration-count（循环次数）：动画重复播放次数 1 - 播放一次 3 - 播放三次 infinite - 无限循环 direction（播放方向）：动画的播放顺序 normal - 正常播放（默认） reverse - 反向播放 alternate - 交替播放（正反正反...） alternate-reverse - 反向交替 fill-mode（填充模式）：动画开始前/结束后的状态 none - 不保持（默认） forwards - 保持最后一帧状态 backwards - 立即应用第一帧状态 both - 同时应用forwards和backwards play-state（播放状态）：控制动画暂停/播放 running - 播放中（默认） paused - 暂停 10.3.2 from / to 写法 单纯“从 A 到 B”的动画，可以用 from / to： 10.3.3 一次性入场动画 如果你只希望元素在第一次进入时播放一个动画，而不是一直循环，可以： 在初始状态触发类名（如 JS 加上 .enter） 用 animation-fill-mode: forwards 保持结束状态 一般来说：交互驱动的小动效优先考虑 transition， 时间驱动/循环/多步骤动画再考虑 animation。 10.4 实战：呼吸按钮、加载动画 这一节用两个小例子把上面的概念串起来。 10.4.1 呼吸按钮（pulse button） 目标效果：按钮轻微放大缩小，像在“呼吸”，吸引用户注意但不过分抢眼。 HTML： CSS（核心部分）： 按钮的动线大致可以想象为： 10.4.2 加载动画（loading spinner） 目标效果：一个简单的圆环一直旋转，表示“正在加载”。 HTML： CSS： 可以用一行文字来记它的本质： 10.4.3 动效的“度”与性能 最后，再强调两个常被忽略的点： 动效的“度” 动画太快：眨眼就过，看不清变化 动画太慢：让人着急，影响操作效率 一般 UI 交互动效时长常见在 150ms ~ 300ms 之间 性能与属性选择 优先对 opacity、transform 做过渡/动画 避免频繁动画 width/height/top/left 等会触发布局重排的属性 动效的目标，不是“炫技”，而是让用户感觉：界面懂我在做什么，并且在温柔地回应我。 --- 第10章带你从过渡、变换到关键帧动画，完成了 CSS 动效的基础拼图。接下来第11章，我们会在此基础上继续探索滤镜与特效，比如毛玻璃、混合模式，让你的页面在细节上更接近成熟产品的视觉质感。 第11章 滤镜与特效 这一章解决的核心问题： - 如何用 filter 做出模糊、灰度、亮度调整等效果？ - mix-blend-mode 是什么？怎么让文字/图层和背景“混色”？ - backdrop-filter 如何实现毛玻璃（玻璃拟态）效果？ - 在不牺牲可读性和性能的前提下，用特效提升页面质感。 11.1 filter 滤镜 filter 可以理解为给元素贴上一个“后期滤镜”，对其像素进行模糊、变亮、变暗、灰度等处理。 常见的滤镜函数： blur(px)：高斯模糊 brightness(%)：亮度 contrast(%)：对比度 grayscale(%)：灰度 saturate(%)：饱和度 sepia(%)：褐色（复古效果） drop-shadow()：投影（类似 box-shadow，但跟随图形轮廓） 11.1.1 基础示例 你也可以链式叠加多个滤镜，执行顺序从左到右： 11.1.2 滤镜 vs 直接改颜色 有些效果既可以通过调整颜色属性（如 background-color）实现，也可以通过滤镜实现。 filter 的优势：可以对图片或视频整体做后期调整，而不改动源文件 代价：在一些设备上滤镜可能比简单颜色变更更耗性能 常见用法： 给背景图加一点 brightness() 压暗，突出前景文字 给缩略图加 grayscale(100%)，hover 时还原彩色 11.2 mix-blend-mode 混合模式 mix-blend-mode 用于控制一个元素和其“背后内容”怎样混合颜色，类似于 Photoshop 里的图层混合模式。 常见混合模式： multiply：正片叠底，通常让颜色变暗 screen：滤色，让颜色变亮 overlay：叠加，对比增强 difference：差值，产生反相效果（更偏实验性） 11.2.1 基础用法 HTML： 简单示意： 注意：mix-blend-mode 的最终效果高度依赖背景内容，难以精确控制，一般用于图形/装饰性排版，不适合作为关键 UI 的唯一对比手段。 11.2.2 常见小用法 让 icon/装饰图案跟背景混色，形成更丰富的质感 做横幅（banner）时，让白色大标题与背景渐变融合得更自然 示例： 在深色背景上，会显得颜色更“沉”，而不是刺眼的纯橙色。 11.3 backdrop-filter 毛玻璃效果 backdrop-filter 是实现「玻璃拟态（Glassmorphism）」的关键属性，它不是对元素自身，而是对元素背后的内容应用滤镜。 典型用法： 半透明卡片，背景被模糊 固定在顶部的导航栏，略带模糊背景 11.3.1 基础示例 视觉结构可以想象为： 11.3.2 浏览器支持与兼容性 backdrop-filter 在现代浏览器中支持已经不错，但： 某些老版本浏览器不支持 移动端不同厂商实现可能略有差异 实战建议： 为 .glass-card 提供一个「退化样式」，例如简单的半透明背景，不依赖 blur 在需要时，可以用 @supports (backdrop-filter: blur(10px)) { ... } 做能力检测 11.4 实战：制作玻璃拟态卡片 综合用上一节的知识，做一个常见的玻璃拟态卡片样式。 11.4.1 HTML 结构 11.4.2 CSS 样式（核心部分） 结构示意： 11.4.3 字体与对比度的注意事项 在做这种特效时，容易只顾好看，忘了“可读性”与“可访问性”： 保证文字与背景的对比度足够（尤其是小字号） 对重要信息，避免依赖颜色与模糊效果作为唯一区分 在深浅两套主题中分别检查玻璃拟态卡片的可读性 --- 第11章中，我们用 filter、mix-blend-mode、backdrop-filter 做了几种常见视觉特效，并完成了一个玻璃拟态卡片。到这里，本篇「强化视觉」从字体、动效到特效已经成型。后面的篇章中，我们会更多地把这些能力带入组件化与实际页面，去构建真正可维护、可复用的 CSS 设计系统。"
    },
    {
      "title": "第五篇_构建真实页面_组件_响应式_维护性",
      "path": "CSS/第五篇_构建真实页面_组件_响应式_维护性.md",
      "category": "CSS",
      "tags": [],
      "date": null,
      "description": "> 目标：把前面学到的盒模型、布局、视觉、动效，真正落地到“真实项目”的代码里。\r\n> \r\n> 看完这一篇，你应该能：\r\n> - 用「组件化」的思维组织 CSS，不再是一堆散乱的选择器；\r\n> - 为页面设计一套清晰的响应式策略，兼顾 PC 和移动端；\r\n> - 使用 CSS 变量和 calc 做主题、间距、尺寸等的集中管理，为后面的架构篇打基础。\r\n\r\n---\r\n\r\n\r\n\r\n> 这一章解决的核心",
      "content": "第五篇 构建真实页面：组件、响应式、维护性 目标：把前面学到的盒模型、布局、视觉、动效，真正落地到“真实项目”的代码里。 看完这一篇，你应该能： - 用「组件化」的思维组织 CSS，不再是一堆散乱的选择器； - 为页面设计一套清晰的响应式策略，兼顾 PC 和移动端； - 使用 CSS 变量和 calc 做主题、间距、尺寸等的集中管理，为后面的架构篇打基础。 --- 第12章 CSS 组件化思想 这一章解决的核心问题： - 写 CSS 时，如何避免“越写越乱、全站一起牵一发动全身”？ - BEM 这种命名方式到底解决了什么问题？ - 一个按钮、卡片、Badge 等组件的 CSS 应该长什么样？ - 如何从“单页样式”走向“可复用组件库”？ 12.1 BEM 命名规范 BEM 是前端界非常流行的一套命名约定，它的全称是： B：Block（块） E：Element（元素） M：Modifier（修饰） 12.1.1 基本理念 你可以把 BEM 理解成： Block：一个相对独立的“模块/组件”（如 card、button、nav） Element：组件内部的组成部分（如 card__title、card__content） Modifier：在“基础样式”上做的变化（如 card--primary、card--highlight） 典型命名规则： 示意图： 12.1.2 BEM 的实际写法 HTML： CSS： 可以看到： .card 提供基础样式 .card__* 只在 card 内部使用，避免了“全局 class 撞名”的问题 .card--primary 只做“差异化”，不重写整套样式 12.1.3 BEM 带来的好处 可读性高：一眼就知道某个类属于哪个组件 可维护性强：改动一个组件的样式，不容易影响其它组件 可复用性好：一个 block 可以在多个页面重复使用 简单对比： 后者更适合团队合作和长期维护。 不必教条地“100% 按 BEM 写”，但学会 BEM 的思路，会大大提升你组织 CSS 的能力。 12.2 模块化样式组织 除了命名规范，还需要考虑“文件怎么拆”。 12.2.1 避免 giant.css 很多项目早期只有一个 style.css，后来越写越多，最后变成几千上万行的大文件： 问题： 找东西困难：修改某个按钮样式，要在大文件里到处搜索 易产生“重复样式”：忘了之前写过类似代码，又写一遍 合作困难：多人同时改一个文件，冲突频繁 12.2.2 更合理的拆分方式 一种常见的拆分结构（示意）： base/：全局通用的基础设置 components/：可复用组件 layout/：布局结构（header、footer、grid 等） pages/：特定页面独有的样式（仅少量） 在构建工具（如 webpack、Vite）或预处理器（如 Sass）里，可以把这些文件再汇总打包。 这里先建立“模块化思维”的概念，具体架构模式（ITCSS、SMACSS 等）会在第六篇再展开。 12.3 可复用组件：卡片、按钮、Badge 这一节我们通过三个最常见的 UI 元素，感受一下“组件化 CSS”的写法： Card（卡片） Button（按钮） Badge（标记） 12.3.1 Button：基础 + 状态 + 尺寸 典型结构： 示例： HTML： 组件化的关键：不要每个按钮都写一套样式，而是把“通用部分”抽到 .btn，差异放到 modifier 上。 12.3.2 Card：可容纳任意内容的容器 卡片更像是一个“内容容器”： HTML： 12.3.3 Badge：用于状态与标签 Badge 是一种小体积的状态/标签标记： HTML： 这些组件可以放在 components/ 目录中，在多个页面反复使用。 12.4 设计系统的基础思想 当你有了足够多的组件以后，就会进入“设计系统（Design System）”的范畴。 12.4.1 从“零散组件”到“系统化” 一开始你可能只有：按钮 + 卡片 + 标题。 逐渐你会抽象出： 色彩系统（主色、成功、警告、背景色等） 字体系统（字号层级、字重、行高） 间距系统（统一的 4/8/12/16/24 间距刻度） 组件库（Button、Input、Card、Modal、Toast...） 可以用一张结构图来理解： CSS 层面，你可以： 把颜色、间距、字号等固化为 CSS 变量（下一章会展开） 组件引用这些变量，而不是写死具体数值 12.4.2 初学者要做到哪一步？ 在你刚开始写 CSS 的阶段，不需要追求完美的设计系统，但可以尽早养成两个习惯： 用组件的视角看页面： 看到一个页面时，先问：这里面有哪些“可复用组件”？ 比如：卡片、列表项、按钮、标签、导航、页脚等 减少复制粘贴： 当你发现自己在多个地方写了类似结构的 HTML/CSS，就考虑抽成一个组件类 例如 card、btn 这些基础组件 本章的目标，是让你从“给页面上色”升级到“给组件上色”。接下来第13章，我们会在组件之上，讨论不同屏幕下它们应该如何“变形”，也就是响应式与适配。 第13章 响应式与适配 这一章解决的核心问题： - 如何让同一套页面在手机和电脑上都好用？ - 媒体查询（@media）应该怎么写，按什么断点来划分？ - 移动端布局的常见策略有哪些？ - 字体和容器如何做自适应？REM + vw 的组合方案如何选择？ 13.1 媒体查询基础 媒体查询允许你根据「设备特性」（如宽度、高度、像素密度）来写不同的 CSS。 最常用的是按视口宽度（width）切换布局： 理解方式： 13.1.1 常见断点的思路 断点没有唯一标准，不同设计系统会有自己一套，但常见区间大致是： 更重要的是：断点应该跟“设计发生明显变化”的地方对齐，而不是盲目抄别人的数值。 一个实用的做法是： 先在浏览器中缩放窗口 当你观察到某个组件「开始看起来不舒服」时 在那个宽度附近设置断点 13.2 移动端布局策略 移动端布局不只是“缩小”桌面布局，而是有自己的一套优先级和交互习惯。 13.2.1 Mobile First vs Desktop First 两种思路： Desktop First：先写桌面样式，再通过 @media (max-width: ...) 针对小屏做调整 Mobile First：先写手机样式，再通过 @media (min-width: ...) 为大屏「增强」 示意： 现在更推荐 Mobile First： 代码往往更简洁：默认样式就是小屏，不用写很多覆盖规则 与“渐进增强”的理念吻合：在能力更强的设备上让体验更好 13.2.2 常见布局模式的适配 举几个常见例子： 两栏布局（左图右文）： 桌面：左右分栏 手机：上下堆叠 多列卡片网格： 桌面：3~4 列 平板：2 列 手机：1 列 可以直接使用前面学过的自适应写法： 这种写法往往不需要太多媒体查询，根据容器宽度自动调整列数。 13.2.3 触控友好的尺寸 移动端布局还要考虑“手指点击区域”： 一般推荐：点击目标至少 40px x 40px 按钮内边距充足，避免太小难点 你可以为 .btn 在小屏上略微增大 padding： 13.3 字体与容器自适应 响应式不仅是“布局变形”，还包含字体、间距等的适配。 13.3.1 使用 REM 做整体缩放 回顾： 1rem = 根元素 html 的 font-size 一个常见做法： 此时： 用 rem 定义的字号、间距会随着屏幕变窄轻微缩小 用 px 定义的细节（如边框）保持不变 13.3.2 clamp() 做“自适应但有边界”的字体 clamp(min, preferred, max) 可以让值在一个范围内随视口变化，但不超出边界。 示例： 理解成： 这样在小手机上不会太大，在超宽屏上也不会夸张地巨大。 13.3.3 容器宽度与安全区域 在大屏上不要让正文跨越整个视口宽度： 示意： 这样在大屏上阅读体验会舒适很多。 13.4 REM + vw 解决方案比较 REM 和 vw 都可以做“随屏幕变化”，但各有优缺点。 13.4.1 REM 方案 特点： 13.4.2 vw 方案 13.4.3 综合建议 字体、组件尺寸：以 rem 为主，配合少量 clamp() + vw 做高级自适应 布局宽度：% + max-width + rem 组合 小装饰性的尺寸变化：可以适度用 vw 做效果 先用简单的 rem + 媒体查询写好一个稳定的响应式，再考虑引入 clamp/vw 这类“锦上添花”的方案。 --- 第13章让你的组件“学会变形”，从桌面到移动端都有良好体验。接下来第14章，我们会把色彩、间距、字号等抽象成 CSS 变量与计算，进一步提升维护性与可扩展性。 第14章 CSS 变量与计算 这一章解决的核心问题： - 怎样避免在 CSS 里到处复制粘贴同一套颜色、间距、阴影？ - var() 和 :root 如何配合，定义一套主题？ - 如何用 calc() 做简单的“数学运算”，比如宽度减去边栏、间距组合？ 14.1 var() 与 :root CSS 变量（Custom Properties）允许你在 CSS 中定义和复用值。 14.1.1 定义与使用 定义变量： 使用变量： 14.1.2 与预处理器变量的区别 如果你用过 Sass/LESS 之类的预处理器，里面也有“变量”： Sass 变量是在“编译阶段”展开的，浏览器看不到 CSS 变量在“运行时”存在，可以根据状态/主题动态改变 示例： 在 JS 中切换 body 上的 theme-light / theme-dark 类，即可完成主题切换，无需重新编译 CSS。 14.2 自定义主题 利用 CSS 变量可以很方便地做主题系统： 14.2.1 基础主题结构 然后组件层统一引用这些变量： 只要在 html 或 body 上切换 .theme-dark 类，整站视觉就会切换到暗色主题。 14.2.2 局部主题 你也可以在某个局部容器上覆盖变量： 这相当于给某一块区域「换皮肤」，而不影响其它页面部分。 14.3 calc() 的数学能力 calc() 允许你在 CSS 中做简单的计算：加、减、乘、除。 14.3.1 基础用法 结合变量（推荐）： 14.3.2 间距与尺寸的组合 例如：卡片宽度减去左右 padding： 这种写法可以让某个子元素“铺满”卡片边缘，而文字仍然保持内边距。 示意： 14.3.3 与 clamp() 等函数组合 calc() 可以与 clamp() 等函数一起使用，构建更复杂的响应式表达式，但在入门阶段不必刻意追求“炫技”。 14.4 暗色模式与亮色模式切换 最后，我们把 CSS 变量、主题与媒体查询结合起来，实现暗色 / 亮色自动或手动切换。 14.4.1 跟随系统主题 可以使用媒体查询： 这样在用户系统设置为“暗色模式”时，会自动应用暗色主题变量。 14.4.2 手动切换按钮 再配合一个简单的切换按钮（由 JS 控制类名）： HTML： JS（伪代码，仅作示意）： 这里不展开 JS 细节，只要理解：利用 CSS 变量 + 类名切换，就能构建出灵活的主题系统。 --- 第14章为你展示了如何把颜色、间距、字号等抽象成 CSS 变量，并通过 calc 等函数做简单计算，从而让样式的“维护”和“变更”都更加集中、高效。到这里，第五篇已经完成了从组件化、响应式到维护性的闭环，为后续的 CSS 架构与工程化打下了基础。"
    },
    {
      "title": "第六篇_CSS进阶_深入浏览器与工程化",
      "path": "CSS/第六篇_CSS进阶_深入浏览器与工程化.md",
      "category": "CSS",
      "tags": [],
      "date": null,
      "description": "> 目标：从“能写页面”升级到“理解浏览器、写得稳、跑得快、好维护”。\r\n>\r\n> 看完这一篇，你应该能：\r\n> - 更深入地理解层叠、优先级、层叠上下文与 z-index；\r\n> - 知道哪些 CSS 写法性能更好，哪些可能拖慢渲染；\r\n> - 理解 Sass、PostCSS 等工具处在 CSS 流程的什么位置，以及它们各自解决什么问题。\r\n\r\n---\r\n\r\n\r\n\r\n> 这一章解决的核心问题：\r",
      "content": "第六篇 CSS 进阶：深入浏览器与工程化 目标：从“能写页面”升级到“理解浏览器、写得稳、跑得快、好维护”。 看完这一篇，你应该能： - 更深入地理解层叠、优先级、层叠上下文与 z-index； - 知道哪些 CSS 写法性能更好，哪些可能拖慢渲染； - 理解 Sass、PostCSS 等工具处在 CSS 流程的什么位置，以及它们各自解决什么问题。 --- 第15章 层叠与优先级的真相 这一章解决的核心问题： - 为什么同一个元素的颜色，在不同地方写，会“互相打架”？ - !important、选择器特异性（优先级）、来源顺序之间到底谁说了算？ - 元素层级（谁压在谁上面）和 z-index 的真实规则是什么？ 你会发现，“调样式”时的很多迷之现象，其实都是层叠规则在发挥作用。 15.1 层叠（Cascade）与来源 15.1.1 样式从哪里来？ 浏览器最终给一个元素计算样式时，要综合来自多方的规则： 用户代理样式（User Agent Style） 浏览器内置的默认样式 例如：h1 默认字号比 p 大，a 标签默认蓝色带下划线 每个浏览器都有自己的默认样式表 用户样式（User Style） 用户在浏览器设置中自定义的样式（现在较少使用） 例如：用户设置最小字号、强制使用某种字体 作者样式（Author Style） ⭐ 最重要 开发者编写的样式 来源：外部CSS文件、<style>标签、style属性 这是我们日常工作的主要部分 大多数情况下，我们主要关心“作者样式”的层叠，但要知道： 默认样式不等于“没有样式”，只是你没写而已 15.1.2 当多条规则命中时的决策顺序 对于同一个属性（比如 color），如果有多条规则都命中了同一个元素，浏览器会按大致顺序做决策： 重要性（Importance）：有 !important 的优先 来源（Origin）：一般作者样式 > 用户样式 > 浏览器默认（视情况而定） 特异性（Specificity）：谁的选择器更“具体” 顺序（Order）：写在后面的覆盖前面的 可以用一条「层叠决策线」来理解： 第 2 章已经讲过特异性基础，这里会更结合实际场景和层叠上下文去看。 15.2 层叠上下文与 z-index 解密 在页面中，元素之间谁在上、谁在下，不完全由 DOM 顺序决定，还受到“层叠上下文（stacking context）”的影响。 15.2.1 什么是层叠上下文？ 可以把层叠上下文想象为一个“局部三维空间”：在这个空间里，元素可以通过 z-index 控制前后顺序； 不同层叠上下文之间，有自己的“整体层级”。 一个简单的比喻： 整个页面是一个大白板 某个卡片（有 position + z-index）可能自己形成一个小白板 小白板内部的前后关系，不会影响到其它小白板内部的前后关系 15.2.2 什么会创建层叠上下文？ 常见会创建层叠上下文的情况： 示意： 15.2.3 z-index 的比较只在“同一个层叠上下文”里有效 一个常见坑： 很多人会以为：box-a 的 z-index: 9999 一定压过 box-b， 但实际上：整个 parent-b（z=2）层叠上下文都压在 parent-a（z=1）之上。 可以用图示理解： 结论：不要指望用“极大值 z-index”解决所有层级问题，更重要的是理解层叠上下文结构，并在合适的容器上设置正确的 z-index。 15.3 浏览器渲染顺序（简化版） 理解浏览器如何渲染，有助于你写出更高效、可预期的 CSS。这里给出一个简化流程： ASCII 示意： 我们后面讲性能优化，会尽量避免那些会频繁触发布局和重绘的写法。 --- 第15章从“谁的规则生效”到“谁在谁上面”，把层叠与层级关系梳理了一遍。接下来第16章，我们会更关注“写得快不快、渲染累不累”，深入 CSS 性能优化的一些实际建议。 第16章 CSS 性能优化 这一章解决的核心问题： - 哪些 CSS 写法对性能影响大，应该尽量避免？ - 如何减少不必要的重排（reflow）和重绘（repaint）？ - 在复杂页面中，如何用 DevTools 粗略判断性能问题？ 16.1 避免昂贵选择器 浏览器在应用 CSS 时，需要对每个元素判断“这个选择器是否命中”。大多数现代浏览器已经对这块做了大量优化，但极端复杂的选择器仍然会增加匹配成本。 16.1.1 选择器匹配的基本策略 浏览器通常是从选择器的“最右边那一段”开始匹配的： 这里会先找所有满足 a.active 的元素，然后再回头检查它们是否处在 .sidebar ul li 的结构中。 16.1.2 避免使用万能选择器组合大范围匹配 例如： 如果不是特别必要，避免在高频区域大量使用 * 作为后代选择器，因为它会匹配所有嵌套元素，增加匹配范围。 在现代浏览器中，性能瓶颈更多来自布局和绘制，而不是选择器本身，但养成写“干净选择器”的习惯，可以减少潜在问题，也提升可维护性。 16.2 动画性能：尽量用 transform / opacity 动画与过渡是性能敏感区域，如果处理不当，会出现卡顿、掉帧。 16.2.1 哪些属性对性能更友好？ 一般建议：优先用 transform 和 opacity 做动效。 原因： 它们通常只触发“合成层更新”（Composite），不需要重新布局 在 GPU 加速下，能以较低成本实现平滑动画 16.2.2 把位置动画改成 transform 示意对比： 16.2.3 避免大面积、频繁的阴影变化 box-shadow 在大面积区域频繁变化会比较耗费绘制性能。 建议： 避免对非常大的元素做频繁阴影动画 尽量使用较柔和、半透明的阴影，而不是极大范围的高斯阴影 16.3 精简 CSS 与压缩策略 16.3.1 删除无用样式 在真实项目中，随着迭代，CSS 常常出现“死代码”：某些类已经不再被使用。 可以借助工具： PurgeCSS、unCSS 等，用于分析哪些选择器在 HTML/模板中未被引用 原理大致是： 在前端构建流程中集成这类工具，可以显著减少产物 CSS 体积。 16.3.2 压缩与拆分 构建阶段常见优化： 压缩：移除空格、注释、简化颜色写法（如 #ffffff → #fff） 拆分：按路由或模块拆分 CSS，首屏只加载必要部分 示意： 在 SPA 框架（React/Vue 等）中，这通常由构建工具自动完成，你重点是要“有这个意识”： 尽量让页面只加载它需要的那部分 CSS 16.3.3 避免过度嵌套与重复 样式编写时尽量避免： Sass 里层层嵌套太深，生成类似 .a .b .c .d .e { ... } 的选择器 同一组样式出现多次而不抽取到公共类 这不仅影响性能，更直接影响可维护性。 16.4 使用 DevTools 粗略观察性能 Chrome DevTools 提供了若干对 CSS/渲染性能有帮助的工具： Rendering 面板中的 Paint flashing：高亮重绘区域 Performance 面板：录制一段用户操作，查看帧率和主要耗时 你可以做一个简单的实验： 写一个用 left/top 动画的位置移动效果 打开 Paint flashing 再改成 transform: translate 动画，对比重绘区域 不需要成为性能专家，但要有“性能嗅觉”：当页面卡顿时，优先检查是否有大面积布局变化或复杂动画。 --- 第16章从选择器、动画到 CSS 体积，给出了性能优化的一些实践建议。接下来第17章，我们会把视角拉长，看看 Sass、PostCSS 这些工具是如何协助我们管理复杂 CSS 的。 第17章 预处理与后处理 这一章解决的核心问题： - Sass 这样的预处理器在现代前端中扮演什么角色？ - PostCSS、Autoprefixer 这些“后处理”工具主要做什么？ - 什么时候该用预处理器，什么时候用原生 CSS 变量和现代特性？ 17.1 Sass 基础 Sass 是最流行的 CSS 预处理器之一，常见语法后缀有 .scss 和 .sass，其中 .scss 与 CSS 语法更接近（分号、大括号等都保留）。 预处理器的核心思想：在编译阶段扩展 CSS 的能力，比如： 变量 嵌套 Mixin（可复用片段） 函数、循环等 17.1.1 变量与嵌套示例 SCSS 示例： 编译后生成的 CSS 大致为： 你可以看到： 变量 $primary 在编译时被替换为实际颜色值 &:hover 嵌套被展开为 .btn:hover 17.1.2 Mixin 与函数 Mixin： 函数示例（简化）： 这些都在“编译阶段”被算好，输出普通 CSS。 17.2 嵌套、变量、Mixin 的利与弊 预处理器带来便利的同时，也有一些需要注意的地方。 17.2.1 优点 17.2.2 潜在问题 一个经验法则： 用预处理器“补足”当前项目所需的能力，而不是把它当成“越复杂越好”的玩具。 17.3 PostCSS 与 Autoprefixer PostCSS 更像是一个“CSS 处理平台”，Autoprefixer 是其中最常用的插件之一。 17.3.1 Autoprefixer：自动补全厂商前缀 过去我们常常需要手动写： 17.3.2 其它常见 PostCSS 插件 在现代前端工程里，PostCSS 通常集成在构建链路中（如 webpack、Vite），你配置好插件后，它在打包时自动处理 CSS。 17.4 构建工具与现代前端中的位置 把整个链路简化成一张图： 现代原生 CSS 的能力越来越强： 因此，新的项目可以考虑： 优先使用现代 CSS 原生特性 在确实需要时，引入少量预处理器能力 工具的目标是“让你的 CSS 更易维护、更好适配浏览器”，而不是增加复杂度本身。理解它们的角色之后，你可以针对项目规模、团队情况来选择合适的组合。 --- 第六篇从层叠与优先级、到性能优化，再到预处理与后处理工具，带你从“会写 CSS”更进一步，理解浏览器与工程化的基础。到这里，你已经具备了构建中大型 CSS 代码库的核心知识储备，接下来可以把更多精力放在“真实项目实践”与“团队协作规范”上。"
    },
    {
      "title": "第七篇_综合实战_从风格到产品",
      "path": "CSS/第七篇_综合实战_从风格到产品.md",
      "category": "CSS",
      "tags": [],
      "date": null,
      "description": "> 目标：把前面所有零散的 CSS 能力，真正组合成一套“能落地的设计体系 + 网站”。\r\n>\r\n> 看完这一篇，你应该能：\r\n> - 从无到有，为一个网站搭建色彩、字体、间距、组件的视觉体系；\r\n> - 为整个站点设计合理的 CSS 架构层次；\r\n> - 读懂并实现一份中大型网站的 CSS 实战方案。\r\n\r\n-\r\n> 这一章不会写出一个完整产品的所有代码，但会带你走完整个流程：\r\n> - 拿到一",
      "content": "第七篇 综合实战：从风格到产品 目标：把前面所有零散的 CSS 能力，真正组合成一套“能落地的设计体系 + 网站”。 看完这一篇，你应该能： - 从无到有，为一个网站搭建色彩、字体、间距、组件的视觉体系； - 为整个站点设计合理的 CSS 架构层次； - 读懂并实现一份中大型网站的 CSS 实战方案。 这一章不会写出一个完整产品的所有代码，但会带你走完整个流程： - 拿到一份设计稿（或自己定义的目标）之后，如何分析？ - 如何规划基础样式、布局系统和组件库？ - 如何一步步搭建页面，并在最后阶段统一风格、优化细节？ 第18章 从零设计一个现代网站视觉体系 这一章解决的核心问题： - 如果完全从零开始一个网站，该先定哪些\"视觉基础决定\"？ - 色彩、字体、间距这三大系统应该如何搭配？ - 如何把这些基础映射到 CSS 变量和组件上，让全站风格统一？ 18.1 色彩系统 一个成熟的网站不会随意挑几种颜色，而是有一套完整的色彩系统： 主色（Primary） - 品牌主色调 辅助色/强调色（Accent） - 用于突出重点 成功/警告/错误（Success/Warning/Danger） - 状态反馈 背景/表面（Background/Surface） - 页面层次 文本颜色层级（高对比/次要/弱化） - 信息层级 18.1.1 基本色板规划 先用一个表格脑补色板（这里只示意，不强调具体数值）： 你可以先在设计工具或纸上画出一个简单色卡： 18.1.2 映射为 CSS 变量 在 CSS 中，将这些色彩固化为变量： 然后组件层统一引用这些变量，而不是写死颜色： 💡 这样一来，你要调整全站的蓝色只需改动 --color-primary，所有使用到主色的地方都会随之更新。 18.2 字体系统 字体系统包括： 字体族（font-family） - 字体栈配置 字号层级（typographic scale） - 大小层级 行高与段落间距 - 阅读体验 18.2.1 字体族与默认字号 在第9章我们已经讨论过常用组合，这里直接落地： 18.2.2 标题层级 定义一套标题层级，确保有明显但合理的差异： ASCII 梯度图： 18.3 间距标准化 良好的间距系统能让页面\"呼吸感\"一致，不会一块挤一块松。 18.3.1 间距刻度（Space Scale） 常见做法是使用\"倍增\"或\"4 的倍数\"刻度，例如： 4, 8, 12, 16, 24, 32, 40, 48, 64... 在 CSS 中定义： 示意条： 18.3.2 应用在布局与组件上 示例： 这样每个页面区域与组件使用的间距都是\"刻度内\"的值，整体会更统一。 18.4 组件统一化 在有了色彩、字体、间距这三套\"基础系统\"之后，我们要做的是： 让组件（Button/Card/Badge/Input/etc.）统一使用这些系统 避免组件自己发明新的颜色、字号、间距 18.4.1 示例：统一按钮体系 我们设计一套按钮体系： 💡 第18章从色彩、字体、间距到组件统一化，搭出了\"网站视觉体系 + CSS 变量 + 组件\"的第一层骨架。接下来第19章，我们会从结构角度，设计完整网站的 CSS 架构。 --- 第19章 完整网站的 CSS 架构 这一章解决的核心问题： - 一个稍微大一点的网站，CSS 文件应该怎么分层和组织？ - Layout / Component / Utility 各自负责什么？ - ITCSS / SMACSS / OOCSS 这些名词大概在讲什么？ 19.1 文件结构设计 我们先从一个比较实用的分层结构开始，然后再对比架构流派。 19.1.1 三层视角：Layout / Component / Utility 可以先把 CSS 分为三层： Layout 层：负责页面的大框架布局 如：header、footer、sidebar、grid 容器、栅格系统 Component 层：负责具体组件 如：按钮、卡片、表单控件、导航菜单、Modal Utility 层：一些小而精的工具类 如：.mt-4（上外边距）、.text-center、.hidden 等 用一张结构图表述： 19.1.2 示例文件结构 结合前面的模块化思路，可以得到类似： 💡 不一定要完全照抄这个结构，但要有\"分层\"的概念：不同职责的样式放在不同层中，而不是所有东西都塞进一个文件。 19.2 Layout 层、Component 层、Utility 层 我们再具体看一下三层的职责。 19.2.1 Layout 层 特点： 负责页面大结构 通常数量不多，但会被很多页面依赖 示例：_header.css： 19.2.2 Component 层 特点： 关注可复用组件 每个组件相对独立，可在多个页面使用 示例（卡片组件）已在前面展示，这里展示一个徽章组件： 19.2.3 Utility 层 特点： 一些小而精、几乎不含语义的小类 可以快速在 HTML 上组合使用，提高开发效率 示例： 💡 这些 Utility 类要适量使用：对于通用的小调整很方便，但不要放任页面全部写成\"类名堆砌\"，还是要保留组件层的封装。 --- 第19章从文件结构和分层架构的角度，帮助你为网站的 CSS 建立一个清晰的\"地基 + 骨架 + 皮肤\"模型。接下来第20章，我们会做一次\"从设计稿到上线页面\"的完整实战。 第20章 超大型综合实战 这一章不会写出一个完整产品的所有代码，但会带你走完整个流程： - 拿到一份设计稿（或自己定义的目标）之后，如何分析？ - 如何规划基础样式、布局系统和组件库？ - 如何一步步搭建页面，并在最后阶段统一风格、优化细节？ 20.1 设计稿分析 假设我们要做一个\"现代 SaaS 产品官网\"首页，典型结构： 顶部导航（Logo + 导航 + CTA 按钮） Hero 区域（主标题 + 副标题 + 行动按钮 + 示意图） 功能区（3~4 个卡片） 客户评价 / 成功案例 底部 CTA 区域 页脚 20.1.1 提取关键要素 从设计稿中提取： 色彩：主色、背景、卡片表面、强调色 字体：标题层级、正文、辅助文字样式 间距：各区块之间的上下间距、卡片内边距 组件：Button、Card、Badge、Input、Layout 模块（Hero、Feature、Footer） 可以画一张\"信息架构 + 组件清单\"： 20.2 基础样式搭建 第一步不是直接堆内容，而是搭建： 基础变量（颜色、字号、间距） 全局排版和容器 20.2.1 基础 tokens 在一个 _tokens.css 或类似文件中定义： 20.2.2 全局排版和容器 到这里，你已经有了：统一色彩、间距的基础，以及复用的 .container、.section。 20.3 布局系统实现 接下来，为各个大模块实现布局： Header：水平布局，Logo + 导航 + CTA Hero：两列布局（左文案，右插图） Features：卡片网格 20.3.1 Header 布局 HTML： CSS： 20.3.2 Hero 区布局 HTML： CSS： 20.4 组件库构建 在完成基础布局后，你可以抽离所有常见元素为组件： Buttons：主按钮、次按钮、幽灵按钮 Cards：功能卡片、价格卡片、客户评价卡片 Badges：状态标签 Inputs：表单控件 Layouts：Grid 行、列、容器 关键点： 组件的 CSS 尽量只依赖 tokens（变量），不直接写魔法数 在多个页面复用时，避免为每页再单独起一套类似的类 你可以在 components/ 目录下按文件拆分： 有了这些组件，新增一个页面会更像是“拼积木”，而不是从零开始写一坨样式。 20.5 全站风格统一化与优化 最后一环是“统一与打磨”： 20.5.1 自查 checklist 可以有一个简单的检查列表： 色彩：主色和辅助色是否统一？是否有明显“多出来的”色值？ 字体：标题层级在所有页面是否一致？正文是否统一？ 间距：是否都来自统一的 space 刻度？有没有特别奇怪的数值？ 组件：同类型组件（卡片、按钮）在不同页面是否风格统一？ 20.5.2 简单工具支持 用编辑器/IDE 的“查找引用”功能，查看某颜色或 class 的使用场景 用 Stylelint 之类工具对 CSS 进行规则检查（如禁止使用某些魔法色值） 20.5.3 性能与可维护性复查 运行构建并查看最终 CSS 体积是否合理 检查是否有大量未使用的类（结合 PurgeCSS 等工具） 对关键页面做一次性能录制，确认动效不会卡顿 真正成熟的 CSS 工程，是在一次又一次这样的“搭建 → 抽象 → 统一 → 优化”循环中形成的。每做完一个项目，都可以回顾：哪些地方可以通过更好的变量、更清晰的组件、更合理的架构来改进。 --- 第七篇通过视觉体系、架构分层和一场综合实战，把前面所有章节的知识串成了一条“从风格到产品”的完整路径。到这里，你已经具备从 0 到 1 构建一个中小型网站 CSS 体系的能力。接下来的第八篇将以番外的形式，补充一些工具、技巧和速查内容，方便你在实际工作中快速查阅与解决问题。 第18章 从零设计一个现代网站视觉体系 这一章解决的核心问题： - 如果完全从零开始一个网站，该先定哪些“视觉基础决定”？ - 色彩、字体、间距这三大系统应该如何搭配？ - 如何把这些基础映射到 CSS 变量和组件上，让全站风格统一？ 18.1 色彩系统 一个成熟的网站不会随意挑几种颜色，而是有一套完整的色彩系统： 主色（Primary） 辅助色/强调色（Accent） 成功/警告/错误（Success / Warning / Danger） 背景/表面（Background / Surface） 文本颜色层级（高对比/次要/弱化） 18.1.1 基本色板规划 先用一个表格脑补色板（这里只示意，不强调具体数值）： 你可以先在设计工具或纸上画出一个简单色卡： 18.1.2 映射为 CSS 变量 在 CSS 中，将这些色彩固化为变量： 然后组件层统一引用这些变量，而不是写死颜色： 这样一来，你要调整全站的蓝色只需改动 --color-primary，所有使用到主色的地方都会随之更新。 18.2 字体系统 字体系统包括： 字体族（font-family） 字号层级（typographic scale） 行高与段落间距 18.2.1 字体族与默认字号 在第9章我们已经讨论过常用组合，这里直接落地： 18.2.2 标题层级 定义一套标题层级，确保有明显但合理的差异： ASCII 梯度图： 18.3 间距标准化 良好的间距系统能让页面“呼吸感”一致，不会一块挤一块松。 18.3.1 间距刻度（Space Scale） 常见做法是使用“倍增”或“4 的倍数”刻度，例如： 4, 8, 12, 16, 24, 32, 40, 48, 64... 在 CSS 中定义： 示意条： 18.3.2 应用在布局与组件上 示例： 这样每个页面区域与组件使用的间距都是“刻度内”的值，整体会更统一。 18.4 组件统一化 在有了色彩、字体、间距这三套“基础系统”之后，我们要做的是： 让组件（Button / Card / Badge / Input / etc.）统一使用这些系统； 避免组件自己发明新的颜色、字号、间距。 18.4.1 示例：统一按钮体系 我们设计一套按钮体系： 颜色使用 --color-primary / --color-accent 等 间距使用 --space-* 字号使用 --font-size-* 你会发现： 不再出现“按钮想用啥颜色就写啥颜色”的情况 想调整按钮整体风格，可以从变量层统一调整 18.4.2 示例：统一卡片体系 不同页面上的卡片，都只允许在这套基础上做少量 modifier，而不是各写一套独特的卡片样式。 18.4.3 从“视觉体系”到“编码体系” 可以用一张简单的对应表总结： --- 第18章从色彩、字体、间距到组件统一化，搭出了“网站视觉体系 + CSS 变量 + 组件”的第一层骨架。接下来第19章，我们会从结构角度，设计完整网站的 CSS 架构：文件如何组织、层与层之间如何分工，以及不同 CSS 架构思想之间的差异。 第19章 完整网站的 CSS 架构 这一章解决的核心问题： - 一个稍微大一点的网站，CSS 文件应该怎么分层和组织？ - Layout / Component / Utility 各自负责什么？ - ITCSS / SMACSS / OOCSS 这些名词大概在讲什么？ 19.1 文件结构设计 我们先从一个比较实用的分层结构开始，然后再对比架构流派。 19.1.1 三层视角：Layout / Component / Utility 可以先把 CSS 分为三层： Layout 层：负责页面的大框架布局 如：header、footer、sidebar、grid 容器、栅格系统 Component 层：负责具体组件 如：按钮、卡片、表单控件、导航菜单、Modal Utility 层：一些小而精的工具类 如：.mt-4（上外边距）、.text-center、.hidden 等 用一张结构图表述： 19.1.2 示例文件结构 结合前面的模块化思路，可以得到类似： 不一定要完全照抄这个结构，但要有“分层”的概念：不同职责的样式放在不同层中，而不是所有东西都塞进一个文件。 19.2 Layout 层、Component 层、Utility 层 我们再具体看一下三层的职责。 19.2.1 Layout 层 特点： 负责页面大结构 通常数量不多，但会被很多页面依赖 示例：_header.css： 19.2.2 Component 层 特点： 关注可复用组件 每个组件相对独立，可在多个页面使用 示例：_card.css（已经在前面多次出现，不再赘述） 19.2.3 Utility 层 特点： 一些小而精、几乎不含语义的小类 可以快速在 HTML 上组合使用，提高开发效率 示例： 这些 Utility 类要适量使用： 对于通用的小调整很方便 但不要放任页面全部写成“类名堆砌”，还是要保留组件层的封装 19.3 常见架构模式比较（ITCSS、SMACSS、OOCSS） 这里不做特别深入的框架研究，只建立一个大致印象，方便你读其他资料时有概念。 19.3.1 OOCSS（面向对象 CSS） 核心思想： 把视觉元素拆分为“结构（Structure）”和“皮肤（Skin）” 鼓励复用“对象”，比如 .media 对象（图 + 文） 简单例子： 然后在不同地方复用 .media 结构 + 不同皮肤。 19.3.2 SMACSS（Scalable and Modular Architecture for CSS） 大致把规则分为： Base（基础） Layout（布局） Module（模块） State（状态） Theme（主题） 你会发现这和我们现在的分层思路是互通的，只是命名略有不同。 19.3.3 ITCSS（Inverted Triangle CSS） ITCSS 把整个 CSS 看成一个倒三角： 层级越往下，具体性越强，影响范围越小。 我们在本书中采用的是一个较为折中的、实践向的架构方式，你可以在未来接触更多资料时，把这些理论和自己的实践互相对照。"
    },
    {
      "title": "第八篇_番外篇_工具_技巧_速查",
      "path": "CSS/第八篇_番外篇_工具_技巧_速查.md",
      "category": "CSS",
      "tags": [],
      "date": null,
      "description": "> 目标：把零散但非常有用的 CSS 小知识、小工具、小套路整理成“随手翻”的番外篇。\r\n>\r\n> 看完这一篇，你应该能：\r\n> - 掌握一批常用但容易被忽略的 CSS 小技巧；\r\n> - 理解一些常见“迷惑行为”背后的原因；\r\n> - 拿到一份可复用的实用代码片段清单；\r\n> - 拿到一份按主题整理的 CSS 属性速查表。\r\n\r\n---\r\n\r\n\r\n\r\n> 这一章不系统讲理论，而是给你一串容易上手",
      "content": "第八篇 番外篇：工具、技巧、速查 目标：把零散但非常有用的 CSS 小知识、小工具、小套路整理成“随手翻”的番外篇。 看完这一篇，你应该能： - 掌握一批常用但容易被忽略的 CSS 小技巧； - 理解一些常见“迷惑行为”背后的原因； - 拿到一份可复用的实用代码片段清单； - 拿到一份按主题整理的 CSS 属性速查表。 --- 第21章 CSS 啊哈时刻：那些“原来还可以这样写”的技巧 这一章不系统讲理论，而是给你一串容易上手、能立刻改善体验的“小 ah-ha 技巧”。 21.1 使用 :is() 简化复杂选择器 当你有多个选择器需要共享一套样式时，过去会这样写： 现在可以用 :is() 把它们合在一起： 更简洁 以后需要新增 h5 时，只需要在 :is() 内补一个选择器 :is() 的特异性由参数中最高的决定 21.2 使用 :where() “零特异性”挂载样式 :where() 和 :is() 类似，但它本身特异性为 0，适合用于“不会抢优先级”的全局样式。 示例： 可以简单理解：:where() 适合写\"轻轻挂在底层的默认样式\"，不会制造特异性地雷。 21.3 用 min(), max(), clamp() 控制“聪明的尺寸” 前面我们已经用 clamp() 做过自适应字体，这里再总结一下： min(a, b)：取较小值 max(a, b)：取较大值 clamp(min, preferred, max)：值在 min~max 之间变化 例子：限制一个卡片宽度： 很窄屏时不会低于 260px 中间区间按视口宽度 50vw 调整 宽屏时不会超过 420px 21.4 使用 aspect-ratio 做固定比例盒子 以前想要固定宽高比（比如 16:9 视频盒子），通常要用 padding hack： 现在可以用更直观的 aspect-ratio： 21.5 用 scroll-margin-* 优化锚点滚动体验 很多页面有\"目录 → 滚动到某一节\"的交互： 如果页面顶部有固定导航栏（fixed header），滚动后标题经常会被遮住。可以在标题上加一个 scroll-margin-top： 这样浏览器在滚动到锚点时，会自动留出指定距离，改善阅读体验。 21.6 用 overscroll-behavior 避免\"橡皮筋串页面\" 在嵌套滚动容器中（比如一个内部可滚动的对话框），滚到顶部/底部时，外层页面容易继续滚动，造成体验不佳。 可以使用： 当用户在 modal-body 内滚动到顶/底时，不会把滚动传递给外层页面 21.7 用 pointer-events 控制点击穿透 有时需要一个\"只展示不挡点击\"的装饰层，比如一个大范围的渐变覆盖或高亮遮罩。 pointer-events: none; 让鼠标事件\"穿透\"这个层，下面的按钮仍然可点击 21.8 用 mix-blend-mode 做文字高亮效果 在深色背景中想做某种\"发光\"式文字，可以试试： 配合背后的渐变背景，可以产生有趣的融合效果（注意可读性和对比度）。 21.9 用子网格（subgrid）（前瞻概念）统一对齐 部分现代浏览器开始支持 subgrid： 子元素可以继承父网格的轨道，实现复杂但统一的对齐布局 目前兼容性还在逐步推进中，做项目时需要根据目标浏览器评估 这一节只是提前种一个“前瞻”概念：未来 CSS 布局会更强大、更系统。 --- 第21章收集了一些“知晓之后会经常用到”的小技巧。接下来第22章，我们会换个角度，专门解释那些在你写 CSS 时经常会问“这玩意儿怎么这么怪”的迷惑行为，让你少踩坑、多理解。 第22章 CSS 常见迷惑行为解释 这一章是“FAQ”风格，集中回答一些 CSS 小白和进阶开发者都会遇到的 WTF： - 为什么 margin 会莫名其妙“折叠”？ - 为什么行内元素明明设置了宽高却没生效？ - 为什么 flex 子项有时会“挤爆”容器？ 22.1 外边距折叠：为什么两个盒子之间不是 20px？ 场景： 很多人以为两个盒子之间的距离是 40px，实际上往往只有 20px。 原因： 垂直方向上相邻块级盒子的 margin 有“折叠规则” 简化理解：上下 margin 取最大值，而不是相加 简单图示： 常用解决方法： 改用 padding 控制父容器的内边距 给其中一个盒子包一层，不让 margin 直接相邻 22.2 行内元素的宽高：为什么不听话？ 场景： 发现：span 看起来没按宽高变大。 原因： span 默认是 display: inline; 行内元素不会响应 width/height，尺寸由内容和字体决定 解决： 改为 inline-block 或 block 22.3 flex 子项为什么会“挤爆”或“缩得很奇怪”？ 场景： 有时子项内容太多，会挤到容器外面；有时又被压扁得看不懂。 关键点： flex: 1 相当于 flex: 1 1 0（grow = 1, shrink = 1, basis = 0） flex-basis: 0 表示“按可用空间重新分配”，忽略内容宽度 如果你更希望“尊重内容宽度，再适度缩放”，可以用： 或者为内容非常多的列设置 min-width，避免被压缩得不可用。 22.4 行高与垂直居中的谜团 场景： 有时文字看起来偏上或偏下。 原因： 字体本身有上/下“预留空间”（ascent/descent） 不同字体、字号下，line-height = height 并不意味视觉完美居中 实战建议： 对于 tag/badge 一类小组件，用 line-height 做垂直居中是简单方案，但要配合具体字体微调 更稳定的方式：使用 flex 居中 22.5 为什么 position: sticky 有时“不吸顶”？ position: sticky 可以让元素在滚动到一定位置后“粘住”，但经常有人发现它不生效。 常见原因： 没有设置 top/bottom 等偏移值 祖先元素设置了 overflow: hidden/auto/scroll，截断了 sticky 的滚动参考 简单示例： Sticky 是“相对最近的可滚动祖先”起作用的，如果你的布局里有中间一层容器设置了 overflow，sticky 就只在那个容器内部生效。 22.6 为什么 transform 会影响 position: fixed？ 当某个祖先元素设置了 transform（比如 transform: translateY(0);），在它内部的 position: fixed 元素，会变成“相对该祖先固定”，而不是相对视口。 原因： transform 等属性会创建新的包含块（containing block） 如果你想让 fixed 元素始终相对视口固定，尽量避免在它的祖先上随意设置 transform。 --- 第22章用几组常见问题解释了 CSS 的一些“怪脾气”。接下来第23章，我们会直接给出一批常用的实用代码片段，方便你在项目中复制粘贴后再按需调整。 第23章 常用实用代码片段库（按钮、卡片、布局模板） 这一章是“复制即可用”型，所有片段都尽量保持简洁，适合作为你自己项目的起点。 23.1 按钮样式集合 23.1.1 主按钮 + 次按钮 + 幽灵按钮 HTML： 23.2 常见卡片布局 23.2.1 信息卡片（标题 + 标签 + 描述） HTML： 23.3 常用布局模板 23.3.1 两列布局（左文右图，移动端自动堆叠） HTML： 23.3.2 自适应卡片网格 宽屏时自动摆成多列 窄屏时自动折到一列，无需额外媒体查询 auto-fit会拉伸项目填满空间，auto-fill则保持项目宽度 23.4 常见导航和页脚片段 23.4.1 简单顶部导航 HTML： 23.5 常用表单样式片段 HTML： --- 第23章给出了一些可以直接复用的基础片段，你可以在每个项目一开始就拷贝过来，再按品牌风格微调。最后的第24章，我们会做一份主题化的属性速查表，方便你“忘记某个属性名字时”快速翻查。 第24章 CSS 全属性速查表（出版附录级） 本章不会按字母顺序列出所有属性，而是按主题分类，帮助你快速回忆“我要改 X，该查哪几个属性”。 24.1 布局相关 布局模型 display（block / inline / inline-block / flex / grid / inline-flex / inline-grid） position（static / relative / absolute / fixed / sticky） float、clear 盒子尺寸与定位 width、min-width、max-width height、min-height、max-height top、right、bottom、left box-sizing 外边距与内边距 margin、margin-top/right/bottom/left padding、padding-top/right/bottom/left Flex 布局 容器：flex-direction、flex-wrap、justify-content、align-items、align-content、gap 子项：flex、flex-grow、flex-shrink、flex-basis、align-self Grid 布局 容器：grid-template-columns、grid-template-rows、grid-template-areas、grid-auto-flow、gap 轨道函数：repeat()、minmax()、auto-fit、auto-fill 子项：grid-column、grid-row、grid-area 24.2 视觉表现相关 背景 background-color background-image background-repeat background-position background-size background-attachment 边框与圆角 border、border-width、border-style、border-color border-radius（含单独四角） 阴影与轮廓 box-shadow text-shadow outline、outline-offset 颜色与透明度 颜色表示法：rgb()、rgba()、hsl()、hsla()、十六进制 opacity 24.3 文本与字体相关 字体 font-family font-size font-weight font-style font-variant（小型大写等） line-height 文本修饰与对齐 text-align text-decoration text-transform text-indent letter-spacing word-spacing 换行与溢出 white-space word-break overflow-wrap text-overflow（配合 overflow: hidden; 和 white-space: nowrap; 实现省略号） 24.4 动效与变换相关 过渡 transition-property transition-duration transition-timing-function transition-delay 变换 transform（translate、scale、rotate、skew） transform-origin 动画 @keyframes animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-fill-mode 24.5 高级与杂项 变量与计算 var()、自定义属性（--token-name） calc()、min()、max()、clamp() 媒体与特性查询 @media（宽高、像素密度、方向） @supports（特性检测） 过滤与混合 filter backdrop-filter mix-blend-mode 滚动与行为 overflow overflow-x、overflow-y scroll-behavior scroll-margin-* overscroll-behavior 交互相关 cursor / 鼠标光标样式 / pointer-events / 鼠标事件控制 / user-select / 文本选择控制 / 24.6 常用属性值速查 24.7 单位速查 --- 💡 速查提示： - 需要控制布局？查看 24.1 - 需要美化外观？查看 24.2 和 24.3 - 需要添加动效？查看 24.4 - 忘记属性值？查看 24.6 - 不确定单位？查看 24.7"
    },
    {
      "title": "目录",
      "path": "CSS/目录.md",
      "category": "CSS",
      "tags": [],
      "date": null,
      "description": "- 1.1 CSS 的工作方式（层叠样式表原理）\r\n- 1.2 HTML 与 CSS 的合作关系（结构与样式分离）\r\n- 1.3 CSS 的三种引入方式（内联、内部、外部样式表）\r\n- 1.4 浏览器如何解析你的样式（CSSOM与渲染树）\r\n\r\n\r\n- 2.1 基础选择器（标签、类、ID选择器详解）\r\n- 2.2 组合选择器（后代、子代、通配符选择器）\r\n- 2.3 关系选择器（相邻兄弟、通用兄弟",
      "content": "✅ CSS 全卷正式目录（2024优化版） CSS：为页面注入风格与秩序 第一篇 认识 CSS：风格的起点 第1章 什么是 CSS：让页面长出灵魂的语言 1.1 CSS 的工作方式（层叠样式表原理） 1.2 HTML 与 CSS 的合作关系（结构与样式分离） 1.3 CSS 的三种引入方式（内联、内部、外部样式表） 1.4 浏览器如何解析你的样式（CSSOM与渲染树） 第2章 CSS 选择器基础：精准定位目标元素 2.1 基础选择器（标签、类、ID选择器详解） 2.2 组合选择器（后代、子代、通配符选择器） 2.3 关系选择器（相邻兄弟、通用兄弟选择器） 2.4 选择器优先级与层叠规则（特异性计算） 第3章 CSS 常用属性初体验 3.1 文字样式（字体、字号、行高、对齐） 3.2 颜色与背景（RGB、HSL、背景图片定位） 3.3 边框与圆角（border属性全解） 3.4 阴影效果（盒子阴影与文字阴影应用） 第二篇 CSS 核心：盒子、布局、视觉 第4章 盒模型：前端世界的物理规则 4.1 盒模型四要素（content、padding、border、margin详解） 4.2 box-sizing的两种模式（content-box vs border-box） 4.3 外边距折叠现象与解决方案 4.4 盒子调试技巧（开发者工具使用） 第5章 视觉表现：颜色、单位、图像 5.1 颜色系统（RGB、HSL、透明度、渐变效果） 5.2 CSS单位体系（px、%、em、rem、vw、vh、calc()） 5.3 背景图像控制（size、position、repeat、attachment） 5.4 现代图像处理（filter滤镜、mix-blend-mode混合） 第6章 布局基础：让页面从混乱到清晰 6.1 display属性详解（block、inline、inline-block、none） 6.2 文档流与脱离文档流 6.3 浮动布局与清除浮动（BFC原理） 6.4 定位系统（static、relative、absolute、fixed、sticky） 第三篇 现代布局：从弹性到网格 第7章 Flexbox：一维弹性布局完全指南 7.1 Flex容器与项目（display:flex的魔力） 7.2 主轴与交叉轴（flex-direction、justify-content、align-items） 7.3 伸缩规则（flex-grow、flex-shrink、flex-basis） 7.4 实战案例（响应式导航栏、卡片布局、垂直居中） 第8章 Grid：二维网格布局终极方案 8.1 Grid基础概念（网格容器、网格项、网格线、网格轨道） 8.2 强大的函数（repeat()、minmax()、auto-fit、auto-fill） 8.3 网格区域命名（grid-template-areas实战） 8.4 综合实战（响应式画廊、仪表盘布局、圣杯布局） 第四篇 强化视觉：字体、动画、变换 第9章 字体：让文字拥有自己的个性 9.1 字体基础（font-family、font-size、font-weight详解） 9.2 Web字体加载（@font-face、字体格式、加载策略） 9.3 排版细节（line-height、letter-spacing、text-decoration） 9.4 中文字体优化（系统字体栈、字体子集化、性能优化） 第10章 过渡与动画：让页面动起来 10.1 transition过渡（四要素：property、duration、timing-function、delay） 10.2 transform变换（translate位移、scale缩放、rotate旋转、skew倾斜） 10.3 animation动画（@keyframes、动画属性、动画序列） 10.4 实战案例（悬浮效果、加载动画、呼吸灯、翻转卡片） 第11章 滤镜与特效 11.1 filter滤镜全家族（blur模糊、brightness亮度、contrast对比度等） 11.2 混合模式（mix-blend-mode的16种模式详解） 11.3 backdrop-filter背景滤镜（毛玻璃效果实现） 11.4 综合实战（玻璃拟态卡片、霓虹文字、图片特效） 第五篇 构建真实页面：组件、响应式、维护性 第12章 CSS 组件化思想 12.1 命名规范（BEM方法论：Block__Element--Modifier） 12.2 模块化CSS（OOCSS、SMACSS、Atomic CSS对比） 12.3 组件实战（Button按钮系统、Card卡片、Badge徽章、Modal弹窗） 12.4 设计系统搭建（Design Tokens、组件库架构） 第13章 响应式与适配 13.1 媒体查询深入（@media规则、断点设计、移动优先vs桌面优先） 13.2 流式布局策略（百分比、viewport单位、弹性图片） 13.3 字体响应式（rem方案、vw方案、clamp()函数） 13.4 现代适配方案（Container Queries、响应式图片、适配最佳实践） 第14章 CSS 变量与计算 14.1 CSS自定义属性（--variable定义、var()使用、作用域） 14.2 主题系统实现（颜色主题、尺寸主题、动态切换） 14.3 calc()计算函数（混合单位计算、动态布局、响应式间距） 14.4 暗色模式实战（prefers-color-scheme、主题切换器、最佳实践） 第六篇 CSS 进阶：深入浏览器与工程化 第15章 层叠与优先级的真相 15.1 层叠上下文详解（创建条件、层叠顺序、实际应用） 15.2 z-index深入理解（层叠等级、父子关系、常见问题） 15.3 特异性计算（权重规则、!important、内联样式） 15.4 CSS继承机制（可继承属性、inherit、initial、unset） 第16章 CSS 性能优化 16.1 选择器性能（避免过度嵌套、减少通配符、优化伪类） 16.2 渲染性能（重排reflow、重绘repaint、合成层） 16.3 动画优化（will-change、transform、GPU加速） 16.4 文件优化（CSS压缩、Critical CSS、代码分割） 第17章 预处理与后处理 17.1 Sass/SCSS实战（变量、嵌套、混入、继承、函数） 17.2 Less与Stylus对比（语法差异、功能特点） 17.3 PostCSS生态（Autoprefixer、cssnano、preset-env） 17.4 CSS-in-JS方案（styled-components、emotion、CSS Modules） 第七篇 综合实战：从风格到产品 第18章 从零设计一个现代网站视觉体系 18.1 色彩系统设计（主色、辅助色、状态色、深浅主题） 18.2 字体系统规划（字体栈、字号层级、行高规范） 18.3 间距标准化（4px基准、间距刻度、应用规则） 18.4 组件统一化（按钮体系、卡片规范、表单样式） 第19章 完整网站的 CSS 架构 19.1 文件结构设计（目录规划、命名约定、引入策略） 19.2 分层架构实践（Base、Layout、Component、Utility、Page） 19.3 CSS方法论对比（ITCSS倒三角、SMACSS、OOCSS、BEM） 19.4 架构演进策略（重构方案、迁移路径、维护规范） 第20章 超大型综合实战 20.1 项目分析（需求梳理、设计稿解读、技术选型） 20.2 基础搭建（设计令牌、全局样式、栅格系统） 20.3 布局实现（Header导航、Hero主视觉、Features卡片） 20.4 组件开发（按钮组、表单系统、模态框、轮播图） 20.5 优化上线（性能优化、兼容处理、部署方案） 第八篇 番外篇：工具、技巧、速查 第21章 CSS 啊哈时刻：那些\"原来还可以这样写\"的技巧 21.1 现代选择器（:is()、:where()、:has()、:not()） 21.2 CSS函数应用（clamp()、min()、max()、calc()） 21.3 实用属性（aspect-ratio、scroll-margin、overscroll-behavior） 21.4 高级技巧（pointer-events、mix-blend-mode、subgrid） 第22章 CSS 常见迷惑行为解释 22.1 布局陷阱（margin折叠、行内元素宽高、flex压缩） 22.2 定位困惑（sticky失效、fixed被transform影响） 22.3 层叠问题（z-index不生效、层叠上下文） 22.4 性能误区（选择器性能、动画卡顿、重排触发） 第23章 常用实用代码片段库 23.1 按钮样式集（主按钮、次按钮、幽灵按钮、加载按钮） 23.2 卡片布局集（信息卡片、图片卡片、价格卡片） 23.3 布局模板（两列布局、自适应网格、瀑布流） 23.4 表单控件（输入框、选择框、开关、进度条） 23.5 导航组件（顶部导航、侧边栏、面包屑、分页） 第24章 CSS 全属性速查表 24.1 布局属性（display、position、flex、grid） 24.2 视觉属性（background、border、shadow、filter） 24.3 文本属性（font、text、line-height、white-space） 24.4 动效属性（transition、transform、animation） 24.5 交互属性（cursor、pointer-events、user-select） 24.6 常用属性值速查（单位、颜色、关键词） 24.7 CSS单位总结（绝对单位、相对单位、视口单位） --- 学习路径建议 入门阶段（第1-3章）：理解CSS基本概念 基础阶段（第4-6章）：掌握盒模型与基础布局 进阶阶段（第7-8章）：精通Flexbox和Grid 美化阶段（第9-11章）：学习视觉效果 实战阶段（第12-14章）：构建真实项目 深入阶段（第15-17章）：理解原理与工程化 综合阶段（第18-20章）：完整项目实践 查阅阶段（第21-24章）：作为工具书随时查阅 特色说明 详细中文注释：每个CSS属性都配有详尽的中文解释 渐进式学习：从简单到复杂，循序渐进 实战导向：大量实际案例和代码示例 现代CSS：涵盖最新CSS特性和最佳实践 工具书价值：第八篇可作为日常开发速查手册 --- 附录 附录 A：CSS 面试与进阶路线图 A.1 CSS 技能等级划分 初级 CSS 开发者 必备技能： 掌握基础选择器和层叠规则 熟悉盒模型和常用布局方法 能够实现简单的页面样式 了解响应式设计基础 常见面试题： 解释盒模型的组成部分 CSS选择器优先级计算 水平垂直居中的实现方法 display属性值的区别 中级 CSS 开发者 必备技能： 精通 Flexbox 和 Grid 布局 掌握 CSS 动画和过渡 理解 BFC 和层叠上下文 能够构建组件化 CSS 架构 常见面试题： BFC 的触发条件和应用 Flexbox 和 Grid 的适用场景 CSS 动画性能优化方法 响应式设计最佳实践 高级 CSS 开发者 必备技能： 深入理解 CSS 渲染原理 掌握 CSS 工程化方案 具备大型项目 CSS 架构能力 了解最新 CSS 特性 常见面试题： CSS 渲染流程和性能优化 CSS-in-JS vs CSS Modules 对比 设计系统的构建思路 CSS Houdini 和未来发展 A.2 学习进阶路径 第一阶段：CSS 基础（1-3个月） 学习目标： 能够编写基础的页面样式 理解 CSS 的工作原理 掌握常用属性的使用 第二阶段：布局精通（3-6个月） 学习目标： 熟练使用现代布局方案 实现复杂的响应式布局 添加流畅的交互动画 第三阶段：工程实践（6-12个月） 学习目标： 掌握 CSS 工程化方案 建立可维护的 CSS 架构 优化 CSS 性能和开发效率 第四阶段：专家水平（1年以上） 学习目标： 深入理解 CSS 底层原理 跟进最新技术发展 具备技术选型和架构能力 A.3 实战项目推荐 入门项目 个人主页：练习基础布局和样式 产品卡片：练习盒模型和视觉设计 简单导航：练习伪类和交互效果 进阶项目 响应式作品集：练习媒体查询和适配 仿制知名网站：练习复杂布局实现 动画Loading页：练习CSS动画技巧 高级项目 组件库开发：练习组件化和架构设计 设计系统搭建：练习系统性思维 性能优化实战：练习工程化能力 附录 B：CSS 工具链生态 B.1 开发工具 代码编辑器插件 VS Code：CSS Peek, IntelliSense for CSS Emmet：快速编写CSS的神器 Prettier：代码格式化工具 stylelint：CSS代码质量检查 浏览器开发工具 Chrome DevTools：最强大的CSS调试工具 Firefox Developer Tools：优秀的Grid和Flexbox调试 Safari Web Inspector：macOS专属开发工具 B.2 预处理器 Sass/SCSS Less B.3 后处理器 PostCSS 生态 常用插件： autoprefixer：自动添加浏览器前缀 cssnano：CSS压缩优化 postcss-preset-env：使用未来CSS特性 postcss-import：处理@import purgecss：移除未使用的CSS B.4 CSS-in-JS 方案 styled-components (React) Emotion B.5 构建工具集成 Webpack CSS 处理 Vite CSS 支持 附录 C：CSS 常用代码片段库 C.1 布局片段 水平垂直居中 两列布局 响应式网格 C.2 组件片段 现代按钮 卡片组件 输入框组件 C.3 动画片段 加载动画 悬浮效果 C.4 实用工具类 间距工具 文本工具 显示工具 --- 学习资源推荐： 官方文档： MDN CSS 文档 W3C CSS 规范 Can I Use - CSS 兼容性查询 在线学习： CSS-Tricks - CSS 技巧和教程 Flexbox Froggy - Flexbox 游戏教程 Grid Garden - Grid 游戏教程 设计系统参考： Tailwind CSS - 实用优先的 CSS 框架 Material Design - Google 设计系统 Ant Design - 企业级 UI 设计系统 这套CSS教程现在提供了完整的学习路径，从基础入门到专家进阶，包含了丰富的实战代码和工具资源，是前端开发者学习CSS的完整指南！🎨"
    },
    {
      "title": "第一篇：初识HTML——走进网页的世界",
      "path": "HTML/第一篇：初识HTML——走进网页的世界.md",
      "category": "HTML",
      "tags": [],
      "date": null,
      "description": "这一章将从宏观上介绍网页和网站的基本概念，并通过HTML、CSS和JavaScript的基础知识，引导你了解网页的构建过程。\n\n\n\n网站是由多个网页组成的集合。可以把网站想象成一本书，每一页都是一个网页。每个网页都有它自己独立的内容和功能，但它们通过超链接（Hyperlink）相互连接，形成一个网络。\n\nHTML（超文本标记语言，HyperText Markup Language），是网页的基础语",
      "content": "第一篇：初识HTML——走进网页的世界 第1章 网页是什么：揭开网站的神秘面纱 这一章将从宏观上介绍网页和网站的基本概念，并通过HTML、CSS和JavaScript的基础知识，引导你了解网页的构建过程。 1.1 网站、网页与HTML的关系 网站是由多个网页组成的集合。可以把网站想象成一本书，每一页都是一个网页。每个网页都有它自己独立的内容和功能，但它们通过超链接（Hyperlink）相互连接，形成一个网络。 HTML（超文本标记语言，HyperText Markup Language），是网页的基础语言，负责定义网页的结构和内容。你可以将HTML比作网页的\"骨架\"，它让浏览器知道如何组织和显示页面上的各种内容。 HTML的全称包含了两个重要概念： 超文本（HyperText）：指页面中可以包含指向其他页面的链接，点击链接可以跳转到其他页面，这就是网页之间能够相互连接的基础 标记语言（Markup Language）：使用各种标签（Tag）来标记文本的不同部分，告诉浏览器如何处理和显示这些内容 HTML：网页内容的组织者，定义了网页上所有元素（例如文本、图像、表格、链接等）的结构。HTML使用标签来描述内容的语义和层次关系，比如<h1>表示一级标题，<p>表示段落，<img>表示图像等。 CSS（层叠样式表，Cascading Style Sheets）：网页外观的设计师，控制网页的样式和布局，例如字体、颜色、间距、对齐等。CSS将样式与内容分离，让网页设计更加灵活和可维护。\"层叠\"意味着多个样式规则可以按优先级叠加应用。 JavaScript：网页的行为专家，赋予网页交互能力和动态效果，例如表单验证、动态加载内容、用户交互等。JavaScript是一种编程语言，可以在浏览器中执行，实现复杂的逻辑处理和用户交互。 这三者共同构成了现代网页的开发基础，被称为\"前端三剑客\"： HTML 提供网页的基本框架 CSS 让网页变得美观，控制网页的布局和样式 JavaScript 让网页变得互动和动态，提供用户与网页的交互 1.2 浏览器：我们看网页的窗口 浏览器是我们用来访问网站的工具，它能够读取HTML文件，解析并渲染出网页内容。浏览器本质上是一个复杂的应用程序，它的工作远不止\"显示网页\"这么简单。 浏览器最重要的是内核，就是藏在壳子里的\"发动机\"。浏览器内核（也称为渲染引擎）负责将HTML、CSS和JavaScript转换成我们看到的精美网页。不同的内核在性能、兼容性和功能特性上都有差异。 浏览器的主要组成部分： 用户界面：包括地址栏、前进后退按钮、书签菜单等 浏览器引擎：负责在用户界面和渲染引擎之间传递指令 渲染引擎：核心组件，负责显示请求的内容 网络：处理网络请求，如HTTP请求等 UI后端：用于绘制基本窗口部件，如下拉列表、复选框等 JavaScript解释器：解析和执行JavaScript代码 数据存储：浏览器需要保存的各种数据，如cookies、localStorage等 功能说明： 解析网页：解析 HTML 构建 DOM 树，解析 CSS 构建样式规则。 渲染页面：将 DOM 和 CSS 合并为渲染树，计算布局并绘制像素。 执行 JavaScript：内置 JS 引擎（如 V8、SpiderMonkey）执行脚本逻辑。 网络资源加载：管理 HTTP 请求、缓存、压缩、CDN 等资源加载策略。 安全策略：实施同源策略、沙箱隔离、HTTPS 校验、防 XSS/CSRF。 跨平台兼容：适配 Windows/macOS/Linux/iOS/Android 等系统。 五大浏览器内核： Blink：谷歌嫡系，Chrome、Edge、Opera 都靠它，市面七成份额，更新最勤快。 特点：性能优秀，HTML5和CSS3支持最完善，开发者工具功能强大 市场份额：约70%，是目前最主流的渲染引擎 代表浏览器：Google Chrome、Microsoft Edge、Opera、Vivaldi等 WebKit：苹果自留地，Safari 和 iOS 上任何浏览器都得用它，苹果不开口，谁也别想换。 特点：内存占用少，电池续航优秀，在移动设备上表现突出 应用场景：所有iOS设备上的浏览器都必须使用WebKit内核 代表浏览器：Safari、iOS版Chrome、UC浏览器等 Gecko：Firefox 的独苗，开源、重隐私，桌面还剩一小片天。 特点：完全开源，注重用户隐私保护，标准兼容性好 市场份额：约3-5%，但在开发者社区中仍有重要地位 代表浏览器：Mozilla Firefox、Waterfox等 Trident：老 IE 的化石，只在机关网银的角落里喘口气。 特点：老版本IE的内核，标准支持较差，已基本被淘汰 现状：仅在一些企业内网和政府网站中还能看到 代表浏览器：Internet Explorer（IE6-IE11） EdgeHTML：微软短命实验，早被 Blink 取代。 历史：微软为替代Trident开发的内核，性能有所提升 结局：2018年微软宣布转向Chromium项目，EdgeHTML停止开发 代表浏览器：Microsoft Edge（旧版本） 国产浏览器喜欢\"双核\"：平时 Blink 用于现代网站，遇到老网站一键切 Trident，兼容养老系统。 一句话：内核选得对，网页才跟手；内核不更新，再好的外壳也拖不动。 浏览器工作流程： 用户输入与URL解析：用户在地址栏输入URL，浏览器会解析URL的各个组成部分（协议、域名、端口、路径等），并检查本地缓存（如HSTS缓存）以决定是否使用HTTPS。同时会进行URL编码，确保特殊字符能正确传输。 网络请求：浏览器通过DNS查询将域名解析为IP地址，随后与服务器建立TCP连接（对于HTTPS还会进行TLS握手），并发送HTTP请求。这个过程包括： DNS查询：域名→IP地址 TCP三次握手：建立可靠连接 TLS握手：加密通信（HTTPS） 发送HTTP请求：包含请求头、请求方法等 关键渲染路径：浏览器接收到HTML响应后，开始解析。这是浏览器将代码转换为可视页面的核心过程。 构建DOM树：将HTML标签转换为文档对象模型（DOM）树。DOM树是页面的结构化表示，每个HTML标签都会成为DOM树中的一个节点。 构建CSSOM树：解析CSS样式，构建CSS对象模型（CSSOM）树。CSSOM包含了所有样式规则和选择器信息。 执行JavaScript：在解析过程中，遇到JavaScript会暂停HTML解析，下载并执行脚本。JavaScript可能会修改DOM和CSSOM，影响后续渲染。 构建渲染树与布局：合并DOM和CSSOM，形成渲染树，然后计算每个节点的精确位置和大小（布局/重排）。这个过程也称为\"回流\"。 绘制与合成：将布局结果转换为屏幕上的像素（绘制），并通过合成层最终显示到屏幕上。现代浏览器使用GPU加速来优化这个过程。 后续交互：页面加载完成后，浏览器会持续监听事件（点击、滚动、键盘输入等），执行相关的JavaScript代码以处理用户交互，实现动态效果。 性能优化提示：理解浏览器工作流程有助于我们进行性能优化。比如减少DOM操作、优化CSS选择器、合理使用JavaScript等都能提升页面加载速度。 现代浏览器通常还提供开发者工具，你可以通过右键点击网页元素并选择“检查”或“审查元素”，打开浏览器的开发者工具，查看网页的HTML、CSS和JavaScript代码。这对调试和学习网页非常有帮助。 1.3 一个网页是如何诞生的？（简单介绍前端三剑客：HTML, CSS, JavaScript） 我们通常看到的网页是浏览器展示的内容，但它背后是HTML、CSS和JavaScript三者共同作用的结果。了解它们的关系非常重要： HTML：为网页提供结构，是网页的骨架，例如文本、图像、表格等。HTML定义了每个元素的位置和内容。它描述了一个网页的静态内容。 语义化：HTML标签具有语义含义，比如<header>表示页头，<nav>表示导航，<article>表示文章内容 层次结构：通过标签的嵌套关系建立文档的层次结构 可访问性：良好的HTML结构有助于屏幕阅读器等辅助设备的理解 CSS：对HTML内容进行样式化，是网页的样式，控制字体、颜色、布局等，使网页不仅能显示信息，还能变得美观。 视觉设计：控制颜色、字体、间距、边框等视觉效果 布局控制：通过Flexbox、Grid等现代布局技术实现复杂的页面布局 响应式设计：让网页在不同设备上都能良好显示 JavaScript：提供网页的动态交互功能，是网页的行为。例如，表单验证、滚动动画、动态内容加载等。 用户交互：响应用户的点击、输入、滚动等操作 数据处理：处理表单数据、与服务器通信、操作DOM等 动态效果：实现动画、过渡效果、实时更新等 举个例子，你打开一个在线商店网站： HTML 负责构建商品列表、商品名称、价格等结构。 CSS 将商品列表呈现为整齐的网格，设置每个商品的标题字体、背景颜色和排版。 JavaScript 实现了交互功能，例如点击\"加入购物车\"按钮，商品加入到购物车的动画效果，或者根据用户的选择动态加载更多商品。 三者的协作关系： HTML先建立基础结构，就像盖房子先打好地基和框架 CSS进行装修美化，让房子变得美观舒适 JavaScript添加智能功能，让房子能够自动调节温度、灯光等 学习建议：作为初学者，建议先掌握HTML的基础结构，再学习CSS进行样式设计，最后学习JavaScript实现交互功能。这样的学习路径更符合认知规律，也更容易建立信心。 前端开发的核心工作就是在HTML、CSS和JavaScript之间找到平衡，通过这三者共同协作，创建一个完整的网页。现代前端开发还涉及很多工具和框架，但这三者始终是基础中的基础。 1.4 准备好你的开发工具：推荐VS Code及其必备插件 VS Code（Visual Studio Code）是一款由Microsoft开发的轻量级代码编辑器，非常适合前端开发者使用。它的优点不仅在于轻巧和快速，还提供了强大的扩展功能。 安装VS Code： 前往VS Code官网，下载并安装VS Code 安装后打开VS Code，首先可以进行一些基础的配置 推荐插件： HTML Snippets：这个插件提供了常用HTML标签的代码片段，帮助你快速插入HTML代码。 使用方法：输入html:5然后按Tab键，会自动生成HTML5的基本文档结构 常用片段：link:css生成CSS链接，script:src生成JavaScript引用，meta:vp生成视口设置 效率提升：减少重复输入，避免语法错误 Live Server：允许你通过实时预览功能查看你的网页变化。 使用方法：安装后，右键点击HTML文件并选择\"Open with Live Server\" 实时更新：保存文件后浏览器会自动刷新，无需手动刷新 本地服务器：模拟真实的HTTP环境，避免本地文件协议的限制 热重载：支持CSS、JS、HTML的热重载，开发效率极高 Prettier - Code formatter：自动格式化代码，使你的代码更加整洁和规范。 配置方法：可以设置保存时自动格式化，或使用快捷键Shift+Alt+F 支持语言：HTML、CSS、JavaScript、JSON等多种语言 团队协作：统一的代码风格，便于团队协作和代码审查 Emmet：这个插件可以极大地提高你的HTML和CSS编写速度。 基础语法：!生成HTML5结构，div>p生成嵌套标签，ul>li*5生成5个列表项 CSS缩写：w100→width: 100px，m10→margin: 10px，tac→text-align: center 高级功能：支持复杂的嵌套结构和属性设置 Bracket Pair Colorizer：使匹配的括号对颜色不同，方便你查看代码结构。 视觉效果：不同层级的括号使用不同颜色，便于识别嵌套关系 适用场景：特别适合复杂的HTML结构和JavaScript代码 自定义设置：可以调整颜色方案和高亮样式 其他实用插件： Auto Rename Tag：自动重命名配对的HTML标签，修改开始标签时结束标签同步更新 CSS Peek：在HTML文件中快速跳转到CSS样式定义 GitLens：增强Git功能，显示代码的修改历史和作者信息 Thunder Client：轻量级的API测试工具，方便测试后端接口 VS Code基础配置建议： 设置字体大小：在设置中搜索font size，调整为适合的大小（推荐14-16px） 启用自动保存：设置files.autoSave为afterDelay，避免代码丢失 配置缩进：设置editor.tabSize为2或4，保持代码缩进一致 开启行号显示：设置editor.lineNumbers为on，方便调试 设置主题：选择护眼的颜色主题，如One Dark Pro或Material Theme 有了VS Code和这些插件，你将能高效地进行HTML、CSS和JavaScript的开发工作。 记住，工具是辅助，重要的是理解前端开发的原理和最佳实践。 第2章 我的第一个HTML页面：Hello, World! 在这一章，我们将亲自实践，写出你的第一个HTML网页——一个简单的\"Hello, World!\"页面。 2.1 如何创建一个HTML文件？ 打开VS Code，点击左上角的“文件”菜单，选择“新建文件”。 在新的文件中输入以下代码： 保存文件，选择“文件” -＞ “保存”或者直接按快捷键Ctrl+S，将文件保存为hello.html，记得保存为.html格式。 现在，你已经创建了一个简单的HTML页面，它包含了一个标题Hello, World!。 2.2 HTML页面的基本骨架：<!DOCTYPE>, <html>, <head>, <body> <!DOCTYPE html>：这不是HTML标签，而是一个指令。这行代码声明当前文档使用HTML5标准。它告诉浏览器用HTML5的方式来解析文档。对于现代网页来说，始终要在文档最顶部使用此声明。 <html lang=\"zh-CN\">：<html>标签是HTML文档的根元素，是DOM树的根节点，所有内容都应该放在<html>标签内。lang=\"zh-CN\"表示网页的语言是中文，有助于搜索引擎和浏览器识别网页的语言。 提示：lang属性能让屏幕阅读器匹配对应语言发音（提升视障用户体验），也帮助搜索引擎为不同语言区域用户提供精准结果；语言代码建议用zh-CN、zh-TW等具体标识，而非泛指的zh。 <head>：<head>部分包含了网页的元信息，诸如字符集、网页标题、外部CSS样式表链接等。此区域包含的是“关于文档的数据”，而非文档本身的内容。它定义了文档与外部资源的关系以及各类设置。这些内容不会直接显示在网页上。 <meta charset=\"UTF-8\">：定义网页的字符编码为UTF-8，这对于显示中文和其他字符集非常重要。字符集声明必须放在最前面。 <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">：这是响应式设计的关键，它帮助页面在不同设备（如手机、平板、电脑）上自适应显示。 width=device-width：视口宽度等于设备宽度 initial-scale=1.0：初始缩放比例为100% <title>：定义浏览器标签页的标题，同时也是用户收藏网页时的默认书名。 <body>：<body>部分包含了网页的实际内容，文档的“内容展示区”，这些内容会显示在浏览器窗口中。在这个例子中，我们有一个<h1>标签，表示一个大的标题，显示文字Hello, World!。 2.3 写下你的第一行代码：<h1>Hello, World!</h1> <h1>标签用于显示网页的主标题。HTML提供了六种标题标签（<h1>到<h6>），<h1>表示最重要的标题，字体最大，<h6>则表示最小的标题。 HTML标题标签详解： 标题标签的使用原则： 语义化：标题应该反映内容的层次结构，而不是仅仅为了改变字体大小 唯一性：每个页面通常只有一个<h1>标签，表示页面的主题 连续性：避免跳级使用，如从<h2>直接跳到<h4> SEO友好：搜索引擎通过标题标签理解页面结构，合理使用有助于SEO 常用的HTML文本标签： 除了标题标签，HTML还提供了丰富的文本格式化标签： HTML列表标签： 你可以在<body>标签内部，插入以下代码： 这段代码将会在网页中显示一个大的标题Hello, World!和一个段落。 2.4 在浏览器中打开你的网页，查看成果！ 完成代码后，你可以通过以下步骤查看你的网页： 保存文件并在VS Code中打开 右键点击文件，选择\"在浏览器中打开\" 如果你安装了Live Server插件，只需右键点击HTML文件并选择\"Open with Live Server\"，就能看到网页的实时效果 你应该看到一个页面，上面显示着\"Hello, World!\"。恭喜！你已经创建了第一个HTML页面。 通过本章的学习，你已经掌握了HTML页面的基本结构，以及如何创建和查看一个简单的HTML网页。接下来，我们将深入学习HTML标签、CSS样式和JavaScript交互，让你的网页变得更加丰富和生动。 小结 本篇文章介绍了HTML的基础概念： 网页、网站与HTML的关系 浏览器的工作原理和内核 前端三剑客（HTML、CSS、JavaScript）的作用 开发工具VS Code的配置 第一个HTML页面的创建 常用HTML标签的使用方法 学习建议和最佳实践 掌握这些基础知识后，你就可以开始HTML的进阶学习了。继续保持学习的热情，多动手实践，相信你很快就能成为一名优秀的前端开发者！"
    },
    {
      "title": "第二篇：HTML基础语法——从零开始写代码",
      "path": "HTML/第二篇：HTML基础语法——从零开始写代码.md",
      "category": "HTML",
      "tags": [],
      "date": null,
      "description": "在 HTML 中，一切内容的结构都由“标签（tag）”组成。\n\n标签的本质，就是给内容 “贴身份标签”：告诉浏览器 “这段内容是什么类型”，它告诉浏览器——这里是一段文字，这里是一张图片，这里是一个标题，以此知道该用什么方式展示给用户。\n\n标签的写法很固定，核心是 \"一对尖括号（< >）包括单词\"，分为 \"开始标签\" 和 \"结束标签\"，中间夹着 \"用户能看到的内容\"。例如：\n\nHTML标签的基本规",
      "content": "第二篇：HTML基础语法——从零开始写代码 第3章 HTML的核心：元素与标签 3.1 什么是标签？——像“括号”一样的存在 在 HTML 中，一切内容的结构都由“标签（tag）”组成。 标签的本质，就是给内容 “贴身份标签”：告诉浏览器 “这段内容是什么类型”，它告诉浏览器——这里是一段文字，这里是一张图片，这里是一个标题，以此知道该用什么方式展示给用户。 标签的写法很固定，核心是 \"一对尖括号（< >）包括单词\"，分为 \"开始标签\" 和 \"结束标签\"，中间夹着 \"用户能看到的内容\"。例如： HTML标签的基本规则： 标签名使用小写字母（HTML5规范推荐） 开始标签和结束标签必须成对出现（除空元素外） 标签可以正确嵌套，但不能交叉 标签可以有属性，属性提供额外信息 <p>这是一个段落。</p> <p> 是\"开始标签（opening tag）\" </p> 是\"结束标签（closing tag）\" 中间的内容是元素的“内容（content）” 类比理解：你可以把 HTML 标签想象成一对“括号”，它把内容包在中间，并说明这段内容是什么类型。 例如： <h1>……</h1> 表示“一级标题” <p>……</p> 表示“段落” <a>……</a> 表示“超链接” 3.2 元素的结构：开始标签、内容、结束标签 一个标准的 HTML 元素结构如下： <标签名>内容</标签名> 例如： <h1>欢迎来到我的网站！</h1> <p>这里是一个简单的段落。</p> 我们可以看到： 开始标签告诉浏览器内容的类型； 内容是用户看到的文本； 结束标签用 / 号来标识结束，结束标签的 / 绝对不能漏！。 提示：标签不区分大小写，但推荐小写（遵循 HTML5 规范）。 3.3 空元素：那些不需要结束标签的特例（如 <br>) 有些标签是空元素（Empty Element），空元素是对 “标准元素结构” 的补充 —— 它们的作用不是 “包裹内容”，而是 “执行某个具体功能”（比如换行、插图片），因此不需要内容，自然也不需要结束标签。 空元素的核心特点：“无内容，单标签” 比如 <br>（换行）：它的作用是 “在当前位置插入一个换行”，不需要包裹任何文字，所以直接写 <br> 就行，不用写 </br>（写了反而不符合规范）。 常见空元素及作用： <br> Break 强制换行（在文字、段落中插入换行符） <hr> Horizontal Rule 插入一条水平分割线（分隔不同内容区块） <img> Image 插入图片（需要配合 src 属性指定图片地址） <input> Input 创建表单输入框（让用户输入文字、选择选项等） <link> 链接外部资源（常用于引入CSS文件） <meta> 提供元数据（如字符编码、视口设置等） <source> 为媒体元素定义多个资源源 实战示例：看 <br> 如何工作 原文例子：<p>你好！<br>我叫小明。</p> 没有 <br> 时，浏览器会显示：你好！我叫小明。（一行文字） 加入 <br> 后，浏览器会在 <br> 位置强制换行，最终显示： 你好！ 我叫小明。 这就是空元素的\"功能型作用\"——它不承载内容，只改变内容的展示形式。 小技巧解析：为什么 HTML5 不用 <br /> 了？ 早期的 XHTML（HTML 的严格版本）要求 “所有标签必须闭合”，所以空元素要写成 <br />（用 / 表示 “自闭合”）；但 HTML5 简化了规则，明确 “空元素不需要自闭合标记”，直接写 <br>、<img> 即可。 现在开发中，优先用 HTML5 写法（如 <br>），避免写冗余的 /（写了也能显示，但不符合最新规范，且增加代码量）。 一句话总结：标准元素 vs 空元素 | 类型 | 结构 | 作用 | 示例 | | -------- | -------------------------- | ---------------------- | ------------------------------ | | 标准元素 | 开始标签 + 内容 + 结束标签 | 包裹内容，定义内容类型 | <h1>标题</h1>、<p>段落</p> | | 空元素 | 单个标签（无结束标签） | 执行功能，无内容可包裹 | <br>、<img>、<input> | 记住这个区别，以后写 HTML 时就不会混淆 “什么时候要成对标签，什么时候用单标签” 了。 3.4 动手练习：用 <p> 和 <br> 写一段自我介绍 试试看写出以下代码： 练习目标：掌握段落与换行标签的基本用法，让页面结构更整洁。 第4章 为元素添加信息：属性的妙用 4.1 什么是属性？ HTML 的“属性（Attribute）”本质是给标签加“附加信息的”的工具。它不改变标签的“核心类型”（比如＜p＞标签再加属性还是段落的意思），但它可以改变标签的外观、行为，或提供额外的描述。 例如，我们可以用 style 属性改外观（如文字颜色）： style=\"color: blue;\" 是属性：高速浏览器 “这个段落的文字颜色要设为蓝色”； 最终效果：用户看到的是 “蓝色的段落文字”，而不是标签默认的黑色。 或者用 title 属性添加提示信息： title=\"这是提示信息\" 是属性：高速浏览器 “当鼠标悬停在这段文字上时，显示‘这是提示信息’的弹窗”； 最终效果：用户把鼠标放在文字上，会看到一个小弹窗，获取额外说明。 一句话总结属性的作用： 标签决定 “内容是什么”（比如 “这是段落”“这是链接”），属性决定 “这个内容‘怎么样’”（比如 “段落是蓝色的”“链接指向哪个网址”）。 4.2 属性的语法：固定格式 name=\"value\"——\"指令名=具体内容\" 所有属性都遵循相同的语法格式： 例如： 在上面的例子中： href 是属性名；告诉浏览器 “要设置什么类型的附加信息”（相当于 “指令名称”）。 \"=\"，连接 “属性名” 和 “属性值”，表示 “将属性名设为这个属性值”。 \"Example网站网址\" 是属性值；告诉浏览器 “附加信息的具体内容”（相当于 “指令的具体参数”） 整体告诉浏览器，这个 ＜a＞ 标签是一个指向该网址的链接。 注意事项： 注意 1：属性名与属性值必须用 = 连接； 注意 2：属性值必须用 “双引号” 包裹； 注意 3：一个标签可以加多个属性，属性之间用 “空格” 分隔。 4.3 常用全局属性介绍：id, class, style, title 这些属性可以用于几乎任何 HTML 元素，因此被称为全局属性。 我们逐个拆解 id、class、style、title 的作用、特点和用法。 id 为元素设置唯一标识符，整个页面中 id 值必须唯一（像身份证号，不能重复）；常用于 “定位元素”（比如配合 JS 找到某个元素） class 给元素设置分类（常用于CSS样式），同一个 class 值可被 多个元素共享（像班级，多个学生同属一个班）；主要用于 “批量设置样式”（配合 CSS） style 直接写入内联样式，样式直接写在标签里，优先级最高（写了就生效）；但不推荐大量用（每个标签写 style 会很繁琐） title 鼠标悬停提示文本，鼠标放在元素上时，会弹出小弹窗显示属性值；常用于 “补充说明”（比如解释专业术语） 说明： id 在页面中必须唯一； class 可以被多个元素共享； 通常我们用 class 来配合 CSS 进行样式设计。 4.4 实战：为你的标题和段落加上不同的 class 下面是一段示例代码： ＜h1 class=\"main-title\"＞欢迎来到我的网页＜/h1＞ ＜p class=\"intro\"＞你好！这是我的第一个HTML页面。＜/p＞ ＜p class=\"highlight\"＞我正在学习如何使用class属性。＜/p＞ 如果我们配合 CSS（后面章节会讲），就可以让不同类型的文字显示不同效果，比如： 小练习：请你为自己的网页写一个标题，并添加两段文字： 第一段为介绍； 第二段为兴趣； 给它们设置不同的 class 名称。 代码示例： 通过为不同元素添加不同的 class 名称，再配合 CSS 样式，就能让网页内容呈现出丰富多样的视觉效果。 属性的高级用法 除了基本的属性用法，HTML还支持一些高级的属性特性： 多属性组合 一个元素可以同时拥有多个属性： 布尔属性 某些属性不需要值，只要存在就表示true： 自定义数据属性 HTML5允许使用 data-* 前缀的自定义属性： 属性的优先级 当多个属性冲突时，优先级通常是：内联样式 > 内部样式 > 外部样式 常见错误和注意事项 属性值必须用引号包围（虽然某些情况下可以省略，但不推荐） 属性名不能重复 class属性可以包含多个值，用空格分隔： id属性在页面中必须唯一 属性名不区分大小写，但推荐小写 本章小结 标签：用来定义网页结构 元素：开始标签 + 内容 + 结束标签 空元素：没有内容的特殊标签，如 <br> 属性：为标签添加附加信息，语法为 name=\"value\" 全局属性：id、class、style、title 常用且通用 通过本章的学习，你已经掌握了HTML元素和标签的基本概念，以及如何使用属性为元素添加附加信息。这些知识是构建网页结构的基础，为后续学习更复杂的HTML特性和CSS样式打下了坚实的基础。"
    },
    {
      "title": "第三篇：构建网页内容——让页面丰富起来",
      "path": "HTML/第三篇：构建网页内容——让页面丰富起来.md",
      "category": "HTML",
      "tags": [],
      "date": null,
      "description": "文本级语义化是 HTML 的核心思想之一 —— 它要求标签不仅承担\"美化文字\"的视觉作用，更要传递\"内容含义\"的语义作用。简单来说：HTML 标签要\"懂内容\"，而不只是\"装内容\"。\n\n\n\n标题标签是网页内容的\"导航路标\"，用于明确内容的层级关系，就像书籍的\"章→节→小节\"结构。\n\nHTML 提供了六级标题，从 <h1>（最高级）到 <h6>（最低级）：六级层级，自上而下递减。\n\n\n\n浏览器默认会根",
      "content": "第三篇：构建网页内容——让页面丰富起来 第5章 组织文本内容：文本级语义化 文本级语义化是 HTML 的核心思想之一 —— 它要求标签不仅承担\"美化文字\"的视觉作用，更要传递\"内容含义\"的语义作用。简单来说：HTML 标签要\"懂内容\"，而不只是\"装内容\"。 5.1 标题的重要性：<h1> 到 <h6>—— 构建内容的\"骨架层级\" 标题标签是网页内容的\"导航路标\"，用于明确内容的层级关系，就像书籍的\"章→节→小节\"结构。 HTML 提供了六级标题，从 <h1>（最高级）到 <h6>（最低级）：六级层级，自上而下递减。 浏览器默认会根据标题等级自动调整字体大小。但视觉大小不是核心，语义层级才是关键。 语义意义： <h1> 通常是页面的主标题（每页建议只用一个） <h2>、<h3> 表示内容的子标题与层次 搜索引擎（SEO）通过 <h1>到<h6> 的层级，快速梳理网页的\"内容大纲\" 提示：不要为了变大变粗而乱用标题。样式问题（字体大小、粗细、颜色）：以后交给 CSS 解决（如font-size: 24px; font-weight: bold;）；HTML 的职责：只负责\"标记内容层级\"，不负责\"美化内容\"。 5.2 段落与换行：<p> 与 <br> <p> 是块级元素（独占一行，前后自动换行），专门用于包裹\"一段完整的、有独立意义的文字\"（如一句话、一个观点、一段描述）。 例如： 而 <br> 是换行标签，用于在段落内部强制换行： 5.3 强调文本：<strong>（重要） vs <b>（粗体），<em>（强调） vs <i>（斜体） 这是语义化的\"高频混淆点\"：两组标签的默认外观完全相同（<strong> 和 <b> 都是粗体，<em> 和 <i> 都是斜体），但语义完全不同。核心区别是：是否传递\"内容重要性\"。 <strong> 标签：表示内容重要 语义：表示内容\"重要、紧急、需要注意\" 适用场景示例： <b> 标签：仅为\"视觉加粗\"，无任何语义 适用场景示例： <em> 标签：表示语气\"强调、重读、转折\" 适用场景示例： <i> 标签：仅为\"视觉斜体\"，无语义（特殊场景） 适用场景示例： 最佳实践：优先使用语义化的 <strong> 与 <em>。浏览器与辅助技术（如屏幕阅读器）能更好理解内容的重要程度，搜索引擎会把 <em>、<strong> 标记的内容视为\"重点信息\"，优先抓取；而 <b>、<i> 标记的内容，会被视为\"普通样式调整\"，无特殊权重。 记住：\"重要性\"用语义标签，\"好看\"用 CSS（比如想让文字加粗但不重要，可用 span style=\"font-weight: bold;\" 替代 <b>）。 5.4 其他文本标签：<span>、<mark>、<small>、<time> 这些标签让文字更有细节： <span> 标签：无语义的\"行内容器\"—— 专门配合 CSS 是 HTML 中最\"灵活\"的文本标签，它没有任何自带语义，唯一作用是\"包裹一段行内文字\"，方便用 CSS 调整样式（如颜色、大小、间距）。行内元素（不独占一行，仅包裹需要调整的局部文字）。 示例： 避坑：别用 <span> 替代 <p>（<span> 是行内元素，不能包裹段落；<p> 是块级元素，专门包裹段落）。 <mark> 标签：语义化的\"高亮标记\"—— 模拟\"荧光笔\" <mark> 的作用是\"高亮显示文本\"，类似用荧光笔涂过的效果，且自带语义：表示\"这段内容是重点、需要用户注意\"。默认黄色背景高亮，且机器能识别为\"重点内容\"。 示例： 区别于 CSS 高亮：用 span style=\"background: yellow;\" 也能实现高亮，但无语义；<mark> 的高亮不仅是视觉效果，还能传递\"重点\"含义。 <small> 标签：语义化的\"小号文字\"—— 用于脚注、版权 <small> 的作用是\"显示小号文字\"，且自带语义：表示\"辅助性内容\"（如版权声明、脚注、免责声明）。默认字体比周围文字小一号，且语义上属于\"次要内容\"； 示例： 区别于 CSS 小号文字：用span style=\"font-size: 12px;\"也能缩小文字，但无\"辅助内容\"语义；<small>的文字，会被屏幕阅读器识别为\"次要信息\"，朗读时可能降低音量。 <time> 标签：语义化的\"时间标签\"—— 机器可解析的时间。 <time> 是专门用于\"标记时间信息\"的标签，核心价值是让机器（搜索引擎、日历工具）能解析时间（如自动添加到日历、识别文章发布时间）。 核心属性：datetime（必须写，用于存储\"机器可识别的标准时间格式\"，如2025-11-03、2025-11-03T14:30）； 示例： 价值：搜索引擎会根据 <time> 的 datetime 属性，精准抓取文章发布时间，提升\"时效性内容\"的搜索排名；日历工具（如谷歌日历）可识别 <time> 标签，支持\"一键添加到日历\"。 说明： <span> 没有特定语义，常配合 CSS 使用； <mark> 和 <time> 则增强网页语义，让机器更懂你。 选标签时，多问\"屏幕阅读器能理解吗？搜索引擎能识别吗？\"—— 语义化标签（<h1>到<h6>、<strong>、<em>、<mark>、<time>）是最佳选择。 5.5 综合练习：写一篇结构清晰的博客文章 第6章 创建超链接与列表：导航与信息组织 6.1 连接世界的超链接：<a> 标签 超链接（Anchor）是网页的灵魂，它让互联网\"互相连通\"，让静态网页能跳转、互通； <a> 标签（Anchor，锚点标签）是 HTML 中唯一负责\"跳转\"的标签，无论是跳转到其他网站、本页的某个位置，还是下载文件，都依赖它。核心是通过属性控制跳转行为，而非标签本身的文字。 标签格式： 核心组成： href：定义\"跳转目标地址\"（核心属性，无此属性则为\"空链接\"） 链接文本：用户能看到并点击的内容（如\"访问 Example 网站\"），建议清晰描述跳转目标（避免\"点击这里\"这类模糊文本） 可选：可包裹图片（如 <a href=\"index.html\"><img src=\"logo.png\" alt=\"首页\"></a>），实现\"点击图片跳转\" 常用属性： href：定义\"跳转目标地址\"（核心属性，无此属性则为\"空链接\"） 跳转到外部网站：href=\"外部网站网址\" 跳转到本地文件：href=\"about.html\" target=\"_blank\"：控制\"跳转窗口\"，_blank 表示\"在新浏览器标签页打开\"，默认是\"覆盖当前页\" title：鼠标悬停在链接上时，显示\"提示文本\"（提升可访问性，避免用户误点） 避坑提示： 不要省略 href：没有 href 的 <a> 标签只是普通文本，无法点击跳转 链接文本要明确：避免\"点击这里\"\"更多\"等模糊描述，比如用\"查看 HTML 教程\"比\"点击这里\"更清晰（利于 SEO 和视障用户） target=\"_blank\" 要慎用：仅在\"需要保留当前页\"时使用（如跳转外部网站），内部页面跳转建议默认覆盖（避免打开过多标签） 6.2 链接的路径：绝对路径 vs 相对路径 href属性中的\"目标地址\"，本质是\"文件路径\"。路径写错会导致链接失效（点击后 404 错误），而路径分为\"绝对路径\"和\"相对路径\"，核心区别是\"以哪个位置为起点找目标文件\"。 绝对路径：从完整网址开始，即\"从全世界出发找文件\"。 从\"完整的网址开头\"（如https://）或\"本地磁盘根目录\"（如C:\\）出发的路径，相当于\"给文件一个'全球唯一地址'\"。 适用场景：跳转到其他网站的内容（如百度、淘宝），或本地文件但需明确磁盘位置时（极少用）。 相对路径：\"从当前文件出发找文件\"。 以\"当前 HTML 文件所在的文件夹\"为起点，找目标文件的路径，相当于\"告诉浏览器'目标文件在我旁边 / 上级文件夹里'\"。 适用场景：跳转到自己网站内的其他文件（如首页、关于页、图片），是开发中最常用的路径方式。 核心规则：通过符号表示层级关系： 无符号：目标文件与当前文件在同一文件夹（如当前是index.html，目标about.html在同一文件夹，路径直接写about.html） 文件夹名/：目标文件在当前文件夹的子文件夹里（如图片在images文件夹，路径写images/logo.png） ../：目标文件在当前文件夹的上级文件夹里（如当前在pages/index.html，目标about.html在上级project文件夹，路径写../about.html） 示例： 总结： | 路径类型 | 优点 | 缺点 | |---------|------|------| | 绝对路径 | 地址完整，不依赖当前文件位置，不会错 | 本地测试时可能失效；项目移植时需修改 | | 相对路径 | 灵活，项目移植时无需修改 | 依赖文件层级，层级写错会导致 404 | 避坑提示： 开发网站优先用相对路径：避免项目上传到服务器后，绝对路径失效（如本地C:\\路径在服务器上不存在） 层级符号别写错：多写或少写 ../ 是最常见错误 文件夹/文件名别用中文：中文可能导致路径解析错误，建议用英文 6.3 列表：组织信息的利器 6.3.1 无序列表 <ul>：\"无顺序的并列项\" 语义：表示\"多个同类、无先后顺序的内容\"（如分类、选项、功能列表） 默认外观：每个列表项前有\"圆点标记\"（可通过 CSS 改成方块、空心圆等） 结构：<ul>是父容器，每个列表项用<li>包裹（<li>是唯一允许的直接子元素） 适用场景：导航菜单（如首页、关于、博客）、商品分类、功能点列举等。 6.3.2 有序列表 <ol>：\"有顺序的步骤 / 排名\" 语义：表示\"多个有先后顺序、步骤性或排名的内容\"（如教程步骤、排行榜、流程） 默认外观：每个列表项前有\"数字标记\"（1、2、3…，可通过 CSS 改成字母、罗马数字等） 结构：与<ul>一致，父容器<ol>，子元素<li> 适用场景：教程步骤、考试题目、排行榜（如\"Top 5 热门文章\"）、流程说明等。 说明： <ul>：无序（圆点） <ol>：有序（编号） <li>：每个列表项 6.3.3 核心规则与避坑 必须用<li>包裹列表项：不能在<ul>/<ol>里直接写文字（如<ul>HTML</ul>是错误的，必须写成<ul><li>HTML</li></ul>）。 列表项可嵌套：<li>里可以再放<ul>/<ol>（如导航菜单的下拉列表）。 示例： 样式靠 CSS 修改：不要为了改\"圆点 / 数字\"而混用列表类型（如用<ol>却想去掉数字，应保留<ul>，用 CSS list-style: none;隐藏标记）。 6.4 定义列表 <dl>：用于\"术语 - 解释\"的键值对结构，可以理解成表格。 <dl>（Definition List，定义列表）是特殊的列表类型，不用于\"并列项\"，而用于\"术语解释、参数说明\"，核心是\"键（术语）- 值（解释）\"的对应关系。 6.4.1 结构：三个标签的配合 定义列表由三个标签组成，缺一不可： <dl>：父容器，包裹整个\"术语 - 解释\"组； <dt>：Definition Term（定义术语），表示\"需要解释的词 / 概念\"（如 HTML、CSS）； <dd>：Definition Description（定义描述），表示\"对<dt>的解释内容\"（如\"超文本标记语言\"）； 关系：一个<dt>可以对应多个<dd>（如一个术语有多个解释），也可以多个<dt>对应多个<dd>。 6.4.2 示例：技术术语解释 6.5 实战：制作一个网站导航栏和一个产品功能列表 第7章 嵌入图片与多媒体：让网页更生动 7.1 在网页中插入图片：<img> 标签—— 视觉内容的\"入口\" <img> 标签是 HTML 中唯一用于嵌入图片的标签，它是自闭合标签（无需写 </img>），核心依赖\"属性\"控制图片的\"来源、替代文本、尺寸\"，缺一不可。 属性含义： src：图片路径，告诉浏览器\"从哪里加载图片\"，路径错误会导致图片不显示（出现\"破损图标\"），支持相对路径/绝对路径（同 <a> 标签逻辑） alt：替代文本（图片加载失败或无障碍阅读时使用），不能空着！描述要精准（如\"夕阳下的海边\"而非\"图片 1\"），纯装饰性图片可写 alt=\"\" width/height：图片的\"显示尺寸\"（单位默认是像素），控制图片在页面中的大小，只写一个属性（如只写 width=\"400\"），另一个会自动\"等比缩放\"（避免图片变形）；不写则显示图片原始尺寸 可访问性要点：alt 属性非常重要！它不仅用于加载失败时的提示，也是视障用户理解图片内容的关键。 7.2 图片示例 避坑与可访问性重点： alt属性不是\"可选项\"： 没有alt的图片，对视障用户（依赖屏幕阅读器）来说\"完全不存在\"；图片加载失败时（如网络差、路径错），用户也不知道这里本该是什么内容。即使是纯装饰的图片（如背景花纹），也要写alt=\"\"（空值），告诉机器\"这张图无实际意义\"。 width/height别硬写固定值： 若同时写width=\"300\"和height=\"500\"，但图片原始比例是\"3:2\"，会导致图片拉伸变形（比如把圆形拍成椭圆）。正确做法是\"只写一个属性\"，让浏览器自动保持比例。 7.3 简单嵌入视频 <video> 和音频 <audio>：让网页\"动起来、响起来\" 视频和音频是传递动态信息的核心元素，HTML5 直接提供<video>和<audio>标签，无需依赖第三方插件（如早期的 Flash）。两者用法逻辑相似，核心都是\"指定资源路径 + 控制播放行为\"。 <video>嵌入视频文件 常用属性： src：视频文件路径（同<img>，支持 mp4、webm 等，推荐 mp4（兼容性最好）） controls：必加！显示\"播放 / 暂停、进度条、音量\"等控制按钮（不加则用户无法操作视频） width：视频显示宽度（同<img>，高度自动缩放） autoplay：页面加载完成后自动播放（谨慎用！多数浏览器（如 Chrome）限制\"静音才能自动播\"，避免扰民） loop：视频播放结束后自动重新开始（适合广告、背景视频） poster：视频加载完成前显示的\"封面图\"（避免黑屏等待，提升体验） <audio>嵌入音频文件 常用属性： src：音频文件路径（支持 mp3、wav 等，推荐 mp3） controls：必加！显示\"播放 / 暂停、进度条、音量\"按钮（不加则无法操作音频） autoplay/loop：同<video>，但音频自动播更易引发反感，几乎不用 基础用法示例： 避坑提示： controls绝对不能省： 没有controls的视频 / 音频是\"死资源\"—— 用户看不到播放按钮，也无法控制进度，相当于\"嵌入了但没完全嵌入\"。 视频格式选 mp4： 不同浏览器支持的视频格式不同（如 Safari 不支持 webm），mp4 是所有现代浏览器的\"通用格式\"，避免出现\"在 Chrome 能播、在 Safari 播不了\"的问题。 autoplay别滥用： 多数浏览器为了用户体验，会限制非静音的autoplay（比如必须用户点击页面后才能自动播），强行加autoplay可能无效，还会让代码冗余。 7.4 实战：创建一个包含图片和视频的相册页面 第8章 构建清晰的页面结构：布局与语义化 8.1 \"div+css\"布局的旧时代与语义化标签的新时代 早期网页用一堆<div class=\"header\">、<div class=\"main\">来划分区域，但<div>本身\"没有任何语义\"—— 机器（搜索引擎、屏幕阅读器）不知道哪个是\"核心内容\"，哪个是\"侧边栏\"。HTML5 引入的语义化结构标签，就是给这些区域\"贴明标签\"，让页面结构\"一看就懂\"。 对比维度 | 旧时代：div+CSS 布局 | 新时代：HTML5语义化标签 ---------|----------------------|------------------------ 机器可理解性 | 差：机器只知道是<div>，不知道\"header\"是\"页头\"（class是给人看的，机器不理解语义） | 好：标签自带语义（如<main>=\"核心内容\"），搜索引擎/屏幕阅读器能直接识别 SEO友好度 | 低：搜索引擎难判断哪个<div>的内容是核心，抓取效率低 | 高：搜索引擎优先抓取<main>、<article>里的内容，提升核心内容排名 代码可读性 | 差：一堆<div>，需要看class才知道用途，后期维护容易乱 | 好：标签名就是用途（如<nav>=\"导航\"），新人看代码也能快速理清结构 可访问性 | 差：视障用户用屏幕阅读器时，无法快速定位\"核心内容\"\"导航\" | 好：屏幕阅读器能识别语义标签，直接播报\"进入页头\"\"进入主体内容\"，提升无障碍体验 结论： 旧时代的<div>布局，本质是\"用样式（class）伪装结构\"；新时代的语义化布局，是\"用标签本身定义结构\"。语义化不是\"视觉上的变化\"，而是\"机器理解层面的升级\"—— 页面看起来可能一样，但背后的逻辑清晰度、SEO 效果、无障碍体验天差地别。 8.2 像搭积木一样构建页面：7 个核心语义化标签（自带\"功能说明\"） <header> 页面 / 区块的\"头部\" 用途与使用规则： 可用于\"整个页面的头部\"（放网站标题、导航），也可用于\"某个区块的头部\"（如<section>的标题）； 一个页面可多个<header>（如每个<article>都有自己的 header）。 典型示例场景： 页面顶部：放\"我的博客\"标题 + 导航菜单； 文章区块顶部：放文章标题 + 发布时间。 <nav> 页面的\"导航区域\" 用途与使用规则： 专门放\"跳转链接集合\"（如首页、关于、博客、联系的链接）； 一个页面通常只有 1 个<nav>（避免多个导航混淆）。 典型示例场景： 页面顶部的导航栏； 侧边栏的\"相关链接\"列表。 <main> 页面的\"核心内容区域\" 用途与使用规则： 整个页面唯一（不能有多个<main>），包含页面最核心的内容（如文章正文、商品列表）； 不能嵌套在<header>、<footer>、<aside>里。 典型示例场景： 博客页：放文章正文； 商品页：放商品详情 + 购买按钮。 <article> 页面中\"独立完整的内容\" 用途与使用规则： 内容可\"单独拿出来用\"（如一篇文章、一个评论、一个新闻）； 可嵌套在<main>里（如<main>包含多个<article>表示\"多篇文章\"）。 典型示例场景： 博客首页：每个文章卡片都是一个<article>； 新闻页：每则新闻都是一个<article>。 <section> 页面中\"内容分组区块\" 用途与使用规则： 用于\"把相关内容打包成一个区块\"（如\"旅行图片区\"\"视频日志区\"），没有明确语义时用它； 可嵌套（如<section>里再放<section>），但别过度嵌套。 典型示例场景： 相册页：\"旅行记忆\"图片组+\"视频日志\"视频组，各用一个<section>； 商品页：\"商品详情\"区+\"用户评价\"区，各用一个<section>。 <aside> 页面的\"侧边栏 / 附属内容\" 用途与使用规则： 内容与<main>核心内容\"相关但非必需\"（如作者简介、相关推荐、广告）； 通常放在<main>旁边（视觉上的侧边栏）。 典型示例场景： 博客正文右侧：放\"作者简介\"\"热门文章推荐\"； 商品详情右侧：放\"配送信息\"\"同类商品\"。 <footer> 页面 / 区块的\"底部\" 用途与使用规则： 可用于\"整个页面的底部\"（放版权、联系方式、备案信息），也可用于\"某个区块的底部\"（如<article>的\"点赞评论区\"）； 一个页面可多个<footer>。 典型示例场景： 页面底部：放\"© 2025 我的博客 版权所有\"； 文章区块底部：放\"点赞\"\"分享\"按钮。 8.3 使用示例 8.4 大型实战：使用语义化标签搭建博客首页结构 目标：构建一个完整的页面骨架。 这个示例的核心逻辑：每个标签都在\"做自己该做的事\"——<header>管头部，<nav>管导航，<main>管核心，<aside>管附属，<footer>管底部。即使没有 CSS 美化，机器和人也能一眼看懂\"页面的哪部分是核心、哪部分是辅助\"。 本篇总结： 从\"内容\"到\"结构\"的完整闭环，让网页\"有内容、不单调\"。 <img>（图片）、<video>（视频）、<audio>（音频）传递视觉/听觉信息，提升用户体验（纯文本→图文音视频） 让网页\"有结构、不混乱\"，<header>/<nav>/<main>等语义化标签建立逻辑骨架，提升 SEO 和无障碍（混乱 div→机器可懂的结构）"
    },
    {
      "title": "第四篇：表单与交互——连接用户与服务器",
      "path": "HTML/第四篇：表单与交互——连接用户与服务器.md",
      "category": "HTML",
      "tags": [],
      "date": null,
      "description": "网页不仅仅是展示信息的工具，更是人与网站之间的桥梁。\n\n在这一篇中，我们将学习如何通过表单（Form）实现用户与服务器的交互——从最基本的文本输入，到复杂的注册流程。\n\n掌握表单技术，意味着你能让网页真正\"动起来\"。\n\n\n\n\n\n表单（Form）不是单一的\"输入框\"，而是一个包含多个输入控件的\"容器\"——它的核心功能有两个：\n\n第一步：收集用户在控件中输入的信息（如用户名、密码）；\n\n第二步：将收集",
      "content": "第四篇：表单与交互——连接用户与服务器 网页不仅仅是展示信息的工具，更是人与网站之间的桥梁。 在这一篇中，我们将学习如何通过表单（Form）实现用户与服务器的交互——从最基本的文本输入，到复杂的注册流程。 掌握表单技术，意味着你能让网页真正\"动起来\"。 第9章 表单基础：收集用户输入 9.1 表单是什么？ 表单（Form）不是单一的\"输入框\"，而是一个包含多个输入控件的\"容器\"——它的核心功能有两个： 第一步：收集用户在控件中输入的信息（如用户名、密码）； 第二步：将收集到的信息按规则\"打包\"，发送到服务器（如登录时验证账号密码）。 生活中的例子：我们在APP里填的\"登录页\"\"注册页\"\"订单提交页\"，本质都是HTML表单的可视化呈现。 9.1.1 <form>——表单的\"骨架\" 所有表单控件（输入框、按钮等）都必须放在<form>标签内部，它相当于给这些控件\"统一制定规则\"：数据要发给谁、用什么方式发。 在HTML中，表单由<form>标签定义： 9.1.2 <form> 4个核心属性：决定数据\"怎么提交\" action：表单数据的\"提交目标地址\"（服务器的URL），即数据要发给哪个后台接口 实际场景示例：登录时，action=\"/login\"表示数据发给服务器的\"登录接口\"；搜索时，action=\"/search\"发给\"搜索接口\" method：数据的\"提交方式\"，仅支持两种：GET或POST 实际场景示例：登录用POST（密码敏感），搜索用GET（结果可分享链接） name：表单的\"名字\"（可选），主要用于JS获取表单对象（后续章节会讲） 实际场景示例：如<form name=\"loginForm\">，JS可通过document.loginForm快速找到这个表单 target：表单提交后，服务器返回的结果\"在哪里显示\" _self（默认）：在当前页面显示结果 _blank：在新标签页显示结果（避免覆盖当前页） 9.1.3 关键区别：GET vs POST——数据\"怎么发\"更合适？ method属性的两个值（GET/POST），决定了数据的\"传输方式\"，二者的差异直接影响安全性和适用场景，绝对不能混用： | 对比维度 | GET方式 | POST方式 | |---------|---------|----------| | 数据位置 | 数据会拼在URL后面（地址栏可见） | 数据藏在\"请求体\"中（地址栏看不见，后台传输） | | 安全性 | 低——数据暴露在地址栏，任何人都能看到 | 高——数据不暴露，适合传输敏感信息 | | 数据长度 | 有限制（URL长度通常不超过2048字符） | 无限制（可传输大文件、长文本） | | 适用场景 | 仅用于\"查询/获取数据\"，不修改服务器内容 | 用于\"提交/修改数据\"，尤其是敏感操作 | 典型场景对比： 用GET的场景：百度搜索（输入关键词后，地址栏会显示wd=关键词，可分享链接）； 用POST的场景：用户登录（密码不会出现在地址栏，避免泄露）。 9.2 文本输入框：<input type=\"text\">——单行文本收集 文本输入框是最基础的\"用户输入控件\"，专门用于收集单行文本（如用户名、手机号、搜索关键词），不能输入换行内容。 9.2.1 基本语法 <input>：是\"自闭合标签\"（不需要</input>），通过type属性决定它的\"控件类型\"； type=\"text\"：明确这是\"单行文本输入框\"。 9.2.2 input的5个常用属性：控制输入规则 name：给输入的\"数据起名字\"，是服务器识别数据的\"钥匙\" 如name=\"username\"，服务器接收数据时，会通过\"username\"这个键，拿到用户输入的用户名（格式：username=张三） value：输入框的\"默认值\"（页面加载时就显示的内容） 如<input type=\"text\" value=\"默认用户名\">，适合\"回显已保存的信息\"（如编辑个人资料时，默认显示当前用户名） placeholder：输入框内的\"提示文字\"（用户输入后会消失） 如placeholder=\"请输入手机号\"，告诉用户\"这里该填什么\"，提升体验 maxlength：限制用户输入的\"最大字符数\" 如maxlength=\"11\"用于手机号输入，避免用户输入超过11位的无效内容 readonly：设置输入框\"只读\"（用户不能修改内容，只能复制） 如显示用户的\"会员ID\"：<input type=\"text\" value=\"VIP12345\" readonly>，防止用户篡改 9.2.3 注意点 文本输入框只能输单行内容，若需要输入多行（如留言），需用后续章节的<textarea>标签 name属性必须写——如果没写，服务器会\"找不到对应数据\"（相当于给包裹贴了标签，没标签就不知道是谁的包裹） 9.3 密码框：<input type=\"password\">——敏感信息的\"可视化隐藏\" 密码框是文本输入框的\"安全版\"，核心差异是：用户输入的内容会被\"●\"或\"\\*\"隐藏，避免旁人偷窥，但它本身不具备\"加密功能\"。 提示：密码框并不会加密数据，安全依赖于HTTPS传输和服务器端处理。 密码框的语法与普通文本框完全兼容，支持所有文本框的核心属性，仅需将type=\"text\"改为type=\"password\"： 关键注意事项（避坑点）： 无加密功能，安全依赖后端：密码框仅\"隐藏显示\"，输入的原始密码会直接提交给服务器。若要确保安全，必须满足两个条件： 页面使用HTTPS协议（加密传输过程，防止数据被拦截） 服务器接收后对密码进行加密存储（如用MD5、SHA256等算法，不存储明文） name属性必写：若省略name=\"password\"，服务器会\"找不到密码数据\"（相当于快递没贴收件人，无法投递）。 支持的属性与文本框一致：除了上述name/placeholder/maxlength，还支持value（默认密码，不推荐用，不安全）、readonly（只读，密码场景几乎不用）等。 9.4 提交按钮：<input type=\"submit\"> 和 <button> 触发表单数据\"发送动作\"的核心 提交按钮是表单的\"触发开关\"——没有它，用户输入的所有信息（用户名、密码等）都无法发送到服务器。HTML提供两种常用的提交按钮标签，各有适用场景。 两种提交按钮：<input type=\"submit\"> vs <button type=\"submit\"> | 对比维度 | <input type=\"submit\"> | <button type=\"submit\"> | |---------|-------------------------|-------------------------| | 标签类型 | 自闭合标签（无需</input>） | 双标签（需</button>，可包裹内容） | | 按钮文字设置 | 通过value属性设置（如value=\"登录\"） | 直接写在标签内部（如<button>登录</button>） | | 内容灵活性 | 仅支持纯文字，无法插入其他元素 | 支持插入图片、图标、换行等HTML | | 兼容性 | 所有浏览器兼容（包括旧版IE） | 主流浏览器兼容（IE9+） | 关键避坑点： 必须指定type=\"submit\"：若<button>标签省略type，部分浏览器会默认它是\"提交按钮\"，但为了兼容性（避免浏览器差异），必须明确写type=\"submit\"；若写成type=\"button\"，则只是\"普通按钮\"，不会触发表单提交 提交动作依赖<form>标签：提交按钮必须放在<form>标签内部，否则点击后无任何反应（按钮不知道要提交哪个表单的数据） 9.5 实战：制作一个用户登录框 目标：创建一个简单的登录表单。 交互流程：用户点击\"登录\"后发生了什么？ 数据打包：浏览器自动收集<form>内部所有带name属性的输入框数据，格式为\"name=值&name=值\"（如username=张三&password=123456） 数据发送：按<form>的method（POST）规则，将打包后的数据发送到action指定的地址（/login接口） 服务器处理：服务器接收数据后，验证\"用户名是否存在\"\"密码是否匹配\"，然后返回结果（如登录成功跳转首页，失败提示\"密码错误\"） 第10章 丰富的表单控件（上） 10.1 单选按钮 <input type=\"radio\">——二选一/多选一的\"单选题\" 单选按钮的核心作用是从多个选项中强制选择一个，无法多选也无法不选（除非未设置默认值且不限制必填），典型场景如\"性别选择\"\"支付方式选择\"\"学历选择\"等。 10.1.1 基本语法与核心逻辑 单选按钮需通过<label>标签包裹（或关联），语法结构如下： 用<label>包裹按钮与文字，可让文字也能点击。点击\"男/女\"文字时，会自动聚焦到对应的单选按钮，无需精准点击小圆圈，极大提升用户体验（尤其对移动端友好）。 name属性：单选按钮的\"分组钥匙\" 这是单选按钮的核心避坑点——同一组选项必须设置相同的name值（如上例的name=\"gender\"）。 若name不同，浏览器会认为是\"独立选项\"，导致可以同时选中\"男\"和\"女\"，违背\"单选\"逻辑。 value属性：服务器接收的\"真实数据\" 用户看到的是\"男/女\"文字，但提交到服务器的是value值（male或female）。若省略value，服务器可能接收不到有效数据（或接收为on，无意义）。 10.1.2 常用扩展：默认选中（checked） 若需要页面加载时\"默认选中某选项\"（如注册表单默认选\"男\"），可添加checked属性（无需赋值，只要存在即生效）： 注意：同一组单选按钮中，checked只能给一个选项添加，否则最后一个checked会覆盖前面的。 10.2 复选框 <input type=\"checkbox\">——可多选的\"多选题\" 复选框与单选按钮相反，核心作用是从多个选项中选择一个或多个（也可一个都不选），典型场景如\"兴趣爱好勾选\"\"同意条款\"\"选择需要的服务\"等。 10.2.1 基本语法与数据提交 复选框的语法与单选按钮类似，同样依赖<label>和name属性： name属性：分组与数据识别 同一组复选框（如\"兴趣爱好\"）需设置相同的name值（如上例name=\"hobby\"），这样服务器才能通过hobby这个\"key\"，一次性获取所有选中的选项值。 服务器接收的数据格式 若用户同时勾选\"音乐\"和\"运动\"，服务器会收到hobby=music&hobby=sports的数据（多个相同name对应不同value），后端需按\"数组\"格式解析（如Python中的request.form.getlist(\"hobby\")）。 10.2.2 常用扩展场景 （1）默认选中（checked） 与单选按钮一致，给需要默认勾选的选项添加checked属性： （2）必填项（required） 典型场景如\"注册时必须同意用户协议\"，需强制用户勾选，可结合required属性： 注意：required仅在\"至少勾选一个\"时生效，若需要\"勾选特定数量\"（如至少2个兴趣），需用JavaScript实现，HTML原生无法满足。 10.3 下拉选择框 <select> + <option>——大量选项的\"空间优化师\" 当选项数量较多（如\"省份\"\"城市\"\"职业\"）时，用单选按钮会占用大量页面空间，而下拉选择框能将选项折叠，点击后展开选择，极大节省布局空间。 10.3.1 基本结构：容器与选项的配合 下拉选择框由两个标签配合组成： <select>：容器标签，定义\"下拉选择框\"整体，name属性用于服务器识别数据 <option>：选项标签，每个<option>对应一个可选值，value是提交给服务器的数据，标签内文字是显示给用户的内容 基本语法如下（以\"选择城市\"为例）： 占位提示的技巧：第一个<option>设为value=\"\"，文字为\"--请选择--\"，避免用户误选默认值（若直接默认选\"北京\"，可能不符合用户实际城市）。 默认选中（selected）：若需要默认选中某选项，给对应的<option>添加selected属性： 10.3.2 扩展功能：多选与分组 （1）允许多选（multiple） 给<select>添加multiple属性，可实现\"多选\"功能（需按住Ctrl键/Command键选择多个选项）： size属性：控制下拉框\"展开时显示的选项数量\"，默认是1（仅显示当前选中项），设为3则显示3个选项，减少滚动操作。 （2）选项分组（<optgroup>） 当选项需要分类（如\"水果\"按\"温带/热带\"分组）时，用<optgroup>标签给选项分组，提升可读性： 注意：<optgroup>仅用于分组，本身不可点击选择，用户只能选里面的<option>。 10.4 多行文本域 <textarea>——长文本输入的\"专属容器\" 单行文本框（<input type=\"text\">）无法输入换行内容，而多行文本域（<textarea>）专门用于输入\"多行长文本\"，如\"留言评论\"\"个人简介\"\"反馈内容\"等。 10.4.1 基本语法与核心属性 <textarea>是双标签（需闭合），基本语法如下： rows与cols的局限性：这两个属性是\"字符维度\"的大小控制（如rows=\"5\"表示能显示5行文字），但不同字体、浏览器下字符大小不同，实际开发中更推荐用CSS控制宽高（更灵活）： 默认值设置：若需要显示默认文本（如\"请在这里填写反馈\"），直接在<textarea>标签内部写入内容： 10.4.2 常见问题与解决方案 （1）禁止拉伸大小 默认情况下，<textarea>右下角有一个\"拉伸手柄\"，用户可随意改变其大小，可能导致页面布局混乱。用CSS的resize属性禁止拉伸： resize可选值：none（禁止拉伸）、both（默认，双向拉伸）、horizontal（仅水平拉伸）、vertical（仅垂直拉伸）。 （2）换行符的处理 用户在<textarea>中输入的换行，提交到服务器后会以\"换行符\"（\\n或\\r\\n）的形式存储。若后端直接将数据显示在网页上，换行符会被解析为\"空格\"，导致文字挤在一起。 解决方案：后端显示时，将\\n替换为HTML的换行标签<br>，或给容器添加CSS样式white-space:pre-wrap;（保留换行和空格）。 实战案例：组合控件制作\"用户信息表\" 将本章控件组合，实现一个包含\"性别（单选）、兴趣（复选）、城市（下拉）、个人简介（多行）\"的表单，代码如下： 第11章 丰富的表单控件（下）与表单进阶 11.1 HTML5新增的输入类型——让输入更\"智能\" HTML5之前，所有文本类输入都依赖<input type=\"text\">，需手动通过JS验证格式（如邮箱、日期）；HTML5新增的输入类型，不仅能自动适配输入场景（如日期弹出日历、数字只允许输数值），还能原生实现基础格式验证，极大减少代码量并提升用户体验。 以下是5个最常用的新增类型，按\"使用频率\"和\"实用价值\"排序讲解： | 输入类型 | 核心作用 | 关键属性 | 浏览器表现 | 适用场景 | |----------|----------|----------|------------|----------| | email | 收集邮箱地址，自动验证格式 | 无特殊属性（可结合required） | 移动端弹出\"带@的键盘\"，提交时校验是否含@和域名（如xxx@xxx.com） | 注册页邮箱输入、找回密码邮箱填写 | | url | 收集网址，自动验证格式 | 无特殊属性 | 移动端弹出\"带.com的键盘\"，提交时校验是否含http://或https:// | 个人博客地址、分享链接输入 | | number | 收集数值（整数/小数），限制输入内容 | min（最小值）、max（最大值）、step（步长，默认1） | 输入框右侧带\"上下箭头\"（点击可增减数值），仅允许输入数字、-、. | 年龄（min=0,max=150）、商品数量（min=1）、评分（step=0.5） | | date | 收集日期，避免手动输入格式错误 | min（最小日期）、max（最大日期） | 弹出系统原生日历选择器（无需自己写日历组件），值格式固定为YYYY-MM-DD | 出生日期、预约日期、订单日期 | | range | 收集\"非精确数值\"，通过滑块选择 | min、max、step | 显示横向滑块（无输入框），拖动即可选择数值，默认不显示当前值 | 音量调节、亮度调节、评分星级（非精确）、筛选范围（如\"价格区间1-10\"） | 关键避坑与扩展技巧 兼容性处理： 旧浏览器（如IE8及以下）不支持这些新增类型，会自动降级为<input type=\"text\">。若需兼容旧浏览器，需额外通过JavaScript补充验证逻辑（如邮箱格式校验）。 date类型的格式问题： 无论用户选择哪个日期，浏览器提交给服务器的格式永远是YYYY-MM-DD（如2024-10-01），后端接收时需按此格式解析，避免因\"2024/10/01\"\"10-01-2024\"等格式导致数据错误。 range类型显示当前值： 滑块默认不显示选中的数值，需结合<output>标签和JavaScript实现\"实时显示\"，示例如下： 11.2 表单属性：placeholder, required, disabled, readonly——控制输入规则与交互体验 4个核心属性详解（含对比与避坑） placeholder - 输入框内的\"提示文字\"，用户输入后自动消失 适用场景：告诉用户\"该填什么内容\"（如\"请输入手机号\"） 注意事项： 不能替代<label>（屏幕阅读器可能不读取placeholder） 默认文字颜色较浅，可通过CSS自定义（::placeholder { color: #999; }） 示例：<input type=\"text\" placeholder=\"请输入用户名\"> required - 标记为\"必填项\"，未填写时阻止表单提交，并弹出原生提示 适用场景：注册页的用户名、密码、邮箱等必须填写的字段 关键注意事项： 原生提示样式无法直接修改，需通过JS自定义验证反馈 不能替代后端验证（前端验证可被绕过，后端必须再校验一次） 示例：<input type=\"password\" required> disabled - 禁用控件（灰化显示），用户无法点击、输入或选中，值不会提交到服务器 适用场景： 条件不满足时禁用提交按钮（如\"未同意协议则禁用\"） 显示\"不可操作的历史数据\"（如已过期的订单状态） 关键注意事项： 禁用后控件样式会变灰，可通过CSS调整（input:disabled { opacity: 0.8; }） 若需\"显示但可复制\"，用readonly而非disabled 示例：<button type=\"submit\" disabled>提交（需同意协议）</button> readonly - 控件\"只读\"（用户可选中、复制内容，但不能修改），值会提交到服务器 适用场景： 显示用户的\"不可修改信息\"（如会员ID、注册时间） 编辑页回显\"已确认的信息\"（如身份证号，仅允许查看不允许修改） 关键注意事项： 只读控件仍可聚焦，与disabled（无法聚焦）的核心区别 对单选/复选框无效（单选/复选需用disabled禁用选择） 示例：<input type=\"text\" value=\"VIP12345\" readonly> 易混淆属性对比：disabled vs readonly 很多初学者会混淆这两个属性，核心区别用表格明确： | 对比维度 | disabled | readonly | |----------|----------|----------| | 用户交互 | 完全不可交互（不能点击、输入、聚焦） | 可交互（可选中、复制，不能修改） | | 数据提交 | 控件值不提交到服务器 | 控件值会提交到服务器 | | 适用控件 | 所有控件（文本框、按钮、单选、复选） | 仅文本类控件（文本框、textarea），对单选/复选无效 | | 样式表现 | 灰化显示，默认opacity较低 | 正常显示（无灰化），仅禁止修改 | 11.3 使用<label>提升表单可访问性和体验 <label>标签是表单\"可访问性\"的核心——它的本质是\"将文字提示与输入控件关联\"，解决了\"精准点击输入框\"的痛点，同时适配屏幕阅读器（帮助视障用户理解输入框用途）。 两种关联方式（推荐第二种） 方式1：for属性+id属性（分离式） 通过label的for属性，关联到input的id属性（for的值必须与id完全一致）： 适用场景：文字提示与输入框不在同一行（如表单布局为\"文字左对齐，输入框右对齐\"）。 方式2：包裹式（嵌套关联） 将input直接包裹在label内部，无需for和id，简洁高效： 适用场景：文字提示与输入框紧密关联（如同一行显示），是日常开发中最常用的方式。 好处：为什么必须用<label>？（3个核心价值） 提升用户体验：用户无需精准点击输入框的小区域，<label>标签能让点击文字时自动聚焦对应输入框，尤其在移动端（手指点击精度低）体验提升明显。 优化可访问性：屏幕阅读器会读取<label>的文字，并关联到输入框，告知视障用户\"这个输入框是用来填什么的\"（若没有<label>，视障用户可能无法理解输入框用途）。 避免布局错位：若用普通<span>代替<label>，当输入框被隐藏（如动态表单）时，文字提示可能脱离关联，导致逻辑混乱；<label>会始终与输入框保持关联。 11.4 大型实战：制作一个完整的用户注册表单 学习收获： 掌握多种输入控件的用法 理解表单结构与交互流程 能够独立制作常见的登录、注册等功能界面"
    },
    {
      "title": "第五篇《现代HTML实践——迈向专业前端》",
      "path": "HTML/第五篇《现代HTML实践——迈向专业前端》.md",
      "category": "HTML",
      "tags": [],
      "date": null,
      "description": "当我们掌握了HTML的基本语法与结构后，就要开始迈向更专业的方向。现代前端开发不仅要求页面“能用”，还要求“好用”“快”“对所有人友好”。\n\n本篇将带你从三个方面迈向专业：数据展示、可访问性、性能与SEO优化。\n\n\n\n在网页开发中，“结构化数据展示” 是核心需求之一 —— 比如学生成绩、商品报价、课程安排等，这类数据需要清晰的行列关系才能让用户快速理解。HTML 表格（<table>）正是为解决这",
      "content": "第五篇《现代HTML实践——迈向专业前端》 当我们掌握了HTML的基本语法与结构后，就要开始迈向更专业的方向。现代前端开发不仅要求页面“能用”，还要求“好用”“快”“对所有人友好”。 本篇将带你从三个方面迈向专业：数据展示、可访问性、性能与SEO优化。 第12章 表格：规整地展示数据 在网页开发中，“结构化数据展示” 是核心需求之一 —— 比如学生成绩、商品报价、课程安排等，这类数据需要清晰的行列关系才能让用户快速理解。HTML 表格（<table>）正是为解决这个问题而生，本章将从 “基础结构→增强功能→复杂场景” 逐步拆解表格的使用逻辑，确保你既能写出正确的表格，也能写出符合现代开发规范的表格。 12.1 表格的基本结构：<table>、<tr>、<td>，三大核心标签 表格的最小可用单元由 3 个标签构成，缺一不可。我们可以把表格类比成 \"记事本中的格子纸\"：<table>是整张纸，<tr>是纸上的一行，<td>是行中的一个小格子。 12.1.1 核心标签功能拆解 | 标签 | 英文全称 | 作用描述 | 层级关系 | |------|----------|----------|----------| | <table> | Table | 表格的 \"容器\"，包裹所有表格内容 | 最外层，父容器 | | <tr> | Table Row | 表格的 \"一行\"，包裹该行所有单元格 | 直接子元素（必须在<table>内） | | <td> | Table Data Cell | 表格的 \"单元格\"，存放具体数据（文字 / 图片等） | 直接子元素（必须在<tr>内） | 12.1.2 基础示例与解析 以下是一个 “2 行 2 列” 的简单表格（展示 “姓名 - 成绩” 对应关系）： 结构逻辑：1 个<table>包含 2 个<tr>（2 行），每个<tr>包含 2 个<td>（2 列），确保 \"每行单元格数量一致\" 是表格结构正确的核心（否则会出现错位）。 提示：示例中如果加border=\"1\"（如原文代码），会显示默认边框，但这是旧时代的写法—— 现代前端强调 \"结构与样式分离\"（HTML 管结构，CSS 管样式），因此推荐用以下 CSS 控制表格样式： 12.2 表格的标题与表头：<caption>、<th>，标题与表头（提升可读性 + 可访问性） 基础表格能展示数据，但缺乏 “数据说明”—— 比如 “这张表是做什么的？”“每一列代表什么含义？”。<caption>和<th>标签就是为解决这些问题而生，同时还能提升网页可访问性（帮助残障用户通过屏幕阅读器理解表格）。 12.2.1 两个增强标签的核心作用 <caption> - Caption 表格的 \"总标题\"，说明表格整体用途。必须放在<table>内、所有<tr>之前。 <th> - Table Header Cell 表格的 “表头单元格”，说明列 / 行的含义。默认样式：文字加粗 + 居中；屏幕阅读器可识别。 12.2.2 增强示例与解析 以下是添加了标题和表头的 “学生成绩表”，对比基础表格更易读： 可读性提升：用户打开页面能立刻通过<caption>知道表格主题，通过<th>知道每列数据的含义，无需 \"猜数据\"。 可访问性提升：屏幕阅读器会自动朗读 “表格标题：2024 年秋季学期语文成绩表，表头：姓名、语文成绩、排名”，视障用户能清晰理解表格结构（这是<td>无法实现的）。 12.3 复杂表格：<thead>、<tbody>、<tfoot>、rowspan、colspan，应对实际场景（分组 + 跨行列） 在实际开发中，我们会遇到更复杂的表格需求 —— 比如 “带汇总行的报表”“跨行的课程表”。这时需要用表格分组标签（<thead>/<tbody>/<tfoot>)和跨行列属性（rowspan/colspan）来实现。 12.3.1 表格分组：让结构更清晰（<thead>/<tbody>/<tfoot>） 当表格数据量较大时（比如 100 行数据），“表头、数据、汇总” 混在一起会导致结构混乱。分组标签的作用是 “给表格分块”，同时支持单独控制样式（如表头固定）和提升可维护性。 分组标签功能拆解： <thead> - Table Head 表格的 \"表头区域\"，包含列说明（<th>） <table>内，必须在<tbody>之前 <tbody> - Table Body 表格的 “数据主体区域”，包含所有实际数据 <thead>之后、<tfoot>之前（可多个） <tfoot> - Table Footer 表格的 “表尾区域”，包含汇总 / 备注信息 可在<tbody>之前或之后（浏览器会自动放到底部） 分组示例：带更新时间的课程表： 实际用途： 样式控制：给<thead>加background-color: #f5f5f5，让表头和数据区分开； 动态更新：如果表格数据需要异步加载（比如从服务器获取），只需更新<tbody>即可，无需动表头和表尾。 12.3.2 跨行列：处理 “合并单元格” 场景（rowspan/colspan） 当数据存在 \"跨行 / 跨列关联\" 时（比如 \"周一和周二上午都上同一门课\"\"表尾备注需要占满所有列\"），需要用rowspan（跨行）和colspan（跨列）属性实现单元格合并。 跨行列属性核心逻辑： rowspan 单元格 “跨行” 数字（代表跨越的行数） 一门课占 “周一 + 周二”2行 → rowspan=\"2\" colspan 单元格 “跨列” 数字（代表跨越的列数） 备注占 “星期 + 上午 + 下午”3列 → colspan=\"3\" 跨行列示例：带合并单元格的课程表： 关键注意事项： 跨行后，下一行需 “少写一个<td>”：比如示例中 “周一” 的<td rowspan=\"2\">占了 2 行，所以 “周二” 的<tr>里只需要写 “下午” 的<td>（否则会多一列导致错位）； 取值不要超过实际行列数：比如表格只有 3 列，colspan=\"4\"会导致表格结构错乱； 优先用 “结构简化”：能不合并就不合并，过度合并会增加维护成本（比如后续修改课程时，容易忘记调整rowspan值）。 12.3.3 小结：表格学习重点 基础结构：牢记<table>（容器）→ <tr>（行）→ <td>（单元格）的层级关系，确保每行单元格数量一致； 增强功能：用<caption>写表格标题，用<th>写表头（提升可读性 + 可访问性）； 复杂场景：用<thead>/<tbody>/<tfoot>分组（结构清晰 + 样式可控），用rowspan/colspan处理合并单元格（按需使用，避免过度）； 现代规范：拒绝用border等 HTML 属性控制样式，全部交给 CSS（结构与样式分离）。 12.4 实战：制作一个课程表 通过以上知识，我们可以轻松完成一个漂亮的课程表，并用CSS美化样式： 通过<link rel=\"preload\">，你可以 “主动告诉浏览器”：“这个资源很重要，不管解析到哪里，先提前加载好”—— 相当于 “给关键资源开绿灯”，缩短首屏渲染时间。 通过预加载，你可以告诉浏览器“先准备好关键资源”。 14.3.1 基础用法：必须掌握的 2 个属性 核心属性解析： href：资源的 URL 路径（绝对路径或相对路径均可）； as：资源类型（必须准确，否则浏览器会忽略预加载，甚至报错），常见类型： | as值 | 对应资源类型 | 示例 | |------|-------------|------| | style | CSS 样式表 | href=\"main.css\" as=\"style\" | | script | JavaScript 文件 | href=\"app.js\" as=\"script\" | | image | 首屏关键图片（如 banner） | href=\"banner.webp\" as=\"image\" | | font | 自定义字体文件（如思源黑体） | href=\"simhei.woff2\" as=\"font\" type=\"font/woff2\" | 14.3.2 关键注意事项：避免 \"滥用导致反效果\" 预加载虽好，但不能随意用—— 每一个预加载的资源都会占用浏览器的 “并发请求数” 和带宽，若加载非关键资源，会挤压其他资源的加载时间，反而变慢。 正确场景（只预加载以下资源）： 首屏必须的 CSS（如main.css，没有它页面会 \"无样式\"）； 阻塞交互的核心 JS（如app.js，控制首页按钮点击、表单验证）； 首屏关键图片（如顶部 banner，没有它首屏会 “缺内容”）。 错误场景（禁止预加载）： 非首屏资源（如下一页的 CSS、底部的广告图片）； 可延迟加载的资源（如统计 JS、聊天插件）； 重复预加载（同一资源多次用rel=\"preload\"，浪费带宽）。 14.3.3 与 <link rel=\"prefetch\"> 的区别：别混淆 \"当前\" 与 \"未来\"” 很多开发者会把preload和prefetch搞混，两者的核心区别是 “加载时机” 和 “用途”： | 类型 | 核心用途 | 加载时机 | 适用场景示例 | |------|----------|----------|----------------| | preload | 加载 “当前页面必须的关键资源” | 解析到标签就加载 | 首屏 CSS、核心 JS、banner 图 | | prefetch | 加载 “未来可能用到的资源” | 空闲时才加载 | 下一页的 JS（如点击 “下一章” 会用到的chapter2.js） | rel=\"preload\"； 加载 “当前页面必须的关键资源” ；优先级高，解析到标签就加载 首屏 CSS、核心 JS、banner 图 示例对比： 小结： HTML 性能与 SEO 优化的 “3 个核心” SEO 优化：让搜索引擎 “看懂” 你的网页 用<title>传递核心关键词（前置、唯一、简洁）； 用<meta name=\"description\">写 “吸引人的摘要”（提升点击率）； 用<meta charset=\"UTF-8\">确保内容正常显示（基础保障）。 图片优化：解决 “加载慢” 的最大痛点 加width/height防止布局偏移（优化 CLS）； 首屏外图片用loading=\"lazy\"按需加载； 选 WebP/AVIF 格式 + 压缩，让图片 “变轻”。 资源预加载：让关键资源 “提前就位” 用rel=\"preload\"加载首屏 CSS、核心 JS（缩短白屏时间）； 不滥用，只预加载 “当前页面必须的资源”； 区分preload（当前）和prefetch（未来），避免浪费带宽。 这一篇，我们从三个角度提升了HTML开发的“专业度”： 方向 学习重点 表格 用结构化数据清晰展示信息 可访问性 让每个用户都能无障碍访问 性能与SEO 优化加载速度与搜索引擎友好度。"
    },
    {
      "title": "第六篇：实战与未来——从学会到用好",
      "path": "HTML/第六篇：实战与未来——从学会到用好.md",
      "category": "HTML",
      "tags": [],
      "date": null,
      "description": "第六篇：实战与未来——从学会到用好\n\n学完前面的知识，你已经能看懂大多数网页的基础结构，也能写出不少小型页面。接下来，就要把这些零散的知识拼装成一个真正的“作品”。只有在实战中碰到各种细节问题，你才能真正理解一门语言。\n\n而在熟练之后，你也会忍不住问一句：HTML的边界到底在哪里？它还能带我去多远？\n\n这一篇，就是你的“出门右转”。\n\n\n\n在这一章，我们将从零开始构建一个完整的静态网站。它不依赖任",
      "content": "第六篇：实战与未来——从学会到用好 学完前面的知识，你已经能看懂大多数网页的基础结构，也能写出不少小型页面。接下来，就要把这些零散的知识拼装成一个真正的“作品”。只有在实战中碰到各种细节问题，你才能真正理解一门语言。 而在熟练之后，你也会忍不住问一句：HTML的边界到底在哪里？它还能带我去多远？ 这一篇，就是你的“出门右转”。 第15章 大型综合实战：从头开始构建一个静态网站 在这一章，我们将从零开始构建一个完整的静态网站。它不依赖任何框架，没有复杂的工具链，只靠你熟悉的 HTML 标签与规范做出一个可上线的迷你站点。 目标是让你真正体验到“把一张白纸变成一个网站”的全过程。 15.1 项目分析与结构设计 在写代码前，一定要知道你要做什么。这一步就像盖房子前先画图纸。 网站主题 我们将以“个人知识库介绍站点”为例。你可以把它理解为： 主页是介绍、作品展示、联系方式，多页面相互链接，简单但结构完整。 页面规划 常见页面结构如下： index.html：首页 about.html：关于我 notes.html：知识库索引 contact.html：联系表单 gallery.html：图片或作品展示页面 你可以视情况增减，但一个小型网站一般会落在 3 到 8 页之间。 文件组织结构 推荐使用如下目录结构： 清晰的结构可以让未来维护变得轻松，尤其是当你的内容越来越多时。 15.2 编写所有页面的 HTML 结构 这里我们不会贴大量代码，而是指导你按照步骤“组装”页面。 每个页面都应该包含的基础结构： <header>：站点标题与导航菜单 <main>：页面主体 <footer>：版权、备案或社交链接 统一的 <nav> 导航栏 一致的 <title> 前缀，如 \"我的知识库 | 首页\" 示例结构（概念性模板）： 把这个基础结构复用在所有页面上，浏览体验会更专业。 15.3 整合表单、表格、多媒体等所有元素 这一部分的目标是让你把前面学过的 HTML 元素“打包上阵”。 表单（contact.html） 你可以使用： <form> <input>（text、email） <textarea> <button> <fieldset> / <legend> <label> 示例用途：收集访客留言。 表格（notes.html） 用 <table> 展示你的学习记录或知识分类。 例如： 分类 笔记数量 最后更新时间 图片与视频（gallery.html） 用 <img>、<video>、<figure> 展示你的作品或素材集合。 添加 <figcaption> 让页面更具可读性。 语义化补强 适时使用： <section> <article> <aside> <time> <blockquote> 这些标签能让你的网站读起来更像“内容”，而不是杂乱的堆叠。 15.4 代码复查与优化 在项目结束前，我们要做一次“质量巡检”。 主要包括： 检查标签是否闭合 不匹配的标签是最常见的错误。 图片是否有 alt 属性 这是无障碍与SEO的重要基础。 链接是否全部能正确跳转 是否重复使用一些结构 可考虑提取公共部分（如 header/footer）到未来的模板引擎中。 文件命名与路径是否统一 静态网站虽然简单，但耐心与规范会让你走得更远。 第16章 进阶之路：HTML还能做什么？ 当你掌握了基础 HTML 后，就会发现它远不只是“画静态骨架”。HTML 还在不断进化，而且其中一些能力直接决定了现代网站的表现力。 让我们看看下一步你可以往哪里走。 16.1 下一代图片格式与 <picture> 标签 现代网页越来越重视性能。WebP、AVIF 这类新一代图片格式比 JPG/PNG 更轻、更快。 <picture> 可以让浏览器根据环境自动选择最优图像： 优势： 自适应加载 适配暗色模式 针对不同分辨率输出不同图片 这是前端性能优化的起点。 16.2 原生弹出框：<dialog> 元素 过去你需要 JS 拼一个\"弹窗模块\"，现在只需要一个标签。 优点： 无需自造 UI 结构 自动居中 支持模态模式 无障碍友好 这是 HTML 进入“原生组件时代”的标志。 16.3 Web Components 简介：创建你自己的 HTML 标签 Web Components 让你可以创造自己的标签，例如 <my-card>、<user-profile>、<note-item>。 为什么需要 Web Components？ 传统 HTML 的局限性很明显： 自带标签（如<div>、<p>、<button>）功能单一，想实现 \"用户卡片\"\"商品列表项\" 这类重复 UI，每次都要写一堆嵌套标签 + CSS，代码冗余； 样式冲突：页面中不同模块的 CSS 可能互相干扰（比如两个地方都写.card{border:1px solid #000}，后加载的会覆盖前一个）； 逻辑分散：组件的 HTML 结构、CSS 样式、交互逻辑往往散落在页面不同地方，维护麻烦。 Web Components 的核心目标就是解决这些问题 ——把 UI 模块封装成一个 \"自定义 HTML 标签\"，比如<user-card>、<product-item>，用的时候像用<div>一样简单，且内部样式 / 逻辑完全独立。 虽然要用到 JavaScript，但核心思想很简单： 自定义元素 Shadow DOM 隔离样式 可复用组件化结构 这让 HTML 从“使用标签”扩展到“发明标签”。未来你看到的网页上那些神奇的 UI 很可能就是这样被封装的。 16.4 总结与未来学习方向（CSS、JavaScript） HTML 是基础中的基础，但它不是终点。 作为《HTML 入门到精通》的“收尾与启航”章节，核心是帮你理清 HTML 之后该往哪走。 一、先复盘：你已掌握的 HTML 能力，是后续学习的“地基” 在学后续内容前，先明确你已经拥有的“基础武器库”——这些能力是 CSS、JavaScript 发挥作用的前提： 内容承载：用 <p>/<h1>/<span> 等标签组织文本，用 <img>/<video> 嵌入多媒体，满足\"页面有内容\"的基本需求； 结构逻辑：用 <header>/<nav>/<main>/<footer> 等语义化标签搭建页面骨架，让代码“有逻辑、易维护”（而非全靠 <div> 堆结构）； 功能基础：用 <table> 展示结构化数据（如知识库索引），用 <form>+<input> 实现用户交互（如联系表单），甚至能用 <picture>/<dialog> 等现代标签优化体验； 简单说：HTML 已经帮你搭好了“房子的框架”，但这个框架还“没装修（缺样式）”“不能动（缺交互）”“没法批量复制和交付（缺工程化）”——这正是后续三大路径要解决的问题。 二、拆解三大成长路径：从“能用”到“专业” 路径1：CSS——给HTML\"装修\"，让页面\"像样\" HTML 是\"骨架\"，CSS 就是\"皮肤、装修、布局\"——它的核心目标是 \"让页面好看、有排版、适配不同设备\"。 路径2：JavaScript——给HTML\"注入灵魂\"，让页面\"动起来\" 如果说 CSS 让页面\"好看\"，JavaScript（简称 JS）就让页面\"能交互、有逻辑、能连接数据\"——它的核心目标是 \"让页面从'静态图片'变成'可操作的工具'\"。 关键认知：JS 是“HTML 的‘操作系统’”——它能操作 HTML 元素（比如修改文本、隐藏/显示元素）、操作 CSS 样式（比如点击后改变卡片颜色），甚至能完全重写页面内容。没有 JS，网页只能是“看的”；有了 JS，网页才能是“用的”（比如知乎、淘宝、抖音这类应用，核心都是 JS 驱动）。 路径3：工程化——让开发\"高效、可靠\"，从\"写代码\"到\"做项目\" 当你能用 HTML+CSS+JS 写出单个页面后，会遇到新问题：\"项目变大了怎么办？\"\"多人一起写代码冲突了怎么办？\"\"怎么把代码放到网上让别人访问？\"——工程化就是解决这些问题的\"方法论+工具链\"，核心目标是 \"让你能高效、稳定地开发和交付'大型项目'\"。 工程化的“入门必备”的5 个点： 模块化：解决“代码混乱、难复用” 把庞大的 JS/CSS 代码拆成“小模块”（比如一个 JS 文件专门处理表单逻辑，一个 CSS 文件专门写导航栏样式），每个模块“功能单一、可复用”——避免把所有代码堆在一个文件里，导致“改一行代码，全页出问题”。 构建工具：解决\"代码'不能直接用'\" 写好的代码（比如 ES6 语法的 JS、SCSS 语法的 CSS），部分浏览器可能不支持；而且代码里可能有注释、空格，体积大、加载慢——构建工具（如 Vite、Webpack）能帮你\"处理代码\"： 转换：把浏览器不支持的语法（如 ES6）转成支持的语法 压缩：去掉注释、空格，让代码体积变小（加载更快） 合并：把多个小 JS/CSS 文件合并成少数几个，减少浏览器请求次数 项目结构：解决\"文件乱放、难找\" 规范文件的存放位置（比如之前的 /assets/images//styles），并扩展到 JS 模块、组件、接口请求等——比如： 这样不管项目多大，别人接手时都能\"快速找到想要的文件\"。 Git：解决“代码版本混乱、丢失” Git 是“版本控制工具”——它能记录你每次修改代码的内容，比如： 你今天改了 CSS 导致页面错乱，能随时“回退”到昨天能正常运行的版本 多人一起开发时，能合并各自的代码（避免“你改了导航栏，我又把导航栏代码删了”的冲突） 这是专业开发的“标配”——没有 Git，代码丢了、改乱了都没法补救。 部署到线上：解决\"代码'只能自己看'\" 写好的代码在自己电脑上能运行，但别人看不到——部署就是\"把代码放到服务器上，让所有人能通过网址访问\"。 简单的部署方式：用 Vercel、Netlify 等平台，上传代码后自动生成一个网址（比如 your-project.vercel.app）；复杂的方式：买服务器（如阿里云、腾讯云），把代码传到服务器上配置运行。 三、总结：三条路径的关系——缺一不可的\"专业前端闭环\" \"这是从初级到中级、再到专业的必经之路\"，核心原因是这三条路径是 \"互相依赖、缺一不可\" 的： 没有 CSS：JS 再强，页面也是\"没装修的骨架\"，用户体验差 没有 JS：CSS 再好看，页面也是\"不能动的图片\"，没法实现核心功能（如表单提交、数据加载） 没有工程化：HTML+CSS+JS 能写小页面，但一旦项目变大（比如 10+ 页面、多人协作），就会\"代码混乱、维护不了、上线困难\" 简单说： 初级前端：能靠 HTML+CSS 写静态页面 中级前端：能靠 JS 给页面加交互、连数据 专业前端：能靠工程化，高效、稳定地交付大型项目（比如电商网站、后台系统） 最后：给初学者的学习顺序建议 如果你刚学完 HTML，不用同时学三条路径，建议按“CSS → JavaScript → 工程化”的顺序推进： 先学 CSS：用 Flexbox/Grid 把页面布局和样式搞懂，先做出“好看的静态页面”（比如把你的“个人知识库”页面装修好） 再学 JavaScript：从“操作 DOM（修改 HTML/CSS）”开始，逐步学交互、逻辑、API 通讯（比如给联系表单加验证、让知识库索引自动加载数据） 最后学工程化：当你能写多个页面后，再学 Git、构建工具（如 Vite），尝试把项目部署到线上——这时你就已经具备“中级前端”的核心能力了"
    },
    {
      "title": "HTML 目录",
      "path": "HTML/HTML 目录.md",
      "category": "HTML",
      "tags": [],
      "date": null,
      "description": "- 1.1 网站、网页与HTML的关系\r\n- 1.2 浏览器：我们看网页的窗口\r\n- 1.3 HTML、CSS、JavaScript的分工合作\r\n- 1.4 开发环境搭建与第一个网页\r\n\r\n\r\n- 2.1 DOCTYPE声明与HTML版本\r\n- 2.2 html、head、body三大核心结构\r\n- 2.3 meta标签与页面元信息\r\n- 2.4 字符编码与国际化\r\n\r\n\r\n\r\n\r\n- 3.1 标",
      "content": "HTML 完整教程目录 HTML：网页结构的基石 第一篇 初识HTML——走进网页的世界 第1章 网页是什么：揭开网站的神秘面纱 1.1 网站、网页与HTML的关系 1.2 浏览器：我们看网页的窗口 1.3 HTML、CSS、JavaScript的分工合作 1.4 开发环境搭建与第一个网页 第2章 HTML文档结构：认识HTML的骨架 2.1 DOCTYPE声明与HTML版本 2.2 html、head、body三大核心结构 2.3 meta标签与页面元信息 2.4 字符编码与国际化 第二篇 HTML基础语法——从零开始写代码 第3章 标签与元素：HTML的基本语法 3.1 标签的基本结构和语法规则 3.2 属性与属性值的使用 3.3 块级元素与行内元素 3.4 HTML注释与代码规范 第4章 文本内容标签：让网页有内容 4.1 标题标签（h1-h6）的正确使用 4.2 段落、换行与文本格式化 4.3 强调与重要性标签 4.4 引用与代码显示 第三篇 构建网页内容——让页面丰富起来 第5章 链接与导航：连接网页的桥梁 5.1 超链接的创建与属性 5.2 内部链接与外部链接 5.3 锚点跳转与页面导航 5.4 下载链接与邮件链接 第6章 图像与媒体：让网页更生动 6.1 图片标签与属性详解 6.2 图片格式选择与优化 6.3 响应式图片与picture元素 6.4 音频与视频嵌入 第7章 列表与结构：组织信息的艺术 7.1 有序列表与无序列表 7.2 描述列表与术语定义 7.3 列表嵌套与样式控制 7.4 导航列表的最佳实践 第8章 表格数据：结构化信息展示 8.1 表格基础结构（table、tr、td） 8.2 表头与表尾的使用 8.3 单元格合并与复杂表格 8.4 表格的语义化与无障碍 第四篇 表单与交互——连接用户与服务器 第9章 表单基础：用户输入的入口 9.1 form元素与表单属性 9.2 基础输入控件（text、password、email等） 9.3 多选与单选控件 9.4 下拉选择与文本域 第10章 现代表单元素：HTML5的增强功能 10.1 日期时间输入控件 10.2 数字与范围输入 10.3 文件上传与进度条 10.4 表单验证与用户体验 第11章 表单处理与提交：数据的传递 11.1 表单提交方法（GET vs POST） 11.2 表单数据编码与传输 11.3 表单验证策略 11.4 无障碍表单设计 第五篇 现代HTML实践——迈向专业前端 第12章 语义化HTML：让代码更有意义 12.1 HTML5语义化标签详解 12.2 页面结构的最佳实践 12.3 微数据与结构化数据 12.4 SEO友好的HTML编写 第13章 嵌入内容与API：扩展网页能力 13.1 iframe内联框架的使用 13.2 嵌入式内容（object、embed） 13.3 Canvas与SVG集成 13.4 Web API的HTML接口 第14章 移动端适配：响应式HTML基础 14.1 viewport元标签配置 14.2 移动端友好的HTML结构 14.3 触摸友好的交互元素 14.4 性能优化与加载策略 第六篇 实战与未来——从学会到用好 第15章 HTML最佳实践：专业开发规范 15.1 代码组织与文件结构 15.2 命名规范与团队协作 15.3 性能优化技巧 15.4 调试工具与开发流程 第16章 现代HTML特性：面向未来的技术 16.1 Web Components基础 16.2 Custom Elements自定义元素 16.3 Shadow DOM与样式隔离 16.4 未来学习方向指引 --- 特别补充篇（番外） A.1 HTML实体与特殊字符 A.1.1 HTML实体的作用与语法 A.1.2 常用实体字符速查 A.1.3 Unicode字符与国际化 A.2 元素类型详解 A.2.1 块级元素与行内元素对比 A.2.2 行内块元素的特点 A.2.3 元素类型转换与应用 A.3 高级特性补充 A.3.1 引用元素（blockquote、cite） A.3.2 页面加载流程与优化 A.3.3 内联框架高级用法 --- 学习路径建议 🎯 初学者路径（第1-2篇） 目标：掌握HTML基础语法和文档结构 理解HTML的作用和基本概念 掌握标签、属性、元素的基本语法 能够创建简单的网页结构 📋 内容构建路径（第3篇） 目标：丰富网页内容和媒体元素 掌握链接、图片、列表、表格的使用 理解内容组织的最佳实践 能够构建内容丰富的网页 🔗 交互功能路径（第4篇） 目标：实现用户交互和数据收集 掌握表单设计和数据处理 理解用户体验和无障碍设计 能够创建功能完整的表单 🚀 现代实践路径（第5-6篇） 目标：掌握现代HTML开发技能 学习语义化和SEO优化 了解移动端适配和性能优化 掌握现代HTML特性和最佳实践 📚 进阶扩展（补充篇） 目标：深入理解HTML的细节和高级特性 掌握HTML实体和特殊字符处理 理解元素类型和布局基础 了解高级特性和实践技巧 --- 教程特色 循序渐进：从基础概念到实际应用，逐步深入 实用导向：大量代码示例和实践项目 现代标准：基于HTML5标准和最佳实践 完整体系：涵盖HTML开发的各个方面 面向未来：介绍Web Components等前沿技术 --- 后续学习方向 完成HTML学习后，建议按以下顺序继续： CSS样式设计 - 美化网页外观和布局 JavaScript交互 - 添加动态功能和用户交互 前端工程化 - 现代开发工具和工作流 前端框架 - React、Vue等现代开发框架 HTML是前端开发的基石，掌握扎实的HTML基础将为后续学习奠定坚实基础！🌟 --- 附录 附录 A：HTML 面试与进阶路线图 A.1 HTML 技能等级划分 初级 HTML 开发者 必备技能： 掌握HTML基础语法和文档结构 熟悉常用标签和属性 能够创建简单的静态网页 了解表单和媒体元素的使用 常见面试题： HTML文档的基本结构 块级元素与行内元素的区别 表单提交的GET与POST方法 img标签的alt属性作用 中级 HTML 开发者 必备技能： 精通HTML5语义化标签 掌握响应式HTML结构 理解无障碍和SEO优化 能够构建复杂的表单和布局 常见面试题： HTML5新增的语义化标签 meta标签的作用和配置 表单验证的实现方法 图片优化和响应式处理 高级 HTML 开发者 必备技能： 深入理解HTML渲染机制 掌握Web Components技术 具备HTML性能优化能力 了解最新HTML标准和特性 常见面试题： 浏览器的HTML解析过程 Web Components的实现原理 HTML性能优化策略 微数据和结构化数据 A.2 学习进阶路径 第一阶段：HTML基础（1-2周） 学习目标： 理解HTML的作用和基本概念 掌握常用标签的语法和用法 能够创建基础的网页结构 第二阶段：内容丰富化（2-3周） 学习目标： 熟练使用各种内容标签 掌握表单设计和数据处理 理解用户交互的HTML实现 第三阶段：语义化实践（3-4周） 学习目标： 掌握HTML5语义化标签 理解SEO和无障碍设计 建立规范的编码习惯 第四阶段：现代特性（4-6周） 学习目标： 了解现代HTML特性 掌握性能优化技巧 跟进HTML标准发展 A.3 实战项目推荐 入门项目 个人简历页面：练习基础标签和文档结构 新闻文章页：练习语义化和内容组织 联系表单页：练习表单设计和验证 进阶项目 企业官网：练习复杂布局和导航 博客系统：练习内容管理和SEO 电商产品页：练习媒体处理和用户体验 高级项目 后台管理系统：练习复杂表单和数据展示 多媒体展示页：练习性能优化和响应式 Web组件库：练习组件化和可复用性 附录 B：HTML 开发工具与资源 B.1 开发工具 代码编辑器 VS Code：HTML智能提示、Emmet插件、Live Server WebStorm：完整的HTML开发环境 Sublime Text：轻量级HTML编辑器 浏览器开发工具 Chrome DevTools：元素检查、DOM调试 Firefox Developer Tools：网格布局调试 Safari Web Inspector：移动端调试 B.2 HTML验证工具 在线验证器 本地检测工具 B.3 HTML生成工具 模板引擎 静态站点生成器 Hugo：基于Go的快速静态站点生成器 Jekyll：GitHub Pages支持的静态站点生成器 Eleventy：现代JavaScript静态站点生成器 B.4 HTML优化工具 压缩工具 性能分析 Lighthouse：页面性能和质量评估 PageSpeed Insights：页面加载速度分析 WebPageTest：详细的性能测试 附录 C：HTML 常用代码片段库 C.1 文档结构模板 HTML5基础模板 响应式页面模板 C.2 导航组件 主导航菜单 面包屑导航 C.3 表单组件 完整联系表单 文件上传组件 C.4 媒体组件 响应式图片 视频播放器 C.5 数据展示组件 数据表格 卡片布局 --- 学习资源推荐： 官方文档： MDN HTML 文档 W3C HTML 规范 HTML Living Standard 在线学习： HTML Dog - HTML 基础教程 W3Schools HTML - 交互式HTML学习 freeCodeCamp - 免费编程课程 工具和验证： W3C Markup Validator - HTML验证工具 Can I Use - HTML特性兼容性查询 WebAIM - 无障碍性测试工具 这套HTML教程现在提供了完整的学习路径和实用资源，从基础入门到专业实践，是前端开发者学习HTML的完整指南！📚"
    },
    {
      "title": "HTML 特别补充篇（番外）",
      "path": "HTML/HTML 特别补充篇（番外）.md",
      "category": "HTML",
      "tags": [],
      "date": null,
      "description": "- A.1 实体（HTML Entities）\n- A.2 引用元素 blockquote\n- A.3 块元素、行内元素、行内块元素\n- A.4 列表全面总结（ul/ol/dl）\n- A.5 超链接与锚点跳转\n- A.6 图片格式与使用场景\n- A.7 页面加载流程\n- A.8 内联框架 iframe\n- A.9 HTML 实体大全表格（扩展）\n\n\n\nHTML 里有许多\"细节知识点\"，不算主线，但",
      "content": "HTML 特别补充篇（番外） 一、番外篇目录 A.1 实体（HTML Entities） A.2 引用元素 blockquote A.3 块元素、行内元素、行内块元素 A.4 列表全面总结（ul/ol/dl） A.5 超链接与锚点跳转 A.6 图片格式与使用场景 A.7 页面加载流程 A.8 内联框架 iframe A.9 HTML 实体大全表格（扩展） 二、前言 HTML 里有许多\"细节知识点\"，不算主线，但在项目里频繁出现。它们像散落在桌角的小螺丝，一旦遗漏就会让网页出现小 bug。 A.1 实体（HTML Entities）：解决 \"符号显示冲突\" 的核心工具 在网页中： HTML 解析器会默认把 <、>、& 等符号当作 \"语法指令\"（比如 < 代表标签开始），同时会自动合并多个空格。如果我们想原样显示这些符号或保留空格，就必须用「实体字符」（以 & 开头、; 结尾的特殊代码）代替。 核心痛点：为什么必须用实体？ 直接写符号会触发两种问题： 语法冲突：浏览器误把符号当 HTML 语法，导致页面错乱或报错。 例：想在页面显示 <div> 这个标签本身，直接写 <p><div></p>，浏览器会把 <div> 当成真实标签解析，最终页面不会显示 \"<div>\" 这几个字，反而可能多出一个空的 div 元素。 空格丢失：HTML 会自动合并连续的空格（哪怕敲 10 个空格，浏览器也只显示 1 个），无法实现 \"文字间固定间距\" 的需求。 高频使用场景 + 实例 | 需求场景 | 错误写法 | 实体正确写法 | 浏览器显示结果 | |---------|---------|------------|-------------| | 显示 \"小于号（<）\" | <p>1 < 2</p> | <p>1 &lt; 2</p> | 1 < 2 | | 显示 \"HTML 标签本身\" | <p><div></p> | <p>&lt;div&gt;</p> | <div> | | 显示 \"& 符号\" | <p>A & B</p> | <p>A &amp; B</p> | A & B | | 保留 \"多个连续空格\" | <p>你&nbsp;&nbsp;&nbsp;好</p>（3 个空格） | <p>你&nbsp;&nbsp;&nbsp;好</p> | 你&nbsp;&nbsp;&nbsp;好 | | 显示 \"版权符号（©）\" | <p>版权所有</p> | <p>版权所有 &copy;</p> | 版权所有 | 核心作用（为什么不能忽略？） 避免语法崩溃：这是最关键的 —— 比如用户输入 \"3 > 2\"，如果不用 &gt;，浏览器可能误判 > 为标签结束，导致后续代码失效。 保证显示一致性：不同浏览器对 \"特殊符号\" 的解析规则可能有差异，实体是跨浏览器统一显示的 \"通用语言\"。 提升源码可读性：用 &lt; 代替 <，其他人看源码时能明确 \"这里是要显示符号，不是标签\"，避免误解。 A.2 引用元素 blockquote（长引用）：给 “长引用” 加 “语义 + 样式” 双保险 <blockquote> 是专门用于展示 “长段落引用内容” 的标签（比如引用某篇文章的段落、名人名言、外部资料等），它不仅能自动实现 “引用样式”，更重要的是传递 “这是引用内容” 的语义（让搜索引擎、屏幕阅读器能识别）。 核心区别：为什么不用 div 加 CSS 代替？ 很多人会用 <div style=\"margin-left: 20px;\">引用内容</div> 实现缩进，但 <blockquote> 有两个不可替代的优势： 语义化：告诉浏览器 / 搜索引擎 \"这是引用的外部内容\"，而非普通文本 —— 这对 SEO（搜索引擎优化）和无障碍访问（比如屏幕阅读器会提示 \"以下是引用内容\"）至关重要。 默认样式统一：所有浏览器对 <blockquote> 的默认样式一致（块元素、左缩进、自动换行），无需额外写 CSS 就能保证跨浏览器显示统一。 关键特性 + 实例 | 特性 | 说明 | |------|------| | 块元素 | 独占一行，宽度默认 100% 父容器，不能和行内元素（如 span、a）并排显示。 | | 自动缩进 | 默认左侧有 40px 左右的缩进（不同浏览器略有差异，可通过 CSS 调整）。 | | 支持 cite 属性 | 可选，用于标注引用来源（如 <blockquote cite=\"https://xxx.com\">），不直接显示在页面，但搜索引擎能识别 | 正确实例（引用一篇技术文章的内容）： 浏览器显示效果（自动左缩进，视觉上明确区分 \"引用内容\" 和 \"普通内容\"） <blockquote> 用于引用外部内容： 语义化 HTML 是指用正确的标签描述内容的含义，而非仅通过样式来定义外观。 常见误区 误区 1：用 <blockquote> 包裹 “短引用”（如一句话）—— 短引用建议用 <q> 标签（行内元素，自动添加引号，如 <q>语义化很重要</q> 显示为 “语义化很重要”）。 误区 2：忽略 cite 属性 —— 虽然 cite 不直接显示，但标注来源能提升内容的可信度，尤其对博客、文档类网站很重要。 误区 3：用 CSS 覆盖默认样式后，觉得 <blockquote> 没用 —— 即使调整了缩进、颜色，它的 \"引用语义\" 依然存在，比 div 更专业。 A.3 块元素、行内元素、行内块元素 块元素（Block）：\"独占一行的布局块\" 块元素是页面的 \"大容器\"，天生适合做独立的布局模块（比如头部、段落、列表），核心特点是 \"霸道占地\"—— 自己占一整行，后面的元素只能在下方排列。 A.3.1.1. 核心特性（必记） | 特性 | 通俗解释 | |------|----------| | 独占一行 | 无论内容多宽，元素都会占满父容器的 \"一整行\"，后面的元素必须换行显示。 | | 宽度默认 100% | 父元素不手动设置宽度时，块元素会自动撑满它的 \"父容器\"（比如父 div 宽 800px，它就宽 800px）。 | | 高度由内容撑开 | 不手动设置高度时，元素高度会随内容多少变化（内容越多，元素越高）。 | | 支持所有盒模型属性 | 可以直接设置 width/height（宽高）、margin（外边距）、padding（内边距）。 | A.3.1.2. 常用标签： div：通用布局容器（比如包裹头部、主体、底部，是前端布局的 \"万能块\"） p：段落文本（一篇文章的每个段落都是独立块，避免段落间 \"挤在一行\"） h1–h6：标题（比如文章标题、章节标题，天生独占一行，符合阅读逻辑） ul / ol / li：列表（比如导航菜单、商品列表，每个 li 都是块元素，默认独占一行） header/footer：语义化布局块（头部、底部，本质是 \"有语义的 div\"，布局行为和 div 一致） A.3.1.3. 实例：直观看块元素的 \"独占一行\" 浏览器显示效果：h2 占满父容器的一整行（宽 600px），p 元素完全在 h2 下方，不会和 h2 并排 —— 这就是块元素的 “独占一行” 特性。 A.3.1.4. 关键注意点 块元素内部可以嵌套其他块元素或行内元素（比如 div 里可以放 h2 和 p，h2 里可以放 span） 但有例外：p 标签（段落）不能嵌套块元素（比如不能在 p 里放 div），否则浏览器会自动拆分，导致布局错乱 行内元素（Inline）：\"不换行的文字容器\" 行内元素是页面的 “文字伙伴”，天生适合包裹小块内容（比如单个词、链接），核心特点是 “紧凑占地”—— 不独占一行，能和其他行内元素 “挤在同一行”，且无法控制大小。 A.3.2.1. 核心特性（必记） | 特性 | 通俗解释 | |------|----------| | 不独占一行 | 元素宽度由内容决定，后面的行内元素可以紧跟在旁边，不会换行。 | | 宽高由内容撑开 | 元素大小完全由内容决定（比如 “链接” 两个字的宽度就是元素宽度）。 | | 仅支持部分盒模型属性 | 可以设置 padding（内边距）和 margin（外边距），但垂直方向的 margin 无效。 | A.3.2.2. 常用标签 & 实际场景 | 常用标签 | 典型场景 | |----------|----------| | span | 包裹段落中的部分文字（比如给某句话标红、加粗，不影响整体段落布局）。 | | a | 超链接（比如文章中的 \"点击查看\"，可以和文字并排，不用独占一行）。 | | em/strong | 文字强调（em 斜体、strong 加粗，仅改变文字样式，不影响布局）。 | | del | 删除线（比如商品原价上的横线，和现价并排显示）。 | A.3.2.3. 实例：行内元素 “不换行 + 无法控大小” 浏览器显示效果： span（标红文字）和 a（链接）都在 p 标签的同一行，没有换行； 虽然给 span 设了 width: 200px、给 a 设了 height: 50px，但元素大小依然由 “文字内容” 决定（标红文字多宽，span 就多宽）—— 这就是行内元素 “无法控大小” 的特性。 A.3.2.4. 关键注意点 行内元素内部只能嵌套行内元素或文本，不能嵌套块元素（比如不能在 span 里放 div），否则浏览器会强制拆分，导致样式混乱 行内元素的 “垂直 margin 无效”：比如给 a 标签设 margin-top: 20px，它不会向上移动，但设 margin-left: 20px（水平方向）是有效的 行内块（Inline-block）：“能控大小的并排元素” 行内块元素是 “中间派”—— 结合了行内元素的 “不独占一行” 和块元素的 “能控大小”，天生适合做 “需要并排且有固定大小” 的元素（比如图标、按钮、小卡片）。 A.3.3.1. 核心特性（必记） | 特性 | 通俗解释 | |------|----------| | 不独占一行 | 和行内元素一样，能和其他元素（行内 / 行内块）并排显示，不自动换行。 | | 支持手动设置宽高 | 和块元素一样，可以直接设置 width/height，元素大小由 \"手动设置\" 或 \"内容\" 决定（优先手动设置）。 | | 支持所有盒模型属性 | 可以正常设置 margin、padding（垂直方向也有效），没有行内元素的限制。 | A.3.3.2. 常用标签 & 实际场景 | 常用标签 | 典型场景 | |----------|----------| | img | 图片（比如商品图片、图标，需要并排显示且控制尺寸，比如 \"一排 3 张图，每张宽 200px\"）。 | | input | 表单控件（比如文本输入框、按钮，需要和文字或其他控件并排，且设置固定宽度）。 | | button | 按钮（比如 \"提交\"\"取消\" 按钮，需要并排显示且控制大小）。 | A.3.3.3. 实例：行内块元素 “并排 + 可控大小” img | 图片（比如商品图片、图标，需要并排显示且控制尺寸，比如 “一排 3 张图，每张宽 200px”）。 浏览器显示效果：img、input、button 三个元素并排显示（没有换行），且各自的宽高完全按手动设置生效 —— 这就是行内块元素的核心价值，解决了 “既要并排，又要控大小” 的需求。 A.3.3.4. 关键注意点 行内块元素之间会有默认的 “空白间隙”（比如两个 img 之间会有几个像素的空隙），这是因为 HTML 代码中的换行 / 空格被解析为空白字符。解决方法：给父容器设 font-size: 0，或让元素代码连写（不换行）。 A.3.3.5.三类元素核心区别对比（一目了然） | 对比维度 | 块元素（Block） | 行内元素（Inline） | 行内块元素（Inline-block） | |----------|------------------|--------------------|-----------------------------| | 是否独占一行 | 是（强制换行） | 否（可并排） | 否（可并排） | | 宽高默认值 | 宽 100% 父元素，高由内容撑开 | 宽高均由内容撑开 | 宽高均由内容撑开 | | 能否手动设宽高 | 能（width/height 有效） | 不能（设置无效） | 能（width/height 有效） | | 垂直 margin 有效性 | 有效 | 无效 | 有效 | | 典型用途 | 布局容器（头部、段落、列表） | 包裹文字（标红、链接） | 并排控件（图片、按钮、输入框） | A.3.3.6.实际开发中，选择哪种元素，只看一个需求：你需要它如何 “占地” 和 “控大小”： 要做 “独占一行的布局块”（比如页面头部、文章段落）→ 选块元素（div、h1、p）； 要包裹 “段落中的部分文字”（比如标红、加链接），且不希望换行 → 选行内元素（span、a）； 要做 “并排显示且有固定大小” 的元素（比如一排图标、两个并排按钮）→ 选行内块元素（img、button）。 此外，还可以通过 CSS 的 display 属性强制改变元素类型（比如给 div 设 display: inline-block，让它从 “独占一行” 变成 “并排且可控大小”）—— 这是前端布局的常用技巧，但前提是先理解元素的原生特性哦！ A.4 列表全面总结（ul、ol、dl） 有序列表 <ol>：“有顺序的列表，缺一个都不行” <ol>（Ordered List）的核心是列表项有 “先后逻辑”，浏览器会自动为每个项添加 “有序编号”（如 1、2、3 或 A、B、C）。 A.4.1.1. 必须用 <ol> 包裹 <li>（List Item，列表项），每个 <li> 代表一个有序内容： 浏览器显示效果： 1.第一步：准备面粉、鸡蛋、牛奶 2.第二步：将材料混合搅拌成面糊 3.第三步：平底锅加热，倒入面糊煎制 A.4.1.2. 核心属性：控制 “编号类型” 和 “起始位置” 通过 type 和 start 属性，可自定义有序列表的编号规则（这是 <ol> 的核心灵活点）： type 属性：指定编号样式（可选值共 5 种） start 属性：指定编号的 “起始数字”（注意：start 的值必须是整数，哪怕 type 是字母或罗马数字） | type 值 | 编号样式 | 实例（start=\"3\" 时）| 说明| |---|---|---|---| |1 | 阿拉䴥数字 | 3、4、5 | 默认值（不写 type 时）| |a | 小写英文字母 c、d、e | 适合 “次级步骤” 或 “分类”| |A | 大写英文字母 C、D、E | 适合 “章节标题”（如 A 章、B 章）| |i | 小写罗马数字 iii、iv、v | 适合 “学术文档” 或 “复古风格”| |I | 大写罗马数字 III、IV、V | 适合 “重要排名”（如 I 等奖、II 等奖）| A.4.1.3. 常见场景 步骤类：食谱、组装说明书、软件操作指南（“第一步、第二步”） 排名类：考试成绩排名（“1. 张三 98 分，2. 李四 95 分”） 章节类：文章分节（“A. 引言，B. 实验方法”） 无序列表 <ul>：“无顺序的并列，谁先谁后都一样” <ul>（Unordered List）的核心是列表项仅 “并列展示”，无先后逻辑，浏览器会自动为每个项添加 “无序符号”（如圆点、方块）。 A.4.2.1. 基础语法 同样用 <ul> 包裹 <li>，每个 <li> 是一个并列内容： 浏览器显示效果： ・商品特点 1：无添加防腐剂 ・商品特点 2：常温保存 30 天 ・商品特点 3：独立小包装 A.4.2.2. 核心样式：控制 “符号类型” 或 “去除符号” <ul> 没有像 <ol> 那样的 type 属性（HTML5 已废弃 <ul> 的 type 属性），需通过 CSS 的 list-style-type 控制符号，或直接去除符号（最常用场景）。 样式需求 | CSS 写法 | 符号效果 | 说明 默认符号 |（不写或 list-style-type: disc;） | 实心圆点（・） | 最常用的默认样式。 空心圆圈 |（list-style-type: circle;） | 空心圆圈（○） | 适合 “次级列表”（如列表内嵌套列表）。 实心方块 |（list-style-type: square;） | 实心方块（□） | 适合 “强调类并列内容”。 完全去除符号 |（list-style: none;） | 无任何符号 | 前端开发中最常用（如导航菜单）。 实例 1：空心圆圈列表 显示效果： ○ 待办 1：买水果 ○ 待办 2：取快递 实例 2：去除符号（导航菜单常用） 显示效果（无符号，适合做导航）： 首页 关于我们 联系客服 A.4.2.3. 常见场景 导航菜单：网站顶部 / 侧边的导航（如 “首页、分类、我的”） 并列内容：商品特点、文章标签、待办清单（非步骤类） 嵌套列表：列表内再嵌套列表（如 “主分类 → 子分类”，子分类常用空心圆圈） 定义列表 <dl>：“术语 - 解释配对，像字典一样” <dl>（Description List）是三种列表中最特殊的 —— 它不强调 “顺序” 或 “并列”，而是强调 “术语（Term）” 与 “解释（Description）” 的对应关系，结构是 “术语 + 解释” 的配对。 A.4.3.1. 基础语法 和前两种不同，<dl> 不包裹 <li>，而是包裹 <dt> 和 <dd>： <dt>（Description Term）：需要解释的 “术语 / 关键词”（如 “HTML”“CSS”） <dd>（Description Definition）：对 <dt> 的 “解释 / 说明”（如 “一种标记语言”） 一个 <dt> 可以对应多个 <dd>（一个术语有多个解释），语法如下： 浏览器显示效果（默认：<dt> 左对齐，<dd> 左缩进并换行）： HTML HyperText Markup Language（超文本标记语言），用于构建网页结构。 A.4.3.2. 核心特点 无 “编号 / 符号”：仅通过 “缩进” 区分术语和解释，语义更聚焦 “配对关系”； 灵活性高：支持 “1 个 dt 对应多个 dd”“多个 dt 对应多个 dd”（如 FAQ 中 “问题 dt + 答案 dd” 的批量展示）。 A.4.3.3. 常见场景 术语表：技术文档中的 “名词解释”（如前端术语、法律术语）； FAQ 问答：“问题” 作为 <dt>，“答案” 作为 <dd>（如 “Q：如何退款？A：在订单页点击‘申请退款’”）； 商品参数：“参数名” 作为 <dt>，“参数值” 作为 <dd>（如 “品牌：XX | 尺寸：30cm | 重量：500g”）。 A.4.3.4. 常见误区（避坑指南） 误区 1：在 <ol>/<ul> 里直接放文本或其他标签（如 <div>） → 错误：<ol>第一步：准备材料</ol>（缺少 <li>） → 正确：必须用 <li> 包裹每个列表项，因为 <li> 才是 “列表项的语义载体”。 误区 2：用 <ul> 做 “有顺序的内容”（如步骤），再手动加 “1、2、3” 文本 → 错误：<ul> <li>1. 准备材料</li></ul>（语义错误，应选 <ol>） → 正确：优先用 <ol> 的原生编号，而非手动加数字（语义更清晰，且方便后续修改顺序）。 误区 3：用 <dl> 做 “普通并列内容”（如商品特点） → 错误：<dl> <dt>特点1</dt> <dd>无添加</dd></dl>（语义浪费，应选 <ul>） → 正确：仅当内容是 “术语 - 解释” 关系时用 <dl>，普通并列用 <ul> 更简洁。 A.5 超链接与锚点跳转 无论哪种链接，都以 <a> 标签为载体，其核心作用是 “建立跳转关系”。关键属性有两个： href：指定 “跳转目标”（必填，值可以是页面地址、空值、锚点标识）； target：指定 “跳转方式”（可选，控制在当前窗口还是新窗口打开）。 基本链接：跳转到其他页面 / 资源 基本链接是最常用的场景，用于从 “当前页面” 跳转到 “其他页面”（或图片、文档等资源），href 需填写目标资源的地址（相对路径或绝对路径）。 A.5.1.1. 核心属性解析 属性取值说明示例 href： ① 相对路径：同一项目内的文件（基于当前页面位置）； ② 绝对路径：完整的互联网地址（含协议，如 https://）相对路径：page.html、../about/info.html； 绝对路径：https://www.baidu.com target控制跳转窗口（4 个常用值）： ① \\_self：当前窗口打开（默认，不写即为此值）； ② \\_blank：新窗口 / 标签页打开； ③ \\_parent：父框架打开（用于 iframe 嵌套场景）； ④ \\_top：顶层窗口打开（突破所有框架嵌套）； （2）实例演示 （3）注意事项 相对路径要注意 “文件层级”： page.html：当前页面同一文件夹的文件； ../page.html：当前文件夹的上一级文件夹中的文件（../ 表示向上一级）； docs/page.html：当前文件夹下的 docs 子文件夹中的文件。 绝对路径必须带完整协议（http:// 或 https://），否则浏览器会把它当作 “相对路径” 解析（比如写 www.XXX.com 会报错）。 空链接：临时占位，暂不跳转 空链接用于 “跳转目标未确定” 的场景（比如开发初期的按钮、导航占位），核心是 href 填写 “空值”，但两种空值写法的效果不同，需注意区别。 （1）两种空链接写法对比 | 写法 | 效果 | 适用场景 | |------|------|----------| | href=\"#\" | 点击后会跳转到当前页面的顶部（因为 # 本身代表 \"页面顶部\"） | 临时占位，允许点击后轻微滚动（如导航栏占位）； | | href=\"javascript:;\" | 点击后无任何动作（执行空的 JavaScript 代码，不跳转、不滚动）| 纯占位，不希望有任何滚动或跳转（如未完成的按钮）； | （2）实例演示 （3）注意事项 空链接仅用于开发临时占位，正式项目中必须替换为真实的 href 地址（否则用户点击后无意义，影响体验和 SEO）； 避免过度使用 href=\"#\"：如果页面很长，点击后跳转到顶部可能让用户困惑，此时优先用 href=\"javascript:;\"。 页面内部跳转（锚点）：定位到当前页面的指定位置 当页面内容很长（如长文档、长表单）时，锚点跳转能让用户快速定位到 “页面内的某个部分”，核心逻辑是： “用 <a href=\"#id值\"> 定义跳转入口，用 id=\"id值\" 定义跳转目标”。 （1）实现步骤（2 步即可） 定义 “跳转目标”：给页面中需要定位的元素（如标题、段落）添加 id 属性，值自定义（需遵守规则）； 定义 “跳转入口”：用 <a> 标签，href 取值为 # + 目标元素的id值（如 href=\"#part2\"）。 （2）实例演示 （3）必须遵守的 2 个规则（关键！否则失效） id 值必须唯一：同一页面中，不能有两个元素的 id 相同（比如不能同时给两个标题设 id=\"part2\"），否则浏览器无法判断要跳转到哪个目标； id 不能以数字开头：这是 HTML 语法规定（如 id=\"2part\" 无效，id=\"part2\" 有效），否则锚点无法生效。 （4）进阶：平滑滚动（提升体验） 默认锚点跳转是 “瞬间定位”，加上一行 CSS 可实现 “平滑滚动”（更友好），只需给页面根元素（html）添加样式： A.6 图片格式与使用场景 5种图片格式核心信息 JPG（JPEG） 核心特点：色彩丰富（数百万色）、有损压缩（可平衡体积与清晰度）、不支持透明 对应用途：各类照片场景（电商商品照、文章配图、非透明头像） 避坑提醒：不用于需透明的图（如logo）；避免过度压缩导致失真 GIF 核心特点：支持动图、仅256色（色彩少）、仅单色透明（效果简陋） 对应用途：简单动图场景（表情包、加载动画、基础按钮动效） 避坑提醒：不存照片/色彩丰富图（易色块失真）；不用于复杂动图（体积过大） PNG 核心特点：真透明（alpha通道）、无损压缩（高清无细节损失）、体积较大 对应用途：需透明的静态图（UI图标、品牌logo、带透明阴影的图） 避坑提醒：无需透明的静态图尽量不用（拖慢加载）；不支持动图 WebP 核心特点：全能（支持丰富色彩、真透明、动图）、体积极小（比JPG小20%-30%，比PNG小50%+）、兼容性差（不支持IE及部分老浏览器） 对应用途：新项目、不兼容老浏览器的场景（现代网站、APP内嵌网页、电商商品图） 避坑提醒：需兼容老设备时避免使用；可做降级处理（主流显WebP，老设备显JPG/PNG） Base64 核心特点：文本形式嵌入代码（无需单独请求图片）、无HTTP请求、编码后体积增大30%左右 对应用途：&lt;10KB的极小静态图（小图标、简单小背景图） 避坑提醒：不用于大图片（&gt;10KB）；不用于动态图片（如用户上传头像） 原则： 效果不一样：选效果最好的； 比如需要 “透明背景” 时，绝不能选不支持透明的 JPG；需要 “动图” 时，绝不能选静态的 PNG。 效果一样：选体积最小的； 比如展示一张不需要透明的照片，JPG 和 WebP 都能满足效果，但 WebP 体积更小，就选 WebP。 A.7 页面加载流程（简图） 解析 HTML 结构 遇到外链 CSS → 下载 → 应用 遇到 JS → 下载 → 执行 图片等资源逐步加载 页面完整呈现 A.8 内联框架 iframe：在网页中 “嵌套网页” 的核心工具 iframe（Inline Frame，内联框架）的核心作用是在当前网页中 “挖一块区域”，嵌入另一个独立网页 / 文档—— 两个页面相互隔离（样式、脚本不干扰），却能在同一窗口展示，是实现 “多内容区独立加载” 的经典方案。 一、存在意义 解决“在一个页面中展示多个独立网页”的需求，如管理后台内容区局部刷新、嵌入外部模块（天气查询）、预览PDF等。 二、基础用法 核心属性： src（必选）：指定嵌入的网页/文档地址（绝对/相对路径）； width/height：控制嵌入区域尺寸（px或百分比）； frameborder：控制边框（0=隐藏，1=显示，推荐设0）。 实例： 三、进阶用法（与<a>标签联动） 逻辑：给iframe加name属性（如name=\"box\"），<a>标签用target=\"box\"，实现“点击链接在iframe内打开新内容”。 实例： 四、核心用途 展示多个独立页面（如商品详情页嵌入评价模块，互不干扰）； 加载文档/资源（如预览PDF合同、PPT课件，利用第三方预览能力）； 管理后台布局（左侧固定菜单+右侧iframe内容区，减少整体刷新）。 五、避坑提醒 边框：必设frameborder=\"0\"，避免默认丑边框； 尺寸：width=\"100%\"需父容器有明确宽度，高度按需调整（加scrolling=\"auto\"控制滚动条）； 安全：嵌入不可信网页时，用sandbox属性限制权限（如sandbox=\"allow-scripts\"）； 性能：避免过多iframe（建议≤3个），减少请求和内存占用。 六、总结 核心价值是“隔离式嵌入”，适用于独立页面展示、文档预览等场景；关键是掌握属性用法和避坑要点，虽部分被路由替代，但特定场景不可替代。 A.9 HTML 实体大全表格（常用版） | 符号 | 对应实体写法 | | --- | --- | | & | &amp; | | < | &lt; | | > | &gt; | | \" | &quot; | | ' | &apos; | | 空格 | &nbsp; | | © | &copy; | | ® | &reg; | | £ | &pound; | | ¥ | &yen; | | × | &times; | | ÷ | &divide; | | → | &rarr; | | ← | &larr; | | ↑ | &uarr; | | ↓ | &darr; | | ✓ | &check; | | ✗ | &cross; | 这些实体能解决特殊符号在HTML中的显示问题，日常开发高频使用。 致谢 写下这本书，就像在一条缓慢生长的河岸上摆放石子。每一块石子都来自我走过的学习之路，而它们能最终排成形，是因为我不是一个人在走。 感谢所有带我入行的前端开发者们。无论是文章里的一句话，论坛中无意的回答，还是开源仓库不眠夜的更新，这些看似平凡的东西都在悄悄铺出一条清晰的学习道路。 感谢所有愿意耐心解释标签、属性、兼容性、语义化的人。你们说的每一句“这其实可以更简单”，都让我意识到前端世界远比我想象的明亮。 感谢所有愿意提问、讨论、争论的人。你们的问题让我发现了知识的空白，而空白就是改进的入口。 感谢每一位阅读本书的人。你拿起它的那一刻，就已经是前端宇宙里的同行者了。愿我们继续在代码里撒盐、铺桥、修路，把一个个小页面变成能让生活更顺畅的小风口。 愿你我在之后学习篇章再见，都走得更远，也学得更稳。"
    },
    {
      "title": "ess",
      "path": "JavaScriptES6+/ess.md",
      "category": "JavaScriptES6+",
      "tags": [],
      "date": null,
      "description": "<font style=\"color:000000;\">let 关键字用来声明变量，使用let 声明的变量有几个特点：</font>\n\n<font style=\"color:000000;\">1) 不允许重复声明</font>\n\n<font style=\"color:000000;\">2) 块儿级作用域</font>\n\n<font style=\"color:000000;\">3) 不存在变量提升<",
      "content": "1、let <font style=\"color:#000000;\">let 关键字用来声明变量，使用let 声明的变量有几个特点：</font> <font style=\"color:#000000;\">1) 不允许重复声明</font> <font style=\"color:#000000;\">2) 块儿级作用域</font> <font style=\"color:#000000;\">3) 不存在变量提升</font> <font style=\"color:#000000;\">4) 不影响作用域链</font> <font style=\"color:#000000;\">5) 暂时性死区</font> <font style=\"color:#000000;\">6）不与顶级对象挂钩</font> 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”。该变量在声明之前使用都属于“暂时性死区“。 <font style=\"color:#FF0000;\">应用场景：以后声明变量使用let 就对了</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //声明变量格式</font> <font style=\"color:#595959;\"> let a;</font> <font style=\"color:#595959;\"> let b, c, d;</font> <font style=\"color:#595959;\"> let e = 100;</font> <font style=\"color:#595959;\"> let f = 521,</font> <font style=\"color:#595959;\"> g = \"iloveyou\",</font> <font style=\"color:#595959;\"> h = [];</font> <font style=\"color:#595959;\"> //1. 变量不能重复声明，防止变量被污染</font> <font style=\"color:#595959;\"> // let star = '王老师';</font> <font style=\"color:#595959;\"> // let star = '余老师'; //会报错</font> <font style=\"color:#595959;\"> //2. 块儿级作用域 避免暴露成全程作用域，影响别人</font> <font style=\"color:#595959;\"> {</font> <font style=\"color:#595959;\"> let girl = '王老师';</font> <font style=\"color:#595959;\"> var boy='张老师'</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(girl);//报错</font> <font style=\"color:#595959;\"> console.log(boy);//张老师</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> // if else while for 这些语句里，都是有块级作用域的</font> <font style=\"color:#595959;\"> //for 循环的计算器，就很合适let命令</font> <font style=\"color:#595959;\"> for(let i=0;i<3;i++){</font> <font style=\"color:#595959;\"> console.log(i);//0,1,2</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(i);//报错</font> <font style=\"color:#595959;\"> //3. 不影响作用域链</font> <font style=\"color:#595959;\"> //作用域链：内层作用域 ——> 外层作用域 ——> 全局作用域</font> <font style=\"color:#595959;\"> {</font> <font style=\"color:#595959;\"> let school = \"bdqn\";</font> <font style=\"color:#595959;\"> function fn() {</font> <font style=\"color:#595959;\"> console.log(school);//在fn作用域没有，还是会向上寻找</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fn();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //4. 不存在变量提升</font> <font style=\"color:#595959;\"> // console.log(song);</font> <font style=\"color:#595959;\"> // let song = '恋爱达人';</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> // 5、let暂时性死区</font> <font style=\"color:#595959;\"> var a = 1;</font> <font style=\"color:#595959;\"> if (true) {</font> <font style=\"color:#595959;\"> a = 2; // 报错，初始化前不能访问a,也就是在同一个作用域中，不可以访问，再定义</font> <font style=\"color:#595959;\"> let a = 1;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> // 6、 不与顶层对象挂钩</font> <font style=\"color:#595959;\"> var myname='zhangsan'</font> <font style=\"color:#595959;\"> let myage=18</font> <font style=\"color:#595959;\"> console.log(window.myname);//zhangsan</font> <font style=\"color:#595959;\"> console.log(window.myage);//undefined</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> </script></font> 2、const <font style=\"color:#000000;\">const 关键字用来声明常量，const 声明有以下特点</font> <font style=\"color:#000000;\">1) 声明必须赋初始值</font> <font style=\"color:#000000;\">2) 标识符一般为大写（建议）</font> <font style=\"color:#000000;\">3) 不允许重复声明</font> <font style=\"color:#000000;\">4) 值不允许修改</font> const实际上保存的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。 <font style=\"color:#FF0000;\">注意: 对象属性修改和数组元素变化不会出发const 错误, 对象地址不可改变。</font> <font style=\"color:#000000;\">5) 块儿级作用域</font> 6)、 不与顶层对象挂钩 <font style=\"color:#FF0000;\">应用场景：声明对象类型使用const，非对象类型声明选择let</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //声明常量</font> <font style=\"color:#595959;\"> const SCHOOL = 'bdqn';</font> <font style=\"color:#595959;\"> //注意事项</font> <font style=\"color:#595959;\"> //1. 一定要赋初始值</font> <font style=\"color:#595959;\"> // const A;</font> <font style=\"color:#595959;\"> //2. 一般常量使用大写(潜规则)</font> <font style=\"color:#595959;\"> // const a = 100;</font> <font style=\"color:#595959;\"> //3. 常量的值不能修改</font> <font style=\"color:#595959;\"> // SCHOOL = 'bdqn';</font> <font style=\"color:#595959;\"> //4. 块儿级作用域</font> <font style=\"color:#595959;\"> // {</font> <font style=\"color:#595959;\"> // const PLAYER = 'UZI';</font> <font style=\"color:#595959;\"> // }</font> <font style=\"color:#595959;\"> // console.log(PLAYER);</font> <font style=\"color:#595959;\"> //5. 对于数组和对象的元素修改, 不算做对常量的修改, 不会报错</font> <font style=\"color:#595959;\"> const TEAM = ['UZI','MXLG','Ming','Letme'];</font> <font style=\"color:#595959;\"> // TEAM.push('Meiko');</font> <font style=\"color:#595959;\"> // 6、 不与顶层对象挂钩</font> <font style=\"color:#595959;\"> var myname = \"zhangsan\";</font> <font style=\"color:#595959;\"> const myage = 18;</font> <font style=\"color:#595959;\"> console.log(window.myname); //zhangsan</font> <font style=\"color:#595959;\"> console.log(window.myage); //undefined</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#F33232;\">面试题1．let和const的区别（/var，let，const的区别？）</font> let声明的变量可以改变，值和类型都可以改变（let：声明的是变量）； const声明的常量不可以改变，这意味着，const一旦声明，就必须立即初始化，不能以后再赋值，当然数组和对象等复合类型的变量，变量名不指向数据，而是指向数据所在的地址。 const只保证变量名指向的地址不变，并不保证该地址的数据不变。 <font style=\"color:#FF0001;\">let和const总结</font> let 声明的变量会产生块作用域，var 不会产生块作用域 const 声明的常量也会产生块作用域 不同代码块之间的变量无法互相访问 注意: 对象属性修改和数组元素变化不会出发 const 错误 （数组和对象存的是引用地址） 应用场景：声明对象类型使用 const，非对象类型声明选择 let cosnt声明必须赋初始值，标识符一般为大写，值不允许修改。 3、变量的解构赋值 <font style=\"color:#000000;\">ES6 允许按照一定模式，从数组和对象中快速的提取成员，对变量进行赋值，这被称为</font><font style=\"color:#F33232;\">解构赋值。</font> 本质上，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 1>解构分类 （1）、数组的解构 ES6中允许从数组中提取值，按照对应位置，对变量赋值 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //数组的解构</font> <font style=\"color:#595959;\"> const F4 = ['小沈阳','刘能','赵四','宋小宝'];</font> <font style=\"color:#595959;\"> let [xiao, liu, zhao, song] = F4;</font> <font style=\"color:#595959;\"> console.log(xiao);</font> <font style=\"color:#595959;\"> console.log(liu);</font> <font style=\"color:#595959;\"> console.log(zhao);</font> <font style=\"color:#595959;\"> console.log(song); </font> <font style=\"color:#595959;\"> // 省略变量</font> <font style=\"color:#595959;\"> let [a, , c] = [1, 2, 3]; </font> <font style=\"color:#595959;\"> console.log(a, c);//1，3</font> <font style=\"color:#595959;\"></script></font> （2）、对象的解构 对象的解构与数组有一个重要的不同。数组的元素是按顺序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值，否则解构失败就是undefined。 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //对象的解构</font> <font style=\"color:#595959;\"> const zhao = {</font> <font style=\"color:#595959;\"> name: \"赵本山\",</font> <font style=\"color:#595959;\"> age: \"不详\",</font> <font style=\"color:#595959;\"> xiaopin: function () {</font> <font style=\"color:#595959;\"> console.log(\"我可以演小品\");</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> data: {</font> <font style=\"color:#595959;\"> list: [\"贾玲\", \"沈腾\", \"···\"],</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> let {</font> <font style=\"color:#595959;\"> name:n,//起别名</font> <font style=\"color:#595959;\"> age=18,//可以定义默认值</font> <font style=\"color:#595959;\"> xiaopin,</font> <font style=\"color:#595959;\"> data: { list },//可以解构下一级数据</font> <font style=\"color:#595959;\"> } = zhao;</font> <font style=\"color:#595959;\"> console.log(n);//赵本山</font> <font style=\"color:#595959;\"> console.log(age);</font> <font style=\"color:#595959;\"> console.log(xiaopin);</font> <font style=\"color:#595959;\"> console.log(list);</font> <font style=\"color:#595959;\"> xiaopin();</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> let {xiaopin} = zhao;</font> <font style=\"color:#595959;\"> xiaopin();</font> <font style=\"color:#595959;\"> </script></font> （3）、字符串解构 <font style=\"color:#595959;\">let [a, b, c] = \"hello\";</font> <font style=\"color:#595959;\"> console.log(a); //h</font> <font style=\"color:#595959;\"> console.log(b); //e</font> <font style=\"color:#595959;\"> console.log(c); //l</font> <font style=\"color:#595959;\"> let { length } = \"hello\";</font> <font style=\"color:#595959;\"> console.log(length);//5</font> 2、解构应用 （1）、变量值交换 <font style=\"color:#595959;\">let a = 1;</font> <font style=\"color:#595959;\">let b = 2;</font> <font style=\"color:#595959;\">[a, b] = [b, a];</font> <font style=\"color:#595959;\">console.log(a);</font> （2）、函数返回多个值 <font style=\"color:#595959;\"> function myfun() {</font> <font style=\"color:#595959;\"> return [2, 3, 4];</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> let [a, b, c] = myfun();</font> <font style=\"color:#595959;\"> console.log([a, b, c]);//[2, 3, 4]</font> <font style=\"color:#595959;\"> console.log(a);//2</font> <font style=\"color:#595959;\"> console.log(b);//3</font> <font style=\"color:#595959;\"> console.log(c);//4</font> （3）、函数参数传参数 <font style=\"color:#595959;\"> function myfun([a, b, c]) {</font> <font style=\"color:#595959;\"> console.log(a);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> myfun([4, 5, 6]);</font> 4、模板字符串 ES6 引入新的声明字符串的方式 『`』 '' \"\" <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //1. 声明</font> <font style=\"color:#595959;\"> // let str = 我是一个字符串哦!;</font> <font style=\"color:#595959;\"> // console.log(str, typeof str);</font> <font style=\"color:#595959;\"> //2. 内容中可以直接出现换行符</font> <font style=\"color:#595959;\"> let str = <ul></font> <font style=\"color:#595959;\"> <li>孙悟空</li></font> <font style=\"color:#595959;\"> <li>猪八戒</li></font> <font style=\"color:#595959;\"> <li>沙悟净</li></font> <font style=\"color:#595959;\"> <li>白骨精</li></font> <font style=\"color:#595959;\"> </ul>;</font> <font style=\"color:#595959;\"> //3. 变量拼接 ${lovest}</font> <font style=\"color:#595959;\"> let lovest = '沈腾';</font> <font style=\"color:#595959;\"> let out = ${lovest}是我心目中最搞笑的演员!!;</font> <font style=\"color:#595959;\"> console.log(out);</font> <font style=\"color:#595959;\"> </script></font> 5、字符串扩展 （1）、 includes函数 <font style=\"color:#333333;\">判断字符串中是否存在指定字符，返回布尔值，</font> 语法：string.includes(\"xxx\") <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> let myname = \"hello\";</font> <font style=\"color:#595959;\"> console.log(myname.includes(\"e\")); //true</font> <font style=\"color:#595959;\"> console.log(myname.startsWith(\"o\")); //false</font> <font style=\"color:#595959;\"> console.log(myname.endsWith(\"k\")); //false</font> <font style=\"color:#595959;\"> </script> </font> （2）、repeat函数 <font style=\"color:#333333;\">repeat()方法返回一个新字符串,表示将原字符串重复n次。</font>str.repeat(数值) <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> let res = \"hello\";</font> <font style=\"color:#595959;\"> console.log(res.repeat(1)); //hello</font> <font style=\"color:#595959;\"> console.log(res.repeat(0)); //\"\"</font> <font style=\"color:#595959;\"> console.log(res.repeat(2.5)); //hellohello</font> <font style=\"color:#595959;\"> console.log(res.repeat(\"2\"); //hellohello</font> <font style=\"color:#595959;\"> </script></font> 6、数值扩展 （1）、Number.EPSILON JavaScript 表示的最小精度，一般用在浮点数运算上， EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16 <font style=\"color:#595959;\">console.log(0.1 + 0.2 === 0.3);//false</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> function equal(a, b) {</font> <font style=\"color:#595959;\"> if (Math.abs(a - b) < Number.EPSILON) {</font> <font style=\"color:#595959;\"> return true;</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> return false;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(equal(0.1 + 0.2, 0.3));//true</font> <font style=\"color:#000000;\">（2）</font>二进制和八进制 <font style=\"color:#595959;\"> let b = 0b1010;// 0b开头 二进制</font> <font style=\"color:#595959;\"> let o = 0o77;// 0o开头 八进制</font> <font style=\"color:#595959;\"> let d = 100; //十进制</font> <font style=\"color:#595959;\"> let x = 0xff;//0x开头 十六进制</font> （3）、 Number.isFinite <font style=\"color:#4D4D4D;\">如果传递的值是有限数字，则返回true。 布尔值，字符串，对象，数组等所有其他内容均返回false：</font> <font style=\"color:#595959;\">console.log(Number.isFinite(100));//true</font> <font style=\"color:#595959;\">console.log(Number.isFinite(100/0));//false</font> <font style=\"color:#595959;\">console.log(Number.isFinite(Infinity));//false</font> <font style=\"color:#595959;\">console.log(Number.isFinite(NaN)); //false</font> （4）、 Number.isNaN 检测一个数值是否为 NaN,<font style=\"color:#333333;\">只有对于NaN才返回true，非NaN一律返回false。</font> <font style=\"color:#595959;\">console.log(Number.isNaN(123));//false</font> （5）、Number.parseInt Number.parseFloat 字符串转整数,必须以数字开头 <font style=\"color:#595959;\">console.log(Number.parseInt('5211314love'));</font> <font style=\"color:#595959;\"> console.log(Number.parseFloat('3.1415926神奇'));</font> （6）、 Number.isInteger 判断一个数是否为整数 <font style=\"color:#595959;\"> console.log(Number.isInteger(5));//true</font> <font style=\"color:#595959;\"> console.log(Number.isInteger(2.5));//false</font> （7）、Math.trunc 将数字的小数部分抹掉 <font style=\"color:#595959;\">console.log(Math.trunc(3.5));//3</font> （8）、Math.sign 判断一个数到底为正数负数还是零,<font style=\"color:#333333;\">对于非数值，会先将其转换为数值。</font> <font style=\"color:#595959;\">console.log(Math.sign(100));//1</font> <font style=\"color:#595959;\">console.log(Math.sign(0));//0</font> <font style=\"color:#595959;\">console.log(Math.sign(-20000));//-1 </font> 7、数组扩展 （1）、Array.from()方法 将伪数组或可遍历对象转换为真正的数组。 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 举例1：</font> <font style=\"color:#595959;\"> Array.from(\"12345\"); // [1,2,3,4,5]</font> <font style=\"color:#595959;\"> // 举例2：</font> <font style=\"color:#595959;\"> let arr1 = {</font> <font style=\"color:#595959;\"> 1: \"a\",</font> <font style=\"color:#595959;\"> 2: \"b\",</font> <font style=\"color:#595959;\"> length: 3,</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> console.log(Array.from(arr1)); // [undefined, 'a', 'b']</font> <font style=\"color:#595959;\"> //举例3</font> <font style=\"color:#595959;\"> function test() {</font> <font style=\"color:#595959;\"> console.log(Array.from(arguments));// [1, 2, 3]</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> test(1, 2, 3);</font> <font style=\"color:#595959;\"> //举例4:选择器</font> <font style=\"color:#595959;\"> let divs = document.querySelectorAll(\"div\");</font> <font style=\"color:#595959;\"> console.log(Array.from(divs));//[div, div, div]</font> <font style=\"color:#595959;\"> </script></font> （2）、array.find() 方法 该方法主要应用于查找第一个符合条件的数组元素 它的参数是一个回调函数。 在回调函数中可以写你要查找元素的条件,当条件成立为true时,返回该元素。 如果没有符合条件的元素,返回值为undefined <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // 举例1：</font> <font style=\"color:#595959;\"> let arr1 = [1, 2, 3, 2];</font> <font style=\"color:#595959;\"> let res = arr1.find((item) => {</font> <font style=\"color:#595959;\"> // console.log(item,'item');</font> <font style=\"color:#595959;\"> //return item>2</font> <font style=\"color:#595959;\"> return item == 2</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> console.log(res); //2, 如果未找到，返回undefined</font> <font style=\"color:#595959;\"> // 举例2：</font> <font style=\"color:#595959;\"> let person = [</font> <font style=\"color:#595959;\"> { name: \"张三\", age: 16 },</font> <font style=\"color:#595959;\"> { name: \"李四\", age: 17 },</font> <font style=\"color:#595959;\"> { name: \"王五\", age: 18 },</font> <font style=\"color:#595959;\"> ];</font> <font style=\"color:#595959;\"> let target = person.find((item, index) => {</font> <font style=\"color:#595959;\"> return item.name == \"张三\";</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> console.log(target.name);//张三</font> <font style=\"color:#595959;\"> </script></font> （3）、array.findindex()方法 定义：用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1。 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> let ary = [1,5, 10, 15];</font> <font style=\"color:#595959;\"> let index = ary.findIndex((item, index) => {</font> <font style=\"color:#595959;\"> return item > 9;</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> console.log(index); // 2 第一个比9大的数字在索引值为2的部位</font> <font style=\"color:#595959;\"> </script></font> （4）、array.includes()方法 定义：判断某个数组是否包含给定的值，返回布尔值。 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> let ary = [1, 5, 10, 15];</font> <font style=\"color:#595959;\"> console.log(ary.includes(5)); //true</font> <font style=\"color:#595959;\"> </script></font> （5）、Array.of()方法 将一组值转化为数组,即新建数组 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> let arr1 = new Array(3);</font> <font style=\"color:#595959;\"> console.log(arr1); // [,,]</font> <font style=\"color:#595959;\"> let arr2 = Array.of(3);</font> <font style=\"color:#595959;\"> console.log(arr2); // [3]</font> <font style=\"color:#595959;\"> </script></font> （6）、fill方法 使用自己想要的参数替换原数组内容,但是会改变原来的数组 可以传多个参数 1个参数：默认从数组第一位开始替换 2个参数：（替换的值，替换索引位置） 3个参数：（替换的值，替换索引开始位置，替换索引结束位置【不包括】） <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> let arr1 = new Array(3).fill(\"hello\");</font> <font style=\"color:#595959;\"> let arr2 = [\"猪八戒\", \"孙悟空\", \"唐僧\"].fill(\"kerwin\", 1, 2);</font> <font style=\"color:#595959;\"> console.log(arr1); // ['hello', 'hello', 'hello']</font> <font style=\"color:#595959;\"> console.log(arr2); // ['猪八戒', 'kerwin', '唐僧']</font> <font style=\"color:#595959;\"> </script></font> （7）、最新数组方法 https://blog.csdn.net/m0_64346035/article/details/124368893 <font style=\"color:#000000;\">（8）、spread 扩展运算符</font> <font style=\"color:#000000;\">扩展运算符（spread）也是三个点（...）。它好比rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包。</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 『...』 扩展运算符能将『数组』转换为逗号分隔的『参数序列』</font> <font style=\"color:#595959;\"> //声明一个数组 ...</font> <font style=\"color:#595959;\"> const tfboys = ['易烊千玺','王源','王俊凯'];</font> <font style=\"color:#595959;\"> // => '易烊千玺','王源','王俊凯'</font> <font style=\"color:#595959;\"> // 声明一个函数</font> <font style=\"color:#595959;\"> function chunwan(){</font> <font style=\"color:#595959;\"> console.log(arguments);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> chunwan(...tfboys);// chunwan('易烊千玺','王源','王俊凯')</font> <font style=\"color:#595959;\"> </script></font> 扩展运算符的应用 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <div></div></font> <font style=\"color:#595959;\"> <div></div></font> <font style=\"color:#595959;\"> <div></div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //1. 数组的合并 </font> <font style=\"color:#595959;\"> const kuaizi = ['王太利','肖央'];</font> <font style=\"color:#595959;\"> const fenghuang = ['曾毅','玲花'];</font> <font style=\"color:#595959;\"> // 数组的合并 第一种方式</font> <font style=\"color:#595959;\"> // const zuixuanxiaopingguo = kuaizi.concat(fenghuang);</font> <font style=\"color:#595959;\"> // 数组的合并 第二种方式</font> <font style=\"color:#595959;\"> const zuixuanxiaopingguo = [...kuaizi, ...fenghuang];</font> <font style=\"color:#595959;\"> console.log(zuixuanxiaopingguo);</font> <font style=\"color:#595959;\"> //2. 数组的克隆（深拷贝）</font> <font style=\"color:#595959;\"> const sanzhihua = ['E','G','M'];</font> <font style=\"color:#595959;\"> const sanyecao = [...sanzhihua];// ['E','G','M']</font> <font style=\"color:#595959;\"> console.log(sanyecao);</font> <font style=\"color:#595959;\"> //3. 将伪数组转为真正的数组</font> <font style=\"color:#595959;\"> const divs = document.querySelectorAll('div');</font> <font style=\"color:#595959;\"> const divArr = [...divs];</font> <font style=\"color:#595959;\"> console.log(divArr);// arguments </font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"></body></font> 8、对象拓展 ES6 新增了一些 Object 对象的方法 （1)、简写对象 <font style=\"color:#000000;\">ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。</font> <font style=\"color:#595959;\"> //这样的书写更加简洁</font> <font style=\"color:#595959;\"> let name = 'bdqn';</font> <font style=\"color:#595959;\"> let change = function(){</font> <font style=\"color:#595959;\"> console.log('我们可以改变你!!');</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> const school = {</font> <font style=\"color:#595959;\"> // name:name,//属性名和变量值一样，可以简写一个</font> <font style=\"color:#595959;\"> name,</font> <font style=\"color:#595959;\"> change, //外部定义的函数</font> <font style=\"color:#595959;\"> fun: function () {</font> <font style=\"color:#595959;\"> console.log(\"我是复杂写法\");</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> improve() {</font> <font style=\"color:#595959;\"> //直接在对象里定义函数</font> <font style=\"color:#595959;\"> console.log(\"我是简写\");</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> console.log(school);</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#FF0000;\">注意：对象简写形式简化了代码，所以以后用简写就对了</font> （2)、 Object.is 比较两个值是否严格相等，与『===』行为基本一致 （+0 与 NaN） <font style=\"color:#595959;\">console.log(Object.is(120, 120));// === </font> <font style=\"color:#595959;\">console.log(Object.is(NaN, NaN));// true</font> <font style=\"color:#595959;\">console.log(NaN === NaN);// false</font> （3) 、Object.assign 对象的合并，将原对象的所有可枚举属性，复制到目标对象，后面的对象会覆盖前面的对象一样的属性 Object.assign(target, object1，object2)的第一个参数是目标对象，后面可以跟一个或多个源对象作为参数。 target：参数合并后存放的对象 object1：参数1 object2：参数2 <font style=\"color:#595959;\">const obj1 = {</font> <font style=\"color:#595959;\"> name: \"tom\",</font> <font style=\"color:#595959;\"> age: 18,</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> const obj2 = {</font> <font style=\"color:#595959;\"> name: \"bob\",</font> <font style=\"color:#595959;\"> age: 28,</font> <font style=\"color:#595959;\"> sex: \"男\",</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> console.log(Object.assign(obj1, obj2));</font> <font style=\"color:#595959;\"> //{name: 'bob', age: 28, sex: '男'}</font> （4) 、setPrototypeOf、 getPrototypeOf 可以直接设置对象的原型，不建议使用 setPrototypeOf(school, cities) 参数1:给谁设置原型对象 school 参数2:设置哪个原型对象 cities <font style=\"color:#595959;\">const school = {</font> <font style=\"color:#595959;\"> name: \"bdqn\",</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> const cities = {</font> <font style=\"color:#595959;\"> xiaoqu: [\"北京\", \"上海\", \"深圳\"],</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> // 设置原型</font> <font style=\"color:#595959;\"> Object.setPrototypeOf(school, cities);</font> <font style=\"color:#595959;\"> // 获取原型</font> <font style=\"color:#595959;\"> Object.getPrototypeOf(school);</font> <font style=\"color:#595959;\"> console.log(school);</font> 9、函数扩展 1>、箭头函数 <font style=\"color:#000000;\">ES6 允许使用「箭头」（=>）定义函数。</font> <font style=\"color:#333333;\">箭头函数只能简写函数表达式，不能简写声明式函数</font> <font style=\"color:#595959;\"> function fn() {} // 不能简写</font> <font style=\"color:#595959;\"> const fun = function () {}; // 可以简写</font> <font style=\"color:#595959;\">const obj = {</font> <font style=\"color:#595959;\">fn: function () {}, // 可以简写</font> <font style=\"color:#595959;\">};</font> （1）、 语法：() =>{} ():函数的形参 =>:必须的语法，指向代码块 {}:代码块 <font style=\"color:#595959;\"> <script> </font> <font style=\"color:#595959;\"> // ES6 允许使用「箭头」（=>）定义函数。</font> <font style=\"color:#595959;\"> //声明一个函数</font> <font style=\"color:#595959;\"> /* let fn = function(){</font> <font style=\"color:#595959;\"> } */</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> /* let fn = (a,b) => {</font> <font style=\"color:#595959;\"> return a + b;</font> <font style=\"color:#595959;\"> } */</font> <font style=\"color:#595959;\"> //调用函数</font> <font style=\"color:#595959;\"> // let result = fn(1, 2);</font> <font style=\"color:#595959;\"> // console.log(result);</font> <font style=\"color:#595959;\"> </script> </font> （2）、箭头函数的特性 this 是静态的. this 始终指向函数声明时所在作用域下的 this 的值，没有自己的this 不能作为构造实例化对象 会报错 不能使用 arguments 变量 箭头函数的简写 1) 省略小括号, 当形参有且只有一个的时候 2) 函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的 执行结果 <font style=\"color:#595959;\"> <script> </font> <font style=\"color:#595959;\"> //箭头函数的特性</font> <font style=\"color:#595959;\"> //1. this 是静态的. this 始终指向函数声明时所在作用域下的 this 的值，没有自己的this</font> <font style=\"color:#595959;\"> function getName() {</font> <font style=\"color:#595959;\"> console.log(this.name);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> let getName2 = () => {</font> <font style=\"color:#595959;\"> console.log(this.name);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //设置 window 对象的 name 属性</font> <font style=\"color:#595959;\"> window.name = \"北大青鸟\";</font> <font style=\"color:#595959;\"> const school = {</font> <font style=\"color:#595959;\"> name: \"bdqn\",</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //直接调用，this指向window</font> <font style=\"color:#595959;\"> // getName();</font> <font style=\"color:#595959;\"> // getName2();</font> <font style=\"color:#595959;\"> //call 方法调用</font> <font style=\"color:#595959;\"> // getName.call(school); //指向school</font> <font style=\"color:#595959;\"> // getName2.call(school); //指向window</font> <font style=\"color:#595959;\"> //2. 不能作为构造实例化对象 会报错</font> <font style=\"color:#595959;\"> /* let Person = (name, age) => {</font> <font style=\"color:#595959;\"> this.name = name;</font> <font style=\"color:#595959;\"> this.age = age;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> let me = new Person('xiao',30);</font> <font style=\"color:#595959;\"> console.log(me); */</font> <font style=\"color:#595959;\"> //3. 不能使用 arguments 变量</font> <font style=\"color:#595959;\"> /* let fn = () => {</font> <font style=\"color:#595959;\"> console.log(arguments);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fn(1,2,3); */</font> <font style=\"color:#595959;\"> //4. 箭头函数的简写</font> <font style=\"color:#595959;\"> //1) 省略小括号, 当形参有且只有一个的时候</font> <font style=\"color:#595959;\"> /* let add = n => {</font> <font style=\"color:#595959;\"> return n + n;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(add(9)); */</font> <font style=\"color:#595959;\"> //2) 省略花括号, 当代码体只有一条语句的时候, 此时 return 必须省略</font> <font style=\"color:#595959;\"> // 而且语句的执行结果就是函数的返回值</font> <font style=\"color:#595959;\"> / let pow = (n) => n n;</font> <font style=\"color:#595959;\"> console.log(pow(8)); */</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#FF0000;\">注意：箭头函数不会更改this 指向，用来指定回调函数会非常合适</font> <font style=\"color:#F33232;\">补充this指向问题汇总</font> 1、作为普通函数被调用时--<font style=\"color:#4D4D4D;\">this指向全局对象window</font> <font style=\"color:#595959;\">window.age = 18;</font> <font style=\"color:#595959;\"> function fn() {</font> <font style=\"color:#595959;\"> console.log(this.age);//18</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fn()</font> <font style=\"color:#4D4D4D;\">2、</font>对象方法里的this 当函数作为对象方法被调用时this指向该对象 <font style=\"color:#595959;\"> var obj = {</font> <font style=\"color:#595959;\"> age: 18,</font> <font style=\"color:#595959;\"> fn: function () {</font> <font style=\"color:#595959;\"> console.log(this === obj);//true</font> <font style=\"color:#595959;\"> console.log(this.age);//18</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(obj.fn());</font> <font style=\"color:#4D4D4D;\">3、</font>构造函数里面的this 构造函数里的this指向 new创建的实例化对象(没有return的情况下) 如果构造函数内出现了return并且是一个object对象那么最终的运算结果返回这个对象 只要构造函数不返回数据或者返回基本数据类型 this仍然指向实例 <font style=\"color:#595959;\"> function Fn() {</font> <font style=\"color:#595959;\"> this.age = 18;</font> <font style=\"color:#595959;\"> //此时a.age是return的结果20</font> <font style=\"color:#595959;\"> return {</font> <font style=\"color:#595959;\"> age: 20,</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> let a = new Fn();</font> <font style=\"color:#595959;\"> console.log(a.age); //20</font> <font style=\"color:#4D4D4D;\">4、</font>call&& apply&&bind 在function的原型上有三个方法 call apply bind,所有函数都是Function的实例,所以所有的函数都可以调用这三个方法,而这三个方法都是用来改变this指向的 定义：call(thisObj，Object) 调用一个对象的一个方法，以另一个对象替换当前对象。 说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 <font style=\"color:#595959;\">function fn(x, y) {</font> <font style=\"color:#595959;\"> console.log('加油');</font> <font style=\"color:#595959;\"> console.log(this);//this指向window</font> <font style=\"color:#595959;\"> console.log(x + y);</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">var o = {</font> <font style=\"color:#595959;\"> name: 'andy'</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">fn.call()//call 呼叫 可以调用函数</font> <font style=\"color:#595959;\">fn.call(o, 1, 2)//第一个值是this指向, 后边实参</font> <font style=\"color:#595959;\">fn.apply(o, [10, 20])//apply传递数组</font> <font style=\"color:#595959;\">fn.call(10, 20)//this-->new Numbe(10) x-->20 y-->undefined </font> <font style=\"color:#4D4D4D;\">5、</font>箭头函数中this 箭头函数里面没有自己的this 他只会从自己的作用域链上一层继承this <font style=\"color:#595959;\"> this.age = 20;</font> <font style=\"color:#595959;\"> var obj = {</font> <font style=\"color:#595959;\"> age: 18,</font> <font style=\"color:#595959;\"> fn: () => {</font> <font style=\"color:#595959;\"> console.log(this.age);//20</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> obj.fn()</font> 2> <font style=\"color:#000000;\">参数默认值</font> （1）、 形参初始值 具有默认值的参数, 一般位置要靠后(潜规则) <font style=\"color:#595959;\"> function add(a, b, c = 10) {</font> <font style=\"color:#595959;\"> return a + b + c;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //let res1 = add(1, 2, 3);//6</font> <font style=\"color:#595959;\"> let res2 = add(1,1);//12</font> <font style=\"color:#595959;\"> cons</font> <font style=\"color:#595959;\">ole.log(res2);</font> （2）、 与解构赋值结合 <font style=\"color:#595959;\"> function connect({ name, age, sex, price = \"3000\" }) {</font> <font style=\"color:#595959;\"> console.log(name);</font> <font style=\"color:#595959;\"> console.log(age);</font> <font style=\"color:#595959;\"> console.log(sex);</font> <font style=\"color:#595959;\"> console.log(price);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> connect({</font> <font style=\"color:#595959;\"> name: \"章三\",</font> <font style=\"color:#595959;\"> age: 20,</font> <font style=\"color:#595959;\"> sex: \"男\",</font> <font style=\"color:#595959;\"> // price: 4000,</font> <font style=\"color:#595959;\"> });</font> （3）、这个默认值的方式箭头函数也可以使用 <font style=\"color:#595959;\">const fn = (a = 10) => {</font> <font style=\"color:#595959;\"> console.log(a);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> fn(); // 不传递参数的时候，函数内部的 a 就是 10</font> <font style=\"color:#595959;\"> fn(20); // 传递了参数 20 的时候，函数内部的 a 就是 20</font> 注意： 箭头函数如果你需要使用默认值的话，那么一个参数的时候也需要写（） <font style=\"color:#000000;\">10、rest 参数</font> <font style=\"color:#000000;\">ES6 引入rest 参数，用于获取函数的实参，用来代替arguments</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // ES5 获取实参的方式</font> <font style=\"color:#595959;\"> /* function date(){</font> <font style=\"color:#595959;\"> console.log(arguments);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> date('大白','二黑','三孩'); */</font> <font style=\"color:#595959;\"> // rest 参数</font> <font style=\"color:#595959;\"> /* function date(...args) {</font> <font style=\"color:#595959;\"> console.log(args); // filter some every map</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> date(\"大白\", \"二黑\", \"三孩\"); */</font> <font style=\"color:#595959;\"> // rest 参数必须要放到参数最后</font> <font style=\"color:#595959;\"> /* function fn(a,b,...args){</font> <font style=\"color:#595959;\"> console.log(a);</font> <font style=\"color:#595959;\"> console.log(b);</font> <font style=\"color:#595959;\"> console.log(args);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fn(1,2,3,4,5,6); */</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#FF0000;\">注意：rest 参数非常适合不定个数参数函数的场景</font> 11、Symbol <font style=\"color:#000000;\">（1）、Symbol 基本使用</font> <font style=\"color:#000000;\">ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。</font> undefined string symbol object null number boolean <font style=\"color:#000000;\">Symbol 特点</font> <font style=\"color:#000000;\">1) Symbol 的值是唯一的，用来解决命名冲突的问题</font> <font style=\"color:#000000;\">2) Symbol 值不能与其他数据进行运算</font> <font style=\"color:#000000;\">3) Symbol 定义的对象属性不能使用for…in 循环遍历，但是可以使用Reflect.ownKeys 来获取对象的所有键名</font> <font style=\"color:#FF0000;\">注: 遇到唯一性的场景时要想到Symbol</font> <font style=\"color:#595959;\">script></font> <font style=\"color:#595959;\"> //创建方式</font> <font style=\"color:#595959;\"> //创建Symbol方式1</font> <font style=\"color:#595959;\"> let s = Symbol();</font> <font style=\"color:#595959;\"> // console.log(s, typeof s);</font> <font style=\"color:#595959;\"> //创建方式2</font> <font style=\"color:#595959;\"> // Symbol()函数可以接受一个字符串作为参数，</font> <font style=\"color:#595959;\"> // 表示对 Symbol 实例的描述。这主要是为了在控制台显示，比较容易区分。</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> let s2 = Symbol('bdqn');//'bdqn'这个内容只是个标识</font> <font style=\"color:#595959;\"> let s3 = Symbol('bdqn');</font> <font style=\"color:#595959;\"> console.log('s2===s3',s2===s3);//false</font> <font style=\"color:#595959;\"> // 创建方式3 Symbol.for </font> <font style=\"color:#595959;\"> // Symbol.for并不是每次都会创建一个新的symbol，它会先检索symbol表中是否有，没有再创建新的，有就返回上次存储的</font> <font style=\"color:#595959;\"> let s4 = Symbol.for('bdqn');</font> <font style=\"color:#595959;\"> let s5 = Symbol.for('bdqn');</font> <font style=\"color:#595959;\"> console.log('s4===s5',s4===s5);//true</font> <font style=\"color:#595959;\"> //注意事项</font> <font style=\"color:#595959;\"> //1:不能与其他数据进行运算</font> <font style=\"color:#595959;\"> // let result = s + 100;</font> <font style=\"color:#595959;\"> // let result = s > 100;</font> <font style=\"color:#595959;\"> // let result = s + s;</font> <font style=\"color:#595959;\"> </script></font> （2）、Symbol创建对象属性 <font style=\"color:#000000;\">可以给对象添加属性和方法</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //向对象中添加方法 up down</font> <font style=\"color:#595959;\"> let game = {</font> <font style=\"color:#595959;\"> name: \"俄罗斯方块\",</font> <font style=\"color:#595959;\"> up: function () {},</font> <font style=\"color:#595959;\"> down: function () {},</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //声明一个对象</font> <font style=\"color:#595959;\"> /* let methods = {</font> <font style=\"color:#595959;\"> up: Symbol(),</font> <font style=\"color:#595959;\"> down: Symbol(),</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> game[methods.up] = function () {</font> <font style=\"color:#595959;\"> console.log(\"我可以改变形状\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> game[methods.down] = function () {</font> <font style=\"color:#595959;\"> console.log(\"我可以快速下降!!\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> console.log(game); */</font> <font style=\"color:#595959;\"> let youxi = {</font> <font style=\"color:#595959;\"> name:\"狼人杀\",</font> <font style=\"color:#595959;\"> [Symbol('say')]: function(){</font> <font style=\"color:#595959;\"> console.log(\"我可以发言\")</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> [Symbol('zibao')]: function(){</font> <font style=\"color:#595959;\"> console.log('我可以自爆');</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(youxi);</font> <font style=\"color:#595959;\"> </script></font> （3）、Symbol的内置对象 <font style=\"color:#000000;\">除了定义自己使用的Symbol 值以外，ES6 还提供了11 个内置的Symbol 值，指向语言内部使用的方法。可以称这些方法为魔术方法，因为它们会在特定的场景下自动执行。</font> | Symbol.hasInstance | 当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法 | | --- | --- | | Symbol.isConcatSpreadable | 对象的Symbol.isConcatSpreadable属性等于的是一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。 | | Symbol.species | 创建衍生对象时，会使用该属性 | | Symbol.match | 当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。 | | Symbol.replace | 当该对象被str.replace(myObject)方法调用时，会返回该方法的返回值。 | | Symbol.search | 当该对象被str.search(myObject)方法调用时，会返回该方法的返回值。 | | Symbol.split | 当该对象被str.split(myObject)方法调用时，会返回该方法的返回值。 | | Symbol.iterator | 对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器 | | Symbol.toPrimitive | 该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。 | | Symbol.toStringTag | 在该对象上面调用toString方法时，返回该方法的返回值 | | Symbol.unscopables | 该对象指定了使用with关键字时，哪些属性会被with环境排除。 | 12、迭代器 <font style=\"color:#000000;\">遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator 接口，就可以完成遍历操作。（Iterator 接口就是对象里面的一个属性）</font> <font style=\"color:#000000;\">Iterator 接口就是对象的一个属性</font> Iterator 的作用有三个： 一是为各种数据结构，提供一个统一的、简便的访问接口； 二是使得数据结构的成员能够按某种次序排列； 三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of循环 <font style=\"color:#000000;\">1) ES6 创造了一种新的遍历命令for...of 循环，Iterator 接口主要供for...of 消费</font> <font style=\"color:#000000;\">2) 原生具备iterator 接口的数据(可用for of 遍历) </font> <font style=\"color:#000000;\">a) Array </font> <font style=\"color:#000000;\">b) Arguments </font> <font style=\"color:#000000;\">c) Set </font> <font style=\"color:#000000;\">d) Map </font> <font style=\"color:#000000;\">e) String </font> <font style=\"color:#000000;\">f) TypedArray </font> <font style=\"color:#000000;\">g) NodeList</font> <font style=\"color:#000000;\">3) 工作原理</font>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。 <font style=\"color:#000000;\">（5） 每调用next 方法返回一个包含value 和done 属性的对象</font> <font style=\"color:#000000;\">done：是否循环完毕</font> <font style=\"color:#F33232;\">注: 迭代器就是按照一定的顺序对元素进行遍历的过程</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //声明一个数组</font> <font style=\"color:#595959;\"> const xiyou = [\"唐僧\", \"孙悟空\", \"猪八戒\", \"沙僧\"];</font> <font style=\"color:#595959;\"> //使用 for...of 遍历数组 </font> <font style=\"color:#595959;\"> for (let v of xiyou) {</font> <font style=\"color:#595959;\"> console.log(v);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> let iterator = xiyou[Symbol.iterator]();</font> <font style=\"color:#595959;\"> console.log(iterator);</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> //调用对象的next方法</font> <font style=\"color:#595959;\"> console.log(iterator.next());</font> <font style=\"color:#595959;\"> console.log(iterator.next());</font> <font style=\"color:#595959;\"> console.log(iterator.next());</font> <font style=\"color:#595959;\"> console.log(iterator.next());</font> <font style=\"color:#595959;\"> console.log(iterator.next());</font> <font style=\"color:#595959;\"> </script></font> 13、生成器 Generator 函数是 ES6 提供的一种异步编程解决方案，<font style=\"color:#000000;\">语法行为与传统函数完全不同</font> Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 （1）、生成器基本语法 <font style=\"color:#4D4D4D;\">通过function关键字后的星号(</font><font style=\"color:#F33232;\"></font><font style=\"color:#4D4D4D;\">)来表示，函数中会用到新的关键字</font><font style=\"color:#F33232;\">yield</font><font style=\"color:#4D4D4D;\">。星号（）可以紧挨着function关键字，也可以在中间添加一个空格</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //生成器其实就是一个特殊的函数</font> <font style=\"color:#595959;\"> //异步编程 纯回调函数 node fs ajax mongodb</font> <font style=\"color:#595959;\"> //yield 函数代码的分隔符,分割代码</font> <font style=\"color:#595959;\"> function* cook() {</font> <font style=\"color:#595959;\"> let i = 1;</font> <font style=\"color:#595959;\"> console.log(我被执行了${i}次);</font> <font style=\"color:#595959;\"> yield \"盛米\";</font> <font style=\"color:#595959;\"> i++;</font> <font style=\"color:#595959;\"> console.log(我被执行了${i}次);</font> <font style=\"color:#595959;\"> yield \"淘米\";</font> <font style=\"color:#595959;\"> i++;</font> <font style=\"color:#595959;\"> console.log(我被执行了${i}次);</font> <font style=\"color:#595959;\"> yield \"煮米\";</font> <font style=\"color:#595959;\"> i++;</font> <font style=\"color:#595959;\"> console.log(我被执行了${i}次);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> let iterator = cook(); //返回一个迭代器对象，里面有个next()方法</font> <font style=\"color:#595959;\"> //函数不会一下子执行完毕，会以yield为分割线，调一次next，执行一次</font> <font style=\"color:#595959;\"> console.log(iterator.next());</font> <font style=\"color:#595959;\"> console.log(iterator.next());</font> <font style=\"color:#595959;\"> console.log(iterator.next());</font> <font style=\"color:#595959;\"> console.log(iterator.next());</font> <font style=\"color:#595959;\"> //遍历</font> <font style=\"color:#595959;\"> // for(let v of cook()){</font> <font style=\"color:#595959;\"> // console.log(v);</font> <font style=\"color:#595959;\"> // }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">代码说明：</font> <font style=\"color:#000000;\">1) cook</font><font style=\"color:#4D4D4D;\">()前的星号 * 表明它是一个生成器</font> <font style=\"color:#000000;\">2) 生成器函数返回的结果是迭代器对象，调用迭代器对象的next 方法可以得到yield 语句后的值</font> <font style=\"color:#000000;\">3) yield 相当于函数的暂停标记，</font><font style=\"color:#4D4D4D;\">每当执行完一条yield语句后函数就会自动停止执行</font><font style=\"color:#000000;\">，也可以认为是函数的分隔符，每调用一次next方法，执行一段代码</font> <font style=\"color:#000000;\">4) next 方法可以传递实参，作为yield 语句的返回值</font> <font style=\"color:#000000;\">5）y</font><font style=\"color:#4D4D4D;\">ield关键字只可在生成器内部使用，在其他地方使用会导致程序抛出错误</font> （2）、生成器函数参数 概念：next('BBB')传入的参数作为上一个next方法的返回值。 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> function * gen(arg) {</font> <font style=\"color:#595959;\"> console.log(arg);//AAA</font> <font style=\"color:#595959;\"> let one = yield \"aaa\";</font> <font style=\"color:#595959;\"> console.log(one);//BBB</font> <font style=\"color:#595959;\"> let two = yield \"bbb\";</font> <font style=\"color:#595959;\"> console.log(two);//CCC</font> <font style=\"color:#595959;\"> let three = yield \"ccc\";</font> <font style=\"color:#595959;\"> console.log(three);//DDD</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //执行获取迭代器对象</font> <font style=\"color:#595959;\"> let iterator = gen(\"AAA \");</font> <font style=\"color:#595959;\"> console.log(iterator.next()); //{value: 'aaa', done: false}</font> <font style=\"color:#595959;\"> //next方法可以传入的实参，作为yield语句整体返回的结果</font> <font style=\"color:#595959;\"> console.log(iterator.next(\"BBB\"));</font> <font style=\"color:#595959;\"> console.log(iterator.next(\"CCC\"));</font> <font style=\"color:#595959;\"> console.log(iterator.next(\"DDD\"));</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\">（3）、生成器函数实例</font> （3）、生成器函数实例 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 异步编程 文件操作 网络操作(ajax, request) 数据库操作</font> <font style=\"color:#595959;\"> // 需求：1s 后控制台输出 111 2s后输出 222 3s后输出 333</font> <font style=\"color:#595959;\"> // 回调地狱（一层套一层，不停回调）</font> <font style=\"color:#595959;\"> /* setTimeout(() => {</font> <font style=\"color:#595959;\"> console.log(111);</font> <font style=\"color:#595959;\"> setTimeout(() => {</font> <font style=\"color:#595959;\"> console.log(222);</font> <font style=\"color:#595959;\"> setTimeout(() => {</font> <font style=\"color:#595959;\"> console.log(333);</font> <font style=\"color:#595959;\"> }, 3000);</font> <font style=\"color:#595959;\"> }, 2000);</font> <font style=\"color:#595959;\"> }, 1000); */</font> <font style=\"color:#595959;\"> // 生成器函数解决回调地域</font> <font style=\"color:#595959;\"> //生成3个异步函数</font> <font style=\"color:#595959;\"> function one() {</font> <font style=\"color:#595959;\"> setTimeout(() => {</font> <font style=\"color:#595959;\"> console.log(111);</font> <font style=\"color:#595959;\"> iterator.next(); //函数one执行完毕后，调用next(),执行下一个异步函数</font> <font style=\"color:#595959;\"> }, 1000);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> function two() {</font> <font style=\"color:#595959;\"> setTimeout(() => {</font> <font style=\"color:#595959;\"> console.log(222);</font> <font style=\"color:#595959;\"> iterator.next(); //函数two执行完毕后，调用next(),执行下一个异步函数</font> <font style=\"color:#595959;\"> }, 2000);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> function three() {</font> <font style=\"color:#595959;\"> setTimeout(() => {</font> <font style=\"color:#595959;\"> console.log(333);</font> <font style=\"color:#595959;\"> iterator.next(); //函数three执行完毕后，调用next(),执行下一个异步函数</font> <font style=\"color:#595959;\"> }, 3000);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //用生成器函数将三个异步函数放在yield语句中</font> <font style=\"color:#595959;\"> function* gen() {</font> <font style=\"color:#595959;\"> yield one();</font> <font style=\"color:#595959;\"> yield two();</font> <font style=\"color:#595959;\"> yield three();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //调用生成器函数</font> <font style=\"color:#595959;\"> let iterator = gen();</font> <font style=\"color:#595959;\"> iterator.next(); //调用一次next执行一个yield语句，这个只会执行one()回调</font> <font style=\"color:#595959;\"> </script></font> 14<font style=\"color:#000000;\">、</font>Promise （0）、回调地狱 回调地狱：就是回调函数<font style=\"color:#FF0000;\">嵌套过多</font>导致的 当一个回调函数嵌套一个回调函数的时候 就会出现一个嵌套结构 当嵌套的多了就会出现回调地狱的情况 比如我们发送三个 ajax 请求 第一个正常发送 第二个请求需要第一个请求的结果中的某一个值作为参数 第三个请求需要第二个请求的结果中的某一个值作为参数 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> function fn() {</font> <font style=\"color:#595959;\"> setTimeout(function () {</font> <font style=\"color:#595959;\"> console.log(\"111\");</font> <font style=\"color:#595959;\"> setTimeout(function () {</font> <font style=\"color:#595959;\"> console.log(\"222\");</font> <font style=\"color:#595959;\"> setTimeout(function () {</font> <font style=\"color:#595959;\"> console.log(\"333\");</font> <font style=\"color:#595959;\"> }, 1000);</font> <font style=\"color:#595959;\"> }, 2000);</font> <font style=\"color:#595959;\"> }, 3000);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fn();</font> <font style=\"color:#595959;\"> </script></font> （1）、什么是promise <font style=\"color:#0D0016;\">Promise是</font><font style=\"color:#FE2C24;\">ES6</font><font style=\"color:#0D0016;\">异步编程的一种</font><font style=\"color:#FE2C24;\">解决方案</font><font style=\"color:#0D0016;\">(目前最先进的解决方案是async和await的搭配（</font><font style=\"color:#FE2C24;\">ES8</font><font style=\"color:#0D0016;\">），但是它们是</font><font style=\"color:#FE2C24;\">基于promise</font><font style=\"color:#0D0016;\">的)</font> <font style=\"color:#0D0016;\">从语法上讲，Promise是一个</font><font style=\"color:#FE2C24;\">对象</font><font style=\"color:#0D0016;\">或者说是</font><font style=\"color:#FE2C24;\">构造函数</font><font style=\"color:#0D0016;\">，用来封装</font><font style=\"color:#FE2C24;\">异步操作</font><font style=\"color:#0D0016;\">并可以获取其</font><font style=\"color:#FE2C24;\">成功</font><font style=\"color:#0D0016;\">或</font><font style=\"color:#FE2C24;\">失败</font><font style=\"color:#0D0016;\">的结果。</font> （2）、Promise对象的状态: a、对象的状态不受外界影响。 <font style=\"color:#333333;\">Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</font> pending: 等待中，或者进行中，表示还没有得到结果 resolved(Fulfilled): 已经完成，表示得到了我们想要的结果，可以继续往下执行 rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行 b、Promise对象<font style=\"color:#4D4D4D;\">三种状态不受外界影响，</font><font style=\"color:#333333;\">三种的状态的变化途径只有两种。</font> 从“未完成”到“成功” 从“未完成”到“失败” <font style=\"color:#333333;\">一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</font> <font style=\"color:#333333;\">c、Promise 的最终结果只有两种。</font> 异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。 异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected。 （3）、Promise语法格式 <font style=\"color:#595959;\">//写法一</font> <font style=\"color:#595959;\">new Promise(function (resolve, reject) {</font> <font style=\"color:#595959;\"> // resolve 表示成功的回调</font> <font style=\"color:#595959;\"> // reject 表示失败的回调</font> <font style=\"color:#595959;\">}).then(function (res) {</font> <font style=\"color:#595959;\"> // 成功的函数</font> <font style=\"color:#595959;\">}).catch(function (err) {</font> <font style=\"color:#595959;\"> // 失败的函数</font> <font style=\"color:#595959;\">})</font> <font style=\"color:#595959;\">//写法二</font> <font style=\"color:#595959;\">new Promise(function (resolve, reject) {</font> <font style=\"color:#595959;\"> // resolve 表示成功的回调</font> <font style=\"color:#595959;\"> // reject 表示失败的回调</font> <font style=\"color:#595959;\">}).then(function (res) {</font> <font style=\"color:#595959;\"> // 成功的函数</font> <font style=\"color:#595959;\">},function(res){</font> <font style=\"color:#595959;\"> // 失败的函数</font> <font style=\"color:#595959;\">})</font> 出现了new关键字，就明白了<font style=\"color:#F33232;\">Promise对象其实就是一个构造函数</font>，是用来生成Promise实例的。能看出来构造函数接收了一个函数作为参数，该函数就是Promise构造函数的回调函数，该函数中有<font style=\"color:#F33232;\">两个参数resolve和reject</font>，这两个参数也分别是两个函数！ 简单的去理解的话 resolve函数的目的是将Promise对象状态变成成功状态，在异步操作成功时调用，将异步操作的结果，作为参数传递出去。 reject函数的目的是将Promise对象的状态变成失败状态，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 <font style=\"color:#FE2C24;\">注意：then方法可以接受两个函数</font><font style=\"color:#4D4D4D;\">，第一个函数为</font><font style=\"color:#FE2C24;\">promise状态为成功的回调函数</font><font style=\"color:#4D4D4D;\">，第二个函数为</font><font style=\"color:#FE2C24;\">promise状态为失败的回调函数</font><font style=\"color:#4D4D4D;\">（</font><font style=\"color:#FE2C24;\">可以不写，一般用catch方法捕获promise状态为失败的异常信息）</font> （4）、代码示例 <font style=\"color:#595959;\"> const promise = new Promise((resolve,reject)=>{</font> <font style=\"color:#595959;\"> //异步代码</font> <font style=\"color:#595959;\"> setTimeout(()=>{</font> <font style=\"color:#595959;\"> // resolve(['111','222','333'])</font> <font style=\"color:#595959;\"> reject('error')</font> <font style=\"color:#595959;\"> },2000)</font> <font style=\"color:#595959;\"> })</font> <font style=\"color:#595959;\"> //写法一</font> <font style=\"color:#595959;\"> promise.then((res)=>{</font> <font style=\"color:#595959;\"> //兑现承诺，这个函数被执行</font> <font style=\"color:#595959;\"> console.log('success',res);</font> <font style=\"color:#595959;\"> }).catch((err)=>{</font> <font style=\"color:#595959;\"> //拒绝承诺，这个函数就会被执行</font> <font style=\"color:#595959;\"> console.log('fail',err);</font> <font style=\"color:#595959;\"> })</font> <font style=\"color:#595959;\"> //写法二</font> <font style=\"color:#595959;\"> promise.then(</font> <font style=\"color:#595959;\"> function (value) {</font> <font style=\"color:#595959;\"> console.log(value);</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> function (reason) {</font> <font style=\"color:#595959;\"> console.error(reason);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> );</font> （5）、Promise封装Ajax <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // 接口地址: </font><font style=\"color:#595959;\">https://api.apiopen.top/getJoke</font> <font style=\"color:#595959;\"> const p = new Promise((resolve, reject) => {</font> <font style=\"color:#595959;\"> //1. 创建对象</font> <font style=\"color:#595959;\"> const xhr = new XMLHttpRequest();</font> <font style=\"color:#595959;\"> //2. 初始化</font> <font style=\"color:#595959;\"> xhr.open(\"GET\", \"https://api.apiopen.top/getJoke\");</font> <font style=\"color:#595959;\"> //3. 发送</font> <font style=\"color:#595959;\"> xhr.send();</font> <font style=\"color:#595959;\"> //4. 绑定事件, 处理响应结果</font> <font style=\"color:#595959;\"> xhr.onreadystatechange = function () {</font> <font style=\"color:#595959;\"> //判断</font> <font style=\"color:#595959;\"> if (xhr.readyState === 4) {</font> <font style=\"color:#595959;\"> //判断响应状态码 200-299</font> <font style=\"color:#595959;\"> if (xhr.status >= 200 && xhr.status < 300) {</font> <font style=\"color:#595959;\"> //表示成功</font> <font style=\"color:#595959;\"> resolve(xhr.response);</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> //如果失败</font> <font style=\"color:#595959;\"> reject(xhr.status);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> //指定回调</font> <font style=\"color:#595959;\"> p.then(</font> <font style=\"color:#595959;\"> function (value) {</font> <font style=\"color:#595959;\"> console.log(value);</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> function (reason) {</font> <font style=\"color:#595959;\"> console.error(reason);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> );</font> <font style=\"color:#595959;\"> </script></font> （6）、promise的对象方法 p1,p2,p3为promise的实例对象 Promise.then()<font style=\"color:#4D4D4D;\">方法</font> then方法的返回结果是 Promise 对象, 返回对象状态由回调函数的执行结果决定，结果有以下： a. 如果回调函数中返回的结果是 非 promise 类型的属性, 状态为成功, 返回值为对象的成功的值 b. 是 promise 对象,内部返回的状态，就是它的状态 c. 抛出错误 返回失败的promise状态 链式调用 可以改变回调地狱的情况 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //创建 promise 对象</font> <font style=\"color:#595959;\"> const p = new Promise((resolve, reject) => {</font> <font style=\"color:#595959;\"> setTimeout(() => {</font> <font style=\"color:#595959;\"> resolve(\"用户数据\");</font> <font style=\"color:#595959;\"> // reject('出错啦');</font> <font style=\"color:#595959;\"> }, 1000);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> const result = p.then(</font> <font style=\"color:#595959;\"> (value) => {</font> <font style=\"color:#595959;\"> console.log(value);</font> <font style=\"color:#595959;\"> //1. 非 promise 类型的属性</font> <font style=\"color:#595959;\"> // return 'iloveyou';</font> <font style=\"color:#595959;\"> //2. 是 promise 对象</font> <font style=\"color:#595959;\"> // return new Promise((resolve, reject)=>{</font> <font style=\"color:#595959;\"> // // resolve('ok');</font> <font style=\"color:#595959;\"> // reject('error');</font> <font style=\"color:#595959;\"> // });</font> <font style=\"color:#595959;\"> //3. 抛出错误</font> <font style=\"color:#595959;\"> // throw new Error('出错啦!');</font> <font style=\"color:#595959;\"> throw \"出错啦!\";</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> (reason) => {</font> <font style=\"color:#595959;\"> console.warn(reason);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> );</font> <font style=\"color:#595959;\"> //链式调用</font> <font style=\"color:#595959;\"> p.then(value=>{}).then(value=>{}); </font> <font style=\"color:#595959;\"> </script></font> Promise.catch() <font style=\"color:#FE2C24;\">一般用catch方法捕获promise状态为失败的异常信息</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> const p = new Promise((resolve, reject)=>{</font> <font style=\"color:#595959;\"> setTimeout(()=>{</font> <font style=\"color:#595959;\"> //设置 p 对象的状态为失败, 并设置失败的值</font> <font style=\"color:#595959;\"> reject(\"出错啦!\");</font> <font style=\"color:#595959;\"> }, 1000)</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> // p.then(function(value){}, function(reason){</font> <font style=\"color:#595959;\"> // console.error(reason);</font> <font style=\"color:#595959;\"> // });</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> p.catch(function(reason){</font> <font style=\"color:#595959;\"> console.warn(reason);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#4D4D4D;\">Promise.all()</font> <font style=\"color:#FE2C24;\">并发处理多个异步任务</font><font style=\"color:#4D4D4D;\">，</font><font style=\"color:#FE2C24;\">所有任务都执行完成</font><font style=\"color:#4D4D4D;\">才能得到结果</font> <font style=\"color:#595959;\">Promise.all( [p1,p2,p3] ) .then ( (result) => {consoleog (result)</font> <font style=\"color:#595959;\">})</font> <font style=\"color:#4D4D4D;\">Promise.race()</font> 只返回异步任务数组中第一个执行完的结果，其他任务仍在执行，不过结果会被抛弃 应用场景： 几个接口返回一样的数据，哪个快用哪个 <font style=\"color:#595959;\">Promise.race ( [p1,p2] ).then ( (result)=>{</font> <font style=\"color:#595959;\">console. log (result)</font> <font style=\"color:#595959;\">})</font> 15、set （1）、set基本知识 <font style=\"color:#000000;\">ES6 提供了新的</font><font style=\"color:#F33232;\">数据结构</font><font style=\"color:#000000;\"> Set（集合）。它类似于数组，但成员的值都是唯一的，集合实现了iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历</font> 实例的属性和方法 size：返回Set实例的成员总数。 Set.prototype.add(value)：添加某个value。 Set.prototype.delete(value)：删除某个value，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //声明一个 set</font> <font style=\"color:#595959;\"> let s = new Set();</font> <font style=\"color:#595959;\"> let s2 = new Set(['张三','李四','王五','赵六']);</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> //元素个数</font> <font style=\"color:#595959;\"> // console.log(s2.size);</font> <font style=\"color:#595959;\"> //添加新的元素</font> <font style=\"color:#595959;\"> // s2.add('jack');</font> <font style=\"color:#595959;\"> //删除元素</font> <font style=\"color:#595959;\"> // s2.delete('李四');</font> <font style=\"color:#595959;\"> //检测</font> <font style=\"color:#595959;\"> // console.log(s2.has('王五'));</font> <font style=\"color:#595959;\"> //清空</font> <font style=\"color:#595959;\"> // s2.clear();</font> <font style=\"color:#595959;\"> // console.log(s2);</font> <font style=\"color:#595959;\"> //遍历元素</font> <font style=\"color:#595959;\"> for(let v of s2){</font> <font style=\"color:#595959;\"> console.log(v);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> </script></font> set遍历 Set.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：遍历每个成员 <font style=\"color:#595959;\">let arr = new Set([\"red\", \"green\", \"blue\"]);</font> <font style=\"color:#595959;\"> // 返回键名</font> <font style=\"color:#595959;\"> for (let item of arr.keys()) {</font> <font style=\"color:#595959;\"> // console.log(item);//red green blue</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 返回键值</font> <font style=\"color:#595959;\"> for (let item of arr.values()) {</font> <font style=\"color:#595959;\"> // console.log(item);//red green blue</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // set 键名=键值</font> <font style=\"color:#595959;\"> // 返回键值对</font> <font style=\"color:#595959;\"> for (let item of arr.entries()) {</font> <font style=\"color:#595959;\"> // console.log(item);// ['red', 'red'] ['green', 'green'] ['blue', 'blue']</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // set也有forEach()方法</font> <font style=\"color:#595959;\"> arr.forEach((value, key) => console.log(key + \" : \" + value));</font> <font style=\"color:#000000;\">（2）、set实践</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> let arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];</font> <font style=\"color:#595959;\"> //1. 数组去重</font> <font style=\"color:#595959;\"> // let result = new Set(arr);</font> <font style=\"color:#595959;\"> // result = [...result];</font> <font style=\"color:#595959;\"> // console.log(result);</font> <font style=\"color:#595959;\"> //2. 交集</font> <font style=\"color:#595959;\"> let arr2 = [4, 5, 6, 5, 6];</font> <font style=\"color:#595959;\"> / 可以先去重，避免做无用对比 /</font> <font style=\"color:#595959;\"> // let result = [...new Set(arr)].filter(item => {</font> <font style=\"color:#595959;\"> // let s2 = new Set(arr2);//数组2去重后的结果 4 5 6</font> <font style=\"color:#595959;\"> // if(s2.has(item)){</font> <font style=\"color:#595959;\"> // return true;</font> <font style=\"color:#595959;\"> // }else{</font> <font style=\"color:#595959;\"> // return false;</font> <font style=\"color:#595959;\"> // }</font> <font style=\"color:#595959;\"> // });</font> <font style=\"color:#595959;\"> //简化版本</font> <font style=\"color:#595959;\"> // let result = [...new Set(arr)].filter((item) => new Set(arr2).has(item));</font> <font style=\"color:#595959;\"> //console.log(result);</font> <font style=\"color:#595959;\"> //3. 并集</font> <font style=\"color:#595959;\"> // let union = [...new Set([...arr, ...arr2])];</font> <font style=\"color:#595959;\"> // console.log(union);</font> <font style=\"color:#595959;\"> //4. 差集</font> <font style=\"color:#595959;\"> // let diff = [...new Set(arr)].filter(item => !(new Set(arr2).has(item)));</font> <font style=\"color:#595959;\"> // console.log(diff);</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">16、Map</font> <font style=\"color:#000000;\">ES6 提供了Map</font><font style=\"color:#F33232;\"> 数据结构</font><font style=\"color:#000000;\">。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。</font> <font style=\"color:#000000;\">Map 的属性和方法：</font> <font style=\"color:#000000;\">1) size 返回Map 的元素个数</font> <font style=\"color:#000000;\">2) set 增加一个新元素，返回当前Map </font> <font style=\"color:#000000;\">3) get 返回键名对象的键值</font> <font style=\"color:#000000;\">4) has 检测Map 中是否包含某个元素，返回boolean 值</font> <font style=\"color:#000000;\">5) clear 清空集合，返回undefined</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> / map升级后的对象，键名可以是对象 /</font> <font style=\"color:#595959;\"> //声明 Map</font> <font style=\"color:#595959;\"> let m = new Map();</font> <font style=\"color:#595959;\"> //添加元素 set()</font> <font style=\"color:#595959;\"> m.set('name','bdqn');//键名：字符串</font> <font style=\"color:#595959;\"> m.set('change', function(){//键名：字符串</font> <font style=\"color:#595959;\"> console.log(\"我们可以改变你!!\");</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> let key = {</font> <font style=\"color:#595959;\"> school : '北京大学'</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> m.set(key, ['北京','上海','深圳']);//键名：对象</font> <font style=\"color:#595959;\"> //size</font> <font style=\"color:#595959;\"> // console.log(m.size);</font> <font style=\"color:#595959;\"> //删除</font> <font style=\"color:#595959;\"> // m.delete('name');</font> <font style=\"color:#595959;\"> //获取 get()</font> <font style=\"color:#595959;\"> // console.log(m.get('change'));</font> <font style=\"color:#595959;\"> // console.log(m.get(key));</font> <font style=\"color:#595959;\"> //清空 clear()</font> <font style=\"color:#595959;\"> // m.clear();</font> <font style=\"color:#595959;\"> //遍历</font> <font style=\"color:#595959;\"> // for(let v of m){</font> <font style=\"color:#595959;\"> // console.log(v);</font> <font style=\"color:#595959;\"> // }</font> <font style=\"color:#595959;\"> console.log(m);</font> <font style=\"color:#595959;\"> </script></font> 17、class类 JavaScript 语言中，生成实例对象的传统方法是通过构造函数，ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 1> class初体验 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // //es5通过构造函数实现</font> <font style=\"color:#595959;\"> // function PersonO(username, password) {</font> <font style=\"color:#595959;\"> // this.username = username;</font> <font style=\"color:#595959;\"> // this.password = password;</font> <font style=\"color:#595959;\"> // }</font> <font style=\"color:#595959;\"> // // 添加方法</font> <font style=\"color:#595959;\"> // PersonO.prototype.getstr = function () {</font> <font style=\"color:#595959;\"> // console.log(\"用户名：\" + this.username + \",密码：\" + this.password);</font> <font style=\"color:#595959;\"> // };</font> <font style=\"color:#595959;\"> // // 实例化对象</font> <font style=\"color:#595959;\"> // const po1 = new PersonO(\"章三\", \"abc123\");</font> <font style=\"color:#595959;\"> // console.log(po1);</font> <font style=\"color:#595959;\"> // po1.getstr();</font> <font style=\"color:#595959;\"> // es6实现 class方法实现</font> <font style=\"color:#595959;\"> class PersonN {</font> <font style=\"color:#595959;\"> //构造方法 constructor名字不能修改</font> <font style=\"color:#595959;\"> // 当我们new实例对象的时候，这个方法自动执行</font> <font style=\"color:#595959;\"> constructor(username, password) {</font> <font style=\"color:#595959;\"> this.username = username;</font> <font style=\"color:#595959;\"> this.password = password;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //方法必须使用该语法, 不能使用 ES5 的对象完整形式</font> <font style=\"color:#595959;\"> getstr() {</font> <font style=\"color:#595959;\"> console.log(\"用户名：\" + this.username + \"，密码：\" + this.password);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //ES5 的对象完整形式 报错</font> <font style=\"color:#595959;\"> // getstr:function () {}</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> const pn1 = new PersonN(\"123456\", \"789012\");</font> <font style=\"color:#595959;\"> pn1.getstr();</font> <font style=\"color:#595959;\"> </script></font> 说明：使用class关键词 声明类，constructor为构造方法，一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加， this关键字则代表实例对象， getstr()为普通方法，不要用es5完整写法，getstr()存在 prototype上。 pn1.constructor === pn1.prototype.constructor // true 2> 类的静态成员 es5可以直接给构造函数添加属性，方法，这些属性方法不在这个构造函数实例的对象身上 对应的es6中，类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // es5</font> <font style=\"color:#595959;\"> function Phone() {}</font> <font style=\"color:#595959;\"> // 给Phone添加静态属性</font> <font style=\"color:#595959;\"> Phone.name = \"手机\";</font> <font style=\"color:#595959;\"> Phone.call = function () {</font> <font style=\"color:#595959;\"> console.log(\"我可以打电话\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //实例化对象</font> <font style=\"color:#595959;\"> let apple = new Phone();</font> <font style=\"color:#595959;\"> // console.log(apple.name); //undefined</font> <font style=\"color:#595959;\"> //apple.change(); //报错 实例身上是没有构造函数身上的属性和方法</font> <font style=\"color:#595959;\"> // Phone.call(); //我可以打电话</font> <font style=\"color:#595959;\"> class PhoneN{</font> <font style=\"color:#595959;\"> static name='手机'</font> <font style=\"color:#595959;\"> static game(){</font> <font style=\"color:#595959;\"> console.log('我可以打游戏');</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> let p1=new PhoneN()</font> <font style=\"color:#595959;\"> console.log(p1.name);//undefined</font> <font style=\"color:#595959;\"> console.log(PhoneN.name);//手机</font> <font style=\"color:#595959;\"> </script></font> 3> 类的继承 （1）、es5的继承 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //手机 父级构造函数</font> <font style=\"color:#595959;\"> function Phone(brand, price) {</font> <font style=\"color:#595959;\"> this.brand = brand;</font> <font style=\"color:#595959;\"> this.price = price;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> Phone.prototype.call = function () {</font> <font style=\"color:#595959;\"> console.log(\"我可以打电话\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //智能手机 子级构造函数</font> <font style=\"color:#595959;\"> function SmartPhone(brand, price, color, size) {</font> <font style=\"color:#595959;\"> //通过call方法改变this指向，指向SmartPhone的实例对象</font> <font style=\"color:#595959;\"> Phone.call(this, brand, price);</font> <font style=\"color:#595959;\"> //子类独有的属性</font> <font style=\"color:#595959;\"> this.color = color;</font> <font style=\"color:#595959;\"> this.size = size;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //设置子级构造函数的原型 让SmartPhone的实例对象有父类的属性方法</font> <font style=\"color:#595959;\"> SmartPhone.prototype = new Phone();</font> <font style=\"color:#595959;\"> SmartPhone.prototype.constructor = SmartPhone;</font> <font style=\"color:#595959;\"> //声明子类的方法</font> <font style=\"color:#595959;\"> SmartPhone.prototype.photo = function () {</font> <font style=\"color:#595959;\"> console.log(\"我可以拍照\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> SmartPhone.prototype.playGame = function () {</font> <font style=\"color:#595959;\"> console.log(\"我可以玩游戏\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //实例化对象</font> <font style=\"color:#595959;\"> const chuizi = new SmartPhone(\"锤子\", 2499, \"黑色\", \"5.5inch\");</font> <font style=\"color:#595959;\"> console.log(chuizi);</font> <font style=\"color:#595959;\"> </script></font> （2）、es6的继承 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 定义父类</font> <font style=\"color:#595959;\"> class Student {</font> <font style=\"color:#595959;\"> //构造方法</font> <font style=\"color:#595959;\"> constructor(realname, age) {</font> <font style=\"color:#595959;\"> this.realname = realname;</font> <font style=\"color:#595959;\"> this.age = age;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //父类的成员属性</font> <font style=\"color:#595959;\"> play(str) {</font> <font style=\"color:#595959;\"> console.log(\"我会玩\" + str);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //定义子类</font> <font style=\"color:#595959;\"> class ItStudent extends Student {</font> <font style=\"color:#595959;\"> //构造方法</font> <font style=\"color:#595959;\"> constructor(realname, age, major) {</font> <font style=\"color:#595959;\"> //调用父类的方法，相当于Student.call(this,realname, age)</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">super(realname, age);</font> <font style=\"color:#595959;\"> this.major = major;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //子类的成员属性</font> <font style=\"color:#595959;\"> program(type) {</font> <font style=\"color:#595959;\"> console.log(\"我会编程的语言是：\" + type);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 子类对父类方法的重写</font> <font style=\"color:#595959;\"> play(str) {</font> <font style=\"color:#595959;\"> console.log(\"我只学习，不玩\" + str);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //实例化对象</font> <font style=\"color:#595959;\"> const It1 = new ItStudent(\"张三\", 20, \"大数据\");</font> <font style=\"color:#595959;\"> console.log(It1.realname);</font> <font style=\"color:#595959;\"> It1.play(\"游戏\"); //我只学习，不玩游戏</font> <font style=\"color:#595959;\"> </script></font> 说明：Class 可以通过extends关键字实现继承，让子类继承父类的属性和方法。ES6 规定，子类必须在constructor()方法中调用super()，否则就会报错。 4> getter和setter设置 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // get 和 set</font> <font style=\"color:#595959;\"> class Phone {</font> <font style=\"color:#595959;\"> // get 监测动态属性的变化</font> <font style=\"color:#595959;\"> get price() {</font> <font style=\"color:#595959;\"> console.log(\"价格属性被读取了\");</font> <font style=\"color:#595959;\"> return \"iloveyou\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // set 对更改设置的值做判断，合法怎么办，不合法怎么办</font> <font style=\"color:#595959;\"> set price(newVal) {</font> <font style=\"color:#595959;\"> console.log(\"价格属性被修改了\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //实例化对象</font> <font style=\"color:#595959;\"> let s = new Phone();</font> <font style=\"color:#595959;\"> console.log(s.price);//输出price属性，只要读取，就会执行get后面对应的函数代码，函数的返回值就是属性的返回值</font> <font style=\"color:#595959;\"> s.price = \"9.9\";//更改price属性，只要更改，就会执行set后面对应的函数代码</font> <font style=\"color:#595959;\"> </script></font> 18、模块化（module） <font style=\"color:#000000;\">模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。</font> 1、模块化的优势 <font style=\"color:#000000;\">1) 防止命名冲突</font> <font style=\"color:#000000;\">2) 代码复用</font> <font style=\"color:#000000;\">3) 高维护性，可以对某些模块化升级</font> 2、ES6 模块化语法 <font style=\"color:#000000;\">模块功能主要由两个命令构成：</font><font style=\"color:#FF0000;\">export </font><font style=\"color:#000000;\">和</font><font style=\"color:#FF0000;\">import</font><font style=\"color:#000000;\">。</font> <font style=\"color:#FF0000;\">export </font><font style=\"color:#000000;\">命令用于规定模块的对外接口，</font><font style=\"color:#FF0000;\">对外暴露</font> <font style=\"color:#FF0000;\">import </font><font style=\"color:#000000;\">命令用于输入其他模块提供的功能 ，</font><font style=\"color:#FF0000;\">引入暴露的文件</font> 1> 暴露语法汇总 <font style=\"color:#000000;\">（1）、</font><font style=\"color:#FF0000;\">分别暴露</font> <font style=\"color:#595959;\">//m1.js 分别暴露</font> <font style=\"color:#595959;\">export let school = 'bdqn';</font> <font style=\"color:#595959;\">export function teach() {</font> <font style=\"color:#595959;\"> console.log(\"我们可以教给你开发技能\");</font> <font style=\"color:#595959;\">}</font> （2）、<font style=\"color:#FF0000;\">统一暴露</font> <font style=\"color:#595959;\">// m2.js 统一暴露</font> <font style=\"color:#595959;\">let school = 'bdqn';</font> <font style=\"color:#595959;\">function findJob(){</font> <font style=\"color:#595959;\"> console.log(\"我们可以帮助你找工作!!\");</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#FF0000;\">export {school, findJob}; //用花括号包裹</font> （3）、<font style=\"color:#FF0000;\">默认暴露</font> <font style=\"color:#595959;\">//m3.js 默认暴露</font> <font style=\"color:#FF0000;\">export default </font><font style=\"color:#595959;\">{</font> <font style=\"color:#595959;\"> school: 'bdqn',</font> <font style=\"color:#595959;\"> change: function(){</font> <font style=\"color:#595959;\"> console.log(\"我们可以改变你!!\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">}</font> export和export default的区别(面试题) 1、两者均可用于导出常量、函数、文件、模块； 2、在一个文件中<font style=\"color:#FF0000;\">可以多次</font>使用<font style=\"color:#FF0000;\">export</font>，但是<font style=\"color:#FF0000;\">export default只能用一次</font>； 3、<font style=\"color:#FF0000;\">通过export输出的，在import导入时需要使用{}，export default不需要；</font> 4、<font style=\"color:#FF0000;\">export与export default不可同时使用；</font> 2> 引入暴露文件语法 （1）、通用方式 <font style=\"color:#595959;\"> //1. 通用的导入方式</font> <font style=\"color:#595959;\"> //引入 m1.js 模块内容</font> <font style=\"color:#595959;\"> import * as m1 from './js/m1.js'</font> <font style=\"color:#595959;\"> //引入 m2.js 模块内容</font> <font style=\"color:#595959;\"> import * as m2 from \"./js/m2.js\";</font> <font style=\"color:#595959;\"> //引入 m3.js</font> <font style=\"color:#595959;\"> import * as m3 from \"./js/m3.js\";</font> <font style=\"color:#595959;\"> console.log(m1);</font> （2）、解构附值 <font style=\"color:#595959;\">//2. 解构赋值形式的导入方式</font> <font style=\"color:#595959;\"> import { school, teach } from \"./js/m1.js\";</font> <font style=\"color:#595959;\"> //</font><font style=\"color:#FF0000;\">用别名</font> <font style=\"color:#595959;\"> import </font><font style=\"color:#FF0000;\">{school as yyzx, findJob} </font><font style=\"color:#595959;\">from \"./js/m2.js\";</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> import {default as m3} from \"./js/m3.js\";</font> （3）、简易形式 <font style=\"color:#595959;\"> //3. 简便形式的导入方式 针对默认暴露</font> <font style=\"color:#595959;\"> import m3 from \"./js/m3.js\";</font> 3> 建立入口文件形式 <font style=\"color:#595959;\">// app.js 入口文件</font> <font style=\"color:#595959;\">//模块引入</font> <font style=\"color:#595959;\">import * as m1 from \"./m1.js\";</font> <font style=\"color:#595959;\">import * as m2 from \"./m2.js\";</font> <font style=\"color:#595959;\">import * as m3 from \"./m3.js\";</font> <font style=\"color:#595959;\">console.log(m1);</font> <font style=\"color:#595959;\">console.log(m2);</font> <font style=\"color:#595959;\">console.log(m3);</font> <font style=\"color:#595959;\"><!--index.html 引入 入口文件 --></font> <font style=\"color:#595959;\"> <script src=\"./js/app.js\" type=\"module\"></script></font> 三、ES7 1.Array.includes Includes 方法用来检测数组中是否包含某个元素，返回布尔类型值 JavaScript<font style=\"color:#585A5A;\">运行代码复制代码</font> <font style=\"color:#6C6C6C;\">1</font> <font style=\"color:#6C6C6C;\">2</font> <font style=\"color:#6C6C6C;\">3</font> <font style=\"color:#6C6C6C;\">4</font> <font style=\"color:#6C6C6C;\">5</font> <font style=\"color:#6C6C6C;\">6</font> <font style=\"color:#6C6C6C;\">7</font> <font style=\"color:#6C6C6C;\">8</font> <font style=\"color:#6C6C6C;\">9</font> <font style=\"color:#6C6C6C;\">10</font> <font style=\"color:#6C6C6C;\">11</font> <<font style=\"color:#232930;\">script</font><font style=\"color:#E10023;\">></font> <font style=\"color:#6A737D;\">// includes </font> <font style=\"color:#D73A49;\">const</font> <font style=\"color:#A13000;\">mingzhu</font> <font style=\"color:#E10023;\">=</font> [<font style=\"color:#669900;\">'王二'</font>,<font style=\"color:#669900;\">'张三'</font>,<font style=\"color:#669900;\">'李四'</font>,<font style=\"color:#669900;\">'王五'</font>]; <font style=\"color:#6A737D;\">//判断</font> <font style=\"color:#232930;\">console</font><font style=\"color:#E10023;\">.</font><font style=\"color:#005CC5;\">log</font>(<font style=\"color:#232930;\">mingzhu</font><font style=\"color:#E10023;\">.</font><font style=\"color:#005CC5;\">includes</font>(<font style=\"color:#669900;\">'张三'</font>));<font style=\"color:#6A737D;\">//true</font> <font style=\"color:#232930;\">console</font><font style=\"color:#E10023;\">.</font><font style=\"color:#005CC5;\">log</font>(<font style=\"color:#232930;\">mingzhu</font><font style=\"color:#E10023;\">.</font><font style=\"color:#005CC5;\">includes</font>(<font style=\"color:#669900;\">'周六'</font>));<font style=\"color:#6A737D;\">//false</font> <font style=\"color:#6A737D;\">//indexOf 是否存在数组中 返回的是数字</font> <font style=\"color:#232930;\">console</font><font style=\"color:#E10023;\">.</font><font style=\"color:#005CC5;\">log</font>(<font style=\"color:#232930;\">mingzhu</font><font style=\"color:#E10023;\">.</font><font style=\"color:#005CC5;\">indexOf</font>(<font style=\"color:#669900;\">'张三'</font>));<font style=\"color:#6A737D;\">//1</font> <font style=\"color:#232930;\">console</font><font style=\"color:#E10023;\">.</font><font style=\"color:#005CC5;\">log</font>(<font style=\"color:#232930;\">mingzhu</font><font style=\"color:#E10023;\">.</font><font style=\"color:#005CC5;\">indexOf</font>(<font style=\"color:#669900;\">'周六'</font>));<font style=\"color:#6A737D;\">//-1</font> <<font style=\"color:#669900;\">/script></font> 2、 指数操作符 在ES7 中引入指数运算符「」，用来实现幂运算，功能与Math.pow 结果相同 JavaScript<font style=\"color:#585A5A;\">运行代码复制代码</font> <font style=\"color:#6C6C6C;\">1</font> <font style=\"color:#6C6C6C;\">2</font> <font style=\"color:#232930;\">console</font><font style=\"color:#E10023;\">.</font><font style=\"color:#005CC5;\">log</font>(<font style=\"color:#005CC5;\">2</font> <font style=\"color:#E10023;\"></font> <font style=\"color:#005CC5;\">10</font>); <font style=\"color:#6A737D;\">//1024</font> <font style=\"color:#232930;\">console</font><font style=\"color:#E10023;\">.</font><font style=\"color:#005CC5;\">log</font>(<font style=\"color:#232930;\">Math</font><font style=\"color:#E10023;\">.</font><font style=\"color:#005CC5;\">pow</font>(<font style=\"color:#005CC5;\">2</font>, <font style=\"color:#005CC5;\">10</font>));<font style=\"color:#6A737D;\">//1024</font> 四、ES8 <font style=\"color:#DF2A3F;\">1、async 和 await</font> <font style=\"color:#000000;\">async 和await 两种语法结合可以让异步代码像同步代码一样</font> （1）、async 函数 async 是一个修饰符，async 定义的函数会默认的返回一个Promise对象resolve(已定型成功或失败)的值，因此对async函数可以直接进行then操作,返回的值即为then方法的传入函数。 <font style=\"color:#000000;\">async 函数的返回值为promise 对象，</font> <font style=\"color:#000000;\">promise 对象的结果由async 函数执行的返回值决定</font> 返回的结果不是一个 Promise 类型的对象, 是字符串、数字、undefined等,就是成功的结果 抛出错误, 返回的结果是一个失败的 Promise 返回的结果如果是一个 Promise 对象，根据Promise返回的结果确定状态 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //async 函数</font> <font style=\"color:#595959;\"> async function fn() {</font> <font style=\"color:#595959;\"> /* 1: 返回的结果不是一个 Promise 类型的对象, 是字符串、数字、undefined等</font> <font style=\"color:#595959;\"> 返回的结果就是成功 Promise 对象 */</font> <font style=\"color:#595959;\"> // return 'bdqn';</font> <font style=\"color:#595959;\"> // return; </font> <font style=\"color:#595959;\"> // 2:抛出错误, 返回的结果是一个失败的 Promise</font> <font style=\"color:#595959;\"> throw new Error('出错啦!');</font> <font style=\"color:#595959;\"> // 3:返回的结果如果是一个 Promise 对象，根据Promise返回的结果确定状态</font> <font style=\"color:#595959;\"> // return new Promise((resolve, reject) => {</font> <font style=\"color:#595959;\"> // resolve(\"成功的数据\");</font> <font style=\"color:#595959;\"> // reject(\"失败的错误\");</font> <font style=\"color:#595959;\"> // });</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> const result = fn();</font> <font style=\"color:#595959;\"> //调用 then 方法</font> <font style=\"color:#595959;\"> result.then(</font> <font style=\"color:#595959;\"> (value) => {</font> <font style=\"color:#595959;\"> console.log(value,'成功回调');</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> (reason) => {</font> <font style=\"color:#595959;\"> console.warn(reason,'失败回调');</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> );</font> <font style=\"color:#595959;\"> </script></font> （2）、await 表达式 <font style=\"color:#000000;\">await 必须写在async 函数中</font> <font style=\"color:#000000;\">await 右侧的表达式一般为promise 对象</font> <font style=\"color:#000000;\">await 返回的是promise 成功的值</font> <font style=\"color:#000000;\">await 的promise 失败了, 就会抛出异常, 需要通过try...catch 捕获处理</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //创建 promise 对象</font> <font style=\"color:#595959;\"> const p = new Promise((resolve, reject) => {</font> <font style=\"color:#595959;\"> // resolve(\"用户数据\");</font> <font style=\"color:#595959;\"> reject(\"失败啦!\");</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> //1: await 要放在 async 函数中. await单向依赖async</font> <font style=\"color:#595959;\"> async function main() {</font> <font style=\"color:#595959;\"> try {</font> <font style=\"color:#595959;\"> // result 是Promise对象成功的值</font> <font style=\"color:#595959;\"> let result = await p;</font> <font style=\"color:#595959;\"> console.log(result, \"async,await\");</font> <font style=\"color:#595959;\"> } catch (e) {</font> <font style=\"color:#595959;\"> //e返回的 是Promise对象失败的值</font> <font style=\"color:#595959;\"> console.log(e, \"async,await\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //调用函数</font> <font style=\"color:#595959;\"> main();</font> <font style=\"color:#595959;\"> // Promise调用then方法</font> <font style=\"color:#595959;\"> /* p.then(</font> <font style=\"color:#595959;\"> (v) => {</font> <font style=\"color:#595959;\"> console.log(v, \"then方法\");</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> (r) => {</font> <font style=\"color:#595959;\"> console.log(r, \"then方法\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> ); */</font> <font style=\"color:#595959;\"> </script></font> （3）、async与await封装AJAX请求 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // 发送 AJAX 请求, 返回的结果是 Promise 对象</font> <font style=\"color:#595959;\"> function sendAJAX(url) {</font> <font style=\"color:#595959;\"> return new Promise((resolve, reject) => {</font> <font style=\"color:#595959;\"> //1. 创建对象</font> <font style=\"color:#595959;\"> const x = new XMLHttpRequest();</font> <font style=\"color:#595959;\"> //2. 初始化</font> <font style=\"color:#595959;\"> x.open(\"GET\", url);</font> <font style=\"color:#595959;\"> //3. 发送</font> <font style=\"color:#595959;\"> x.send();</font> <font style=\"color:#595959;\"> //4. 事件绑定</font> <font style=\"color:#595959;\"> x.onreadystatechange = function () {</font> <font style=\"color:#595959;\"> if (x.readyState === 4) {</font> <font style=\"color:#595959;\"> if (x.status >= 200 && x.status < 300) {</font> <font style=\"color:#595959;\"> //成功啦</font> <font style=\"color:#595959;\"> resolve(x.response);</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> //如果失败</font> <font style=\"color:#595959;\"> reject(x.status);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //第一种：promise then 方法测试</font> <font style=\"color:#595959;\"> // sendAJAX(\"https://api.apiopen.top/getJoke\").then(value=>{</font> <font style=\"color:#595959;\"> // console.log(value);</font> <font style=\"color:#595959;\"> // }, reason=>{})</font> <font style=\"color:#595959;\"> //第二种： async 与 await 测试 axios</font> <font style=\"color:#595959;\"> async function main() {</font> <font style=\"color:#595959;\"> //发送 AJAX 请求</font> <font style=\"color:#595959;\"> let result = await sendAJAX(\"https://api.apiopen.top/getJoke\");</font> <font style=\"color:#595959;\"> console.log(result);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> main();</font> <font style=\"color:#595959;\"> </script></font> 2、对象方法扩展 （1）、<font style=\"color:#000000;\">Object.values 和Object.entries</font> <font style=\"color:#000000;\">Object.values()方法返回一个给定对象的所有可枚举属性值的数组</font> <font style=\"color:#000000;\">Object.entries()方法返回一个给定对象自身可遍历属性[key,value] 的数组</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //声明对象</font> <font style=\"color:#595959;\"> const school = {</font> <font style=\"color:#595959;\"> name: \"bdqn\",</font> <font style=\"color:#595959;\"> cities: [\"北京\", \"上海\", \"深圳\"],</font> <font style=\"color:#595959;\"> xueke: [\"前端\", \"Java\", \"大数据\", \"测试\"],</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //获取对象所有的键</font> <font style=\"color:#595959;\"> console.log(Object.keys(school),'key');//['name', 'cities', 'xueke'] 'key'</font> <font style=\"color:#595959;\"> //获取对象所有的值</font> <font style=\"color:#595959;\"> console.log(Object.values(school),'value');//['bdqn', Array(3), Array(4)] 'value'</font> <font style=\"color:#595959;\"> //entries 返回的是一个数组，数组里放一组组数组，里面是键，值</font> <font style=\"color:#595959;\"> console.log(Object.entries(school),'entries');</font> <font style=\"color:#595959;\"> //有了上面的entries结果，方便创建 Map</font> <font style=\"color:#595959;\"> // const m = new Map(Object.entries(school));</font> <font style=\"color:#595959;\"> // console.log(m,'map');</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">（2）、Object.getOwnPropertyDescriptors</font> <font style=\"color:#000000;\">该方法返回指定对象所有自身属性的描述对象</font> <font style=\"color:#000000;\">补充</font> Object.create( proto[,propertiesObject] ) 参数 proto：创建对象的原型，表示要继承的对象 propertiesObject(可选 )：也是一个对象，用于对新创建的对象进行初始化 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //声明对象</font> <font style=\"color:#595959;\"> const school = {</font> <font style=\"color:#595959;\"> name: \"bdqn\",</font> <font style=\"color:#595959;\"> cities: [\"北京\", \"上海\", \"深圳\"],</font> <font style=\"color:#595959;\"> xueke: [\"前端\", \"Java\", \"大数据\", \"测试\"],</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //对象属性的描述对象</font> <font style=\"color:#595959;\"> console.log(Object.getOwnPropertyDescriptors(school),'111');</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> // 可以对对象深层次的克隆</font> <font style=\"color:#595959;\"> const obj = Object.create(null, {</font> <font style=\"color:#595959;\"> name: {</font> <font style=\"color:#595959;\"> //设置值</font> <font style=\"color:#595959;\"> value: \"bdqn\",</font> <font style=\"color:#595959;\"> //属性特性</font> <font style=\"color:#595959;\"> writable: true,//是否可写</font> <font style=\"color:#595959;\"> configurable: true,//是否可以删除</font> <font style=\"color:#595959;\"> enumerable: true,//是否可以遍历</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> 3、字符串填充 padStart()、padEnd()方法可以使得字符串达到固定长度， 有两个参数，字符串目标长度和填充内容。 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> let str = \"hello\";</font> <font style=\"color:#595959;\"> console.log(str.padStart(10, \"m\")); //mmmmmhello</font> <font style=\"color:#595959;\"> console.log(str.padEnd(10, \"m\")); //hellommmmm</font> <font style=\"color:#595959;\"> console.log(str.padStart(5, \"m\")); //hello，如果长度够，就不添加</font> <font style=\"color:#595959;\"> console.log(str.padEnd(5, \"m\")); //hello</font> <font style=\"color:#595959;\"> </script></font> 五、ES9 1、对象拓展 <font style=\"color:#000000;\">Rest 参数与spread 扩展运算符在ES6 中已经引入，不过ES6 中只针对于数组，在ES9 中为对象提供了像数组一样的rest 参数和扩展运算符</font> （1）、<font style=\"color:#000000;\">Rest 参数</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //rest 参数</font> <font style=\"color:#595959;\"> function connect({ name, sex, ...other }) {</font> <font style=\"color:#595959;\"> console.log(name); //孙悟空</font> <font style=\"color:#595959;\"> console.log(sex); //男</font> <font style=\"color:#595959;\"> console.log(other); //{age: 20, address: '花果山'}</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> connect({</font> <font style=\"color:#595959;\"> name: \"孙悟空\",</font> <font style=\"color:#595959;\"> sex: \"男\",</font> <font style=\"color:#595959;\"> age: 20,</font> <font style=\"color:#595959;\"> address: \"花果山\",</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> 注意： 1：rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 function f(a, ...b, c) { ... } // 报错 2：函数的length属性，不包括 rest 参数。 (function(a) {}).length // 1 (function(...a) {}).length // 0 (function(a, ...b) {}).length // 1 （2）、<font style=\"color:#000000;\"> spread 扩展运算符</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // spread 扩展运算符 对象合并</font> <font style=\"color:#595959;\"> const nameOne = {</font> <font style=\"color:#595959;\"> q: \"孙悟空\",</font> <font style=\"color:#595959;\"> h:18</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> const nameTwo = {</font> <font style=\"color:#595959;\"> w: \"猪八戒\",</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> const nameThree = {</font> <font style=\"color:#595959;\"> e: \"沙悟净\",</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> const nameFour = {</font> <font style=\"color:#595959;\"> r: \"白骨精\",</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //对象的合并</font> <font style=\"color:#595959;\"> const name = { ...nameOne, ...nameTwo, ...nameThree, ...nameFour };</font> <font style=\"color:#595959;\"> console.log(name);</font> <font style=\"color:#595959;\"> //{q: '孙悟空', h:18，w: '猪八戒', e: '沙悟净', r: '白骨精'}</font> <font style=\"color:#595959;\"> </script></font> 2、正则拓展 （1）、正则命名分组 JS正则表达式可以返回一个匹配的对象, 一个包含匹配字符串的类数组 ES9允许使用命名捕获 ? , 在打开捕获括号后立即命名 语法： ?<变量名> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //声明一个字符串</font> <font style=\"color:#595959;\"> // let str = '<a href=\"https://www.baidu.com/\">百度</a>';</font> <font style=\"color:#595959;\"> //需求：提取 url 与 『标签文本』</font> <font style=\"color:#595959;\"> //第一种写法</font> <font style=\"color:#595959;\"> // const reg = /<a href=\"(.)\">(.)<\\/a>/;</font> <font style=\"color:#595959;\"> // //执行</font> <font style=\"color:#595959;\"> // const result = reg.exec(str);</font> <font style=\"color:#595959;\"> // console.log(result);</font> <font style=\"color:#595959;\"> // // console.log(result[1]);//url</font> <font style=\"color:#595959;\"> // // console.log(result[2]);//文本</font> <font style=\"color:#595959;\"> //第二种方式 ?<变量名></font> <font style=\"color:#595959;\"> let str = '<a href=\"https://www.baidu.com/\">百度</a>';</font> <font style=\"color:#595959;\"> //分组命名</font> <font style=\"color:#595959;\"> const reg = /<a href=\"(?<url>.)\">(?<text>.)<\\/a>/;</font> <font style=\"color:#595959;\"> const result = reg.exec(str);</font> <font style=\"color:#595959;\"> console.log(result.groups.url);</font> <font style=\"color:#595959;\"> console.log(result.groups.text);</font> <font style=\"color:#595959;\"> </script></font> （2）、反向断言 语法：(?<=y)x如果想匹配x，x的前面必须是y <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //声明字符串</font> <font style=\"color:#595959;\"> let str = 'LP5211314你知道么666啦啦啦';</font> <font style=\"color:#595959;\"> //正向断言 根据匹配结果666后面的内容‘啦啦’，判断匹配结果是否合法</font> <font style=\"color:#595959;\"> const reg = /\\d+(?=啦)/;//如果想匹配数字，数字后面必须时啦</font> <font style=\"color:#595959;\"> const result = reg.exec(str);</font> <font style=\"color:#595959;\"> //反向断言 (?<=么) 根据匹配结果666前面的内容'么'，判断匹配结果是否合法</font> <font style=\"color:#595959;\"> const reg = /(?<=么)\\d+/;//如果想匹配数字，数字前面必须时么</font> <font style=\"color:#595959;\"> const result = reg.exec(str);</font> <font style=\"color:#595959;\"> console.log(result);</font> <font style=\"color:#595959;\"> </script></font> 3、<font style=\"color:#DF2A3F;\">promise.finally()</font> 无论是成功还是失败, 都运行同样的代码, 比如隐藏对话框, 关闭数据连接 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> function fun() {</font> <font style=\"color:#595959;\"> return new Promise((resolve, reject) => {</font> <font style=\"color:#595959;\"> // resolve(\"成功\");</font> <font style=\"color:#595959;\"> reject(1111);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fun()</font> <font style=\"color:#595959;\"> .then((res) => {</font> <font style=\"color:#595959;\"> console.log('成功');</font> <font style=\"color:#595959;\"> })</font> <font style=\"color:#595959;\"> .catch((err) => {</font> <font style=\"color:#595959;\"> console.log('失败');//失败</font> <font style=\"color:#595959;\"> })</font> <font style=\"color:#595959;\"> .finally(() => {</font> <font style=\"color:#595959;\"> console.log(\"关闭数据连接\");//\"关闭数据连接\"</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> ES10 1、Object.fromEntries 将二维数组，转为对象，一般常用来将map对象，转为对象 <font style=\"color:#595959;\"> const res = Object.fromEntries([</font> <font style=\"color:#595959;\"> [\"name\", \"bdqn\"],</font> <font style=\"color:#595959;\"> [\"xueke\", \"Java,大数据,前端,云计算\"],</font> <font style=\"color:#595959;\"> ]);</font> <font style=\"color:#595959;\"> console.log(res, \"result\");</font> <font style=\"color:#595959;\"> //{name: 'bdqn', xueke: 'Java,大数据,前端,云计算'}</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\">//Map 是一种数据结构，也是一个对象;</font> <font style=\"color:#595959;\"> const m = new Map();</font> <font style=\"color:#595959;\"> m.set(\"name\", \"bdqn\");</font> <font style=\"color:#595959;\"> console.log(m); //Map(1) {'name' => 'bdqn'}</font> <font style=\"color:#595959;\"> const result = Object.fromEntries(m);</font> <font style=\"color:#595959;\"> console.log(result); //{name: 'bdqn'}</font> ES8 中学习的Object.entries 将对象转为二维数组，与Object.fromEntries互为逆运算 <font style=\"color:#595959;\"> const arr = Object.entries({</font> <font style=\"color:#595959;\"> name: \"bdqn\",</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> console.log(arr);</font> <font style=\"color:#000000;\">2、trimStart 和trimEnd</font> trimStart 与 trimEnd 指定清楚左侧还是右侧空白字符 <font style=\"color:#595959;\"> <script> </font> <font style=\"color:#595959;\"> / trimStart 与 trimEnd 指定清楚左侧还是右侧空白字符 / </font> <font style=\"color:#595959;\"> let str = ' 爱老虎油 ';</font> <font style=\"color:#595959;\"> console.log(str.trim());//清除两侧空白</font> <font style=\"color:#595959;\"> console.log(str.trimStart());//清除左侧空白</font> <font style=\"color:#595959;\"> console.log(str.trimEnd());//清除右侧空白</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">3、Array.flat 与flatMap</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //flat 平</font> <font style=\"color:#595959;\"> //将多维数组转化为低位数组</font> <font style=\"color:#595959;\"> const arr = [1, 2, [5, 6]];</font> <font style=\"color:#595959;\"> console.log(arr.flat(1), \"arr\"); //[1, 2, 5, 6]</font> <font style=\"color:#595959;\"> const arr2 = [1, 2, [5, 6, [7, 8, 9]]];</font> <font style=\"color:#595959;\"> //参数为深度 是一个数字,默认值是1</font> <font style=\"color:#595959;\"> console.log(arr2.flat(2), \"arr2\"); //[1, 2, 5, 6, 7, 8, 9]</font> <font style=\"color:#595959;\"> //flatMap </font> <font style=\"color:#595959;\"> /* flatMap()方法对原数组的每个成员执行一个函数</font> <font style=\"color:#595959;\"> （相当于执行Array.map()），</font> <font style=\"color:#595959;\"> 然后对返回值组成的数组执行flat()方法。</font> <font style=\"color:#595959;\"> 该方法返回一个新数组，不改变原数组。 */</font> <font style=\"color:#595959;\"> const arr3 = [1, 2, 3, 4];</font> <font style=\"color:#595959;\"> const res1 = arr3.flatMap((item) => item*10);</font> <font style=\"color:#595959;\"> const res2 = arr3.flatMap((item) => [item*10]);</font> <font style=\"color:#595959;\"> console.log(res1, \"res1\"); //[10, 20, 30, 40] 'res1'</font> <font style=\"color:#595959;\"> console.log(res2, \"res2\"); //[10, 20, 30, 40] 'res2'</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">4、Symbol.description </font> <font style=\"color:#000000;\">获取Symbol的描述字符串</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //创建 Symbol</font> <font style=\"color:#595959;\"> let s = Symbol('bdqn');</font> <font style=\"color:#595959;\"> console.log(s.description);//bdqn</font> <font style=\"color:#595959;\"> </script></font> 七、ES11 <font style=\"color:#000000;\">1、Promise.allSettled </font> 调用 allsettled 方法，返回的结果始终是成功的，返回的是promise结果值 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //声明两个promise对象</font> <font style=\"color:#595959;\"> const p1 = new Promise((resolve, reject) => {</font> <font style=\"color:#595959;\"> setTimeout(() => {</font> <font style=\"color:#595959;\"> resolve(\"商品数据 - 1\");</font> <font style=\"color:#595959;\"> }, 1000);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> const p2 = new Promise((resolve, reject) => {</font> <font style=\"color:#595959;\"> setTimeout(() => {</font> <font style=\"color:#595959;\"> // resolve(\"商品数据 - 2\");</font> <font style=\"color:#595959;\"> reject('出错啦!');</font> <font style=\"color:#595959;\"> }, 1000);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> //调用 allsettled 方法，返回的结果始终是成功的，返回的是promise结果值</font> <font style=\"color:#595959;\"> const res = Promise.allSettled([p1, p2]);</font> <font style=\"color:#595959;\"> console.log(res,'res');</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> //调用all方法，返回的结果要根据Promise状态来决定，必须要全部成功，才能成功</font> <font style=\"color:#595959;\"> const res1 = Promise.all([p1, p2]);</font> <font style=\"color:#595959;\"> console.log(res1,'res1');</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">2、</font>动态 import 导入 标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。 <font style=\"color:#000000;\">即：动态导入是我需要的时候，再导入进来，然后调用，不需要的时候，我不导入</font> <font style=\"color:#000000;\">html文件</font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <button id=\"btn\">登录</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 用户输入用户名,密码</font> <font style=\"color:#595959;\"> function login() {</font> <font style=\"color:#595959;\"> return \"普通用户\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> let btn = document.querySelector(\"#btn\");</font> <font style=\"color:#595959;\"> btn.onclick = function () {</font> <font style=\"color:#595959;\"> // 拿到用户名密码</font> <font style=\"color:#595959;\"> let role = login();</font> <font style=\"color:#595959;\"> // 将拿到的用户密码放到处理函数里</font> <font style=\"color:#595959;\"> render(role); //处理函数</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> async function render(role) {</font> <font style=\"color:#595959;\"> if (role == \"管理员\") {</font> <font style=\"color:#595959;\"> // 第一种写法</font> <font style=\"color:#595959;\"> // let res1 = import(\"./js/1.js\"); //返回一个Promise对象</font> <font style=\"color:#595959;\"> // res1.then((res) => {</font> <font style=\"color:#595959;\"> // console.log(res);</font> <font style=\"color:#595959;\"> // });</font> <font style=\"color:#595959;\"> // 第二种写法</font> <font style=\"color:#595959;\"> let res1 = await import(\"./js/1.js\");</font> <font style=\"color:#595959;\"> console.log(res1);</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> // let res2 = import(\"./js/2.js\"); //返回一个Promise对象</font> <font style=\"color:#595959;\"> // res2.then((res) => {</font> <font style=\"color:#595959;\"> // console.log(res);</font> <font style=\"color:#595959;\"> // });</font> <font style=\"color:#595959;\"> // 第二种写法</font> <font style=\"color:#595959;\"> let res2 = await import(\"./js/2.js\");</font> <font style=\"color:#595959;\"> console.log(res2);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#000000;\">1.js 需要动态导入的js逻辑文件</font> <font style=\"color:#595959;\">console.log('hello.js');</font> <font style=\"color:#595959;\">export default{</font> <font style=\"color:#595959;\"> name:'管理员'</font> <font style=\"color:#595959;\">}}</font> <font style=\"color:#000000;\">2.js 需要动态导入的js逻辑文件</font> <font style=\"color:#595959;\">console.log(\"2.js\");</font> <font style=\"color:#595959;\">export default {</font> <font style=\"color:#595959;\"> name: \"普通用户\",</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#000000;\">3、BigInt</font> （1）、概念 <font style=\"color:#4D4D4D;\">BigInt数据类型提供了一种方法来表示大于2^53-1的整数。BigInt可以表示任意大的整数</font> <font style=\"color:#4D4D4D;\">适用场景：更加准确的使用时间戳和数值比较大的ID</font> <font style=\"color:#4D4D4D;\">（2）、BigInt()构造函数</font> <font style=\"color:#4D4D4D;\">传递给BigInt()的参数将自动转换为BigInt</font> <font style=\"color:#4D4D4D;\">无法转换的数据类型和值会引发异常</font> 除了不能使用一元加号运算符外，其他的运算符都可以使用 <font style=\"color:#4D4D4D;\">BigInt和Number之间不能进行混合操作</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //大整形（用来做更大的数值运算）</font> <font style=\"color:#595959;\"> //语法：数字+n</font> <font style=\"color:#595959;\"> // let n = 521n;</font> <font style=\"color:#595959;\"> // console.log(n, typeof(n));//521n 'bigint'</font> <font style=\"color:#595959;\"> //（1）传递给BigInt()的参数将自动转换为BigInt</font> <font style=\"color:#595959;\"> // let n = 123;</font> <font style=\"color:#595959;\"> // console.log(BigInt(n));//123n</font> <font style=\"color:#595959;\"> //（2）无法转换的数据类型和值会引发异常</font> <font style=\"color:#595959;\"> // console.log(BigInt(1.2));// 不能有浮点数子，会报错</font> <font style=\"color:#595959;\"> //BigInt(null); //报错</font> <font style=\"color:#595959;\"> //BigInt(\"a\"); // 报错</font> <font style=\"color:#595959;\"> //（3）BigInt除了不能使用一元加号运算符外，其他的运算符都可以使用</font> <font style=\"color:#595959;\"> // console.log(BigInt(+1n));//报错</font> <font style=\"color:#595959;\"> let max = Number.MAX_SAFE_INTEGER; //最大安全整数</font> <font style=\"color:#595959;\"> console.log(max, \"max\"); //9007199254740991</font> <font style=\"color:#595959;\"> console.log(max + 1); //9007199254740992</font> <font style=\"color:#595959;\"> console.log(max + 2); ////9007199254740992 不可以运算正确的结果了</font> <font style=\"color:#595959;\"> console.log(BigInt(max)); //9007199254740991n</font> <font style=\"color:#595959;\"> console.log(BigInt(max) + BigInt(1)); //9007199254740992n</font> <font style=\"color:#595959;\"> console.log(BigInt(max) + BigInt(2)); //9007199254740993n</font> <font style=\"color:#595959;\"> // （4）BigInt和Number之间不能进行混合操作</font> <font style=\"color:#595959;\"> console.log(1n + 5); //报错</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">4、globalThis 对象</font> globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）。不像 window 或者 self这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是 globalThis。 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> console.log(globalThis);//Window</font> <font style=\"color:#595959;\"> </script></font> 5、String.matchAll matchAll() 方法返回一个包含所有匹配正则表达式的结果的迭代器。可以使用 for...of 遍历，或者使用 展开运算符(...) 或者 Array.from 转换为数组. <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 需求，提取li中的内容</font> <font style=\"color:#595959;\"> let str = <ul></font> <font style=\"color:#595959;\"> <li>1111</li></font> <font style=\"color:#595959;\"> <li>2222</li></font> <font style=\"color:#595959;\"> </ul>`;</font> <font style=\"color:#595959;\"> //声明正则</font> <font style=\"color:#595959;\"> const reg = /<li>(.*)<\\/li>/g;</font> <font style=\"color:#595959;\"> //调用方法</font> <font style=\"color:#595959;\"> const result = str.matchAll(reg);</font> <font style=\"color:#595959;\"> console.log(result, \"result\");//result里有next()方法，可遍历</font> <font style=\"color:#595959;\"> for (let v of result) {</font> <font style=\"color:#595959;\"> //返回一个数组，[0]符合条件的每一项，[1]每一项里面的值</font> <font style=\"color:#595959;\"> // console.log(v, \"v\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 6、可选链操作符 语法：?. 判断前面的值有没有传入，如果传了继续读取后面的属性，如果没有传，那就返回undefined，也不会报错，免去了做层层判断 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> function main(obj) {</font> <font style=\"color:#595959;\"> const person = obj?.one?.name;</font> <font style=\"color:#595959;\"> // const person = obj?.one?.name?.age;//undefined</font> <font style=\"color:#595959;\"> console.log(person);//张三</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> main({</font> <font style=\"color:#595959;\"> one: {</font> <font style=\"color:#595959;\"> name: \"张三\",</font> <font style=\"color:#595959;\"> sex: \"男\",</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> two: {</font> <font style=\"color:#595959;\"> name: \"李四\",</font> <font style=\"color:#595959;\"> sex: \"男\",</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> 7、空值合并运算符 空值合并运算符（??）是一个逻辑运算符。 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数。否则返回左侧的操作数。 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> let obj = {</font> <font style=\"color:#595959;\"> name: \"张三\",</font> <font style=\"color:#595959;\"> age: 18,</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> // ||或运算符 像亲情，找true &&与运算符 像爱情，找false</font> <font style=\"color:#595959;\"> // console.log(obj.age || \"年龄不详\"); //18</font> <font style=\"color:#595959;\"> // console.log(obj.age && \"年龄不详\"); //'年龄不详'</font> <font style=\"color:#595959;\"> // ??</font> <font style=\"color:#595959;\"> // console.log(obj.age ?? \"19\"); // 18</font> <font style=\"color:#595959;\"> // console.log(obj.age1 ?? \"19\"); //19</font> <font style=\"color:#595959;\"> // || 或运算符无法区分false、0、空字符串和null/undefined</font> <font style=\"color:#595959;\"> // ??无法识别null/undefined</font> <font style=\"color:#595959;\"> // console.log(false ||'你好');//你好</font> <font style=\"color:#595959;\"> // console.log(false ??'你好');//false</font> <font style=\"color:#595959;\"> // console.log(''||'hello');//hello</font> <font style=\"color:#595959;\"> // console.log(''??'hello');//返回空</font> <font style=\"color:#595959;\"> // console.log(0 || \"你好\"); //你好</font> <font style=\"color:#595959;\"> // console.log(0 ?? \"hello\"); //0</font> <font style=\"color:#595959;\"> // console.log(null || \"你好1\"); //你好</font> <font style=\"color:#595959;\"> // console.log(null ?? \"hello1\"); //hello</font> <font style=\"color:#595959;\"> // console.log(undefined || \"你好2\"); //你好</font> <font style=\"color:#595959;\"> // console.log(undefined ?? \"hello2\"); //hello</font> <font style=\"color:#595959;\"> </script></font> ??和 || 的区别是什么呢? 他们两个最大的区别就是’ '和 0，??的左侧 为 ’ '或者为 0 的时候，依然会返回左侧的值； || 会对左侧的数据进行boolean类型转换，所以’ '和 0 会被转换成false,返回右侧的值 八、ES12 1、逻辑赋值操作符 逻辑赋值操作符 ??=、&&=、 ||= <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> let a = true;</font> <font style=\"color:#595959;\"> let b = false;</font> <font style=\"color:#595959;\"> //console.log(a || b);//true</font> <font style=\"color:#595959;\"> //console.log(a && b);//false</font> <font style=\"color:#595959;\"> a ||= b; //a=a||b</font> <font style=\"color:#595959;\"> //console.log(a); //true</font> <font style=\"color:#595959;\"> a &&= b; //a=a&&b</font> <font style=\"color:#595959;\"> //console.log(a); //false</font> <font style=\"color:#595959;\"> let obj = {</font> <font style=\"color:#595959;\"> name: \"章三\",</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> // obj.name ??= \"李四\";</font> <font style=\"color:#595959;\"> // console.log(obj.name);</font> <font style=\"color:#595959;\"> obj.age ??= 18;</font> <font style=\"color:#595959;\"> console.log(obj.age);</font> <font style=\"color:#595959;\"> </script></font> 2、数字分隔符 这个新特性是为了方便程序员看代码而出现的，如果数字比较大，那么看起来就不是那么一目了然 <font style=\"color:#333333;\">分隔符不仅可以分割十进制，也可以分割二进值或者十六进值的数据，非常好用</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> let num=123456789</font> <font style=\"color:#595959;\"> let num1=123_456_789</font> <font style=\"color:#595959;\"> console.log(num===num1);//true</font> <font style=\"color:#595959;\"> </script></font> 3、 replaceAll 所有匹配都会被替代项替换。模式可以是字符串或正则表达式，而替换项可以是字符串或针对每次匹配执行的函数。并返回一个全新的字符串 <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> let str = \"Lorem,Lorem ipsum dolor sit Lorem.\";</font> <font style=\"color:#595959;\"> let newStr = str.replaceAll(\"Lorem\",'*');</font> <font style=\"color:#595959;\"> console.log(newStr);//, ipsum dolor sit *.</font> <font style=\"color:#595959;\"> </script></font> 4、Promise.any 只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> let ajax1 = function () {</font> <font style=\"color:#595959;\"> return new Promise((resolve, reject) => {</font> <font style=\"color:#595959;\"> reject(\"失败1\");</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> let ajax2 = function () {</font> <font style=\"color:#595959;\"> return new Promise((resolve, reject) => {</font> <font style=\"color:#595959;\"> reject(\"失败2\");</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> let ajax3 = function () {</font> <font style=\"color:#595959;\"> return new Promise((resolve, reject) => {</font> <font style=\"color:#595959;\"> reject(\"失败3\");</font> <font style=\"color:#595959;\"> // resolve('成功')</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> Promise.any([ajax1(), ajax2(), ajax3()])</font> <font style=\"color:#595959;\"> .then((res) => {</font> <font style=\"color:#595959;\"> console.log(res);</font> <font style=\"color:#595959;\"> })</font> <font style=\"color:#595959;\"> .catch((err) => {</font> <font style=\"color:#595959;\"> console.log(\"err\", err);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> ES13 类的私有属性 私有属性 语法： #属性名; <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> class Person {</font> <font style=\"color:#595959;\"> //公有属性</font> <font style=\"color:#595959;\"> name;</font> <font style=\"color:#595959;\"> //私有属性 #属性名;</font> <font style=\"color:#595959;\"> #age;</font> <font style=\"color:#595959;\"> #weight;</font> <font style=\"color:#595959;\"> //构造方法</font> <font style=\"color:#595959;\"> constructor constructor(name, age, weight) {</font> <font style=\"color:#595959;\"> this.name = name;</font> <font style=\"color:#595959;\"> this.#age = age;</font> <font style=\"color:#595959;\"> this.#weight = weight;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 内部创建一个方法，外部执行，可以进行访问</font> <font style=\"color:#595959;\"> intro() {</font> <font style=\"color:#595959;\"> console.log(this.name);</font> <font style=\"color:#595959;\"> console.log(this.#age);</font> <font style=\"color:#595959;\"> console.log(this.#weight);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //实例化</font> <font style=\"color:#595959;\"> const girl = new Person(\"晓红\", 18, \"45kg\");</font> <font style=\"color:#595959;\"> //console.log(girl,'girl');</font> <font style=\"color:#595959;\"> //Person {name: '晓红', #age: 18, #weight: '45kg'}</font> <font style=\"color:#595959;\"> //直接在外部访问，私有属性访问不了</font> <font style=\"color:#595959;\"> // console.log(girl.name);//晓红</font> <font style=\"color:#595959;\"> // console.log(girl.#age);//报错</font> <font style=\"color:#595959;\"> // console.log(girl.#weight);//报错</font> <font style=\"color:#595959;\"> //通过内部访问，可以的</font> <font style=\"color:#595959;\"> girl.intro();</font> <font style=\"color:#595959;\"> </script></font> 十ES14 1、Array扩展 1.1、findLast 数组支持倒序查找 <font style=\"color:#4D4D4D;\">在JS中，我们可以使用数组的find()函数来在数组中找到第一个满足某个条件的元素。同样地，我们还可以通过findIndex()函数来返回这个元素的位置。可是，无论是find()还是findIndex()，它们都是从数组的头部开始查找元素的，可是在某些情况下，我们可能有从数组后面开始查找某个元素的需要。</font> <font style=\"color:#4D4D4D;\">ES13出来后，我们终于有办法处理这种情况了，那就是使用新的findLast()和findLastIndex()函数。这两个函数都会从数组的末端开始寻找某个满足条件的元素</font> <font style=\"color:#595959;\">const letters = [</font> <font style=\"color:#595959;\"> { value: 'z' },</font> <font style=\"color:#595959;\"> { value: 'y' },</font> <font style=\"color:#595959;\"> { value: 'x' },</font> <font style=\"color:#595959;\"> { value: 'y' },</font> <font style=\"color:#595959;\"> { value: 'z' },</font> <font style=\"color:#595959;\">];</font> <font style=\"color:#595959;\">// 倒序查找</font> <font style=\"color:#595959;\">const found = letters.findLast((item) => item.value === 'y');</font> <font style=\"color:#595959;\">const foundIndex = letters.findLastIndex((item) => item.value === 'y');</font> <font style=\"color:#595959;\">console.log(found); // { value: 'y' }</font> <font style=\"color:#595959;\">console.log(foundIndex); // 3</font> 1.2、toSorted <font style=\"color:#4D4D4D;\">sort方法的复制版本，区别就是sort是修改原数组，而toSorted是返回新数组。</font> <font style=\"color:#4D4D4D;\">我们先来看看sort</font> <font style=\"color:#595959;\">const arr = [1, 3, 5, 2, 8];</font> <font style=\"color:#595959;\">const newArr = arr.sort();</font> <font style=\"color:#595959;\">console.log(\"原数组:\", arr);</font> <font style=\"color:#595959;\">console.log(\"新数组:\", newArr);</font> <font style=\"color:#4D4D4D;\">我们再来看看toSorted</font> <font style=\"color:#595959;\">const arr = [1, 3, 5, 2, 8];</font> <font style=\"color:#595959;\">const newArr = arr.toSorted();</font> <font style=\"color:#595959;\">console.log(\"原数组:\", arr);</font> <font style=\"color:#595959;\">console.log(\"新数组:\", newArr);</font> <font style=\"color:#4D4D4D;\">看出区别来了吧，新老数组不一样</font> 1.3、toReversed reverse方法的复制版本反转，toReversed不修改原数组，返回新数组 <font style=\"color:#4D4D4D;\">我们先来看看reverse</font> <font style=\"color:#595959;\">const arr = [1, 3, 5, 2, 8];</font> <font style=\"color:#595959;\">const newArr = arr.reverse();</font> <font style=\"color:#595959;\">console.log(\"原数组:\", arr);</font> <font style=\"color:#595959;\">console.log(\"新数组:\", newArr);</font> <font style=\"color:#4D4D4D;\">我们再来看看toReversed</font> <font style=\"color:#595959;\">const arr = [1, 3, 5, 2, 8];</font> <font style=\"color:#595959;\">const newArr = arr.toReversed();</font> <font style=\"color:#595959;\">console.log(\"原数组:\", arr);</font> <font style=\"color:#595959;\">console.log(\"新数组:\", newArr);</font> <font style=\"color:#4D4D4D;\">看出区别来了吧，新老数组不一样</font> 1.4、toSpliced <font style=\"color:#4D4D4D;\">toSpliced与splice区别就很大了。splice是截取原数组的数据，并返回截取出来的数据。toSpliced是对原数组的副本进行操作，然后返回被截取完后的新数组，并不会修改原数组。</font> <font style=\"color:#4D4D4D;\">我们先来看看splice</font> <font style=\"color:#595959;\">const arr = [1, 3, 5, 2, 8];</font> <font style=\"color:#595959;\">const newArr = arr.splice(1, 2);</font> <font style=\"color:#595959;\">console.log(\"原数组:\", arr);</font> <font style=\"color:#595959;\">console.log(\"新数组:\", newArr);</font> <font style=\"color:#4D4D4D;\">看出区别了吧，toSpliced并不会影响原数组。返回的是截取后的数组。</font> 1.5、with 、 通<font style=\"color:#4D4D4D;\">with有点类似我们通过[index]来修改数组，区别就是with不是修改原数组，而是返回整个新数组。</font> <font style=\"color:#4D4D4D;\">我们先来看看通过下标来修改数组的</font> <font style=\"color:#595959;\">const arr = [1, 3, 5, 2, 8];</font> <font style=\"color:#595959;\">arr[1] = 10;</font> <font style=\"color:#595959;\">console.log(\"原数组:\", arr);</font> <font style=\"color:#595959;\">const arr = [1, 3, 5, 2, 8];</font> <font style=\"color:#595959;\">const newArr = arr.with(1, 10);</font> <font style=\"color:#595959;\">console.log(\"原数组:\", arr);</font> <font style=\"color:#595959;\">console.log(\"新数组:\", newArr);</font> 2、WeakMap扩展 <font style=\"color:#4F4F4F;\">支持 Symbol 作用键</font> <font style=\"color:#4D4D4D;\">之前WeakMap是只支持对象作为键，现在还支持 Symbol 作为键</font> <font style=\"color:#595959;\">const weak = new WeakMap();</font> <font style=\"color:#595959;\">const key = Symbol(\"ref\");</font> <font style=\"color:#595959;\">weak.set(key, \"randy\");</font> <font style=\"color:#595959;\">console.log(weak.get(key)); // randy</font>"
    },
    {
      "title": "html+css笔记",
      "path": "JavaScriptES6+/html+css笔记.md",
      "category": "JavaScriptES6+",
      "tags": [],
      "date": null,
      "description": "网页架构\n\n了解h5规范 \n\n<font style=\"color:FF0000;\">1.HTML中不区分大小写,但是我们一般都使用小写</font>\n\n<font style=\"color:FF0000;\">2.HTML中的注释不能嵌套</font>\n\n<font style=\"color:FF0000;\">3.HTML标签必须结构完整，要么成对出现，要么自结束标签</font>\n\n<font ",
      "content": "网页架构 了解h5规范 <font style=\"color:#FF0000;\">1.HTML中不区分大小写,但是我们一般都使用小写</font> <font style=\"color:#FF0000;\">2.HTML中的注释不能嵌套</font> <font style=\"color:#FF0000;\">3.HTML标签必须结构完整，要么成对出现，要么自结束标签</font> <font style=\"color:#FF0000;\">4.HTML标签可以嵌套，但是不能交叉嵌套</font> <font style=\"color:#FF0000;\">5.HTML标签中的属性必须有值，且值必须加引号(双引号单引号都可以)</font> 什么是结构、表现、行为 HTML 用于构建网页的结构 CSS 用于设置网页的样式 JavaScript 用于实现网页的行为 <font style=\"color:#FF0000;\">1、结构,是网页的骨架,由html超文本标记语言创建,用于搭建文档的结构、定义网页的内容，例如标题、正文、图像等；</font> <font style=\"color:#FF0000;\">2、表现,是网页的样式,由css负责创建,用于设置文档的呈现效果,例如颜色、字体、背景等；</font> <font style=\"color:#FF0000;\">3、行为,是网页的行为,由javascript语言创建,可实时更新网页中的内容，例如从服务器获取数据并更新到网页中，能够让网页更加生动。</font> <font style=\"color:#FF0000;\"><!-- 声明用什么编码方式 --></font> <!-- meta 设置元数据 --><!-- <font style=\"color:#FF0000;\">meta标签用来设置网页的元数据</font>，不会变的数据，给浏览器看的 （1）<font style=\"color:#FF0000;\">设置网页的字符集</font>，避免乱码问题 charset 属性 属性值 （2）meta 元素被用于规定<font style=\"color:#FF0000;\">页面的描述</font>description/name/content、关键词keyword、文档的作者、最后修改时间以及其他元数据。 <!-- 字符集 --> <meta charset=\"UTF-8\"> <!-- 1.存储时，务必采用合适的字符编码，否则无法存储，数据丢失 存储时采用那种方式编码，读取时就采用那种方式解码，否则乱码 --> <font style=\"color:#FF0000;\"><!-- 重定向，描述，关键字 --></font> <!-- 重定向 http-equiv定义重定向，content=时间 url--链接--> <meta http-equiv=\"refresh\" content=\"1;url=https://www.jd.com/\" /> <font style=\"color:#FF0000;\"><!-- 描述 --></font> <meta name=\"description\" content=\"淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！\"> <font style=\"color:#FF0000;\"> <!-- 关键字 --></font> <meta name=\"keywords\" content=\"淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺\"> 实体 在网页中编写的多个空格默认会自动被浏览器解析为一个空格 在HTML中，一些如< >这种特殊字符是不能直接使用，比如空格，大于小于号等 如果我们需要在网页中书写这些，我们需要使用一些特殊的符号来表示这些特殊字符， 这些特殊符号我们称为实体（转义字符串） 浏览器解析到实体时，会自动将实体转换为其对应的字符 <font style=\"color:#FF0000;\"> 实体的语法</font> <font style=\"color:#FF0000;\"> &实体的名字;</font> 空格 &nbsp; < &lt; &gt; 版权符号 &copy; 常用标签： <font style=\"color:#FF0000;\"> <h1> </h1>//不同字号，标题标签 h1 ~ h6,从大到小 ，加粗变大 </font> <h2> </h2> <h3> </h3> <font style=\"color:#FF0000;\"><p> </p>// 段落标签</font>，段落标签用于表示内容中的一个自然段，特殊的块元素 一般只用来<font style=\"color:#FF0000;\">包裹文字或图片</font>，它<font style=\"color:#FF0000;\">里面不能放块元素</font> 像上面的每个标签，独占一行，称块元素 像 <em> </em>，不独占一行，称行内元素 行内元素通常在同一行显示，不能设置宽度和高度，而块级元素则独占一行，可以设置宽度和高度 <font style=\"color:#FF0000;\"><em> </em> //倾斜字体，行内元素 </font> <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\"> <strong> </strong>//加粗，行内元素</font> <s> </s> <font style=\"color:#FF0000;\"><del> </del></font>//都表示一个删除的内容,字体中间加横线，<font style=\"color:#FF0000;\">表删除</font>，例如打折页面 ，行内元素 <hgroup> <h1>瑕佽寖娆插垜銆?/h1> <h3>鍖栬鐢卞府銆?/h3> </hgroup>// 用来为<font style=\"color:#FF0000;\">标题分组</font>，可以将一组相关的标题同时放入到hgroup,页面上没区别，主要方别看代码，行内元素 <blockquote> 之老到能躲薪五严得灰报力一反秦为不订疾。 <font style=\"color:#FF0000;\"></blockquote></font>//引用别人说的话 <font style=\"color:#FF0000;\">长引用 会换行 块元素,前面会空2个多点</font> <!-- -->//注释符号，<font style=\"color:#FF0000;\">注释化：ctrl加 /</font> 解除注释化，同理 <font style=\"color:#FF0000;\"><q>病的子韩死故游六身。</q>//表示短引用，加引号，行内</font> 有些标签是没尾标签的，如 <meta charset=\"utf-8\"> <font style=\"color:#FF0000;\"><br />//换行</font>，插哪里，哪里换行，行内 <font style=\"color:#FF0000;\"><hr /></font>//页面上显示一个<font style=\"color:#FF0000;\">分割线</font>，独占一行，块元素 <center> 承以冇看么我在司身。 <p>我下落一死落子自明。</p> <font style=\"color:#FF0000;\"> </center> //居中效果</font> <font style=\"color:#FF0000;\"><div></font>计划管控就好了</div>//没有任何语义，<font style=\"color:#FF0000;\">只表示一个块元素</font>，没效果，制造出一个块元素 <font style=\"color:#FF0000;\"><span></font>为疾为战都他，后宋。</span>//没有任何语义，<font style=\"color:#FF0000;\">表示一个行内元素</font>,一般就用来包裹文字 元素在文档流中会区分为 块元素 行内元素 行内块元素 <font style=\"color:#FF0000;\">块元素</font> 一般是用来布局 1、会<font style=\"color:#FF0000;\">独占一行</font>，自上而下一行一行的排列 2、块元素的宽度默认是父元素的百分百 3、块元素的高度默认是被内容撑开 <font style=\"color:#FF0000;\">常用块元素：div p h1-h6 ul li ol header footer main nav</font> <font style=\"color:#FF0000;\">行内元素</font> 一般用来包裹文字 1、<font style=\"color:#FF0000;\">不会独占一行</font>,自左向右排列，一行满了，就挪到下一行，再自左向右 2、行内元素宽高都是被内容撑开的，<font style=\"color:#FF0000;\">不可以自定义宽度</font> <font style=\"color:#FF0000;\">常用行内元素：span a i em strong del s</font> <font style=\"color:#FF0000;\">行内块元素</font> 兼具块元素，行内元素的特点 <font style=\"color:#FF0000;\">又不会独占一行，又可以设置宽高</font> <font style=\"color:#FF0000;\">常用行内块元素：img</font> 注意： 1、块元素是布局元素，里面什么都能放，能方块元素，能放行内元素，行内块元素 2、行内元素里面不能放块元素 一般就用来包裹文字 3、特殊的块元素 p 不能放块元素 4、特殊的行内元素 a 里面什么都能放，除了它自己 结构化标签 <!-- 布局标签（结构化标签） <font style=\"color:#FF0000;\">header 网页的头部</font> <font style=\"color:#FF0000;\"> main 网页的主体部分（一般就一个）</font> <font style=\"color:#FF0000;\"> footer 网页的底部</font> <font style=\"color:#FF0000;\"> nav 网页的导航</font> <font style=\"color:#FF0000;\"> aside 和主体相关的内容，侧边栏</font> <font style=\"color:#FF0000;\"> article 文章之类的</font> <font style=\"color:#FF0000;\"> section 独立的区块，上面的标签都不合适，就用这个</font> --> <header>头部</header> <main> 主体 <nav></nav>//导航 <aside></aside>//和主体相关的内容，侧边栏 <article></article>//和文章相关， 文章之类的 </main> <footer> 底部 <section></section>//独立的区块 </footer> 列表 <!-- 列表（list） 一组一组 1:有序列表 用<font style=\"color:#FF0000;\">ol</font>标签创建，<font style=\"color:#FF0000;\">li</font>表示列表项 项目符号：<font style=\"color:#FF0000;\">1(默认值)、a、A、i、I</font> 2:无序列表 用<font style=\"color:#FF0000;\">ul</font>标签创建，<font style=\"color:#FF0000;\">li</font>表示列表项 项目符号： <font style=\"color:#FF0000;\"> disc，默认值，实心的圆点</font> <font style=\"color:#FF0000;\">square</font>，<font style=\"color:#FF0000;\">实心的方块</font> <font style=\"color:#FF0000;\">circle，空心的圆</font> 3:定义列表 用<font style=\"color:#FF0000;\">dl</font>标签创建，使用<font style=\"color:#FF0000;\">dt</font>对内容进行定义，使用<font style=\"color:#FF0000;\">dd</font>对内容进行解释说明 <font style=\"color:#FF0000;\">start 属性的值是一个整数，定义一个开始位置</font> <font style=\"color:#FF0000;\">type属性 可以更改项目符号</font> <font style=\"color:#FF0000;\">list-style:none;去除项目符号</font> 注意：列表之间是可以互相嵌套的 属性写在开始标签里，用空格分开 <ol type=\"i\">//创建有序表 ，type属性 更改项目符号，项目符号是i <div> </div> <li> </li> <li> </li> </ol> <ul type=\"circle\">//创建无序表，type属性 更改项目符号，项目符号是空心的圆 <li>一已光。</li> <li>身烦于有。</li> <li>他单卡，人。</li> </ul> <dl> <font style=\"color:#FF0000;\"><dt>html</dt>//列表小标题 ，下定义 </font> <font style=\"color:#FF0000;\"> <dd>html5</dd>//对定义的解释 </font> <dd>css3</dd> <dd>less</dd> <dd>sass</dd> <dt>js</dt> <dd>js基础</dd> <dd>DOM</dd> <dd>Bom</dd> </dl> <a>超链接 <!-- 2个属性，2个功能，1个补充 --> <font style=\"color:#FF0000;\">属性 href（跳转地址），target（在哪里显示）</font> <font style=\"color:#FF0000;\">功能 #（跳到顶部） #id属性值（跳到页面指定位置）</font> <font style=\"color:#FF0000;\">补充 空链接，在href属性中写入一个#或者是javascript:;</font>， <!-- HTML页面使用超链接与网络上的另一个HTML页面相连。几乎可以在所有的网页中找到超链接，点击超链接会出现很多效果： <font style=\"color:#FF0000;\">1：可以让我们从一个页面跳转到另一个页面，</font> <font style=\"color:#FF0000;\"> 2：当前页面的其他位置</font> <font style=\"color:#FF0000;\"> 3:下载</font> —在HTML中链接可以是一个字，一个词，也可以是一个图片，这些都是可以点击的。 —使用a标签来创建一个超链接，它是个<font style=\"color:#FF0000;\">行内元素</font>，在a标签中可以嵌套除自身外的任何元素 --> <!-- 属性： <font style=\"color:#FF0000;\">1: href属性: 指向链接跳转的目标地址</font> -值可以是一个外部的网站的地址 绝对路径 -可以是一个内部页面的地址 相对路径 （1）：绝对路径 就是指完整的描述目标文件位置的路径。 简单来说，绝对路径就是无论你当前的位置在哪，找到目标文件的路径是不变的。 （2）：相对路径 就是指由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。 简单来说，相对路径和你所在的位置是有关系的，你所在位置的不同会导致相对路径也会不同。--> <!-- <font style=\"color:#FF0000;\">2: target属性：可以用来指定打开链接的位置</font> 可选值： <font style=\"color:#FF0000;\">_self，表示在当前窗口中打开（默认值）</font> <font style=\"color:#FF0000;\"> _blank，在新的一个新的页面中打开链接 </font> 可以设置一个内联框架的name属性值，链接将会在指定的内联框架中打开--> <!-- <font style=\"color:#FF0000;\">锚点功能</font>（页面内的跳转） 所谓锚点 ，就是指当点击链接文本时，跳转到当前页面的指定元素位置 （1）若将超链接的<font style=\"color:#FF0000;\">href属性设置为#</font>，点击超链接后， <font style=\"color:#FF0000;\">页面不会发生跳转</font>，而是<font style=\"color:#FF0000;\">跳到</font>当前页面的<font style=\"color:#FF0000;\">顶部</font>的位置 （2）<font style=\"color:#FF0000;\">跳转到页面的指定位置</font>， 语法：将href属性设置为 <font style=\"color:#FF0000;\">#目标元素的id属性值</font> <font style=\"color:#FF0000;\">给标签加标记——id属性</font>（唯一不重复的标记） -每一个标签都可以添加一个id属性 <font style=\"color:#FF0000;\"> -id属性就是元素的唯一标识，同一页面中不能出现重复的id属性</font> <font style=\"color:#FF0000;\"> -id区分大小写，且不能以数字开头</font> --> <a href=\"\" target=\"\"></a> <a href=\"#\"></a> <a href=\"#id\"></a> <a href=\"javascript\"></a> <!-- 4:<font style=\"color:#FF0000;\">空链接</font> 不想使<a>元素生效，<font style=\"color:#FF0000;\">在href属性中写入一个#或者是javascript:;</font>， 此时的<font style=\"color:#FF0000;\">超链接没有作用</font>，当还没有想好超链接具体跳转位置时，可以当做<font style=\"color:#FF0000;\">占位符</font>使用。 --> <!-- cdn方式引入外链 --> <a href=\"https://www.baidu.com/\" target=\"_blank\">跳转链接</a> <!-- 内部页面的跳转 --> <!-- 什么是绝对路径 --> <!-- 相对路径去查找，当前./,上层../继续查找 --> <a href=\"./03.列表.html\" target=\"_blank\"> 同一层文件下面的跳转</a> <a href=\"../01.网页结构/06实体.html\" target=\"_blank\">不同文件下的跳转</a> <!-- 空标签 --> <a href=\"#\"> 内容</a> <!-- 锚链接 --> <a href=\"#bottom\">去底部</a> <a href=\"#center\">去中间</a> <!-- 在开发中可以将#作为超链接的路径的占位符使用 --> <a href=\"#\">我还想好链接到哪里，先占个位子</a> <font style=\"color:#FF0000;\"><!-- javascript:;，此时点击，没有任何反应</font> --> <a href=\"javascript:;\">我还想好链接到哪里，先占个位子</a> <img>引入图片 <!-- 使用img标签来向网页中<font style=\"color:#FF0000;\">引入</font>一个外部<font style=\"color:#FF0000;\">图片</font>，img标签也是一个自结束标签，img这种元素属于替换元素（基于块和行内元素之间，具有两种元素的特点） <font style=\"color:#FF0000;\">src 引入图片的路径 //路径</font> <font style=\"color:#FF0000;\">alt 可以用来设置在图片不能加载时，对图片的描述，</font>图片不显示时，网页显示图片描述搜索引擎可以通过alt属性来识别不同的图片 如果不写alt属性，则搜索引擎不会对img中的图片进行收录 <font style=\"color:#FF0000;\">width</font>：可以用来<font style=\"color:#FF0000;\">修改图片的宽度</font>,一般使用px作为单位 <font style=\"color:#FF0000;\">height</font>：可以用来修改图片的<font style=\"color:#FF0000;\">高度</font>，一般使用px作为单位 // <font style=\"color:#FF0000;\">注意：一般不会同时设置宽高，以防图片变形 </font> 注意： 1:宽度和高度两个属性如果指设置一个，另一个也会同时等比例调整大小，如果两个值同时指定则按照你指定的值来设置。 2:一般开发中除了自适应的页面，不建议设置width和height，大图变小，会多占内存，小图变大会失真 3:pc端，需要多大的图，就裁多大的，移动端，进场会对图片进行缩放（大图缩小） <!-- <font style=\"color:#FF0000;\">行内块元素 具备块元素的可设置宽高同时具备行内元素的不独占一行</font> --> <!-- 内部图片的引入 --> <img src=\"./img/img/bl.gif\" alt=\"这是一张图片\"> <img src=\"./img/img/bl.gif\" alt=\"这是一张图片\" width=\"300\" height=\"400\"> <img src=\"./img/京东logo.png\" alt=\"\"> <font style=\"color:#FF0000;\">img标签是行内块元素 ，自结束标签</font> 图片格式（jpg gif png webp base64） 和油漆是一个道理，不同的图片格式特性不一样，使用场合也有所不同。 <font style=\"color:#FF0000;\">JPEG(JPG)//效果好，保存图片</font> JPEG图片支持的颜色比较多，图片<font style=\"color:#FF0000;\">可以压缩</font>，但是<font style=\"color:#FF0000;\">不支持透明</font> 一般用来保存照片等颜色丰富的图片 <font style=\"color:#FF0000;\">GIF//动图 </font> GIF支持的颜色少，只<font style=\"color:#FF0000;\">支持简单的透明，支持动态图</font> 图片颜色单一或者是动态图时可以使用gif <font style=\"color:#FF0000;\">PNG//显示复杂的图片，为网页而生 </font> PNG支持的颜色多，并且<font style=\"color:#FF0000;\">支持复杂的透明，不支持动图</font> 可以用来显示颜色复杂的透明的图片 专为网页而生的 <font style=\"color:#FF0000;\">webp//优点全具备，但兼容性不好</font> -谷歌新推出的专门用来表示网页的一种格式 -它具有其他图片格式的所有优点，而且文件格式还很小 <font style=\"color:#FF0000;\">-缺点：兼容性不好</font> <font style=\"color:#FF0000;\">base64 //与网页一起出现，需要先转字符</font> -讲图片使用base64编码，这样可以将图片转换为字符，通过字符形式来引入 -一般都是需要和网页一起加载的图片才会使用base64 图片的使用原则： 效果不一致，使用效果好的 效果一致，使用小的 网页加载流程： 先加载网页结构，然后再加载外部的资源包括css文件，js文件，图片，各种插件等 内联框架 <!-- <font style=\"color:#FF0000;\">用iframe来定义一个内联框架</font> --> <!-- <font style=\"color:#FF0000;\">iframe:</font> <font style=\"color:#FF0000;\">src：引入外部网址，全路径/内部链接，相对路径</font> <font style=\"color:#FF0000;\"> frameborder:去除边框效果 </font> <font style=\"color:#FF0000;\"> width：宽度</font> <font style=\"color:#FF0000;\"> height: 高度</font> <font style=\"color:#FF0000;\"> name ：链接的 target 属性</font> <font style=\"color:#FF0000;\"> target: 作为链接的目标</font> <font style=\"color:#FF0000;\"> iframe 可用作链接的目标（target）。</font> <font style=\"color:#FF0000;\"> 链接的 target 属性必须引用 iframe 的 name 属性：</font> --> <!-- <font style=\"color:#FF0000;\">链接跳转</font> --> <iframe src=\"https://www.w3school.com.cn/\" frameborder=\"0\" width=\"800\" height=\"600\"> </iframe> <!-- <iframe src=\"./02.结构标签.html\" width=\"800\" height=\"600\"></iframe> --> <!-- <font style=\"color:#FF0000;\">内嵌内部页面</font> --> <font style=\"color:#FF0000;\">// 定义一个内联框架，实现在网页里出现多个网页</font> <font style=\"color:#6A9955;\"><!-- 引入外部网址，全路径，并装饰框架 --></font> <!-- <font style=\"color:#FF0000;\">链接跳转内部展示/不刷新浏览器</font> name=\"iframe_a\" target=\"iframe_a\"--> <!-- <font style=\"color:#FF0000;\">在内部更新盒子内容</font> --> <iframe src=\"./02.结构标签.html\" width=\"800\" height=\"600\" name=\"iframe_a\"></iframe> <a href=\"https://www.w3school.com.cn/\" target=\"iframe_a\">点击更新</a> <font style=\"color:#FF0000;\">//定义一个内联框架，用name命名框架，再用<a>链接其他网址，实现内部更新框架内容</font> <font style=\"color:#6A9955;\">先做框架并起名，再用超链接的target属性指定在该框架，进行跳转</font> 音视频引入 音乐： <!-- <font style=\"color:#FF0000;\">audio标签</font> 用来向页面中<font style=\"color:#FF0000;\">引入</font>一个外部的<font style=\"color:#FF0000;\">音频</font>文件 音视频文件引入时，<font style=\"color:#FF0000;\">默认</font>情况下<font style=\"color:#FF0000;\">不允许用户自己控制播放停止</font> IE9以下的浏览器是不支持的 属性： <font style=\"color:#FF0000;\">controls 是否允许用户控制播放，不用给值</font> <font style=\"color:#FF0000;\"> autoplay 音频文件是否自动播放 打开页面时，音乐会自动播放，</font> <font style=\"color:#FF0000;\"> 但目前为止，大部分浏览器是不可以自动播放的</font> <font style=\"color:#FF0000;\"> loop 是否循环播放</font> --> <!-- 第一种方式 --> <!-- <audio src=\"./source/BABYDOLL .mp3\" controls autoplay loop></audio> --> <font style=\"color:#FF0000;\">source引入资源 //在audio中引入</font> <!-- 第二种方式 --> <!-- <audio controls autoplay loop > <font style=\"color:#FF0000;\"><source src=\"./source/Hurt.mp3\"></font> </audio> --> <font style=\"color:#FF0000;\"><!-- embed引入资源：src type --></font> <!-- <embed src=\"./source/Hurt.mp3\" type=\"audio/mp3\"> --> 视频： <!-- <font style=\"color:#FF0000;\">video标签</font>来向页面中<font style=\"color:#FF0000;\">引入</font>一个<font style=\"color:#FF0000;\">视频</font>，<font style=\"color:#FF0000;\">使用方式跟音频基本上一样的</font> --> <video src=\"./source/蜗居.mp4\" controls autoplay loop ></video> <video controls autoplay loop > <!-- <source src=\"./source/video.webm\"> --> <!-- <source src=\"./source/绝地逢生.mp4\"> --> <source src=\"./source/3月3日高颜值小家电.mp4\"> </video> css <font style=\"color:#FF0000;\">css -层叠样式表 </font> -网页实际上是一个多层的结构，通过css可以分别为网页的每一层来设置样式，而最终我们能看到的只有最上边的一层 <font style=\"color:#FF0000;\">//类似女生化妆 ，给网页化妆</font> -设置网页中元素的样式 如果要设置css样式，前提 <font style=\"color:#FF0000;\">css书写位置</font> <font style=\"color:#FF0000;\">如何选中对应的结构 </font>//先找对地方，后化妆 <font style=\"color:#FF0000;\"> </font> 你要找的事，找对追求目标，然后各种花招追求她（他） CSS书写位置： <font style=\"color:#FF0000;\">CSS样式：名值对的结构 样式名:样式值;</font> <font style=\"color:#FF0000;\">font-size: 30px; 设置字体大小</font> <font style=\"color:#FF0000;\"> color:red; 设置字体的颜色</font> <font style=\"color:#FF0000;\"> background:black; 设置背景颜色</font> <font style=\"color:#FF0000;\">第二种方式：内部样式表</font> <font style=\"color:#FF0000;\">写在<head>里，在<style>标签里写样式 </font> 在head标签里配置style标签，通过选择器选中对应html结构， 在花括号里面设置css声明块，可以写多组样式，也是以;隔开 //在style里先选对应的元素，然后设置样式 <font style=\"color:#FF0000;\">语法：选择器{css声明块}</font> <font style=\"color:#FF0000;\"> 缺点：不方便复用 </font> <font style=\"color:#FF0000;\"> html文件会变得很长，看起来也不好看</font> 总结：比较大的项目，或者重复使用率比较高的部分，不建议使用 //主要想写一次代码，其他html也可以用 <head> <style> div { color: pink; font-size: 50px; background-color: red; } </style> </head> <font style=\"color:#FF0000;\">第三种方式：外部样式表</font> <font style=\"color:#FF0000;\">在html文件外新建一个.css文件</font>，<font style=\"color:#FF0000;\">在css文件通过选择器选中对应的结构，设置相关的样式</font> <font style=\"color:#FF0000;\">通过link标签，将html文件和css文件联系在一起 //用前，先引用 </font> 总结：大的项目，或者复用率高的，推荐使用 //<font style=\"color:#FF0000;\">一次代码，多个文档使用</font> <link rel=\"stylesheet\" href=\"./03peiqi.css\" /> <font style=\"color:#6A9955;\"><!-- link在head，但不在style --></font> <font style=\"color:#FF0000;\">第一种方式：内联样式/行内样式</font><font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\">//在<body>标签里进行，样式写在开始标签里</font> <font style=\"color:#FF0000;\">在开始标签内，配置style属性，在style属性值里写css样式 </font> //样式分为 样式名：样式值; 名值对的结构 可以写多组css样式，样式与样式之间<font style=\"color:#FF0000;\">用;隔开</font> 缺点： 1、结构和样式耦合 //显得不好看 2、不容易修改 //代码太多，修改麻烦 总结：不建议使用 CSS的语法 html和css是两种不同的语言，所以有不同的书写位置，也有不同的语法 <font style=\"color:#FF0000;\">CSS的语法：</font> <font style=\"color:#FF0000;\"> 选择器 声明块</font> <font style=\"color:#FF0000;\">选择器：如何选中对应的html标签 </font> <font style=\"color:#FF0000;\"> 声明块：就是对应的css样式 名值对结构</font> <font style=\"color:#FF0000;\">标签{名值对} </font> //地方{妆容} //CSS的注释必须写在style里，或者是CSS文件中 CSS常用选择器（元素、id、class、*） <style> / 需求一：标题变红色 / <font style=\"color:#FF0000;\">元素（标签）选择器</font> <font style=\"color:#FF0000;\">作用：通过标签名选中对应的内容</font> <font style=\"color:#FF0000;\"> 语法：标签名{}</font> 注意：html常用标签大概20多个，如果用元素选择器选中设置css样式 一定要注意，是否会波及到其他的内容，如果波及到了，就不要用元素选择器 h1 { color: red; } / 需求二：将第一句诗变绿色 / <font style=\"color:#FF0000;\">id选择器</font> <font style=\"color:#FF0000;\">作用：通过id属性值，选中对应的结构</font> <font style=\"color:#FF0000;\"> 语法：#id属性值{}</font> <font style=\"color:#FF0000;\">注意：id属性值不能重复使用，不能以数字开头，不能是汉字</font> <font style=\"color:#FF0000;\">id值唯一，不能复用</font> #p1 { color: green; } / 需求三：将第二句诗也变绿色 / <font style=\"color:#FF0000;\">class选择器</font> <font style=\"color:#FF0000;\">作用：通过指定class属性值，选中对应的结构</font> <font style=\"color:#FF0000;\"> 语法：.class属性值{}</font> 注意：（1）、这也是最常用的选择器 （2）、 <font style=\"color:#FF0000;\">可以起多个class属性值，中间以空格隔开 </font> <font style=\"color:#FF0000;\">与id相比，class可以复用</font> .pp { color: green; } .p2{ background-color: pink; } .pp.p2{ font-size: 40px; } / 需求四：给所有的标签字体变为24px / <font style=\"color:#FF0000;\">通配选择器 </font> <font style=\"color:#FF0000;\">作用：选中页面中所有的标签</font> <font style=\"color:#FF0000;\"> 语法：*{}</font> 选所有的 { font-size: 24px; color: red; } </style> </head> <body> <div> <h1>登高</h1> <h3>杜甫</h3> <p id=\"p1\">风急天高猿啸哀，渚清沙白鸟飞回。</p> <p class=\"pp p2\">无边落木萧萧下，不尽长江滚滚来。</p> <p class=\"pp\">万里悲秋常作客，百年多病独登台。</p> <p class=\"p2\">艰难苦恨繁霜鬓，潦倒新停浊酒杯。</p> </div> </body> </html> CSS复合选择器（交集、并集） 复合选择器： <font style=\"color:#FF0000;\">交集选择器</font> <font style=\"color:#FF0000;\">作用：选中满足多个条件的元素</font> <font style=\"color:#FF0000;\"> 语法：选择器1选择器2选择器3····{}</font> 注意：如果选择器中有元素选择器，<font style=\"color:#FF0000;\">元素选择器必须放在第一</font>位 <font style=\"color:#FF0000;\">并集选择器</font> <font style=\"color:#FF0000;\"> 作用：同时选中多个选择器对应的内容</font> <font style=\"color:#FF0000;\"> 语法：选择1,选择器2，选择器3···{}</font> 总结： <font style=\"color:#0070C0;\">交集，从多个条件中找到符合的元素。并集，选择多个选择器的元素化妆，简化了代码</font> / 需求一：将class为red的诗句变为红色，同时将class为red的div字体变为24px / .red{ color: red; } p.red{ font-size: 24px; } / 需求二：将h1,h3字体颜色变为黄色/ h1,h3{ color: yellow; } </style> </head> <body> <h1>满江红·写怀</h1> <h3>岳飞·宋</h3> <p class=\"red\">怒发冲冠，凭栏处、潇潇雨歇。</p> <div class=\"red\">抬望眼，仰天长啸，壮怀激烈。</div> <div>三十功名尘与土，八千里路云和月。</div> <p>莫等闲，白了少年头，空悲切！</p> <p>靖康耻，犹未雪。臣子恨，何时灭！</p> <p>驾长车，踏破贺兰山缺。</p> <p>壮志饥餐胡虏肉，笑谈渴饮匈奴血。</p> <p>待从头、收拾旧山河，朝天阙。</p> </body> CSS关系选择器<font style=\"color:#0070C0;\">（父>子{} 祖先 后代{} 兄+弟{} 兄~弟{}）</font> / 需求一：为div的子元素span设置一个字体颜色红色 / <font style=\"color:#FF0000;\"> 1、子元素选择器</font> <font style=\"color:#FF0000;\"> 作用：通过指定的父元素找到指定的子元素</font> <font style=\"color:#FF0000;\"> 语法：父元素>子元素{}</font> #cs > span { color: red; } / 需求二：div里的span元素字体都变为30px / <font style=\"color:#FF0000;\"> </font><font style=\"color:#FF0000;\">2、后代选择器</font> <font style=\"color:#FF0000;\"> 作用：通过指定的祖先元素找到指定的后代元素</font> <font style=\"color:#FF0000;\"> 语法：祖先元素 后代元素{}</font> 注意：由于子元素一定情况下也属于后代元素，在使用的时候，能用子元素选择器，不用后代选择器,否则一定程度上会影响网站性能 #cs span { font-size: 30px; color: blue; } / 需求三:选择下一个兄弟(仅挨着我的)/ <font style=\"color:#FF0000;\"> </font><font style=\"color:#FF0000;\">3、下一个兄弟选择器</font> <font style=\"color:#FF0000;\">作用：通过指定兄找到紧挨着下一个兄弟</font> <font style=\"color:#FF0000;\"> 语法：兄+弟{}</font> .s1+span{ background-color: pink; } / 四:选择下面所有的兄弟(前面的不选)/ <font style=\"color:#FF0000;\"> </font><font style=\"color:#FF0000;\">4、选择所有兄弟选择器 </font> <font style=\"color:#FF0000;\"> 作用：通过指定兄找到下面所有的兄弟，不包括前面的</font> <font style=\"color:#FF0000;\"> 语法：兄～弟{}</font> .p1~span{ background-color: violet; } </style> </head> <body> <div id=\"cs\"> 我是超市<br /> <span>我是零食区</span> <p class=\"p1\"> 我是生鲜区 <span >肉类 <em>羊肉</em> <em>牛肉</em> </span> <span>蔬菜</span> </p> <span class=\"s1\">我是鞋包区</span> <div></div> <span>我是洗护区</span> <span>我是洗护区</span> <span>我是洗护区</span> </div> <br /> <span>我是超市外的小卖部</span> /* <font style=\"color:#FF0000;\"><!-- 元素之间的关系</font> <font style=\"color:#FF0000;\"> 父子关系</font> <font style=\"color:#FF0000;\"> 直接包含和被包含的关系</font> <font style=\"color:#FF0000;\"> 祖先后代关系</font> <font style=\"color:#FF0000;\"> 直接或间接包含和被包含的关系</font> <font style=\"color:#FF0000;\"> 兄弟关系</font> <font style=\"color:#FF0000;\"> 拥有共同父元素的元素</font> --> */ <!-- <div> <div> <div></div> <div></div> </div> </div> --> </body> </html> CSS属性选择器 <font style=\"color:#0000FF;\"> </font> / 需求一：有title属性的p标签，颜色变为红色 / <font style=\"color:#FF0000;\"> </font><font style=\"color:#FF0000;\">1:属性选择器</font><font style=\"color:#FF0000;\"> 通过指定的属性名或属性值来选中对应的内容</font> <font style=\"color:#FF0000;\"> 语法：[属性名]{} 选择含有</font><font style=\"color:#0000FF;\">指定属性</font><font style=\"color:#FF0000;\">的元素</font> <font style=\"color:#FF0000;\">[属性名=属性值]{} 选择含有</font><font style=\"color:#0000FF;\">指定属性和属性值</font><font style=\"color:#FF0000;\">的元素</font> <font style=\"color:#FF0000;\"> [属性名^=属性值]{} 选择</font><font style=\"color:#0000FF;\">属性值</font><font style=\"color:#FF0000;\">以指定值</font><font style=\"color:#0000FF;\">开头</font><font style=\"color:#FF0000;\">的元素 </font>//开头 ^ <font style=\"color:#FF0000;\"> [属性名$=属性值]{} 选择</font><font style=\"color:#0000FF;\">属性值</font><font style=\"color:#FF0000;\">以指定值</font><font style=\"color:#0000FF;\">结尾</font><font style=\"color:#FF0000;\">的元素 </font>//结尾 $ <font style=\"color:#FF0000;\"> [属性名=属性值]{} 选择</font><font style=\"color:#0000FF;\">属性值</font>含有<font style=\"color:#0000FF;\">某值</font><font style=\"color:#FF0000;\">的元素 </font>//含有 /* [class]{ color: red; } */ /* [title=ab]{ background-color: pink; } */ /* [title^=ab]{ font-size: 30px; } */ /* [title$=ab]{ color: orange; } */ [title*=abc]{ color: green; } </style> </head> <body> <h1 title=\"a\" id=\"abcd\">满江红·写怀</h1> //title属性，鼠标点哪，会显示属性值 <h3 title=\"ab\" class=\"ab\">岳飞·宋</h3> <p>····</p> <p title=\"babcb\" class=\"abc\">靖康耻，犹未雪。臣子恨，何时灭！</p> <p title=\"babcdab\">驾长车，踏破贺兰山缺。</p> <p>壮志饥餐胡虏肉，笑谈渴饮匈奴血。</p> <p>待从头、收拾旧山河，朝天阙。</p> </body> </html> 伪类选择器 <font style=\"color:#FF0000;\">一 、伪类（不存在的类，特殊的类）</font> -伪类不特指某一个元素，指的是<font style=\"color:#FF0000;\">一个元素的特殊状态</font> // 元素的特殊状态 -比如：第一个元素，被点击的元素，鼠标移入的元素··· -特点：一般请情况下，<font style=\"color:#FF0000;\">使用：开头</font> <font style=\"color:#FF0000;\">1、 :first-child 第一个子元素</font> <font style=\"color:#FF0000;\"> 先选位置，再判断元素</font> <font style=\"color:#FF0000;\"> 2、 :last-child 最后一个子元素</font> <font style=\"color:#FF0000;\"> 3、 :nth-child() 选中第n个子元素</font> <font style=\"color:#FF0000;\"> 特殊值： n 所有的</font> <font style=\"color:#FF0000;\"> 2n或even 选中偶数</font> <font style=\"color:#FF0000;\"> 2n+1或odd 选中奇数</font> // 以上这些伪类都是<font style=\"color:#FF0000;\">根据所有的子元素进行排序</font> <font style=\"color:#FF0000;\">1、:first-of-type 选中第一个子元素</font> <font style=\"color:#FF0000;\"> 先找元素，再判断位置</font> <font style=\"color:#FF0000;\"> 2、:last-of-type 选中最后一个子元素</font> <font style=\"color:#FF0000;\"> 3、:nth-of-type() 选中第n个子元素</font> <font style=\"color:#FF0000;\"> 功能跟上面相似，</font> <font style=\"color:#FF0000;\"> 不同的是，这是在</font><font style=\"color:#00B0F0;\">同类型的子元素中去选择</font> 需求： ul里面的第一句诗永远是红色 li:first-of-type{ color: red; } <font style=\"color:#FF0000;\"> 二、:not() 否定伪类</font> <font style=\"color:#FF0000;\">-将符合条件的元素从选择器中去除</font> 需求2:将所有li字体变绿色，除了class为l1 <font style=\"color:#00B0F0;\"> li:not(.l1) {</font> <font style=\"color:#00B0F0;\"> color: green;</font> <font style=\"color:#00B0F0;\"> }</font> ul li:nth-child(2n+1){ color: red; } ul p:first-of-type{ color: red; } a元素的伪类 <font style=\"color:#FF0000;\">a元素的伪类 访问过、未访问过、鼠标移入/点击的状态等</font> / 需求一：给未访问过的超链接加红色字体 / <font style=\"color:#FF0000;\">1、:link 用来表示未访问过的链接（正常链接）</font> a:link { color: red; } / 需求二：给访问过的超链接加绿色字体 / <font style=\"color:#FF0000;\">2、:visited 用来表示访问过的链接</font> 由于隐私的原因，所以visited只能改颜色 a:visited{ color: orange; font-size: 50px; } <font style=\"color:#FF0000;\">//注意：:link :visited 这两个伪类是超链接独有</font> / 需求三：鼠标移入，链接字体变大到30px / <font style=\"color:#FF0000;\">3、:hover 用来表示鼠标移入的状态</font> a:hover{ font-size: 30px; color: red; } / 需求四：鼠标点击后，增加背景色pink / <font style=\"color:#FF0000;\">4、:active 鼠标点击后的状态</font> a:active{ background-color: pink; } <font style=\"color:#FF0000;\">//注意：:hover、:active 是所有标签共有的伪类</font> love hate //都出现的话，有顺序 <font style=\"color:#FF0000;\">L-V-H-A </font> <font style=\"color:#FF0000;\">a，LVHA 伪类-超连接：你先捡到了个LV包，然后你HA哈大笑</font>。 <font style=\"color:#6A9955;\">l（link）ov（visited）e h（hover）a（active）te</font> strong:hover{ color: palegreen; } strong:active{ background-color: pink; } </style> </head> <body> <strong>百度</strong> <a href=\"https://www.baidu.com/\">百度</a> <a href=\"https://www.jd.com/\">京东</a> <a href=\"https://www.taobao.com/\">淘宝</a> <a href=\"#\">空链接</a> </body> </html> 伪元素选择器 <style> / 需求一：让文章的首字母一直为字体为24px / / 需求二：让文章的第一行添加背景色黄色 / / 需求三：让选中的内容，字体为红色 / / 需求四：在元素开始的位置前+'abc' / <font style=\"color:#FF0000;\">伪元素，表示页面中一些特殊的并不真实存在的元素（元素的位置）</font> <font style=\"color:#FF0000;\">::first-letter 表示第一个字母</font> <font style=\"color:#FF0000;\"> ::first-line 表示第一行</font> <font style=\"color:#FF0000;\"> ::selection 选中的内容</font> <font style=\"color:#FF0000;\"> ::before 元素的开始位置</font> <font style=\"color:#FF0000;\"> ::after 元素的结束位置</font> <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\">before和after必须要结合content使用 //在元素的开始或结束位置加内容 </font> <font style=\"color:#FF0000;\"> //加的内容是行内元素</font> <font style=\"color:#FF0000;\">行内，after，before</font> p::first-letter{ / color: red; / font-size: 40px; } p::first-line{ color: rgb(143, 34, 34); } div::selection{ background-color: pink; color: red; } div::before{ content:'你好' ; } div::after{ content: 'hello'; } p::before{ content:''; display: inline-block; width: 16px; height: 16px; background-color: red; } </style> </head> <body> <div>Lorem ipsum dolor sit amet.</div> <p> 结核杆菌dolor sit amet consectetur adipisicing elit. Dicta, dignissimos? 的三九由，导不竟德。 </p> </body> </html> 样式的继承（继承祖先的资产） 定义：<font style=\"color:#FF0000;\">为一个元素设置的样式，同时也会应用到它的后代元素上</font> 优势：<font style=\"color:#FF0000;\">方便</font>我们<font style=\"color:#FF0000;\">开发</font>，讲一些通用的样式统一设置到共同的祖先元素上，子元素的样式都可以获取到样式 <font style=\"color:#FF0000;\">注意：并不是所有的样式都会被继承，比如：背景相关的，布局相关等不会被继承</font> 选择器的权重 <font style=\"color:#FF0000;\">样式冲突</font> <font style=\"color:#FF0000;\">通过不同的选择器选中同一个元素，进行一样的样式设定</font> <font style=\"color:#FF0000;\">发生样式冲突时，应用哪一个样式由</font><font style=\"color:#0070C0;\">选择器的权重</font><font style=\"color:#FF0000;\">（优先级）决定</font> <style> / 需求：给span设置背景色 / span{ background-color: pink !important; } /* span,.s1 { background-color: royalblue; } .s1 { background-color: red; } */ /* #ss{ background-color: green; } */ /* div>span{ background-color: orange; } */ /* [class] { background-color: orchid; } */ /* div{ background-color: paleturquoise; } */ / { background-color: peru; } */ 面试题： 选择器权重 权重（模拟） <font style=\"color:#FF0000;\"> !important 最高的优先级</font> <font style=\"color:#FF0000;\"> 内联样式 1000</font> <font style=\"color:#FF0000;\"> id选择器 100</font> <font style=\"color:#FF0000;\"> class选择器 10</font> <font style=\"color:#FF0000;\"> 类和伪类选择器 10</font> <font style=\"color:#FF0000;\">属性选择器 10</font> <font style=\"color:#FF0000;\"> 元素选择器 1 </font> <font style=\"color:#FF0000;\"> 通配选择器 0</font> <font style=\"color:#FF0000;\"> 继承样式 没有权重</font> <font style=\"color:#FF0000;\"> ·····</font> 注意： 1、对比选择器权重的时候，如果是<font style=\"color:#FF0000;\">交集选择器</font>的话，需要将所有选择器<font style=\"color:#FF0000;\">权重相加</font>，最终谁高用谁 2、对比选择器权重的时候，如果是<font style=\"color:#FF0000;\">并集选择器</font>的话,<font style=\"color:#FF0000;\">单独计算选择器权重</font>，谁高听谁的 3、对比选择器权重的时候，如果<font style=\"color:#FF0000;\">选择器权重是相同</font>的，谁<font style=\"color:#FF0000;\">靠下</font>，用谁的 4、对比选择器权重的时候，<font style=\"color:#FF0000;\">累加的选择器权重，最高不会超过上一级</font> //例如：类选择器再高也不会超过id选择器 5、<font style=\"color:#FF0000;\">!important 最高的优先级</font> 慎用 ！important写在样式里 如果样式没有生效，可用来检测是否是选择器权重 再者一般用来修改插件的样式 /* .s1.s2.s3.s11{ background-color: salmon; } #ss{ background-color: seagreen; } */ </style> </head> <body> <!-- --> <div> 我是div元素 <span class=\"s1 s2 s3 s4 s11\" id=\"ss\" style=\"background-color: purple;\">我是div中的span元素</span> </div> </body> </html> 长度单位 <font style=\"color:#FF0000;\">1:像素 px</font> 像素是我们在网页中使用的最多的一个单位， 一个像素就相当于我们屏幕中的一个小点， 我们的屏幕实际上就是由这些像素点构成的 但是这些像素点，是不能直接看见。 不同显示器一个像素的大小也不相同， <font style=\"color:#FF0000;\">显示效果越好越清晰，像素就越小，反之像素越大</font>。 <font style=\"color:#FF0000;\">2:百分比 %</font> 也可以将单位设置为一个百分比的形式， 这样浏览器将会<font style=\"color:#FF0000;\">根据其父元素的样式来计算</font>该值 使用百分比的好处是，当父元素的属性值发生变化时， 子元素也会按照比例发生改变 在我们创建一个自适应的页面时，经常使用百分比作为单位 <font style=\"color:#FF0000;\">em</font> em和百分比类似，它是<font style=\"color:#FF0000;\">相对于当前元素的字体大小来计算的</font> <font style=\"color:#FF0000;\">1em = 1font-size</font> <font style=\"color:#FF0000;\">浏览器默认字体大小是16px</font> 使用em时，当字体大小发生改变时，em也会随之改变 <font style=\"color:#FF0000;\">当设置字体相关的样式时，经常会使用em</font> <font style=\"color:#FF0000;\"> </font><font style=\"color:#FF0000;\">rem </font><font style=\"color:#FF0000;\"> </font> -rem是<font style=\"color:#FF0000;\">相对于根元素(html)的字体大小来计算的</font> 比如根标签的字体大小是25px,那么设置rem根据25px来计算，<font style=\"color:#FF0000;\">10rem=10*25px</font> html { / 注意：根标签html的字体大小 1rem=1font-size / font-size:25px; } .box { width: 400px; height: 300px; background-color: red; } .box1 { / em根据当前的字体大小去计算，1em=1font-size(font-size:20px;) //1em=20px/ font-size:20px; /* width: 10em; height: 15em; */ / width:200,height:300 / / rem计算盒子大小 / width:8rem; height: 12rem; /* width: 50%; height: 100%; */ /* width: 200px; height: 200px; */ 颜色单位： <font style=\"color:#FF0000;\">1:</font>在CSS可以<font style=\"color:#FF0000;\">直接</font>使<font style=\"color:#FF0000;\">用</font>颜色的<font style=\"color:#FF0000;\">单词</font>来表示不同的颜色 红色：red 蓝色：blue 绿色：green 黄色：yellow 注意： 这种用的比较少 不好描述，难记 <font style=\"color:#FF0000;\">2:</font>使用<font style=\"color:#FF0000;\">RGB值</font>来表示不同的颜色 所谓的RGB值指的是通过<font style=\"color:#FF0000;\">Red Green Blue三元色</font>， 通过这三种颜色的<font style=\"color:#FF0000;\">不同的浓度</font>，来<font style=\"color:#FF0000;\">表示</font>出不同的颜色 例子：rgb(红色的浓度,绿色的浓度,蓝色的浓度); <font style=\"color:#FF0000;\">颜色的浓度</font>需要一个<font style=\"color:#FF0000;\">0-255之间的值</font>，255表示最大，0表示没有 浓度也<font style=\"color:#FF0000;\">可以</font>采用一个<font style=\"color:#FF0000;\">百分数</font>来设置， 需要一个<font style=\"color:#FF0000;\">0% - 100%</font>之间的数字 使用百分数最终也会转换为0-255之间的数 0%表示0 100%表示255 -<font style=\"color:#FF0000;\">语法：RGB(红色，绿色，蓝色)</font> -注意：比较常用，计算机可以很好的识别 <font style=\"color:#FF0000;\"> 3:RGBA</font> <font style=\"color:#FF0000;\">-语法：RGBA(红色，绿色，蓝色，透明度)</font> <font style=\"color:#FF0000;\">a:透明度（0-1） 1不透明，0透明</font> <font style=\"color:#FF0000;\">4:</font>使用<font style=\"color:#FF0000;\">十六进制的rgb值</font>来表示颜色，原理和上边RGB原理一样， 十六进制： 0 1 2 3 4 5 6 7 8 9 a b c d e f 00 - ff 00表示没有，相当于rgb中的0 ff表示最大，相当于rgb中255 只不过使用十六进制数来代替，使用三组两位的十六进制数组来表示一个颜色 每组表示一个颜色 第一组表示<font style=\"color:#FF0000;\">红色</font>的浓度，范围<font style=\"color:#FF0000;\">00-ff</font> 第二组表示<font style=\"color:#FF0000;\">绿色</font>的浓度，范围是00-ff 第三组表示<font style=\"color:#FF0000;\">蓝色</font>的浓度，范围00-ff <font style=\"color:#FF0000;\">语法：#红色绿色蓝色;</font> 红色： #ff0000 像这种<font style=\"color:#FF0000;\">两位两位重复的颜色，可以简写</font> 比如：#ff0000 可以写成 #f00 #abc #aabbcc 常用的十六进制颜色：<font style=\"color:#FF0000;\">#f00 红色 #f60 橘色 #ccc 灰色 </font> <font style=\"color:#FF0000;\"> #0f0 绿色 #000黑色 #fff 白色</font> <font style=\"color:#FF0000;\">5:HSL值 HSLA值</font> H 色相 （0-360）hue [hju:] S 饱和度 saturation [,sætʃə'reiʃən] 颜色浓度0%-100% L 亮度 lightness [ˈlaɪtnəs] 颜色亮度0%-100% A 透明度 alpha ['ælfə] .box1{ width:300px; height: 300px; <font style=\"color:#FF0000;\">/ 透明度 /</font> <font style=\"color:#FF0000;\"> / opacity:0.5; /</font> background-color:rgba(255, 0, 0,.5); } .box2{ width:300px; height: 300px; / background-color: rgb(233,23,23); / / background-color: rgba(255, 0, 0, .5); / / background-color:rgb(255,127,127); / background-color: hsla(0, 0%, 0%,.5); } 字体样式 <font style=\"color:#FF0000;\">1:color</font> <font style=\"color:#FF0000;\">设置字体颜色</font>,也可以设置其他颜色*/ color: red; <font style=\"color:#FF0000;\">2:font-size</font> 注意： (1)、设置的并不是文字本身的大小，在页面中，每个文字都是处在一个看不见的框中的，我们设置的<font style=\"color:#FF0000;\">font-size实际上是设置格的高度</font>，并不是字体的大小，一般情况下文字都要比这个格要小一些，也有时会比格大，根据字体的不同，显示效果也不同 (2)、<font style=\"color:#FF0000;\">设置文字的大小</font>,浏览器中一般<font style=\"color:#FF0000;\">默认</font>的文字<font style=\"color:#FF0000;\">大小都是16px,</font>默认的<font style=\"color:#FF0000;\">最小</font>的字体是<font style=\"color:#FF0000;\">12px</font> (3)、<font style=\"color:#FF0000;\">常用的单位 px，rem，em</font> <font style=\"color:#FF0000;\">3:font-family可以指定文字的字体</font> 当采用某种字体时，如果浏览器支持则使用该字体， 如果字体不支持，则使用默认字体 该样式可以同时指定多个字体，多个字体之间使用,分开 当采用多个字体时，浏览器会优先使用前边的字体， 如果前边没有在尝试下一个 /* 浏览器使用的字体默认就是计算机中的字体， 如果计算机中有，则使用，如果没有就不用 在开发中，如果字体太奇怪，用的太少了，尽量不要使用， 有可能用户的电脑没有，就不能达到想要的效果。 */ / font-family: '华文彩云' , arial , '微软雅黑'; / span{ font-family: 'sans-serif'; } <font style=\"color:#FF0000;\">@font-face 可以自定义使用非电脑自带字体</font> //可以将服务器中的字体直接提供给用户去使用 属性： 给字体起的名字 使用步骤 <font style=\"color:#FF0000;\"> （1）、先自定，设置好字体</font> <font style=\"color:#FF0000;\"> （2）、去使用即可</font> <font style=\"color:#FF0000;\">@font-face {</font> <font style=\"color:#FF0000;\"> / 你给字体起的名字 /</font> <font style=\"color:#FF0000;\"> font-family: \"xiyangyang\";</font> <font style=\"color:#FF0000;\"> / 自定义字体的路径 /</font> <font style=\"color:#FF0000;\"> src: url(./字体/MeowScript-Regular.ttf);</font> <font style=\"color:#FF0000;\"> }</font> <font style=\"color:#FF0000;\"> font-family: \"xiyangyang\";</font> 字体分类 <body> <!-- 在网页中将字体分成<font style=\"color:#FF0000;\">5大类</font>： <font style=\"color:#FF0000;\">serif ['serif]（衬线字体）//笔锋</font> <font style=\"color:#FF0000;\"> sans-serif（非衬线字体）//无笔锋，默认</font> <font style=\"color:#FF0000;\"> monospace （等宽字体）</font> <font style=\"color:#FF0000;\"> cursive ['kə:siv]（草书字体）</font> <font style=\"color:#FF0000;\"> fantasy ['fæntəsi]（虚幻字体）</font> 可以将字体设置为这些大的分类,当设置为大的分类以后， 浏览器会自动选择指定的字体并应用样式 一般会将<font style=\"color:#FF0000;\">字体的大分类，指定为font-family中的最后一个字体,用来兜底</font> --> 字体其他样式 <font style=\"color:#FF0000;\">1:font-style</font>可以用来设置<font style=\"color:#FF0000;\">文字的斜体</font> 可选值： <font style=\"color:#FF0000;\">normal，默认值，文字正常显示</font> <font style=\"color:#FF0000;\">italic [i'tælik] 文字会以斜体显示</font> oblique [ə'bli:k]文字会以倾斜的效果显示 - 大部分浏览器都不会对倾斜和斜体做区分， 也就是说我们设置<font style=\"color:#FF0000;\">italic和oblique它们的效果往往是一样的</font> 一般我们只会使用italic <font style=\"color:#FF0000;\">font-style: italic;</font> <font style=\"color:#FF0000;\">2:font-weight可以用来设置文本的加粗效果：</font> 可选值： <font style=\"color:#FF0000;\">normal，默认值，文字正常显示</font> <font style=\"color:#FF0000;\">bold，文字加粗显示</font> 该样式也可以指定<font style=\"color:#FF0000;\">100-900之间的9个值</font>， 但是由于用户的计算机往往没有这么多级别的字体，所以达到我们想要的效果 也就是200有可能比100粗，300有可能比200粗，但是也可能是一样的 <font style=\"color:#FF0000;\"> font-weight:bold; </font> <font style=\"color:#FF0000;\"> font-weight:bolder;</font> *<font style=\"color:#FF0000;\"> 3:font-variant ['vεəriənt] 可以用来设置小型大写字母</font> 可选值： <font style=\"color:#FF0000;\">normal，默认值，文字正常显示</font> <font style=\"color:#FF0000;\">* small-caps 文本以小型大写字母显示</font> 小型大写字母： 将所有的字母都以大写形式显示，但是小写字母的大写，要<font style=\"color:#FF0000;\">比大写字母的大小小一些</font>。 <font style=\"color:#FF0000;\">font-variant: small-caps;</font> .p2{ color: red; <font style=\"color:#FF0000;\">/设置一个文字大小/</font> <font style=\"color:#FF0000;\"> / font-size: 18px; /</font> <font style=\"color:#FF0000;\"> /设置一个字体/</font> <font style=\"color:#FF0000;\"> / font-family:'三极魏碑简体'; /</font> <font style=\"color:#FF0000;\"> /设置文字斜体/</font> <font style=\"color:#FF0000;\"> / font-style: italic; /</font> <font style=\"color:#FF0000;\"> /设置文字的加粗/</font> <font style=\"color:#FF0000;\"> / font-weight: bolder; /</font> <font style=\"color:#FF0000;\"> /设置一个小型大写字母/</font> <font style=\"color:#FF0000;\"> / font-variant: small-caps; /</font> font: small-caps italic bolder 18px \"三极魏碑简体\" } 在CSS中还为我们提供了一个样式叫font， 使用该样式可以同时设置字体相关的所有样式, 可以将字体的样式的值，统一写在font样式中，<font style=\"color:#FF0000;\">不同的值之间使用空格隔开</font> 使用<font style=\"color:#FF0000;\">font设置字体样式</font>时，<font style=\"color:#FF0000;\">斜体 加粗 小大字母，没有顺序要求，甚至可写可不写，如果不写则使用默认值，但是要求</font><font style=\"color:#0070C0;\">文字的大小和字体必须写</font><font style=\"color:#FF0000;\">，而且</font><font style=\"color:#0070C0;\">字体</font><font style=\"color:#FF0000;\">必须是</font><font style=\"color:#0070C0;\">最后一个</font><font style=\"color:#FF0000;\">样式，</font><font style=\"color:#0070C0;\">大小</font><font style=\"color:#FF0000;\">必须是</font><font style=\"color:#0070C0;\">倒数第二个样式</font> 实际上使用<font style=\"color:#FF0000;\">简写</font>属性也会有一个比较好的性能 <font style=\"color:#FF0000;\">/ font: small-caps bold italic 60px \"微软雅黑\"; /</font> / font: 60px \"微软雅黑\"; / / font: 60px \"微软雅黑\"; / font-family: \"华文彩云\"; 行间距 <font style=\"color:#FF0000;\">行高（line height）--文字占有的实际高度</font> 使用line-height来设置行高 行高类似于我们上学单线本，单线本是一行一行，<font style=\"color:#FF0000;\">线与线之间的距离就是行高</font>，控制文字行与行之间的距离 网页中的文字实际上也是写在一个看不见的线中的，而文字会默认在行高中垂直居中显示 —— 可<font style=\"color:#FF0000;\">接收的值</font>： 1.直接就写一个大小，<font style=\"color:#FF0000;\">eg：22px</font> 2.可以指定一个<font style=\"color:#FF0000;\">百分数</font>，则会<font style=\"color:#FF0000;\">相对于字体</font>去计算行高，<font style=\"color:#FF0000;\">eg：30%</font> 3.可以直接传一个<font style=\"color:#FF0000;\">数值</font>，则行高会<font style=\"color:#FF0000;\">设置字体大小相应的倍数</font>，<font style=\"color:#FF0000;\">eg：2</font> —— 行高经常还用来设置文字的行间距 <font style=\"color:#FF0000;\">行高=上间距+文字高度+下间距</font> 行间距 = 行高 - 字体大小 字体框 字体框是字体纯在的格子，设置<font style=\"color:#FF0000;\">font-size</font>实际上就是在<font style=\"color:#FF0000;\">设置字体框的高度</font> 总结： <font style=\"color:#FF0000;\">行高会在字体框的上下平均分配</font> .p1 { font-size: 20px; height: 100px; border: 1px solid red; line-height:5; / 默认行高 / / line-height: 1.333; / } .box { width: 200px; height: 100px; background-color: #bfa; 对于<font style=\"color:#FF0000;\">单行文本</font>来说，可以将<font style=\"color:#FF0000;\">行高设置为和父元素的高度一致</font>，这样可以是单行文本在父元素中<font style=\"color:#FF0000;\">垂直居中</font> .p2 { /* 在font中也可以指定行高，在<font style=\"color:#FF0000;\">字体大小后</font>可以添加<font style=\"color:#FF0000;\">/行高</font>，<font style=\"color:#FF0000;\">来指定行高</font>，该值是可选的，如果<font style=\"color:#FF0000;\">不指定则会使用默认值</font> */ / font: 30px/100px \"微软雅黑\"; / border: 1px solid red; / line-height: 50px; / } 文本样式 <font style=\"color:#FF0000;\"> 1: text-transform</font> 可以用来<font style=\"color:#FF0000;\">设置文本的大小写</font> transform [træns'fɔ:m] 是变形的意思，使变化的意思 可选值： <font style=\"color:#FF0000;\">none 默认值</font>，该怎么显示就怎么显示，<font style=\"color:#FF0000;\">不做任何处理</font> <font style=\"color:#FF0000;\">capitalize </font>[ˈkæpɪtəlaɪz] 单词的<font style=\"color:#FF0000;\">首字母大写</font>，通过空格来识别单词 <font style=\"color:#FF0000;\">uppercase [ˈʌpəˌkeɪs] 所有的字母都大写</font> <font style=\"color:#FF0000;\"> lowercase ['ləuə,keis] 所有的字母都小写</font> text-transform: lowercase; } <font style=\"color:#FF0000;\">2: text-decoration</font> [dɛkə'reɪʃ(ə)n] 可以用来<font style=\"color:#FF0000;\">设置文本的修饰</font> 可选值： <font style=\"color:#FF0000;\">none：默认值</font>，不添加任何修饰，<font style=\"color:#FF0000;\">正常显示</font> <font style=\"color:#FF0000;\">underline </font>为文本添加<font style=\"color:#FF0000;\">下划线</font> <font style=\"color:#FF0000;\">overline</font> 为文本添加<font style=\"color:#FF0000;\">上划线</font> <font style=\"color:#FF0000;\">line-through</font> 为文本添加<font style=\"color:#FF0000;\">删除线</font> / text-decoration: overline; / text-decoration: line-through; a { /*超链接会默认添加下划线，也就是超链接的text-decoration的默认值是underline 如果需要<font style=\"color:#FF0000;\">去除超链接的下划线</font>则需要将该样式设置为none */ <font style=\"color:#FF0000;\">text-decoration: none;</font> } <font style=\"color:#FF0000;\">3: letter-spacing可以指定字符间距</font> letter-spacing: 10px; <font style=\"color:#FF0000;\">4: word-spacing</font>可以<font style=\"color:#FF0000;\">设置单词之间的距离</font> //实际上就是设置词与词之间空格的大小,<font style=\"color:#FF0000;\">对汉字无效</font> / word-spacing: 100px; / <font style=\"color:#FF0000;\">5: text-align</font>用于<font style=\"color:#FF0000;\">设置文本的对齐方式</font> 可选值： <font style=\"color:#FF0000;\">left 默认值，文本靠左对齐</font> <font style=\"color:#FF0000;\"> right ， 文本靠右对齐</font> <font style=\"color:#FF0000;\"> center ， 文本居中对齐</font> <font style=\"color:#FF0000;\"> justify ， 两端对齐</font> 通过调整文本之间的空格的大小，来达到一个两端对齐的目的 <font style=\"color:#FF0000;\">也可以让图片水平居中</font> text-align: center; <font style=\"color:#FF0000;\"> 6: text-indent 设置首行缩进</font> 指定一个<font style=\"color:#FF0000;\">正值</font>时，会自动<font style=\"color:#FF0000;\">向右</font>侧缩进指定的像素 指定一个<font style=\"color:#FF0000;\">负值</font>，则会<font style=\"color:#FF0000;\">向左</font>移动指定的像素, 通过这种方式<font style=\"color:#FF0000;\">可以将</font>一些不想显示的<font style=\"color:#FF0000;\">文字隐藏</font>起来 这个值一般都会使用em作为单位 text-indent:-2em; <font style=\"color:#FF0000;\">7: white-space: </font>;<font style=\"color:#FF0000;\"> 设置网页如何处理空白</font> 可选值： <font style=\"color:#FF0000;\">x 正常</font> <font style=\"color:#FF0000;\">nowrap 不换行</font> <font style=\"color:#FF0000;\"> per 保留空白 </font> <font style=\"color:#FF0000;\">8: text-overflow 文本溢出包含元素时发生的事情</font>。 可选值： <font style=\"color:#FF0000;\"> clip 修剪文本。</font> <font style=\"color:#FF0000;\"> ellipsis</font> [i'lipsis] <font style=\"color:#FF0000;\">显示省略符号来代表被修剪的文本。</font> white-space: nowrap; overflow: hidden; text-overflow: clip; <font style=\"color:#FF0000;\">单行文本省略号</font>，white-space:nowrap; 设置网页<font style=\"color:#FF0000;\">不换行，隐藏溢出的，显示省略号</font> / vertical-align:middle; / <font style=\"color:#FF0000;\">9:vertical-align 设置元素垂直对齐的方式</font> 可选值： <font style=\"color:#FF0000;\">baseline 默认值 基线对齐</font> <font style=\"color:#FF0000;\">top 顶部对齐</font> <font style=\"color:#FF0000;\"> bottom 底部对齐</font> <font style=\"color:#FF0000;\"> middle 居中对齐</font> 应用：<font style=\"color:#FF0000;\">1:图文垂直对齐方式</font> <font style=\"color:#FF0000;\"> 2:图片三像素的问题 </font> 父元素如果不设置高，由图片撑开，此时图片的底部就会有三像素的空白 解决方式<font style=\"color:#FF0000;\">一：vertical-align属性值不为默认值</font> 解决方式<font style=\"color:#FF0000;\">二：给图片转成块元素</font> 解决方式<font style=\"color:#FF0000;\">三：给父元素设置font-size为0</font> 解决方式<font style=\"color:#FF0000;\">四：使元素脱离文档流，如浮动，绝对定位，弹性盒子等</font> 注意 <font style=\"color:#FF0000;\">vertical-align</font> 只对行内元素、行内块元素和表格单元格元素生效：<font style=\"color:#FF0000;\">不能用它垂直对齐块级元素。 </font> / 图文的对齐方式 / .img2{ / display: block; / vertical-align:middle; } .box{ border: 1px solid red; width: 300px; / font-size: 0; / } .box>img{ / vertical-align:bottom; / / display: block; / } 图片三像素问题是指在网页布局中，当<font style=\"color:#FF0000;\">图片作为行内元素或行内块元素与文本处于同一行时，图片底部会出现三像素的空白间隙</font>。<font style=\"color:#FF0000;\">这是由于浏览器默认的垂直对齐方式为基线对齐，而文本的基线与图片底部有一定的间距。</font> 解决方式主要有以下几种： <font style=\"color:#FF0000;\">设置vertical-align属性</font>：将图片的vertical-align属性值设置为非默认值，如top、middle、bottom等，可以改变图片的垂直对齐方式，从而消除三像素空白。 <font style=\"color:#FF0000;\">将图片转换为块元素</font>：通过设置display:block，使图片变为块级元素，它将独占一行，不再与文本基线对齐，从而解决三像素问题。 <font style=\"color:#FF0000;\">设置父元素的font-size为0</font>：这会使父元素内的文本基线位置上移，进而消除图片底部的空白，但需要注意的是，这种方式可能会影响到父元素内其他文本的显示，需要对文本重新设置合适的字体大小。 <font style=\"color:#FF0000;\">使元素脱离文档流</font>：如使用浮动（float）、绝对定位（position:absolute）或弹性盒子（display:flex）等布局方式，让图片脱离文档流的影响，也可以解决三像素问题。 <font style=\"color:#FF0000;\">10: text-shadow: h-shadow v-shadow blur color;</font> <font style=\"color:#FF0000;\">参数1:必需。水平阴影</font>的位置。允许负值。 <font style=\"color:#FF0000;\">参数2:必需。垂直阴影</font>的位置。允许负值。 参数3<font style=\"color:#FF0000;\">:可选</font>。模糊的距离。 参数4<font style=\"color:#FF0000;\">:可选</font>。阴影的颜色 一般用<font style=\"color:#FF0000;\">rgba </font> text-shadow:-2px -3px 1px rgba(255, 0, 0, .1); 多行文本省略号 <font style=\"color:#FF0000;\">多行文本省略号</font>，对于webkit， display: -webkit - box和 -webkit - box - orient: vertical这两个属性一起使用，<font style=\"color:#FF0000;\">将元素设置</font>为一个垂直排列的<font style=\"color:#FF0000;\">弹性盒子</font>。 -webkit - line - clamp: 3是关键属性，它<font style=\"color:#FF0000;\">指定</font>了<font style=\"color:#FF0000;\">显示的行数</font>为 3 行。当文本内容超过 3 行时，<font style=\"color:#FF0000;\">超出的部分会被隐藏</font>。 overflow: hidden用于<font style=\"color:#FF0000;\">隐藏溢出的文本</font>部分。这种方法在非 WebKit 浏览器中可能不被支持，需要添加浏览器前缀来确保兼容性。 overflow: hidden; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient:vertical; 缺一不可 适用范围： 因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端； 注： -<font style=\"color:#FF0000;\">webkit-line-clamp</font>用来<font style=\"color:#FF0000;\">限制在一个块元素显示的文本的行数</font>。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性： <font style=\"color:#FF0000;\">display: -webkit-box; </font>必须结合的属性 ，<font style=\"color:#FF0000;\">将对象作为弹性伸缩盒子模型显示 </font>。 -<font style=\"color:#FF0000;\">webkit-box-orient</font> 必须结合的属性 ，<font style=\"color:#FF0000;\">设置或检索伸缩盒对象的子元素的排列方式 。</font> <font style=\"color:#FF0000;\">vertical 从上到下垂直排列子元素</font> 文档流 文档流（normal flow） -网页是一个多层的结构，一层叠着一层，通过css可以分别为每一层来设置样式 -作为用户来讲，只能看到最顶上一层 -文档流处在网页的最底层，文档流是网页的基础， 它表示的是一个页面中的位置， 我们所创建的元素默认都处在文档流中，在其上排列 -元素主要有两个状态，在文档流中，不在文档流中（脱离文档流） 元素在文档流中的特点 <font style=\"color:#FF0000;\">块元素</font> 1.块元素在文档流中会<font style=\"color:#FF0000;\">独占一行</font>，块元素会<font style=\"color:#FF0000;\">自上向下排列</font>。 2.块元素在文档流中<font style=\"color:#FF0000;\">默认宽度是父元素的100%</font> 3.块元素在文档流中的<font style=\"color:#FF0000;\">高度默认被内容(子元素)撑开</font> 内联元素（<font style=\"color:#FF0000;\">行内元素</font>） 1.内联元素在文档流中<font style=\"color:#FF0000;\">只占自身的大小</font>，会默认<font style=\"color:#FF0000;\">从左向右排列</font>，如果一行中不足以容纳所有的内联元素，则换到下一行，继续自左向右。 2.在文档流中，内联元素的<font style=\"color:#FF0000;\">宽度和高度默认都被内容撑开</font> 盒子模型 把元素布局到页面，就像想买个桌子，放到家里，要知道桌子的大小，形状，然后才能放到家里，所以我们把所有的元素都想成盒子，矩形 盒模型、盒子模型、框模型（box model） <font style=\"color:#FF0000;\">css将页面中所有元素都设置为一个矩形的盒子</font> -将元素设置为矩形的盒子后，对页面的布局就变成了不同的盒子摆放到不同的位置 -每一个盒子，都有以下几个部分组成 <font style=\"color:#FF0000;\">内容区(content) </font> <font style=\"color:#FF0000;\"> 内边距(padding)</font> <font style=\"color:#FF0000;\"> 边框(border) </font> <font style=\"color:#FF0000;\"> 外边距(margin) </font> <font style=\"color:#FF0000;\">决定位置</font> -<font style=\"color:#FF0000;\">盒子可见框的大小由内容区，内边距和边框共同决定</font> <font style=\"color:#FF0000;\">1:内容区(content) </font> <font style=\"color:#FF0000;\">元素中所有的子元素和文本内容都在内容区中排列</font> 使用<font style=\"color:#FF0000;\">width</font>来设置盒子内容区的<font style=\"color:#FF0000;\">宽度</font> 使用<font style=\"color:#FF0000;\">height</font>来设置盒子内容区的<font style=\"color:#FF0000;\">高度 </font> width和height只是设置的盒子内容区的大小，而不是盒子的整个大小， width: 300px; height: 300px; background-color: #bfa; /设置背景颜色/ <font style=\"color:#FF0000;\">2:边框（border）元素设置边框</font> 边框属于盒子边缘，边框里面属于盒子内部，出了边框都是盒子的外部 <font style=\"color:#FF0000;\">设置边框必须指定三个样式</font> <font style=\"color:#FF0000;\">*</font> <font style=\"color:#FF0000;\">border-width:边框的宽度 </font> <font style=\"color:#FF0000;\"> * border-color:边框颜色 </font> <font style=\"color:#FF0000;\"> * border-style:边框的样式</font> 边框的大小会影响整个盒子的大小 border-width: 10px; border-color: #ff0; border-style: dashed; padding: 10px; margin: 10px; 盒子边框 .box{ width: 300px; height: 200px; background-color: rgb(222, 255, 170);} <font style=\"color:#FF0000;\">设置边框</font> 大部分的浏览器中，边框的宽度和颜色都是有默认值，而<font style=\"color:#FF0000;\">边框的样式默认值都是none</font> 设置上2px,下4px,左边6px, 右边1px border-width: 2px 1px 4px 6px; 设置 上下4px 左右6px border-width: 4px 6px; 设置 上4px 左右6px 下2px border-width:4px 6px 2px; / border-color: #f00; / / border-style: dotted; / <font style=\"color:#FF0000;\">1:border-width 默认值一般是3px</font> 使用<font style=\"color:#FF0000;\">border-width可以分别指定四个边框的宽度</font> 如果在border-width指定了四个值，则四个值会分别设置给 上 右 下 左，按照顺时针的方向设置的 如果指定三个值，则三个值会分别设置给 上 左右 下 如果指定两个值，则两个值会分别设置给 上下 左右 如果指定一个值，则四边全都是该值 除了border-width，CSS中还提供了四个<font style=\"color:#FF0000;\">border-xxx-width</font>，xxx的值可能是<font style=\"color:#FF0000;\">top right bottom left</font> <font style=\"color:#FF0000;\">专门用来设置指定边的宽度</font> border-bottom-width:1px; border-bottom-style: dashed; border-bottom-color:#ccc; 四个值设置边框大小顺序上右下左 三个值设置边框的大小顺序上 左右 下 两个值设置边框的大小 上下 左右 <font style=\"color:#FF0000;\">2:border-color</font> <font style=\"color:#FF0000;\">设置边框的颜色 默认值是黑色</font> 和宽度一样，<font style=\"color:#FF0000;\">color也提供四个方向</font>的样式，可以分别指定颜色 <font style=\"color:#FF0000;\">border-xxx-color</font> <font style=\"color:#FF0000;\">3:border-style</font> <font style=\"color:#FF0000;\">设置边框的样式</font> 可选值： <font style=\"color:#FF0000;\"> * </font> <font style=\"color:#FF0000;\">none，默认值，没有边框</font> <font style=\"color:#FF0000;\"> * solid 实线</font> <font style=\"color:#FF0000;\"> double 双线</font> <font style=\"color:#FF0000;\"> dashed [dæʃt] 虚线</font> <font style=\"color:#FF0000;\"> * dotted ['dɔtid] 点状边框</font> style也可以分别指定四个边的边框样式，规则和width一致， 同时它也提供<font style=\"color:#FF0000;\">border-xxx-style</font>四个样式，来分别设置四个边 / <font style=\"color:#FF0000;\">统一设置 </font>/ <font style=\"color:#FF0000;\">border: 1px dotted #f00;</font> / 单独设置 / /* border-top:1px solid #ff0; border-left:1px solid #fc0; border-right:1px solid #f00; border-bottom:1px solid #cf0; */ border - 边框的<font style=\"color:#FF0000;\">简写样式</font>，通过它可以同时设置四个边框的样式，宽度，颜色 - 而且<font style=\"color:#FF0000;\">没有</font>任何的<font style=\"color:#FF0000;\">顺序要求</font> - border一指定就是同时指定四个边不能分别指定 border-top border-right border-bottom border-left <font style=\"color:#FF0000;\">可以单独设置四个边的样式</font>，规则和border一样，只不过它只对一个边生效 .box2{ width: 400px; padding: 10px 0; border-bottom: 1px solid #ccc; } 内边距（padding）： 内容区和边框之间的距离，它会影响到盒子的大小 （1）、分别给<font style=\"color:#FF0000;\">每边设置内边距</font> <font style=\"color:#FF0000;\">padding-top: ;</font> <font style=\"color:#FF0000;\"> padding-right: ;</font> <font style=\"color:#FF0000;\"> padding-bottom: ;</font> <font style=\"color:#FF0000;\"> padding-left: ;</font> （2）<font style=\"color:#FF0000;\">padding简写</font> padding后可以写多个值 4个值 3个值 2个值 1个值 <font style=\"color:#FF0000;\">规则跟之前讲的border-width是一样</font> .box1 { width: 100px; height: 100px; background-color: #bfa; border: 10px solid orange; / 设置内边距 / /* padding-top:40px ; padding-right: 40px; padding-bottom: 40px; padding-left: 40px; */ padding:40px; / margin-bottom: 20px; / } 需求：创建一个子元素box2占满box1，box2把内容区撑满了 .box2{ width: 100%; height: 100%; background-color: red; } 外边距 <font style=\"color:#FF0000;\">外边距指的是当前盒子与其他盒子之间的距离</font>， <font style=\"color:#FF0000;\">他不会影响可见框的大小，而是会影响到盒子的位置。</font> 盒子有四个方向的外边距： <font style=\"color:#FF0000;\">margin-top</font> <font style=\"color:#FF0000;\">上外边距</font>，设置一个正值，元素会向下移动 <font style=\"color:#FF0000;\">margin-right</font> <font style=\"color:#FF0000;\">默认情况下</font>设置margin-right<font style=\"color:#FF0000;\">不会产生任何效果</font> <font style=\"color:#FF0000;\">margin-bottom</font> <font style=\"color:#FF0000;\">下外边距</font>，设置一个正值，其下边的元素会向下移动，<font style=\"color:#FF0000;\">挤别人</font> <font style=\"color:#FF0000;\">margin-left</font> <font style=\"color:#FF0000;\">左外边距</font>，设置一个正值，元素会向右移动 由于页面中的元素都是靠左靠上摆放的， 所以当我们设置<font style=\"color:#FF0000;\">上和左</font>外边距时，会导致盒子<font style=\"color:#FF0000;\">自身的位置发生改变</font>， 而如果是设置<font style=\"color:#FF0000;\">右和下</font>外边距会<font style=\"color:#FF0000;\">改变其他盒子的位置（挤别人）</font> 外边距也可以指定为一个<font style=\"color:#FF0000;\">负值</font>，如果外边距设置的是负值，则元素会向<font style=\"color:#FF0000;\">反方向移动</font> 外边距同样可以使用<font style=\"color:#FF0000;\">简写</font>属性 margin，可以同时设置四个方向的外边距,<font style=\"color:#FF0000;\">规则和padding一样</font> 元素的水平方向的布局 元素的水平方向的布局 元素在其父元素中<font style=\"color:#FF0000;\">水平方向的位置</font>由以下几个属性共同<font style=\"color:#FF0000;\">决定</font> <font style=\"color:#FF0000;\">margin-left border-left padding-left width padding-right border-right margin-right</font> <font style=\"color:#FF0000;\">一个元素在其父元素中</font>，水平布局必须要满足以下的等式 margin-left + border-left + padding-left + width + padding-right + border-right + margin-right =父元素内容区的宽度（<font style=\"color:#FF0000;\">必须满足</font>） 举例：子元素 inner七个元素的值如下 0 +0 + 0+ 200 + 0 + 0 + 0 =600 ？？不成立 以上等式必须满足，如果相加结果等式不成立，则称为过度约束，则浏览器会让等式自动调整 -调整的情况 1:如果七个值中<font style=\"color:#FF0000;\">没有auto</font>情况，则<font style=\"color:#FF0000;\">浏览器会调整margin-right值</font>以使等式满足 0 +0 + 0+ 200 + 0 + 0 + 400 =600 2:这7个值中<font style=\"color:#FF0000;\">width，margin-left，margin-right，这三个值可以设置auto</font> 如果<font style=\"color:#FF0000;\">有设置auto</font>，则<font style=\"color:#FF0000;\">浏览器会自动调整auto的值</font>，以使等式成立 0 +0 + 0+ auto + 0 + 0 + 0 =600 auto=600 0 +0 + 0+ auto + 0 + 0 + 200 =600 auto=400 3:如果将一个宽度和一个外边距设置为auto，则宽度会调整到最大 4:如果三个值都是auto，也只会调整宽度 5:如果将两个外边距设为auto，宽度固定，则两侧外边距会设置为相同的值 会使元素自动在父元素中居中，所以我们经常将左右外边距设置为auto / <font style=\"color:#FF0000;\">有宽先调宽，宽固定，再调两边</font> / .inner { width: 200px; <font style=\"color:#0000FF;\">margin:0 auto; </font> height: 200px; background-color: sandybrown; } <style> .outer { background-color: sandybrown; / height: 400px; / } .inner { width: 100px; height: 100px; background-color: yellowgreen; margin-bottom: 100px; } /* <font style=\"color:#FF0000;\">默认情况下，父元素的高度是被子元素撑开的，</font> <font style=\"color:#FF0000;\"> 若父元素设置了，就是设置多少就是多少</font> */ .box1 { width: 700px; / white-space: nowrap; / height: 100px; background-color: #bfa; overflow:auto; } 子元素是在父元素的内容区中排列的，如果子元素的大小超过了父元素，则子元素会从父元素中溢出 使用<font style=\"color:#FF0000;\">overflow</font>属性<font style=\"color:#FF0000;\">设置父元素如何处理溢出的子元素</font> 可选值： <font style=\"color:#FF0000;\"> visible 默认值</font> 子元素会从父元素中溢出，<font style=\"color:#FF0000;\">在父元素外部的位置显示</font> <font style=\"color:#FF0000;\"> hidden</font> <font style=\"color:#FF0000;\">溢出</font>的内容将会被裁剪<font style=\"color:#FF0000;\">不会显示</font> <font style=\"color:#FF0000;\">scroll</font> <font style=\"color:#FF0000;\">生成两个滚动条</font>，通过滚动条来查看完整的内容 <font style=\"color:#FF0000;\">auto </font> <font style=\"color:#FF0000;\">根据需要生成滚动条</font> 额外两个属性，了解一下 <font style=\"color:#FF0000;\">overflow-x 生横轴时注意换行</font> <font style=\"color:#FF0000;\"> overflow-y</font> </style> </head> <body> <!-- <div class=\"outer\"> <div class=\"inner\"></div> <div class=\"inner\"></div> </div> --> <div class=\"box1\"> </div> </body> 外边距的重叠 <style type=\"text/css\"> .box1 { width: 100px; height: 100px; background-color: red; 为上边的元素设置一个下外边距 <font style=\"color:#FF0000;\">margin-bottom:10px;</font> } .box2 { width: 100px; height: 100px; background-color: green; 为下边的元素设置一个上外边距 <font style=\"color:#FF0000;\">margin-top: -10px;</font> } <font style=\"color:#FF0000;\">垂直外边距的重叠</font> - 在网页中相邻的垂直方向的外边距，会发生外边距的重叠 -<font style=\"color:#FF0000;\">兄弟元素</font> 兄弟元素之间的<font style=\"color:#FF0000;\">相邻外边距会取最大值</font>而不是取和，<font style=\"color:#FF0000;\">谁大听谁的</font> 特殊情况：如果相邻的外边距<font style=\"color:#FF0000;\">一正一负</font>，则<font style=\"color:#FF0000;\">取两者的和</font> 如果相邻的外边距<font style=\"color:#FF0000;\">都是负值</font>，则<font style=\"color:#FF0000;\">取绝对值较大</font>的 兄弟元素的外边距重叠，对开发有利，不用处理 需求：将子元素移动到父元素的左下角 <font style=\"color:#FF0000;\">-父子元素</font> <font style=\"color:#FF0000;\">如果父子元素的垂直外边距相邻了，则子元素的外边距会传递给父元素</font> <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\">暂时解决方案：</font> <font style=\"color:#FF0000;\">1:不用外边距 </font> <font style=\"color:#FF0000;\"> 2:使不相邻</font> <font style=\"color:#FF0000;\"> transparent透明</font> 当父元素没有内边距（padding）、边框（border）或者内容将其与子元素分隔开时，子元素的外边距会与父元素的外边距发生塌陷。 .outer { width: 200px; / height: 200px; / height: 200px; background-color: yellow; / <font style=\"color:#FF0000;\">overflow: hidden;</font> / /<font style=\"color:#FF0000;\">改变padding的时候同时改变盒子的高度 </font>/ /<font style=\"color:#FF0000;\"> padding-top:100px; </font>/ /<font style=\"color:#FF0000;\"> border: 1px solid transparent; </font>/ / <font style=\"color:#FF0000;\">开启元素的隐含属性 overflow，BFC </font>/ / BFC（Block Formatting Context，块格式化上下文） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 / / <font style=\"color:#FF0000;\">BFC简单理解子元素不会影响到其他元素</font> / / overflow: hidden; / / margin-top: 100px; / <font style=\"color:#FF0000;\">方案1:用padding ，改父元素高度</font> /* padding-top: 100px; height: 100px; */ <font style=\"color:#FF0000;\">方案2:为outer设置一个上边框</font> <font style=\"color:#FF0000;\">会改变盒子的大小，有个1px的边框 transparent</font> / border: 1px solid transparent; / 添加边框（border） 原理：通过给父元素添加边框，可以将父元素和子元素在视觉上和布局逻辑上分隔开，阻止外边距的塌陷。 <font style=\"color:#FF0000;\">给父元素添加了一个透明的边框</font>（border: 1px solid transparent），这样就防止了子元素的上外边距使父元素一起向下移动。边框的宽度和样式可以根据实际设计需求进行调整。 添加内边距（padding） 原理：内边距在父元素内部创造了一个空间，使得子元素的外边距不会直接与父元素的外边距相互影响，从而避免塌陷。 <font style=\"color:#FF0000;\">这里给父元素添加了 1px 的上内边距</font><font style=\"color:#222222;\">（</font><font style=\"color:#222222;\">padding - top: 1px</font><font style=\"color:#222222;\">），这就有效地分隔了父元素和子元素的外边距，解决了塌陷问题。内边距的大小可以根据具体情况进行调整，不过要注意它会影响元素内部的空间布局。</font> 触发块格式化上下文（BFC） 原理：<font style=\"color:#FF0000;\">BFC </font>是 CSS 中的一个概念，它是一个<font style=\"color:#FF0000;\">独立的布局环境</font>，其中的<font style=\"color:#FF0000;\">元素布局不会影响到外面的元素，也不会被外面的元素所影响</font>。通过触发父元素的 BFC，可以避免外边距塌陷。 <font style=\"color:#FF0000;\">给父元素设置了overflow: auto，</font>这就触发了父元素的 BFC，使得子元素的外边距不会与父元素的外边距塌陷。除了auto，<font style=\"color:#FF0000;\">overflow:hidden</font>等其他非visible的值<font style=\"color:#FF0000;\">也可以</font><font style=\"color:#FF0000;\">触发 BFC。</font> 行内元素的盒模型 从这几点分析：内容区、内边距 、边框 、外边距 <font style=\"color:#FF0000;\">行内元素的盒模型</font> <font style=\"color:#FF0000;\">1: 不能设置width和height，被内容撑开</font> 2: 可以设置padding，但<font style=\"color:#FF0000;\">垂直方向padding不会影响页面的布局</font>，不会挤别人 3: 可以设置边框，但是<font style=\"color:#FF0000;\">垂直的边框不会影响到页面的布局</font>，不会挤别人 4: 可以设置水平方向的外边距，<font style=\"color:#FF0000;\">水平方向的相邻外边距不会重叠，而是求和</font>，但<font style=\"color:#FF0000;\">不支持垂直外边距</font> / 需求：给超链接设置一个大小100px的大小宽高 / a{ width: 100px; height: 100px; <font style=\"color:#FF0000;\">display: block;</font> background-color: #f60; } / 鼠标放上去我的超链接盒子消失 / .a1:hover{ /<font style=\"color:#FF0000;\"> display:none 不占空间</font> / / display: none; / /<font style=\"color:#FF0000;\">占空间 </font> / <font style=\"color:#FF0000;\">visibility: hidden;</font> } <font style=\"color:#FF0000;\">display </font>用来<font style=\"color:#FF0000;\">设置元素显示的类型</font> 可选值： <font style=\"color:#FF0000;\">inline</font> 将元素设置为<font style=\"color:#FF0000;\">行内</font>元素 <font style=\"color:#FF0000;\">block </font> 将元素设置为<font style=\"color:#FF0000;\">块</font>元素 <font style=\"color:#FF0000;\">inline-block</font> <font style=\"color:#FF0000;\">行内块</font>元素（即<font style=\"color:#FF0000;\">可以设置宽高，又不会独占一行</font>） <font style=\"color:#FF0000;\">table</font> 将元素设置为一个<font style=\"color:#FF0000;\">表格</font> <font style=\"color:#FF0000;\">none</font> 元素<font style=\"color:#FF0000;\">不在页面中显示</font>（<font style=\"color:#FF0000;\">隐藏</font>一个元素） <font style=\"color:#FF0000;\">visibility </font>用来<font style=\"color:#FF0000;\">设置元素的显示状态</font> 可选值： <font style=\"color:#FF0000;\">visible 默认值</font> 元素在页面中<font style=\"color:#FF0000;\">正常显示</font> <font style=\"color:#FF0000;\">hidden </font> 元素不在页面中显示（<font style=\"color:#FF0000;\">隐藏</font>一个元素），<font style=\"color:#FF0000;\">位置依然保留</font> 重置样式表 <!-- 重置样式表，专门用来对浏览器的样式进行重置 --> <font style=\"color:#FF0000;\">默认样式：</font> 浏览器为了在页面中没有样式时，也可以有一个比较好的显示效果， <font style=\"color:#222222;\">原因</font><font style=\"color:#222222;\">：</font>浏览器为很多元素设置了默认的margin和padding，在编写样式时通常不需要这些默认样式，所以需要进行重置。 方式一： <font style=\"color:#FF0000;\"> 1:清除浏览器的默认样式</font> <font style=\"color:#FF0000;\">*{</font> <font style=\"color:#FF0000;\"> margin:0;</font> <font style=\"color:#FF0000;\"> padding: 0;</font> <font style=\"color:#FF0000;\"> list-style: none;</font> <font style=\"color:#FF0000;\"> } </font> 方式二： <font style=\"color:#FF0000;\">2:引入重置样式表 */</font> 盒子大小 默认情况下：盒子可见宽的大小由内容区，内边距，边框共同决定 <font style=\"color:#FF0000;\">box-sizing</font> 用来<font style=\"color:#FF0000;\">设置盒子尺寸的计算方式 width/height 指的是谁</font> 可选值： <font style=\"color:#FF0000;\">content-box 内容区 默认值</font> <font style=\"color:#FF0000;\">border-box 宽度和高度用来设置整个盒子可见框的大小，包括边框，padding，内容区</font> //内减，可见框大小不变 阴影和圆角 知识点1: <font style=\"color:#FF0000;\">box-shadow</font> 用来<font style=\"color:#FF0000;\">设置元素的阴影效果</font>，<font style=\"color:#FF0000;\">不会影响到页面布局</font> 第一个值：<font style=\"color:#FF0000;\">水平</font>偏移量 正->左 负->右 第二个值：<font style=\"color:#FF0000;\">垂直</font>偏移量 正->下 负->上 第三个值：<font style=\"color:#FF0000;\">模糊半径</font> 第四个值：<font style=\"color:#FF0000;\">颜色</font> <font style=\"color:#9CDCFE;\">box-shadow</font><font style=\"color:#D4D4D4;\">: </font><font style=\"color:#B5CEA8;\">-4px</font><font style=\"color:#D4D4D4;\"> </font><font style=\"color:#B5CEA8;\">6px</font><font style=\"color:#D4D4D4;\"> </font><font style=\"color:#B5CEA8;\">30px</font><font style=\"color:#D4D4D4;\"> </font><font style=\"color:#DCDCAA;\">rgba</font><font style=\"color:#D4D4D4;\">(</font><font style=\"color:#B5CEA8;\">0</font><font style=\"color:#D4D4D4;\">, </font><font style=\"color:#B5CEA8;\">0</font><font style=\"color:#D4D4D4;\">, </font><font style=\"color:#B5CEA8;\">0</font><font style=\"color:#D4D4D4;\">, </font><font style=\"color:#B5CEA8;\">.5</font><font style=\"color:#D4D4D4;\">);</font> <font style=\"color:#FF0000;\"> 知识点</font>2: <font style=\"color:#FF0000;\">border-radius 用来设置圆角</font> 以10px为半径画圆 <font style=\"color:#FF0000;\">borde-top-right-radius</font> <font style=\"color:#FF0000;\"> border-top-left-radius</font> <font style=\"color:#FF0000;\"> border-bottom-left-radius</font> <font style=\"color:#FF0000;\"> border-bottom-right-radius</font> <font style=\"color:#FF0000;\"> border-radius: 50%; //画圆，再大也是圆</font> / border-radius: 10px; / /* border-top-left-radius:30px; border-top-right-radius:30px; border-bottom-left-radius:40px; border-bottom-right-radius:40px; */ / 圆 / border-radius:50%; 浮动 块元素在文档流中默认垂直排列，所以这个三个div自上至下依次排开，如果希望块元素在页面中水平排列，可以使块元素脱离文档流 使用<font style=\"color:#FF0000;\">float</font>来<font style=\"color:#FF0000;\">使元素浮动</font>，使一个元素向其父元素的左侧或右侧移动，从而<font style=\"color:#FF0000;\">脱离文档流</font> 可选值： <font style=\"color:#FF0000;\">none，默认值，元素默认在文档流中排列</font> <font style=\"color:#FF0000;\"> left，，向页面的左侧浮动</font> <font style=\"color:#FF0000;\"> right，向页面的右侧浮动</font> 浮动的特点 1:浮动元素会脱离文档流，元素<font style=\"color:#FF0000;\">脱离文档流</font>以后，不会再占用文档流的位置，它<font style=\"color:#FF0000;\">下边的元素会立即向上移动</font> 2:元素浮动以后，元素会尽量向页面的左上或页面右上漂浮 3:<font style=\"color:#FF0000;\">浮动元素默认不会从父元素中移出</font> 4:浮动的元素<font style=\"color:#FF0000;\">不会超过他上边的兄弟元素，最多最多一边齐</font> 5:如果浮动元素的<font style=\"color:#FF0000;\">上边是一个没有浮动的块元素，则浮动元素无法上移</font> 总结： 浮动目前来讲它的主要作用就是让页面中的元素可以水平排列 <font style=\"color:#FF0000;\">通过浮动可以制作一些水平方向的布局</font> 浮动特点 特点1: 浮动的元素不会盖住文字，<font style=\"color:#FF0000;\">文字会自动环绕在浮动元素的周围</font>，所以我们可以通过浮动来<font style=\"color:#FF0000;\">设置文字环绕图片</font>的效果 特点2: 当元素设置浮动以后，会<font style=\"color:#FF0000;\">完全脱离文档流</font>，<font style=\"color:#FF0000;\">元素</font>的<font style=\"color:#FF0000;\">一些特点</font>也会发生<font style=\"color:#FF0000;\">改变</font> <font style=\"color:#FF0000;\">脱离文档流的特点</font> <font style=\"color:#FF0000;\">块元素：</font> 1:块元素<font style=\"color:#FF0000;\">不</font>再<font style=\"color:#FF0000;\">独占</font>页面的<font style=\"color:#FF0000;\">一行</font> 2:块元素的<font style=\"color:#FF0000;\">宽高被内容撑开</font> <font style=\"color:#FF0000;\">行内元素：</font> 1:浮动过后的行内元素<font style=\"color:#FF0000;\">更像行内块元素</font>,因为<font style=\"color:#FF0000;\">一行可以显示多个</font>，并且<font style=\"color:#FF0000;\">默认宽度为内容的宽度</font> 总结：当元素设置浮动以后,<font style=\"color:#FF0000;\">脱离文档流，就不需要再区分块和行内</font> 导航条 <title>w3导航条</title> <style> *{ margin:0; padding: 0; list-style: none; } a{ / 去除下划线 / text-decoration: none; color: #777; / 把a标签变成行内块元素 / display: inline-block; padding:20px; } .nav{ width: 1000px; } .nav li{ float: left; background-color: #e8e7e3; } .nav li a:hover{ background-color:#3f3f3f; Color: #fff; } </style> </head> <body> <ul class=\"nav\"> <li> <a href=\"#\">HTML/CSS</a> </li> <li> <a href=\"#\">Browser Side</a> </li> </ul> 高度塌陷 在文档流中，父元素的高度默认是被子元素撑开的， 也就是子元素多高，父元素就多高。 但是当为子元素设置浮动以后，子元素会完全脱离文档流， 此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。 由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。 <font style=\"color:#FF0000;\">高度塌陷解决方案一</font> 所以在开发中一定要避免出现高度塌陷的问题, 我们可以<font style=\"color:#FF0000;\">将父元素的高度写死</font>，以避免塌陷的问题出现， 但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是<font style=\"color:#FF0000;\">不推荐</font>使用的。 <font style=\"color:#FF0000;\">高度塌陷解决方案二：</font> 页面元素中的隐含属性：Block Formatting Context 即<font style=\"color:#FF0000;\">块格式化上下文</font>，简称<font style=\"color:#FF0000;\">BFC</font> 当开启元素的BFC以后，元素会变成一个<font style=\"color:#FF0000;\">独立的布局区域</font>，<font style=\"color:#FF0000;\">不会在布局上影响到外面的元素</font> BFC 理解为一个封闭的大箱子，箱子内部的元素不会影响到外部。 开启BFC后，元素将会具有如下的特性： <font style=\"color:#FF0000;\">1.父元素的垂直外边距不会和子元素重叠 </font> <font style=\"color:#FF0000;\">2.开启BFC的元素不会被浮动元素所覆盖</font> <font style=\"color:#FF0000;\">3.开启BFC的元素可以包含浮动的子元素（可解决高度塌陷）</font> 如何开启元素的BFC 1.设置元素浮动（不推荐） 使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失 而且使用这种方式也会导致下边的元素上移，不能解决问题 2.设置元素为inline-block（不推荐） 可以解决问题，但是会导致宽度丢失，不推荐使用这种方式 <font style=\"color:#FF0000;\"> 3.将元素的overflow设置为一个非visible的值 </font> 4.设置元素绝对定位(暂时没学习) 元素也会脱离文档流，虽然可以撑开父元素，但是会导致父元素的宽度丢失 而且使用这种方式也会导致下边的元素上移，不能解决问题 推荐方式：<font style=\"color:#FF0000;\">将overflow设置为hidden是副作用最小的开启BFC的方式。</font> 由于受到box1浮动的影响，box2整体向上移动了100px 我们有时希望<font style=\"color:#FF0000;\">清除掉其他元素浮动对当前元素产生的影响</font>，这时可以<font style=\"color:#FF0000;\">使用clear来完成功能</font> <font style=\"color:#FF0000;\">clear可以用来清除其他浮动元素对当前元素的影响</font> 可选值： <font style=\"color:#FF0000;\">none，默认值，不清除浮动</font> <font style=\"color:#FF0000;\"> left，清除左侧浮动元素对当前元素的影响</font> <font style=\"color:#FF0000;\"> right，清除右侧浮动元素对当前元素的影响</font> <font style=\"color:#FF0000;\"> both，清除两侧浮动元素对当前元素的影响</font> <font style=\"color:#FF0000;\"> 清除对他影响最大的那个元素的浮动</font> 原理： <font style=\"color:#FF0000;\">设置了 clear 的元素，通过调整自身来使自己不要和浮动元素排列在一起。</font> <font style=\"color:#FF0000;\">类似于给自己加个margin-top</font> <font style=\"color:#FF0000;\">解决高度塌陷方案三：</font> 可以直接在高度塌陷的<font style=\"color:#FF0000;\">父元素</font>的<font style=\"color:#FF0000;\">最后</font>，添<font style=\"color:#FF0000;\">加一个空白的div</font>，由于这个div并没有浮动，所以他是可以撑开父元素的高度的，然后在对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用 使用这种方式虽然可以解决问题，但是会在页面中添加多余的结构。 <font style=\"color:#FF0000;\">通过after伪类，选中box1的后边</font> 可以通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动，这样做和添加一个div的原理一样，可以达到一个相同的效果，且不会在页面中添加多余的div，这是我们最推荐使用的方式，几乎没有副作用 <font style=\"color:#FF0000;\">解决高度塌陷方案三：</font> <font style=\"color:#FF0000;\">.box1::after{</font> <font style=\"color:#FF0000;\"> / 空内容 /</font> <font style=\"color:#FF0000;\"> content: \"\";</font> <font style=\"color:#FF0000;\"> / 块元素 /</font> <font style=\"color:#FF0000;\"> display: block;</font> <font style=\"color:#FF0000;\"> / 清除浮动 /</font> <font style=\"color:#FF0000;\"> clear: both;</font> <font style=\"color:#FF0000;\"> }</font> 表格 表格在日常生活中使用的非常的多，比如excel就是专门用来创建表格的工具，表格就是用来表示一些格式化的数据的，比如：课程表、银行对账单 在网页中也可以来创建出不同的表格。 <!-- <font style=\"color:#FF0000;\">html表格的书写</font> --> <table border=\"1\" width=\"50%\" align=\"center\"> <!-- <font style=\"color:#FF0000;\">tr表示行，td表示列，有几个tr就有几列</font> --> <tr> <font style=\"color:#FF0000;\"><!-- colspan 合并列--></font>合并同一行中的多个列 <td colspan=\"2\">1</td> <!-- <td>2</td> --> <td>3</td> </tr> <tr> <td>1</td> <td>2</td> <font style=\"color:#FF0000;\"><!-- rowspan合并行--></font>合并同一列中的多个行 <td rowspan=\"2\">3</td> </tr> <tr> <td>1</td> <td>2</td> <!-- <td>3</td> --> </tr> </table> </body> </html> 表格样式 <style type=\"text/css\"> /设置表格的宽度 / table{ width: 300px; /居中/ margin:0 auto; /边框/ border: 1px solid #000; /* <font style=\"color:#FF0000;\">table和td边框之间默认有一个距离</font> <font style=\"color:#FF0000;\">通过border-spacing属性可以设置这个距离</font> */ <font style=\"color:#FF0000;\">设置表格的边框</font>，<font style=\"color:#FF0000;\">要</font><font style=\"color:#4874CB;\">单线边框</font> <font style=\"color:#FF0000;\">方法一 </font> <font style=\"color:#FF0000;\">border-spacing:0;</font> <font style=\"color:#FF0000;\">方法二</font> <font style=\"color:#FF0000;\">border-collapse [kə'læps] 可以用来设置表格的边框合并</font> <font style=\"color:#FF0000;\">如果设置了边框合并，则border-spacing自动失效</font> */ border-collapse: collapse; <font style=\"color:#FF0000;\">/需求二：设置背景色样式/</font> background-color: skyblue; } /* 设置边框 */ th,td{ border: 1px solid #000; } <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\"> 需求三： 设置隔行变色*/</font> <font style=\"color:#FF0000;\">tr:nth-child(even){</font> <font style=\"color:#FF0000;\"> background-color: yellowgreen;</font> <font style=\"color:#FF0000;\"> }</font> <font style=\"color:#FF0000;\">需求四：鼠标移入到tr以后，改变颜色</font> */ tr:hover{ background-color: palegreen; } <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\"> </font> 需求五：<font style=\"color:#FF0000;\">调整td文字在表格中的位置</font> <font style=\"color:#FF0000;\">vertical-align:可选值：top,bottom,middle </font> <font style=\"color:#FF0000;\"> text-align；可选值：left，center，right</font> td{ height: 50px; text-align:center; vertical-align: middle; } </style> </head> <body> <!-- <font style=\"color:#FF0000;\">table是一个块元素</font> 学号 姓名 性别 住址 1 孙悟空 男 花果山 2 猪八戒 男 高老庄 3 沙和尚 男 流沙河 4 唐僧 男 女儿国 <font style=\"color:#FF0000;\">可以使用th标签来表示表头中的内容，它的用法和td一样，不同的是它会有一些默认效果，如加粗</font> <table> <tr> <th>学号</th> <th>姓名</th> <th>性别</th> <th>住址</th> </tr> ...... </table> </body> </html> 长表格 <table> 有一些情况下表格是非常的长的，这时就需要将<font style=\"color:#FF0000;\">表格分为三个部分</font>，<font style=\"color:#FF0000;\">表头，表格的主体，表格底部</font> 在HTML中为我们提供了三个标签： <font style=\"color:#FF0000;\"> thead 表头</font> <font style=\"color:#FF0000;\"> tbody 表格主体</font> <font style=\"color:#FF0000;\"> tfoot 表格底部</font> 这三个标签的作用，就来区分表格的不同的部分，他们<font style=\"color:#FF0000;\">都是table的子标签</font>， 都需要直接写到table中，tr需要写在这些标签当中 <font style=\"color:#FF0000;\">thead中的内容，永远会显示在表格的头部</font> <font style=\"color:#FF0000;\"> tfoot中的内容，永远都会显示表格的底部</font> <font style=\"color:#FF0000;\"> tbody中的内容，永远都会显示表格的中间</font> 如果表格中没有写tbody，浏览器会自动在表格中添加tbody，并且将所有的tr都放到tbody中，所以注意<font style=\"color:#FF0000;\">tr并不是table的子元素，而是tbody的子元素</font> <font style=\"color:#FF0000;\">通过table > tr 无法选中行 需要通过tbody > tr</font> <!-- 需求：表头：日期 收入 支出 合计 12.2 200 10 180 12.2 200 10 180 .... 总计：180 <font style=\"color:#FF0000;\"><thead></font> <tr> <td>日期</td> <td>收入</td> <td>支出</td> <td>合计</td> </tr> <font style=\"color:#FF0000;\"> </thead></font> <font style=\"color:#FF0000;\"><tfoot></font> <tr> <td></td> <td></td> <td>合计：</td> <td>70000</td> </tr> <font style=\"color:#FF0000;\"></tfoot></font> <font style=\"color:#FF0000;\"> <tbody></font> <tr> <td>12.3</td> <td>10000</td> <td>500</td> <td>9500</td> </tr> ...... <font style=\"color:#FF0000;\"> </tbody></font> </table> </body> </html> 父子外边距重叠 .box1{ width: 300px; height: 300px; background-color: #bfa; <font style=\"color:#FF0000;\">父子外边距重叠解决一</font> / <font style=\"color:#FF0000;\">overflow: hidden;</font> / } .box2{ width: 200px; height: 200px; background-color: yellow; margin-top: 100px; } 子元素和父元素相邻的<font style=\"color:#FF0000;\">垂直外边距会发生重叠</font>，<font style=\"color:#FF0000;\">子元素的外边距会传递给父元素</font> 使用<font style=\"color:#FF0000;\">空的table标签</font>可以隔离父子元素的外边距，<font style=\"color:#FF0000;\">阻止外边距的重叠</font> <font style=\"color:#FF0000;\"> 解决父子元素的外边距重叠方法二</font> 添加伪类box1 before <font style=\"color:#FF0000;\">display:table可以将一个元素设置为表格显示</font> <font style=\"color:#FF0000;\">.box1::before{</font> <font style=\"color:#FF0000;\"> content: \" \";</font> <font style=\"color:#FF0000;\"> display:table;</font> <font style=\"color:#FF0000;\"> }</font> / 演示高度塌陷 / .box3{ border: 10px red solid; } .box4{ width: 100px; height: 100px; background-color: yellowgreen; float: left; } <font style=\"color:#FF0000;\">解决父元素高度塌陷(转化成块元素，清除浮动)</font> <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\"> .clearfix::after{</font> <font style=\"color:#FF0000;\"> content: \" \";</font> <font style=\"color:#FF0000;\"> display: block;</font> <font style=\"color:#FF0000;\"> clear: both;</font> <font style=\"color:#FF0000;\"> }</font> 经过修改后的<font style=\"color:#FF0000;\">clearfix</font>是一个多功能的，<font style=\"color:#FF0000;\">既可以解决高度塌陷，又可以确保父元素和子元素的垂直外边距不会重叠（之前之后的）</font> <font style=\"color:#FF0000;\">.clearfix::before,</font> <font style=\"color:#FF0000;\"> .clearfix::after{</font> <font style=\"color:#FF0000;\"> content: \" \";</font> <font style=\"color:#FF0000;\"> display: table;</font> <font style=\"color:#FF0000;\"> clear: both;</font> <font style=\"color:#FF0000;\"> }</font> </style> </head> <body> <div class=\"box3 clearfix\"> <div class=\"box4\"></div> </div> <!-- <div class=\"box1\"> <div class=\"box2\"></div> </div> --> </body> </html> 表单 <body> <font style=\"color:#FF0000;\">表单：</font> <font style=\"color:#FF0000;\"> 将用户信息等本地的数据信息提交给服务器的</font> 比如：百度的搜索框 注册 登录这些操作都需要填写表单 <font style=\"color:#FF0000;\">1:创建表单 form标签</font> <font style=\"color:#FF0000;\">属性：action属性（必须要写）</font> 指向的是一个服务器的地址，当我们提交表单时将会提交到action属性对应的地址 <font style=\"color:#FF0000;\">//表单提交给服务器的位置 </font> <font style=\"color:#FF0000;\"><form action=\"./target.html\"></font> <font style=\"color:#FF0000;\">2:添加表单项 </font>input 使用form创建的仅仅是一个空白的表单，我们还需要向form中添加不同的表单项 <font style=\"color:#FF0000;\">（1）input来创建一个文本框，</font> <font style=\"color:#FF0000;\">type属性是text</font> <font style=\"color:#FF0000;\">name属性：提交内容的名字</font> <font style=\"color:#FF0000;\">如果</font>希望表单项中的<font style=\"color:#FF0000;\">数据会提交到服务器</font>中，<font style=\"color:#FF0000;\">必须指定一个name属性 </font> <font style=\"color:#FF0000;\">value属性值：作为文本框的默认值显示 </font> 用户名 <input type=\"text\" name=\"username\" id=\"user\" value=\"\"> <br> <br> <font style=\"color:#FF0000;\">（2）input创建一个密码框</font> <font style=\"color:#FF0000;\">type属性值是password</font> <font style=\"color:#FF0000;\"> name属性：提交密码的名字</font> 密码 <input type=\"password\" name=\"password\" id=\"\"> <br> <br> <font style=\"color:#FF0000;\">（3）input创建一个单选按钮</font> <font style=\"color:#FF0000;\">- type属性：radio</font> <font style=\"color:#FF0000;\">- name属性进行分组</font>，<font style=\"color:#FF0000;\">属性相同是一组按钮，如果不设置，则都可以选择</font> <font style=\"color:#FF0000;\">- </font><font style=\"color:#30C0B4;\">value</font><font style=\"color:#FF0000;\">属性</font><font style=\"color:#30C0B4;\">必须设置</font><font style=\"color:#FF0000;\">，这样被选中的表单项的value属性值将</font><font style=\"color:#30C0B4;\">会最终提交给服务器 </font> <font style=\"color:#FF0000;\">-checked=\"checked\"属性 默认选中</font> 性别 <input type=\"radio\" name=\"gender\" value=\"man\">男 <input type=\"radio\" name=\"gender\" value=\"woman\" checked=\"checked\">女 <br> <br> <font style=\"color:#FF0000;\">（4）input创建一个多选框</font> <font style=\"color:#FF0000;\">-type属性:checkbox</font> <font style=\"color:#FF0000;\">-checked=\"checked\"属性 默认选中</font> 爱好 <input type=\"checkbox\" name=\"hobby\" value=\"1\">篮球 <input type=\"checkbox\" name=\"hobby\" value=\"2\" checked=\"checked\">跳舞 <input type=\"checkbox\" name=\"hobby\" value=\"3\" checked=\"checked\">唱歌 <input type=\"checkbox\" name=\"hobby\" value=\"4\">游戏 <br /><br /> <font style=\"color:#FF0000;\"> (5)select来创建一个下拉列表</font> <font style=\"color:#FF0000;\">-name属性设置给select，</font> <font style=\"color:#FF0000;\"> -value属性设置给option</font> <font style=\"color:#FF0000;\">-selected=\"selected\"，将选项设置为默认选中</font> 你喜欢的明星 <select name=\"star\" id=\"\"> <option value=\"1\">鹿晗</option> <option value=\"2\" selected=\"selected\">黄子韬</option> <option value=\"3\">丁真</option> </select> <br /><br /> <font style=\"color:#FF0000;\">（6）textarea创建一个文本域</font> 自我介绍 <input <font style=\"color:#FF0000;\">type=\"textarea\" </font>value=\"\" id=\"\" name=\"mark\"> <br /><br /> <font style=\"color:#FF0000;\">（7）input创建一个提交按钮，点击后表单就会提交</font> <font style=\"color:#FF0000;\">-type属性值：submit</font> <font style=\"color:#FF0000;\">-value属性：指定按钮上的文字</font> <input type=\"submit\" value=\"注册\"> <!-- <input type=\"submit\"> --> <font style=\"color:#FF0000;\">（8）创建一个重置按钮，type=\"reset\" </font> <font style=\"color:#FF0000;\">点击重置按钮以后表单中内容将会恢复为默认值</font> <input type=\"reset\" > <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\">（9）创建一个单纯的按钮，button</font> <font style=\"color:#FF0000;\"> 这个按钮没有任何功能，只能被点击</font> <input type=\"button\" value=\"点击\"> <font style=\"color:#FF0000;\">（10）button标签来创建按钮</font> <font style=\"color:#FF0000;\">方式和使用input类似，它是成对出现的标签，使用起来更加的灵活 </font> <br /><br /> <font style=\"color:#FF0000;\"><button type=\"submit\">提交</button></font> <button type=\"reset\">重置</button> <button type=\"button\">点击</button> </form> </body> </html> input属性补充 <font style=\"color:#FF0000;\">1: autocomplete=\"off\" 关闭自动补全</font> <font style=\"color:#FF0000;\"> 2: readonly 设置为只读，不能修改</font> <font style=\"color:#FF0000;\"> 3: disabled 设置为禁用</font> <font style=\"color:#FF0000;\"> 4: autofocus 自动获取焦点</font> <font style=\"color:#FF0000;\"> 5: placeholder 提示内容</font> <input type=\"text\" autocomplete=\"off\" autofocus name=\"username\" placeholder=\"请输入姓名\" value=\"\" /> 在 HTML <font style=\"color:#FF0000;\">表单中，value属性</font>非常重要。对于不同的表单元素，它有不同的用途。 文本框（input type=\"text\"）和密码框（input type=\"password\"）：value属性用于<font style=\"color:#FF0000;\">设置文本框或密码框的初始值</font>。例如，<input type=\"text\" value=\"初始文本\">，在页面加载时，文本框中就会显示 “初始文本”。用户可以对这个值进行修改，当表单提交时，提交的是用户修改后的值。 单选按钮（input type=\"radio\"）和复选框（input type=\"checkbox\"）：value属性用于<font style=\"color:#FF0000;\">定义当该选项被选中并提交表单时所传递的值</font>。比如对于单选按钮<input type=\"radio\" name=\"gender\" value=\"male\">男</input>和<input type=\"radio\" name=\"gender\" value=\"female\">女</input>，当用户选择 “男” 这个选项并提交表单时，传递给服务器的值就是 “male”。 下拉菜单（select）：<font style=\"color:#FF0000;\">在<select>标签内部的<option>标签中有value属性</font>。例如<select><option value=\"option1\">选项1</option><option value=\"option2\">选项2</option></select>，当用户选择 “选项 1” 并<font style=\"color:#FF0000;\">提交表单时，传递的值是 “option1”</font>。 Name <font style=\"color:#222222;\">表单元素方面</font><font style=\"color:#222222;\">：</font> <font style=\"color:#222222;\">文本框（input type=\"text\"）、密码框（input type=\"password\"）等</font><font style=\"color:#222222;\">：“name” 属性用于</font><font style=\"color:#FF0000;\">给这些输入框命名，以便在表单提交时，服务器能够通过这个名称准确识别接收到的是哪个输入框的值</font><font style=\"color:#222222;\">。例如：</font><font style=\"color:#222222;\"><input type=\"text\" name=\"username\"></font><font style=\"color:#222222;\">，这里的 “username” 就是给文本框设定的名称，当用户在该文本框输入内容并提交表单后，服务器端就可以根据 “username” 这个名称获取到用户输入的具体值。</font> <font style=\"color:#222222;\">单选按钮（input type=\"radio\"）和复选框（input type=\"checkbox\"）</font><font style=\"color:#222222;\">：对于单选按钮组和复选框组，</font><font style=\"color:#FF0000;\">相同组内的元素需要设置相同的 “name” 属性值，以确保它们在逻辑上是相互关联的一组选项。</font><font style=\"color:#222222;\">比如对于单选按钮选择性别：</font><font style=\"color:#222222;\"><input type=\"radio\" name=\"gender\" value=\"male\">男</input></font><font style=\"color:#222222;\"> </font><font style=\"color:#222222;\"><input type=\"radio\" name=\"gender\" value=\"female\">女</input></font><font style=\"color:#222222;\">这里 “gender” 就是这两个单选按钮共同的名称，保证了用户只能从 “男”“女” 中选择其一，并且在表单提交时，服务器能通过 “gender” 这个名称知道用户选择的性别对应的 “value” 值。</font> <font style=\"color:#222222;\">下拉菜单（select）</font><font style=\"color:#222222;\">：</font><font style=\"color:#FF0000;\">在下拉菜单中，“name” 属性同样用于给整个下拉菜单元素命名，以便在表单提交时能正确识别其选择的值。</font><font style=\"color:#222222;\">例如：</font><font style=\"color:#222222;\"><select name=\"country\"></font><font style=\"color:#222222;\"> </font><font style=\"color:#222222;\"><option value=\"china\">中国</option></font><font style=\"color:#222222;\"> </font><font style=\"color:#222222;\"><option value=\"usa\">美国</option></font><font style=\"color:#222222;\"> </font><font style=\"color:#222222;\"></select></font><font style=\"color:#222222;\">这里 “country” 就是下拉菜单的名称，当用户选择一个国家并提交表单后，服务器可依据 “country” 获取到对应的国家值（即所选选项的 “value” 值）。</font> <font style=\"color:#FF0000;\">Name相当于坐标，提交表单时，服务器可以精确找到，在通过value确定最终要上传哪个值。</font> 定位： 更加高级的布局手段 定位指的就是将指定的元素摆放到页面的任意位置 通过定位可以任意的摆放元素 通过<font style=\"color:#FF0000;\">position</font>属性来设置元素的定位 -可选值： <font style=\"color:#FF0000;\">static： ['stætik] 默认值，元素没有开启定位</font> <font style=\"color:#FF0000;\"> relative： ['relətiv] 开启元素的相对定位</font> <font style=\"color:#FF0000;\"> absolute： ['æbsəlju:t] 开启元素的绝对定位</font> <font style=\"color:#FF0000;\"> fixed：开启元素的固定定位（也是绝对定位的一种）</font> <font style=\"color:#FF0000;\"> sticky： ['stiki] 开启元素的粘滞定位</font> <font style=\"color:#FF0000;\">相对定位：</font> 当元素的position属性设置为relative时，则开启了元素的相对定位 ==》自恋型 1.当开启了元素的相对定位以后，而<font style=\"color:#FF0000;\">不设置偏移量时，元素不会发生任何变化</font> 2.相对定位是<font style=\"color:#FF0000;\">相对于</font>元素在文档流中<font style=\"color:#FF0000;\">原来的位置</font>进行定位（top:0;left:0;） 3.相对定位的元素<font style=\"color:#FF0000;\">不会脱离文档流</font> 4.相对定位会使元素<font style=\"color:#FF0000;\">提升一个层级</font> 5.相对定位<font style=\"color:#FF0000;\">不会改变元素的性质，块还是块，内联还是内联</font> <font style=\"color:#FF0000;\">偏移量</font> 当开启了元素的定位（position属性值是一个非static的值）时， 可以通过left right top bottom四个属性来设置元素的偏移量，越大越向反方向移动 <font style=\"color:#FF0000;\">left：元素相对于其定位位置的左侧偏移量，</font> <font style=\"color:#FF0000;\"> right：元素相对于其定位位置的右侧偏移量</font> <font style=\"color:#FF0000;\"> top：元素相对于其定位位置的上边的偏移量</font> <font style=\"color:#FF0000;\"> bottom：元素相对于其定位位置下边的偏移量</font> 通常偏移量只需要使用两个就可以对一个元素进行定位， 一般选择水平方向的一个偏移量和垂直方向的偏移量来为一个元素进行定位 --> 绝对定位 当position属性值设置为<font style=\"color:#FF0000;\">absolute</font>时，则开启了元素的绝对定位 <font style=\"color:#FF0000;\">绝对定位：</font> 1.开启绝对定位，会使<font style=\"color:#FF0000;\">元素脱离文档流</font> 2.开启绝对定位以后，如果<font style=\"color:#FF0000;\">不设置偏移量，则元素的位置不会发生变化</font> 3.绝对定位是<font style=\"color:#FF0000;\">相对于离他最近的包含块定位的</font> （一般情况，开启了子元素的绝对定位都会同时开启父元素的相对定位<font style=\"color:#FF0000;\"> '父相子绝'</font>） 4.绝对定位<font style=\"color:#FF0000;\">会使元素提升一个层级</font> 5.绝对定位<font style=\"color:#FF0000;\">会改变元素的性质，开启BFC属性</font> <font style=\"color:#FF0000;\"> 内联元素变成行内块元素，</font> <font style=\"color:#FF0000;\"> 块元素的宽度和高度默认都被内容撑开</font> <font style=\"color:#FF0000;\"> 包含块：containing block </font> <font style=\"color:#FF0000;\">-正常情况下：</font> <font style=\"color:#FF0000;\"> 离当前元素最近的祖先块元素</font> <font style=\"color:#FF0000;\">-定位情况下：</font> <font style=\"color:#FF0000;\"> 离他最近的开启了定位的祖先元素</font> <font style=\"color:#FF0000;\"> 如果所有的祖先元素都没有开启定位，则会相对于浏览器窗口进行定位</font> <font style=\"color:#FF0000;\"> html （根元素，初始包含块） </font> 固定定位 当元素的position属性设置<font style=\"color:#FF0000;\">fixed</font>时，则开启了元素的固定定位 （1）用于固定在浏览器页面上，<font style=\"color:#FF0000;\">不随浏览器的滚动而改变位置；</font> （2）<font style=\"color:#FF0000;\">以浏览器为参照物</font>，和父元素没有任何关系； （3）固定定位<font style=\"color:#FF0000;\">不占有原来的位置，即脱离标准流 </font> (4)应用场景 固定导航 固定侧边栏 广告 --> 粘滞定位 （一般用于页面导航的吸顶效果) -当元素的position属性设置为<font style=\"color:#FF0000;\">sticky</font>时，则开启了元素的粘滞定位 <font style=\"color:#FF0000;\">（1）以浏览器为参照物（体现固定定位特点）；</font> <font style=\"color:#FF0000;\"> （2）占有原来位置（体现相对定位特点）；</font> <font style=\"color:#FF0000;\"> （3）粘滞定位可以在元素到达某个位置时，将其固定 </font> <font style=\"color:#FF0000;\"> (4)没有达到top值之前正常显示，达到top值之后类似于固定定位，不会跟随滚动条滚动而滚动 </font> --> 水平布局 left+margin-left+border-left+padding-left+width+padding-right+border-right+margin-right+right -当<font style=\"color:#FF0000;\">开启决定定位</font>后，<font style=\"color:#FF0000;\">水平方向的布局等式就会加上left，right两个值</font> 此时规则和之前一样，只是多添加了两个值 -当发生过度约束时 1:如果9个值中没有auto，则自动调整right值以使等式满足 2:如果有auto，则自动调整auto的值以使等式满足 -可设置auto的值 margin width left right 四个值中，三个值固定，某一个值设为auto，则会调整这个auto值, 若width left right都为0，margin会均分四个方向值 —两个auto的情况 margin 和width为auto， 调整width margin 和left，right其中一个值为auto，调整left或right width 和left，right其中一个值，调整right left，right都为auto 调整right —三个auto的情况 margin width left ===> width，left，调整left margin width right ===> width，right，调整right width left right ===> width，right，left，调整right —四个值auto的情况 width，right，left ，调整right 垂直布局 等式也必须满足 top+margin-top+····+botoom --> <font style=\"color:#FF0000;\">Right>left>width</font> 2:<font style=\"color:#FF0000;\">父元素的层级再高，也不会盖住子元素</font> / 透明度 0透明 1不透明 中间值0-1 / opacity: 0.5; 层级 1:如果定位元素的层级是一样，则下边的元素会盖住上边的 通过<font style=\"color:#FF0000;\">z-index属性可以用来设置元素的层级</font> 可以为z-index指定一个正整数作为值，该值将会作为当前元素的层级 <font style=\"color:#FF0000;\">层级越高，越优先显示</font> <font style=\"color:#FF0000;\">对于没有开启定位的元素不能使用z-index </font> --> 透明背景 opacity 2、设置元素的透明背景 <font style=\"color:#FF0000;\"> opacity [əu'pæsiti] 可以用来设置元素背景的透明，</font> 它需要一个0-1之间的值 <font style=\"color:#FF0000;\"> 0 表示完全透明</font> <font style=\"color:#FF0000;\"> 1 表示完全不透明</font> <font style=\"color:#FF0000;\"> 0.5 表示半透明 </font> --> 1、opacity用来<font style=\"color:#FF0000;\">设置元素的不透明级别</font>，从 0.0 （完全透明）到 1.0（完全不透明）。 2<font style=\"color:#FF0000;\">、transparent是颜色的一种</font>，这种颜色叫<font style=\"color:#FF0000;\">透明色</font>。 3、rgba(r,g,b,a)稍复杂一点，r：红色值；g：绿色值；b：蓝色值；a：alpha透明度。 alpha表示像素不透明性的值。像素越不透明，则隐藏越多呈现图像的背景。 取值0~1之间。0表示完全透明的像素，1表示完全不透明的像素。 --> 1、opacity是作为一个完整属性出现的。transparent和rgba都是作为属性值出现的。 2、<font style=\"color:#FF0000;\">opacity是对于整个元素起作用的</font>。打个比方，就像拿一块玻璃糊在了这个元素上， 盖上的地方都会受到影响。 而transparent和alpha是对元素的某个属性起作用的。 任何需要设置颜色的地方都可以根据情况使用transparent或rgba。 比如背景、边框、字体等等。哪个属性的颜色设置了transparent，哪个属性就是透明的，完全透明。 哪个属性用rgba()设置了透明，就对哪个属性起作用，透明程度可设置。 3、由于opacity和alpha设置的透明程度可调，就引出一个继承的问题。 <font style=\"color:#FF0000;\">如果一个元素未设置opacity属性，</font> <font style=\"color:#FF0000;\"> 那么它会从它的父元素继承opacity属性的值。而alpha不存在继承</font>。 --> :target选择器称为目标选择器， 用来匹配文档(页面)的url的某个标志符的目标元素。 --> <style> /<font style=\"color:#FF0000;\">这里的:target就是指id=\"brand\"的div对象</font>/ #brand:target { <h2><a href=\"#brand\">页签1</a></h2> <div id=\"brand\">非居不锐君要命作使落出不败而性善，若云了脱鲜程商哥性我选路国活，后弟得放哉在与，丰世下。</div> :target选择器在 CSS 中是一个非常有用的选择器。它用于选择当前活动的目标元素，通常是在 URL 中有一个片段标识符（以#开头的部分）指向的元素。例如，当页面的 URL 是https://example.com/page.html#section - 1时，#section - 1对应的元素就会被:target选择器选中。 <font style=\"color:#FF0000;\">① 每个a标签的href属性须与其兄弟节点.content元素的id值一致</font> <font style=\"color:#FF0000;\">② .content元素与a标签的顺序不能更改 --></font> <ul> <li> <div class=\"content\" id=\"content1\">选项一内容</div> <a href=\"#content1\">选项一</a> </li> <li> <div class=\"content\" id=\"content2\">选项二内容</div> <a href=\"#content2\">选项二</a> </li> <li> <div class=\"content\" id=\"content3\">选项三内容</div> <a href=\"#content3\">选项三</a> </li> </ul> label <label>标签的作用是为鼠标用户改进了可用性， 当用户点击<label>标签中的文本时，浏览器就会自动将焦点转到和该标签相关联的控件上；//<font style=\"color:#FF0000;\">增大控件作用范围</font> <label <font style=\"color:#FF0000;\">for=\"username\"</font>>用户名：</label> <input type=\"text\" name=\"\" <font style=\"color:#FF0000;\">id=\"username\"</font>> lable实现tab栏切换 原理： <font style=\"color:#FF0000;\">当用户点击label元素时，该label所绑定的input单选框就会被选中</font>， 同时通过使用CSS选择器让被选中的input元素之后的label和.content元素都加上相应的样式。 / 找到我的盒子做显示 checked----》input/ input:checked~.content{ opacity: 1; } / 找到lable做出选中的效果 / input:checked +label{ background-color: #666; color: #fff; } ul li:first-child .content{ background-color: #f60; } ul li:nth-child(2) .content{ background-color: green; } ul li:last-child .content{ background-color: yellow; } /* ① input需要隐藏，因为我们并不需要显示它，但它却是实现Tab切换的核心力量 ② “input:checked+label” 表示被选中的单选框后的 label 元素需要做标记 ③ .content 元素需要先全部隐藏 ③ “input:checked~.content” 表示被选中的单选框后的 .content 元素需要显示 <!--① label需要绑定input，方法就是label的for属性值与input的id一致， 这样当点击label元素时input单选框就会被选中 ② input、label和div三者是有顺序的，不能随意调换顺序--> <ul> <li> <input id=\"tab1\" type=\"radio\" name=\"tab\" checked /> <label for=\"tab1\">选项一</label> <div class=\"content\">选项一内容</div> </li> <li> <input id=\"tab2\" type=\"radio\" name=\"tab\" /> <label for=\"tab2\">选项二</label> <div class=\"content\">选项二内容</div> </li> <li> <input id=\"tab3\" type=\"radio\" name=\"tab\" /> <label for=\"tab3\">选项三</label> <div class=\"content\">选项三内容</div> </li> </ul> swiper插件 轮播图（会引用，会修改即可） <font style=\"color:#000000;\">首先加载插件，需要用到的文件有</font><font style=\"color:#4183C4;\">swiper.min.js</font><font style=\"color:#000000;\">和</font><font style=\"color:#4183C4;\">swiper.min.css</font><font style=\"color:#000000;\">文件。</font> <font style=\"color:#000000;\"> <link rel=\"stylesheet\" href=\"path/to/</font><font style=\"color:#000000;\">swiper.min.css</font><font style=\"color:#000000;\">\"></font> <font style=\"color:#000000;\"> <script src=\"path/to/</font><font style=\"color:#000000;\">swiper.min.js</font><font style=\"color:#000000;\">\"></script></font> <font style=\"color:#000000;\">HTML内容。</font> <font style=\"color:#000000;\"><div class=\"swiper-container\"></font> <font style=\"color:#000000;\"> <div class=\"swiper-wrapper\"></font> <font style=\"color:#000000;\"> <div class=\"swiper-slide\">Slide 1</div></font> <font style=\"color:#000000;\"> <div class=\"swiper-slide\">Slide 2</div></font> <font style=\"color:#000000;\"> <div class=\"swiper-slide\">Slide 3</div></font> <font style=\"color:#000000;\"> </div></font> <font style=\"color:#000000;\"> <!-- 如果需要分页器 --></font> <font style=\"color:#000000;\"> <div class=\"swiper-pagination\"></div></font> <font style=\"color:#000000;\"> </font> <font style=\"color:#000000;\"> <!-- 如果需要导航按钮 --></font> <font style=\"color:#000000;\"> <div class=\"swiper-button-prev\"></div></font> <font style=\"color:#000000;\"> <div class=\"swiper-button-next\"></div></font> <font style=\"color:#000000;\"> </font> <font style=\"color:#000000;\"> <!-- 如果需要滚动条 --></font> <font style=\"color:#000000;\"> <div class=\"swiper-scrollbar\"></div></font> <font style=\"color:#000000;\"></div></font><font style=\"color:#A9A9A9;\">导航等组件可以放在container之外</font> <font style=\"color:#000000;\">你可能想要给Swiper定义一个大小，当然不要也行。</font> <font style=\"color:#000000;\">.swiper-container {</font> <font style=\"color:#000000;\"> width: 600px;</font> <font style=\"color:#000000;\"> height: 300px;</font> <font style=\"color:#000000;\">} </font> <font style=\"color:#000000;\">4.初始化Swiper：最好是挨着</body>标签</font> <font style=\"color:#000000;\"><script> </font> <font style=\"color:#000000;\"> var mySwiper = new Swiper ('.swiper-container', {</font> <font style=\"color:#000000;\"> direction: 'vertical',</font> <font style=\"color:#000000;\"> loop: true,</font> <font style=\"color:#000000;\"> </font> <font style=\"color:#000000;\"> // 如果需要分页器</font> <font style=\"color:#000000;\"> pagination: '.swiper-pagination',</font> <font style=\"color:#000000;\"> </font> <font style=\"color:#000000;\"> // 如果需要前进后退按钮</font> <font style=\"color:#000000;\"> nextButton: '.swiper-button-next',</font> <font style=\"color:#000000;\"> prevButton: '.swiper-button-prev',</font> <font style=\"color:#000000;\"> </font> <font style=\"color:#000000;\"> // 如果需要滚动条</font> <font style=\"color:#000000;\"> scrollbar: '.swiper-scrollbar',</font> <font style=\"color:#000000;\"> }) </font> <font style=\"color:#000000;\"> </script></font> <font style=\"color:#000000;\"></body></font> <font style=\"color:#000000;\">5.完成。恭喜你，现在你的Swiper应该已经能正常切换了。现在开始添加各种</font><font style=\"color:#4183C4;\">选项和参数</font><font style=\"color:#000000;\">丰富你的Swiper，开启华丽移动前端创作之旅。</font> 图标字体（iconfont） -在网页中经常需要使用一些图标，可以通过图片来引入图标 但图片本身比较大，也不灵活 -所以使用图标时，我们还可以<font style=\"color:#FF0000;\">将图标直接设置为字体，</font> 然后通过font-face的形式来对字体进行引入 -这样我们就可以通过使用字体的形式来使用图标 <font style=\"color:#000000;\"><link rel=\"stylesheet\" href=\"</font>./font_4771251_qzjb1gs6u3i/iconfont.css<font style=\"color:#000000;\">\"></font> <font style=\"color:#000000;\"><script src=\"</font>./font_4771251_qzjb1gs6u3i/iconfont.js<font style=\"color:#000000;\">\"></script></font> <!-- <font style=\"color:#FF0000;\">第一种方式 转义字符形式</font>--> <!-- <span class=\"iconfont\"><font style=\"color:#FF0000;\">&#xe611;</font></span> <span class=\"iconfont\">&#xe60e;</span> --> <span class=\"iconfont\">&#xe600;</span> <!-- <font style=\"color:#FF0000;\">第二种方式 类名形式 （常用）</font>--> <!-- <i class=\"<font style=\"color:#FF0000;\">iconfont icon-jishuzhuanyi s1</font>\">1</i> <i class=\"iconfont icon-zhijiao-copy-copy3\"></i> --> <i class=\"iconfont icon-gouwuchekong\"></i> <!--<font style=\"color:#FF0000;\">第三种方式 （了解）</font>--> <p>一朵花</p> <!-- <font style=\"color:#FF0000;\">第四种 </font>--> <font style=\"color:#FF0000;\"><svg class=\"icon\" aria-hidden=\"true\"></font> <use xlink:href=\"#icon-gouwuchekong\"></use> </svg> 背景 <font style=\"color:#FF0000;\">1: background-color 设置背景颜色</font> background-color: blueviolet; <font style=\"color:#FF0000;\"> 2:background-image来设置背景图片</font> -<font style=\"color:#FF0000;\"> 语法：background-image:url(相对路径);</font> -可以同时为一个元素指定背景颜色和背景图片， 这样背景颜色将会作为背景图片的底色 -图片在元素中的位置 如果背景图片大于元素，默认会显示图片的左上角 如果背景图片和元素一样大，则会将背景图片全部显示 如果背景图片小于元素大小，则会默认将背景图片平铺以充满元素 background-image: url('./img/gaitubao_小图_png.png'); 需求：虽然图小，但图片我只要一张 <font style=\"color:#FF0000;\">3:background-repeat用于设置背景图片的重复方式</font> 可选值： <font style=\"color:#FF0000;\">repeat，默认值，背景图片会双方向重复（平铺）</font> <font style=\"color:#FF0000;\"> no-repeat ，背景图片不会重复，有多大就显示多大</font> <font style=\"color:#FF0000;\"> repeat-x， 背景图片沿水平方向重复</font> <font style=\"color:#FF0000;\"> repeat-y，背景图片沿垂直方向重复</font> background-repeat: no-repeat; <font style=\"color:#FF0000;\">4:background-position可以调整背景图片在元素中的位置</font> 背景图片<font style=\"color:#FF0000;\">默认是贴着元素的左上角显示</font> 可选值： 该属性可以使用 <font style=\"color:#FF0000;\">top right left bottom center</font>中的两个值 来指定一个背景图片的位置 top left 左上 bottom right 右下 <font style=\"color:#FF0000;\">如果只给出一个值，则第二个值默认是center</font> 也可以直接指定<font style=\"color:#FF0000;\">两个偏移量</font>， 第一个值是<font style=\"color:#FF0000;\">水平偏移量</font> 如果指定的是一个<font style=\"color:#FF0000;\">正值</font>，则图片会<font style=\"color:#FF0000;\">向右</font>移动指定的像素 如果指定的是一个<font style=\"color:#FF0000;\">负值</font>，则图片会<font style=\"color:#FF0000;\">向左</font>移动指定的像素 第二个是<font style=\"color:#FF0000;\">垂直偏移量</font> 如果指定的是一个<font style=\"color:#FF0000;\">正值</font>，则图片会<font style=\"color:#FF0000;\">向下</font>移动指定的像素 如果指定的是一个<font style=\"color:#FF0000;\">负值</font>，则图片会<font style=\"color:#FF0000;\">向上</font>移动指定的像素 第一个值是水平方向，第二值垂直方向，假设只设置一个值，第二个值center / background-position: left bottom; / background-position: 0px -100px; <font style=\"color:#FF0000;\"> 5:background-clip</font> <font style=\"color:#FF0000;\">设置背景的范围</font> 可选值： <font style=\"color:#FF0000;\">border-box 默认值，背景颜色会出现在边框的下边</font> <font style=\"color:#FF0000;\"> padding-box 背景不会出现在边框，只会出现在内容区和内边距</font> <font style=\"color:#FF0000;\"> content-box 背景只出现在内容区</font> / background-clip: border-box; / / 设置背景颜色 / background-color: forestgreen; /设置一个背景图片/ background-image: url('./img/小图.webp'); /设置一个图片不重复/ background-repeat: no-repeat; <font style=\"color:#FF0000;\">6:background-origin </font> <font style=\"color:#FF0000;\">设置背景图片的偏移量计算的原点,配合偏移量使用的</font> <font style=\"color:#FF0000;\">padding-box 从内部距处开始计算</font> <font style=\"color:#FF0000;\"> content-box 背景图片的偏移量从内容区处计算</font> <font style=\"color:#FF0000;\"> border-box 从边框开始计算偏移量</font> / 计算开始的位置 / background-origin:content-box; / 从指定位置开始偏移的量 / background-position:30px ; margin: 0; padding: 0; } /设置一个背景颜色/ background-color: brown; /设置一个背景图片/ background-image: url('./img/大图2.webp'); /设置一个图片不重复/ background-repeat: no-repeat; <font style=\"color:#FF0000;\">7:background-size</font> <font style=\"color:#FF0000;\"> 设置图片的大小</font> 参数： <font style=\"color:#FF0000;\">第一个值：宽度</font> <font style=\"color:#FF0000;\"> 第二个值：高度</font> 如果只写一个，第二值，默认为auto <font style=\"color:#FF0000;\">cover 图片的比例不变，将元素铺满，</font> <font style=\"color:#333333;\">图片将被缩放到足够大，以完全覆盖元素的背景区域，即使图片会被裁剪</font><font style=\"color:#333333;\">‌</font> <font style=\"color:#FF0000;\"> contain 图片比例不变，将元素完整显示</font> <font style=\"color:#333333;\">图片将被缩放到足够小，以完整显示在元素背景中，且不会被裁剪</font><font style=\"color:#333333;\">‌</font> background-size:cover; /设置一个背景颜色/ / background-color: brown; / /设置一个背景图片/ / background-image: url('./img/小图.webp'); / /设置背景不重复/ / background-repeat: no-repeat; / /设置背景图片的位置/ / background-position: center center; / / 设置图片大小 / / background-size:200px ; / / 设置图片偏移的原点 / / background-origin: border-box; / / 设置背景的范围 / / background-clip: border-box; / background 通过该属性可以同时设置所有背景相关的样式 没有顺序的要求，谁在前谁在后都行 也没有数量的要求，不写的样式就使用默认值 <font style=\"color:#FF0000;\">-background-size要写在background-position后面</font> background:brown url('./img/小图.webp') <font style=\"color:#FF0000;\">center center/200px</font> no-repeat; 雪碧图 图片整合技术（CSS-Sprite） 优点： 1 将多个图片整合为一张图片里，浏览器只需要发送一次请求，可以同时加载多个图片， 提高访问效率，提高了用户体验。 2 将多个图片整合为一张图片，减小了图片的总大小，提高请求的速度，增加了用户体验 雪碧图使用步骤 <font style=\"color:#FF0000;\"> 1:先确定要使用的图标</font> <font style=\"color:#FF0000;\"> 2:测量图标的大小</font> <font style=\"color:#FF0000;\"> 3:根据测量结果创建一个元素</font> <font style=\"color:#FF0000;\"> 4:将雪碧图设置为元素的背景</font> <font style=\"color:#FF0000;\"> 5：设置一个偏移量以显示正确的图片</font> 管中窥豹 .btn:link { /将a转换为块元素/ display: block; /设置宽高/ width: 200px; height: 500px; /设置背景图片/ background-image: url(\"./img2/早中晚.webp\"); /设置背景图片不重复/ background-repeat: no-repeat; background-position:-80px 0; } .btn:hover { /* 当是hover状态时，希望图片可以向左移动 */ background-position:-285px 0; } .btn:active { /* 当是active状态时，希望图片再向左移动 */ background-position:-490px 0; } </style> </head> <body> <!-- 创建一个超链接 --> <a class=\"btn\" href=\"#\"></a> </body> </html> 渐变 渐变：通过渐变可以设置一些复杂的背景颜色，可以从实现一个颜色向其他颜色过渡的效果 渐变是图片，通过 background-image设置 可选值 <font style=\"color:#FF0000;\"> 1：linear-gradient(方位,)颜色1,颜色2 </font>['ɡreidiənt] 线性渐变，颜色沿着一条直线发生变化 <font style=\"color:#FF0000;\">参数1:表示方位，（可选值，不写默认是to bottom）</font> <font style=\"color:#FF0000;\"> (1)to left，to right, to bottom, to top</font> <font style=\"color:#FF0000;\"> (2)xxxdeg 表示角度，度数，会更灵活</font> <font style=\"color:#FF0000;\"> (3)turn 表示圈 .5turn</font> <font style=\"color:#FF0000;\"> 参数2:颜色1</font> <font style=\"color:#FF0000;\"> 参数3:颜色2</font> 注意： 可以写多个颜色，默认情况下，颜色是均分占比的 也可以手动的指定渐变的分布情况 background-image:linear-gradient(red 50px,yellow) ; 颜色后直接跟占比 <font style=\"color:#FF0000;\"> 2:repeating-linear-gradient()</font> <font style=\"color:#FF0000;\"> 可以平铺的线性渐变</font> background-image: repeating-linear-gradient(yellow 0px, red 50px); 参数跟linear-gradient是一样的 <font style=\"color:#FF0000;\">参数2-参数1，中间部分是渐变的颜色，拿总高度/差值，就是颜色重复出现的次数</font> / height: 400px; / / 宽度高度水平偏移`垂直偏移 / background-image: radial-gradient(80px 20px at 120px 50px,yellow,blue); 1:radial-gradient() ['reidiəl] ['ɡreidiənt] 经向渐变（放射性的效果） <font style=\"color:#FF0000;\">默认情况下，圆心是根据元素的形状来计算的</font> <font style=\"color:#FF0000;\"> 正方形-->圆形</font> <font style=\"color:#FF0000;\"> 长方形-->椭圆型</font> <font style=\"color:#FF0000;\"> 参数1:圆心的形状</font> <font style=\"color:#FF0000;\"> （1）circle圆形，ellipse椭圆，</font> <font style=\"color:#FF0000;\"> （2）设置的大小 at 位置==>像素1 像素2 at 0px 0px</font> <font style=\"color:#FF0000;\"> background-image: radial-gradient(100px 100px at 100px 0px,red,yellow); </font> <font style=\"color:#FF0000;\"> 参数2:颜色1</font> <font style=\"color:#FF0000;\"> 参数3:颜色2</font> <font style=\"color:#FF0000;\"> ······</font> 过渡transition .box1>div{ width: 100px; height: 100px; margin-bottom: 50px; margin-left: 0; / all全部的一个属性 / transition-property: all; / 过渡的持续时间 / transition-duration: 2s; / 延迟时间 / / transition-delay:1s; / <font style=\"color:#FF0000;\">过渡（transition）</font>[træn'siʒən] -通过过渡可以指定一个属性发生变化时的切换方式 -通过过渡可以创建一些非常好的效果，提升用户体验 <font style=\"color:#FF0000;\">属性（4个）</font> <font style=\"color:#FF0000;\">(1)transition-property </font>['prɔpəti] <font style=\"color:#FF0000;\">指定执行过渡的属性</font>，多个属性，使用逗号隔开，如果所有的属性都要过渡，就使用<font style=\"color:#FF0000;\">all</font>关键词，大部分属性都支持过渡效果 注意过渡时，必须是从一个有效数值向另一个有效数值进行过渡 只要值可以计算的，就可以过渡 <font style=\"color:#FF0000;\">(2)transition-duration [</font>djuə'reiʃən] 指定<font style=\"color:#FF0000;\">过渡效果的持续时间</font> 时间的单位：s和ms 1s=1000ms <font style=\"color:#FF0000;\">(3)transition-timing-function: ;过渡的时序函数</font> <font style=\"color:#FF0000;\"> 指定过渡的执行的方式</font> <font style=\"color:#FF0000;\">可选值：ease [i:z] 默认值，慢速开始，先加速，然后再减速</font> <font style=\"color:#FF0000;\"> linear 匀速运动</font> <font style=\"color:#FF0000;\"> ease-in 慢速开始，加速运动</font> <font style=\"color:#FF0000;\"> ease-out 快速开始，减速运动</font> <font style=\"color:#FF0000;\"> ease-in-out 先加速，后减速</font> <font style=\"color:#FF0000;\"> steps()分布执行过渡效果</font> <font style=\"color:#FF0000;\"> 可以设置一个第二个值</font> <font style=\"color:#FF0000;\"> end 表示动画在每个步骤结束时变化</font> <font style=\"color:#FF0000;\"> start，表示动画在每个步骤开始时立即变化</font> <font style=\"color:#FF0000;\">(4)transition-delay: ;过渡效果的延迟</font>，等待一段时间后执行过渡 <font style=\"color:#FF0000;\">transition：；可以同时设置过渡相关的所有属性，</font> <font style=\"color:#FF0000;\"> 只有一个要求，如果要写延迟，则两个时间中,第一个写延迟，第二个写持续时间 </font> / 过渡的函数 / / transition-timing-function: steps(5,end); / 简写 / 2s持续的时间，1s延迟的时间 / transition: all 2s 1s steps(5); 动画 animation 动画和过渡类似，都是可以实现一些动态效果，不同的是过渡需要在某个属性发生变化时才能触发，动画可以自动触发动画 <font style=\"color:#FF0000;\">设置动画</font>效果，必须<font style=\"color:#FF0000;\">先要设置一个关键帧</font>，关键帧设置了动画每一个步骤 <font style=\"color:#FF0000;\">@keyframes 动画名 {}</font> <font style=\"color:#FF0000;\">第一步：设置关键帧</font> <font style=\"color:#FF0000;\">@keyframes move{</font> <font style=\"color:#FF0000;\"> from{</font> margin-left: 0; } <font style=\"color:#FF0000;\">to{</font> margin-left: 500px; } <font style=\"color:#FF0000;\"> }</font> <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\">第二步 设置box2的动画 animation</font> [ˌænɪˈmeɪʃ(ə)n] .box2 { background-color: #bfa; <font style=\"color:#FF0000;\"> 1:animation-name</font> <font style=\"color:#FF0000;\"> 设置动画的名字，和@keyframs相对应</font> animation-name:move; <font style=\"color:#FF0000;\">2:animation-duration</font> <font style=\"color:#FF0000;\"> 动画执行时间 duration</font> [djuə'reiʃən] animation-duration: 2s; <font style=\"color:#FF0000;\">3:animation-delay</font> <font style=\"color:#FF0000;\"> 动画执行延时 </font> animation-delay:1s; <font style=\"color:#FF0000;\">4:animation-timing-function</font> <font style=\"color:#FF0000;\"> 动画执行的方式</font> animation-timing-function: linear; <font style=\"color:#FF0000;\">5:animation-iteration-count [,itə'reiʃən]</font> <font style=\"color:#FF0000;\"> 动画执行的次数</font> <font style=\"color:#FF0000;\"> 可选值：次数（数字）</font> <font style=\"color:#FF0000;\"> infinite ['infinət] 无限循环 </font> animation-iteration-count:2; <font style=\"color:#FF0000;\">6:animation-direction</font> <font style=\"color:#FF0000;\"> 指定动画运行的方向</font> <font style=\"color:#FF0000;\">可选值</font> <font style=\"color:#FF0000;\"> normal 默认值： 从from向to运行，每次都是这样</font> <font style=\"color:#FF0000;\"> reverse 从to到from运行，每次都是这样</font> <font style=\"color:#FF0000;\"> alternate 从from向to运行，重复执行动画时反向执行</font> <font style=\"color:#FF0000;\"> alternate-reverse 从to向from运行，重复执行动画时反向执行</font> animation-direction: alternate-reverse; <font style=\"color:#FF0000;\">7:animation-play-state</font> <font style=\"color:#FF0000;\"> 设置动画的执行状态</font> <font style=\"color:#FF0000;\"> 可选值：running 默认值 动画执行</font> <font style=\"color:#FF0000;\"> paused 动画暂停 </font> animation-play-state: running; <font style=\"color:#FF0000;\">8:animation-fill-mode</font> <font style=\"color:#FF0000;\"> 动画的填充模式</font> <font style=\"color:#FF0000;\"> 可选值：</font> <font style=\"color:#FF0000;\"> none默认值 动画执行完毕 元素回到原来的位置</font> <font style=\"color:#FF0000;\"> forwards 动画执行完毕，会停止在动画结束的位置</font> <font style=\"color:#FF0000;\"> backwards 动画延时等待时，元素就会处于开始位置</font> <font style=\"color:#FF0000;\"> both 结合了forwards和backwards的特点</font> animation-fill-mode: both; 简写模式 animation: move 2s 2 2s alternate-reverse both; 变形transform .box1 { width: 200px; height: 200px; background-color: #bfa; transform: translateX(0px); 变形是通过css来改变元素的形状或位置 -<font style=\"color:#FF0000;\">变形不会影响到页面的布局(只折腾自己)</font> <font style=\"color:#FF0000;\">-transform: ;</font>用来设置元素的变形效果 ,尽量变形写在一个transform里，不然下面再写一个，就会覆盖上面 <font style=\"color:#FF0000;\">可</font>选值： <font style=\"color:#FF0000;\">-平移：translateX()沿着x轴方向平移</font> <font style=\"color:#FF0000;\">translateY()沿着y轴方向平移</font> <font style=\"color:#FF0000;\"> translateZ()沿着z轴方向平移</font> <font style=\"color:#FF0000;\"> -平移元素，可以是数字，可以是百分比，百分比是相对于自身计算的</font> 需求 ： 使元素居中效果 .box3 { background-color: red; 第一种方式居中 这种方式适用于宽高确定，如果不确定，会自动调整宽高的大小 width: 100px; height: 100px; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin:auto; } .box4 { background-color: pink; position: absolute; / 第二种居中方式动画形式 / <font style=\"color:#FF0000;\">left: 50%;</font> <font style=\"color:#FF0000;\"> top: 50%;</font> <font style=\"color:#FF0000;\"> transform: translateX(-50%) translateY(-50%);</font> } 需求二：作出<font style=\"color:#FF0000;\">卡片悬浮</font>的效果 / 平移可以结合transition 做出浮起来的效果，还不影响其他人 / .box5 { width: 220px; height: 220px; background-color: salmon; / 过渡效果 / } .box5:hover { <font style=\"color:#FF0000;\"> transform: translateY(-3px);</font> <font style=\"color:#FF0000;\"> box-shadow:0 0 10px rgba(0, 0, 0,.5);</font> <font style=\"color:#FF0000;\"> transition: 0.5s ease;</font> } .box1:hover{ transform: translateX(50px); transition: 2s linear; } 视距 perspective <font style=\"color:#FF0000;\">perspective </font>[pə'spektiv] <font style=\"color:#FF0000;\">设置当前网页的视距为800px</font>，人眼距离网页的距离，一般不小于600px z轴平移，调整元素在z轴的位置，正常情况下调整元素和人眼之间的距离，距离越大，元素离人越近 <font style=\"color:#FF0000;\">z轴平移</font>属于立体效果（近大远小），默认情况下网页不支持透视 如果需要<font style=\"color:#FF0000;\">看到效果，必须要设置网页的视距</font> body:hover .box1 { /perspective(800px) 谷歌要直接设置在transform里面 / <font style=\"color:#FF0000;\"> transform: perspective(800px) translateZ(100px);</font> box-shadow: 0 0 10px rgba(0,0, 0, .5); transition: 2s ease; 旋转rotate / 设置当前网页的视距为800px，人眼距离网页的距离，一般不小于600px / /* html{ perspective: 800px; } */ .box1{ width: 200px; height: 200px; background-color: #bfa; margin: 100px auto; transition: 2s; } body:hover .box1{ <font style=\"color:#FF0000;\">通过旋转可以使元素沿着x y或者z旋转指定的角度</font> <font style=\"color:#FF0000;\"> rotateX() 沿着x轴旋转</font> <font style=\"color:#FF0000;\"> rotateY() 沿着y轴旋转</font> <font style=\"color:#FF0000;\"> rotateZ() 沿着z轴旋转</font> <font style=\"color:#FF0000;\"> deg 度</font> <font style=\"color:#FF0000;\"> turn 圈</font> transform: rotateY(1turn); <font style=\"color:#FF0000;\">设置是否显示元素的背面 </font> <font style=\"color:#FF0000;\"> backface-visibility: ;</font> <font style=\"color:#FF0000;\">可选值：visible 默认值，显示</font> <font style=\"color:#FF0000;\"> hidden 不显示</font> */ backface-visibility:hidden; } 缩放scale <font style=\"color:#FF0000;\">对元素进行缩放的函数</font> <font style=\"color:#FF0000;\"> scale（）双方向缩放</font> <font style=\"color:#FF0000;\"> scaleX() x轴方向缩放</font> <font style=\"color:#FF0000;\"> scaleY() y方向缩放</font> <font style=\"color:#FF0000;\"> 值是倍数</font> <font style=\"color:#FF0000;\">默认效果1，小于1，缩小，大于1放大</font> <font style=\"color:#FF0000;\">transform: scale(1.2);</font> <font style=\"color:#FF0000;\"> 变形的原点 默认值center</font> <font style=\"color:#FF0000;\"> transform-origin: 30px 30px</font>; } / 需求：设置图片放大效果 / .img-wrapper{ width: 200px; height: 200px; border: 1px red solid; overflow: hidden; } 1 .img-wrapper:hover img{ transform: scale(1.2); } img{ transition: all 1s; } flex(弹性盒子，伸缩盒) -是css中的又一种布局手段，它主要用来<font style=\"color:#FF0000;\">代替浮动</font>来完成页面的布局 -flex可以使元素具有弹性，让<font style=\"color:#FF0000;\">元素可以根据页面的大小的改变而改变</font> -弹性容器 -要使用弹性盒，必须先将一个元素设置为弹性容器 -通过display来设置弹性容器 <font style=\"color:#FF0000;\">display:flex 设置块级弹性容器</font> <font style=\"color:#FF0000;\"> display:inline-flex 设置为行内的弹性容器</font> -弹性元素 -<font style=\"color:#FF0000;\">弹性容器的直接子元素是弹性元素（弹性项）</font> 注意：一个元素可以同时是弹性容器和弹性元素 / 将ul设置为弹性容器 / display: flex; flex-direction:column-reverse; 一:弹性容器的属性 <font style=\"color:#FF0000;\">1:flex-direction 2:flex-wrap </font> <font style=\"color:#FF0000;\"> 3:flex-flow 4:justify-content</font> <font style=\"color:#FF0000;\"> 5:align-items 6:align-content</font> <font style=\"color:#FF0000;\">1:flex-direction: ; 指定容器中弹性元素的排列方式</font> <font style=\"color:#FF0000;\">可选值：</font> <font style=\"color:#FF0000;\"> row 默认值，弹性元素在容器中水平排列（左向右）</font> <font style=\"color:#FF0000;\"> 主轴-自左向右</font> <font style=\"color:#FF0000;\"> row-reverse 弹性元素在容器中反向水平排列（右向左）</font> <font style=\"color:#FF0000;\"> 主轴-自右向左</font> <font style=\"color:#FF0000;\"> column 弹性元素纵向排列（自上向下）</font> <font style=\"color:#FF0000;\"> 主轴-自上向下</font> <font style=\"color:#FF0000;\"> column-reverse 弹性元素纵向排列（自下向上）</font> <font style=\"color:#FF0000;\"> 主轴-自下向上</font> <font style=\"color:#FF0000;\">主轴：弹性元素的排列方向称为主轴</font> <font style=\"color:#FF0000;\"> 侧轴：与主轴垂直方向的称为侧轴</font> <font style=\"color:#FF0000;\">2: flex-wrap: ;设置弹性元素是否在弹性容器中是否自动换行</font> <font style=\"color:#FF0000;\">可选值： </font> <font style=\"color:#FF0000;\"> nowrap 默认值，元素不会自动换行</font> <font style=\"color:#FF0000;\"> wrap 元素沿着辅轴方向自动换行 </font> <font style=\"color:#FF0000;\"> wrap-reverse 元素沿着辅轴反方向换行 </font> / flex-wrap:wrap-reverse; / <font style=\"color:#FF0000;\">3:flex-flow:wrap和direction的简写属性，且没有顺序要求</font> <font style=\"color:#FF0000;\"> 默认值 row nowrap</font> / flex-flow: row nowrap; / <font style=\"color:#FF0000;\">4:justify-content 如何分配主轴上的空白空间（主轴上的元素如何排列）</font> <font style=\"color:#FF0000;\"> 可选值：</font> <font style=\"color:#FF0000;\"> flex-start 元素沿着主轴起边排列</font> <font style=\"color:#FF0000;\"> flex-end 元素沿着主轴终边排列</font> <font style=\"color:#FF0000;\"> center 元素居中排列</font> <font style=\"color:#FF0000;\"> space-around 空白分布到元素的两侧</font> <font style=\"color:#FF0000;\"> space-between 空白均匀分布到元素间</font> <font style=\"color:#FF0000;\"> space-evenly 空白分布到元素的单侧（兼容性差一些） </font> /1: flex-direction: row; / /2: flex-wrap:wrap-reverse ; / / 3: flex-flow:row wrap; / flex-flow: row wrap; /4: justify-content:space-around; / <font style=\"color:#FF0000;\">5: align-items 在辅轴上如何对齐-元素间的关系</font> <font style=\"color:#FF0000;\"> 可选值：</font> <font style=\"color:#FF0000;\"> stretch 默认值，将同一行元素的长度设置为相同的值</font> <font style=\"color:#FF0000;\"> flex-start 元素不会拉伸， 沿着辅轴起边对齐</font> <font style=\"color:#FF0000;\"> flex-end 元素不会拉伸， 沿着辅轴终边对齐</font> <font style=\"color:#FF0000;\"> center 居中对齐</font> <font style=\"color:#FF0000;\"> baseline 基线对齐（用的不对） </font> align-items:center; /*需求：在弹性盒子里，元素时间正中间居中对齐 */ <font style=\"color:#FF0000;\">6: align-content: ;辅轴空白空间的分布 </font> <font style=\"color:#FF0000;\"> 可选值：</font> <font style=\"color:#FF0000;\"> flex-start 元素沿着辅轴起边排列</font> <font style=\"color:#FF0000;\"> flex-end 元素沿着辅轴终边排列</font> <font style=\"color:#FF0000;\"> center 元素居中排列</font> <font style=\"color:#FF0000;\"> space-around 空白分布到元素的两侧</font> <font style=\"color:#FF0000;\"> space-between 空白均匀分布到元素间</font> <font style=\"color:#FF0000;\"> space-evenly 空白分布到元素的单侧（兼容性差一些）</font> */ / align-content:flex-start; / } 二：弹性元素的属性 <font style=\"color:#FF0000;\"> align-self</font> <font style=\"color:#FF0000;\"> flex-grow flex-shrink </font> <font style=\"color:#FF0000;\"> order flex-basis </font> <font style=\"color:#FF0000;\"> flex /</font> <font style=\"color:#FF0000;\"> 1:用来覆盖当前弹性元素上的align-items */</font> <font style=\"color:#FF0000;\"> align-self:flex-start;</font> <font style=\"color:#FF0000;\">2.flex-grow: ;指定弹性元素的伸展的系数</font> <font style=\"color:#FF0000;\"> -当父元素有多余的空间的时候，子元素如何伸展，0 默认值 是不伸展</font> <font style=\"color:#FF0000;\"> -父元素的剩余空间，会按照比例进行分配</font> <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\">flex-shrink: ; 指定弹性元素的收缩系数</font> <font style=\"color:#FF0000;\"> -当父元素中的空间不足以容纳所有的子元素时，如果对子元素进行收缩，</font> <font style=\"color:#FF0000;\"> 默认值，按照同比例1:1的比例一起缩放，也可分别设置</font> <font style=\"color:#FF0000;\">4. flex-basis 元素的基础长度，指定的是元素在主轴上的基础长度，跟你设置的宽高会冲突</font> <font style=\"color:#FF0000;\"> 如果主轴是横向的，则该值指定的就是元素的宽度</font> <font style=\"color:#FF0000;\"> 如果主轴是纵向的，则该值指定的是元素的高度</font> <font style=\"color:#FF0000;\"> -默认值是auto，表示参考元素自身的高度或宽度</font> <font style=\"color:#FF0000;\"> -如果传递了一个具体的数值，则以该值为准 *</font> <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\">5. flex：可以设置弹性元素所有的三个样式</font> <font style=\"color:#FF0000;\"> flex: 增长 缩减 基础</font> <font style=\"color:#FF0000;\"> initial /ɪˈnɪʃl/ 'flex: 0 1 auto' 弹性元素不增，可减</font> <font style=\"color:#FF0000;\"> auto 'flex: 1 1 auto'弹性元素可增，可减</font> <font style=\"color:#FF0000;\"> none 'flex: 0 0 auto'弹性元素没有弹性</font> <font style=\"color:#FF0000;\"> */</font> <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\">order 决定弹性元素的排列顺序 越小越在之前 */</font> <font style=\"color:#FF0000;\"> order: 2;</font> <font style=\"color:#FF0000;\"> }</font> <font style=\"color:#FF0000;\"> li:nth-child(2) {</font> <font style=\"color:#FF0000;\"> background-color: pink;</font> <font style=\"color:#FF0000;\"> / flex-grow: 3; /</font> <font style=\"color:#FF0000;\"> / 按照1:1的空间压缩，数值比1大收缩 /</font> <font style=\"color:#FF0000;\"> / flex-shrink:3; /</font> <font style=\"color:#FF0000;\"> / flex-basis:400px; /</font> <font style=\"color:#FF0000;\"> order: 3;</font> <font style=\"color:#FF0000;\"> </font> <font style=\"color:#FF0000;\"> </font> 移动端 屏幕 1、屏幕大小 指屏幕的对角线长度,单位是英寸(inch)。 2、屏幕分辨率 指屏幕在:横向、纵向上所拥有的物理像素点总数,一般表示元用n*m表示 3、屏幕密度(ppi) 又称屏幕像素密度,是指屏幕上每英寸里包含的物理像素点个数,!单位是:pp (pixels per inch) ppi值才是真正衡量一块屏幕是否清晰的核心指标 PPI的计算方法是:PPI=开平方(XX+YY)/Z (其中X,Y指长,宽像素数,Z指屏幕大小)。 例如iphone4s分辨率为640*960,屏幕大小为3.5英寸,它的的PPI=开平方 (960960+640640)/3. 5=329.650 像素 3、设备独立像素 设备独立像素简称DIP或DP,又称屏幕密度无关像素 设备独立像素于物理像素关系 普通屏幕下1个设备独立像素对应1个物理像素 高清屏幕下1个设备独立像素对应N个物理像素 4、像素比 像素比(dpr):单一方向设备【物理像素】和【设备独立像素】的比例 5、像素之间的关系 在不考虑缩放的情况下(理想状态下): 普通屏(dpr=1):1css像素=1设备独立像素=1物理像素 2010之前 高清屏(dpr=2):1css像素=1设备独立像素=2物理像素 高清屏(dpr=3):1css像素=1设备独立像素=3物理像素 程序员写了一个width为100px的盒子,那么: 代表100个css像素; 若用户不进行缩放,则对应100个设备独立像素; 在dpr为2的设备上,这100个css像素占据了100*2=200个物理像素(横向) (四)、视口的概念 视口(viewport)就是浏览器显示页面内容的屏幕区域 PC端视口: 在pc端,视口的默认宽度和浏览器窗口的宽度一致,在css标准文档中,pc 端视口也被称为:初始包含块。 移动端视口 移动端视口可以分为布局视口、视觉视口、理想视口(完美视现口)标准 1、布局视口 布局视口 默认的布局视口容器是980px,对pc页面进行压缩,压到跟手机一样大小,就 可以看了,只是元素看上去很小,只能手动去缩放,体验效果不好了 视觉视口 视觉视口就是用户可见的区域,它的绝对宽度永远和设备屏幕一样宽,但这个 宽度里包含的css像素值是变化的 例如:一般手机将980个css像素放入视觉视口中。 注意:布局视口经过压缩后,横向的宽度用css像素表达,就不再是375px,而 是980px 描述一下iPhone6屏幕 1、物理像素:750px 2、设备独立像素:375px 3、css像素:980px 3、理想视口 与屏幕(设备独立像素)等宽的布局视口,称之为理想视口;认上布局视口宽度 与屏幕等宽(设备独立像素),靠meta标签实现 用户不需要缩放、滚动就能看到网站的全部内容 要为移动端设备单独设计一个移动端网站 开启理想视口的方法 <meta name='viewport'content='width=device-width' /> (五)、meta标签设置 <!--<font style=\"color:#FF0000;\">设置完美视口大小</font> <font style=\"color:#FF0000;\">device-width视口宽度和设备保持一致</font> <font style=\"color:#FF0000;\">initial-scale表示页面的初始缩放值,==>屏幕宽度(设备独立像素)布</font> <font style=\"color:#FF0000;\">局视口宽度</font> <font style=\"color:#FF0000;\">user-scalable是否允许用户缩放</font> <font style=\"color:#FF0000;\">maxinum-scale=1.0,最大允许缩放比例</font> <font style=\"color:#FF0000;\">mininum-scale=1.0,最小允许缩放比例</font> <font style=\"color:#FF0000;\"><meta name=\"viewport\"</font> <font style=\"color:#FF0000;\">content=\"</font> <font style=\"color:#FF0000;\">width=device-width,</font> <font style=\"color:#FF0000;\">initial-scale=1.0,</font> <font style=\"color:#FF0000;\">user-scalable=no,</font> <font style=\"color:#FF0000;\">maxinum-scale=1.0,</font> <font style=\"color:#FF0000;\">mininum-scale=1.0 \"</font> /> 问题:图片也是有分辨率的概念的,分辨率指的是物理像素还是cSS像素呢? 图片的分辨率:指的是图片在水平垂直方向需要显示多少个物理像素(发光小 点) 例子:需求:在移动端iphone6中显示100*100px的盒子,里面装双时应的图片 iphone6物理像素宽时750px,设备独立像素时375px, 1个设备独立像素=1个css像素=2个物理像素 5050设备独立像素=5050css像素 =100*100物理像素 100100设备独立像素=100100css像素=200*200物理像素 一倍图: 使用的是100*100物理像素的图片 100100分辨率图片=》对应屏幕中100100的发光点(物理像素):=》对应 css中50*50px 此时强行设置100*100px css像素,很明显对比起来就较为模糊 <font style=\"color:#FF0000;\">二倍图</font> 使用200*200的图片 200200分辨率的图片=》对应屏幕200200的发光点(物理像素)==》css中 100*100px 此时设置为100*100px,正好完美对应显示 结论 在现在移动端中,例如:在iphone6中,需要显示多少px的图片,为了不被强 行放大,需要使用宽高为2倍分辨率的图片,显示更好的效果 而这种使用的宽高为2倍分辨率大小的图片,称之为2倍图 实际开发过程中还存在2倍图、3倍图、4倍图之类的,但是具体使用哪一种看 公司具体的需要 <font style=\"color:#FF0000;\">响应式设计原则(面试题)</font> <font style=\"color:#FF0000;\">渐近增强</font> <font style=\"color:#FF0000;\">基本需求==>更好体验</font> <font style=\"color:#FF0000;\">优雅降级</font> <font style=\"color:#FF0000;\">完备功能==>向下兼容</font> 移动优先的响应式布局采用的是渐进增强原则 二:移动开发的选择 由于移动端设备的屏幕尺寸大小不一,会出现:同一个元素,在两个不同的手 机上显示效果不一样(比例不同)。要想让同一个元素在不同词设备上,显示效 果一样,就需要适配,无论采用何种适配方式,中心原则永远是等比 <font style=\"color:#FF0000;\">(二)、移动端开发几个注意点</font> <font style=\"color:#FF0000;\">1、去除默认样式,可以用normalize.css(默认样式不去除,处理各浏览器对</font> <font style=\"color:#FF0000;\">默认样式的不同解析),resize.css(直接把所有的默认样式都去掉,要用,你</font> <font style=\"color:#FF0000;\">就自己重设)</font> <font style=\"color:#FF0000;\">2、盒子模型采用box-sizing的属性,border-box属性值</font> <font style=\"color:#FF0000;\">3、超链接点击高亮背景的效果需要去除</font> <font style=\"color:#FF0000;\">-webkit-tap-highlight-color:transparent;</font> 三:移动端常见实现方式 1、响应式页面兼容移动端 百分比,flex,rem,媒体查询, <font style=\"color:#FF0000;\">媒体查询(meidia Query):</font> <font style=\"color:#FF0000;\">作用:</font> <font style=\"color:#FF0000;\">1.使用@media查询,可以针对不同的媒体类型定义不同的样式</font> <font style=\"color:#FF0000;\">2.@media可以针对不同的屏幕尺寸设置不同的样式</font> <font style=\"color:#FF0000;\">3.当重制浏览器大小的过程中,页面也会根据浏览器的宽度和高度重新渲染页面</font> <font style=\"color:#FF0000;\">语法:</font> <font style=\"color:#FF0000;\">@media媒体类型 关键字 (媒体特性){css}</font> <font style=\"color:#FF0000;\">媒体类型(可以同时用多个媒体类型,用逗号隔开,这样他们之间就是或的关系</font> <font style=\"color:#FF0000;\">all所有设备</font> <font style=\"color:#FF0000;\">print打印设备或打印预览</font> <font style=\"color:#FF0000;\">screen带屏幕的设备(电脑,手机)</font> <font style=\"color:#FF0000;\">speech屏幕阅读器</font> <font style=\"color:#FF0000;\">关键字and not only来连接</font> <font style=\"color:#FF0000;\">将媒体类型或多个媒体特性连接到一起作为媒体查询的条件</font> <font style=\"color:#FF0000;\">and:可以将多个媒体特性连接到一起,相当于且的意思</font> <font style=\"color:#FF0000;\">not:排除某个媒体类型,相当于\"非\"的意思,可以省略</font> <font style=\"color:#FF0000;\">only:指定某个特定的媒体类型,可以省略</font> <font style=\"color:#FF0000;\">媒体特性(必须要有小括号)</font> <font style=\"color:#FF0000;\">width页面可见宽度</font> <font style=\"color:#FF0000;\">max-width视口的最大宽度(视口小于指定宽度时就生效,小于等于xxxpx)</font> <font style=\"color:#FF0000;\">min-width视口的最小宽度(视口大于指定宽度时就生效)</font> <font style=\"color:#FF0000;\">max-height最大高度</font> <font style=\"color:#FF0000;\">min-height最小高度</font> <font style=\"color:#FF0000;\">orientation:landscape横屏</font> <font style=\"color:#FF0000;\">orientation:portrait 竖屏</font> 常用的断点 样式切换的分界点,我们称其为断点,也就是网页的样式 bootstarp框架 https://www.bootcss.com/ 2、单独制作移动端页面 百分比,flex,rem,vw 1><font style=\"color:#FF0000;\">流式布局</font> <font style=\"color:#FF0000;\">就是百分比布局</font>,也称为非固定像素布局 通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩,不受固定像素的限制,内 容向两侧填充,主要是设置宽度 一般配合以下属性使用,免得盒子里面的元素,被挤下来 max-width最大宽度(max-height最大高度) min-width最小宽度(min-height最小高度) 2>、<font style=\"color:#FF0000;\">flex弹性布局</font> rem (1)、<font style=\"color:#FF0000;\">rem单位</font> 相对单位,相对于html根元素的字体大小,通过更改html文字的的大小,改变页面的 大小 (2)、rem适配方案 按照设计稿与设备宽度的比例,动态计算并设置html根标签的font-sizze大小(媒体查 询) css中,设计稿元素的宽、高、相对位置等取值,按照同等比例换算为rem)为单位的 值 根字体=(手机横向设备独立像素值=设计稿css像素值)/10 设计稿元素设计数值转成rem:设计值/(设计稿宽度/10) 例如:iPhone6,根字体=375/10=37.5px 以rem为单位,即1rem=37.5px 如果设计稿是375px 写一个100px*100px的盒子,用rem来表示1100px/ (375px/10) =2.667rem 设计稿是固定的,根据设计稿来开发页面,用rem这个相对单立去根据设计稿设计的 大小开发好页面后,再根据不同的手机设备独立像素去更改根标签字体的大小,就 可以实现响应式的变化 手机横向设备独立像素值,可以用flexible.js计算,用里面的js去做ト理 css元素的设计值换算用css中的Cssrem:Root Font Size去实现 px to rem & rpx & vw (cssrem) (3)、<font style=\"color:#FF0000;\">flexible.js</font> 1、<font style=\"color:#FF0000;\">手机淘宝团队出得移动端适配库,它的原理是将当前设备(设备独立像素=css像</font> <font style=\"color:#FF0000;\">素)划分为10等份,但不同设备下,比例还是一致的。</font> <font style=\"color:#FF0000;\">只要确定当前html文字大小就可以了.</font> 4>、混合布局(主流) 综上所有,一起使用,选取一种主要技术选型,其他技术为辅助(推荐 rem适配一移动端开发的步骤 第一步:拿到多大的设计稿,将root font size改成:设计稿的大JV10 第二步:引入flexable.js,会动态的去修改html的字体大小 第三步:正常根据设计稿的大小去开发,将所有的px值换算为rem的值 5>、vw、vh(未来的趋势) <font style=\"color:#FF0000;\">vw也是百分比,只不过这个百分比只参考设备视口</font> <font style=\"color:#FF0000;\">vw (Viewport's width):1vw等于视口宽度的1%</font> <font style=\"color:#FF0000;\">vh (Viewport's height):1vh等于视口高度的1%</font> vmin:vw和vh中的较小值 vmax:选取vw和vh中的最大值 (1)、750的设计稿:html{font-size:13.3333vw} 1vw表示1%的屏幕宽度,而我们的设计稿通常是750px的,屏幕一共是100vw,对应的 就是750px,1vw=7.5px 那么1px就是0.13333vw, 同时我们知道另一个单位rem,rem是相对于html元素字体大小,放了方便计算,我们自 定义html字体大小为100px 通过上面的计算结果我们知道1px是0.13333vw,那么100px就是13.333vw了 这样后面的用rem就很好计算了。13.333vw对应的是100px,然后我们就可以很偷快的 写rem单位了,由于自定义的1rem=100px, 书写代码时,就是(设计图元素大小/100),单位是rem 如果750的设计稿设计一个盒子大小是200px,里面有字体大小50px,那么对应的就 是,盒子宽高2rem,字体大小是0.5rem (2)、1080设计稿:html{font-size:9.259vw} 如果设计稿时1080px,屏幕是100vw,那么对应的1px=0.09259vw,rem根标签依然自 定义取100px,那么就是1rem=100px,那么1rem=9.259vw 如果1080的设计稿设计一个盒子大小是200px,里面有字体大小50px,那么对应的就 是,盒子宽高2rem,字体大小是0.5rem 总结: 虽然还是vw布局,但还是用rem去写 1、无关屏幕的大小,反正100w,就是屏幕的100%,用屏幕的大小作为固定值换算 相对单位 2、自定义一个rem跟px之间的换算比值,为了好算一般是1rem=100px,计算出vw跟 rem,px之间的关系 例如750的设计稿:1font-size=100px=1rem=13.3333vw 3、后面750设计稿上的所有尺寸都用rem来算。例如200px*200px的盒子,就是 2rem2rem的盒子,也就是26.666vw26.666vw的盒子。 用vw去开发 1、看设计箱是多大,自定义1rem=100px,然后1px=xxxvw, 将html{font-size:xxxvw} 2、去更改root font size,更改1rem=100px 3、根据设计稿的大小,将px值写成rem 总结: <font style=\"color:#FF0000;\">都是一个绝对值为参考值</font> <font style=\"color:#FF0000;\">flexable.js是以设备独立像素为绝对值,去算rem的值</font> <font style=\"color:#FF0000;\">vw是设备的视口的宽度为绝对值,去算rem的值</font> <font style=\"color:#FF0000;\">最终都是把设计稿中的px换算成rem</font> <font style=\"color:#FF0000;\">less是一门css的预处理语言</font> -less是一个css的增强版，通过less可以编写更少的代码，实现更强大的样式 -less中添加了许多的新特性，像对变量的支持，对mixin的支持。。。。 -less的语法大体上和css语法一致，但less中添加了许多对css的拓展 所以浏览器无法直接执行less代码，要执行必须将less转换为css，然后由浏览器执行 <font style=\"color:#FF0000;\"> -less即可以在客户端上运行，也可以借助Node.js在服务端运行</font> <!-<font style=\"color:#FF0000;\">-第二种 easy less 引入我的css --></font> <!-- <link rel=\"stylesheet\" href=\"./less语法.css\"> --> <!-- <font style=\"color:#FF0000;\">第三种外部引入less --></font> <link rel=\"stylesheet/less\" type=\"text/less\" href=\"./less语法.less\"> <!<font style=\"color:#FF0000;\">-- 第一种方式直接在内容写，要引入less.js --></font> <!-- <style type=\"text/less\"> </style> --> <!-- 第三种引入方法 --> <!--运行时编译 --> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/less.js/3.11.1/less.min.js\"></script> <!-- vscode 插件 Easy LESS 插件 --> <font style=\"color:#FF0000;\">// 定义变量1</font> <font style=\"color:#FF0000;\">@color:yellow;</font> <font style=\"color:#FF0000;\">@width:300px;</font> @border:1px solid #000; #wrap{ width: @width; height: @height; background-color: @color; border:@border; } @width:300px; @height:300px; @color:red; @border:10px double black; <font style=\"color:#FF0000;\">//声明一个变量</font> <font style=\"color:#FF0000;\">@sector:#wrap; //选择器</font> <font style=\"color:#FF0000;\">@w:width; //属性名</font> <font style=\"color:#FF0000;\">@h:height;</font> <font style=\"color:#FF0000;\">@{sector}{ //选择器这里必须加上花括号包裹</font> <font style=\"color:#FF0000;\"> @{w}:@width;</font> @{h}:@height; border:@border; background-color:@color; margin:0 auto; } @url:\"../img/img1.png\"; // .warp{ <font style=\"color:#FF0000;\">background: url(../img.png) no-repeat;</font> border: 1px solid @color; // } .@{selector}{ width: 100px; height: 100px; <font style=\"color:#FF0000;\"> background: url(@url) no-repeat;</font> border: 1px solid @color; } @var: 0px; <font style=\"color:#FF0000;\">// 变量是块级作用域</font> .class { @var: 10px; .brass { @var: 20px; width: @var; //30 <font style=\"color:#FF0000;\"> 读完块级作用域后，再去确定变量值</font> @var: 30px; } <font style=\"color:#FF0000;\"> width: @var; //10</font> } *{ margin: 0; padding: 0; } ul{ background-color: #333; overflow: hidden; height: 50px; line-height: 50px; width: 400px; margin: 50px auto; li{ list-style: none; float: left; width: 25%; text-align: center; a{ text-decoration: none; color: white; } <font style=\"color:#FF0000;\"> // &表示上一级选择器</font> &:hover{ background-color:tomato; } <font style=\"color:#FF0000;\">//带参数的混合 </font> <font style=\"color:#FF0000;\">// 行参</font> <font style=\"color:#FF0000;\">.base(@w,@h,@color</font>){ width: @w; height: @h; background-color: @color; margin-bottom: 10px } // <font style=\"color:#FF0000;\">以下传入实参</font> #box1{ <font style=\"color:#FF0000;\"> .base(100px,100px,red);</font> } #box2{ .base(200px,200px,pink); } <font style=\"color:#FF0000;\">//带参数的混合 </font> <font style=\"color:#FF0000;\">// 行参</font> <font style=\"color:#FF0000;\">.base(@w:100px,@h:100px,@color:yellow)</font>{ width: @w; height: @h; background-color: @color; margin-bottom: 10px } <font style=\"color:#FF0000;\">// 以下传入实参</font> #box1{ <font style=\"color:#FF0000;\"> .base(100px,100px,red);</font> } #box2{ .base(200px,200px,pink); }"
    },
    {
      "title": "js",
      "path": "JavaScriptES6+/js.md",
      "category": "JavaScriptES6+",
      "tags": [],
      "date": null,
      "description": "编程就是计算机为了解决某个问题，而使用某种程序设计语言编写程序设计语言编写程序代码，并最终得到结果的过程\n\n计算机程序：就是计算机所执行的一系列的指令集合，而程序全部都是用我们所掌握的语言来编写的。\n\n注意：任何能够执行代码的设备都是计算机，可能是智能手机、ATM机、黑莓PI、服务器等\n\n计算机语言指用于人与计算机之间通讯的语言，它是人与计算机之间传递信息的媒介\n\n计算机语言的种类非常多，总体来说",
      "content": "一、计算机基础 1、编程语言 编程就是计算机为了解决某个问题，而使用某种程序设计语言编写程序设计语言编写程序代码，并最终得到结果的过程 计算机程序：就是计算机所执行的一系列的指令集合，而程序全部都是用我们所掌握的语言来编写的。 注意：任何能够执行代码的设备都是计算机，可能是智能手机、ATM机、黑莓PI、服务器等 计算机语言指用于人与计算机之间通讯的语言，它是人与计算机之间传递信息的媒介 计算机语言的种类非常多，总体来说分为三类：机器语言，汇编语言，和高级语言三大类 <font style=\"color:#F33232;\">机器语言</font>是计算机最终执行的语言，它由0和1组成的二进制数，二进制数是计算机语言的基础 <font style=\"color:#F33232;\">汇编语言</font>和机器语言实质是相同的，都是对硬件操作，只不过指令采取了英文缩写的标志符，容易记忆和识别 <font style=\"color:#F33232;\">高级语言</font>主要相对于低级语言而言的，它并不是特指某一种具体的语言，而是包括很多编程语言，常用的高级语言像C语言，java，C#，PHP，JS，go语言等 2、计算机基础 计算机的组成： 硬件： 输入设备（鼠标、键盘、手写板、摄像头等） 输出设备（显示器、打印机、投影仪等）， CPU（负责处理数据与运算） 硬盘和内存（负责存储数据，硬盘永久存储数据，内存暂时存储数据） 软件：系统软件（windows、linux、macOS），应用软件（浏览器、QQ、VSCode、Sublime、Word） 数据存储 计算机内部使用二进制0和1表示数据，所有的数据、所有的程序包含操作系统都是以二进制的形式放在硬盘和内存中的 数据的存储单位 bit<byte<kb<Gb<Tb<···· 位（bit）：1bit可以保存一个0或1（最小的存储单位） 字节（byte）：1B=8b 千字节（kb）：1kb=1024b 兆字节（mb）：1mb=1024kb 吉字节（gb）：1gb=1024mb 太字节（tb）：1tb=1024gb 二、ES核心 第一节、初始JS （一）、js的简介 1、JS是什么 JS历史：JS是布兰登·艾奇（Brendan Eich）花了10天的时间设计的，由最初的liveScript改名为JavaScript； <font style=\"color:#FF0000;\">JS是运行在客户端的脚本语言；</font> <font style=\"color:#FF0000;\">脚本语言：不需要编译，运行过程中由js解释器（js引擎）逐行来进行解释并执行</font>； <font style=\"color:#FF0000;\">JS可以基于Node.js技术进行服务器端编程</font> 2、JS能做什么 表单动态校验（密码强度监测）、网页特效、服务端开发（Node.js）、桌面程序（Electron）、App、控制硬件-物联网、游戏开发 3、浏览器执行JS <font style=\"color:#FF0000;\">浏览器分成两部分：渲染引擎和JS引擎</font> 渲染引擎：用来<font style=\"color:#FF0000;\">解析html和css</font>，所称<font style=\"color:#FF0000;\">内核</font> JS引擎：也称为JS解释器。用来<font style=\"color:#FF0000;\">读取</font>网页中的<font style=\"color:#FF0000;\">JavaScript代码</font>，对其处理后<font style=\"color:#FF0000;\">运行</font> 浏览器本身并不会执行JS代码，而是通过设置JavaScript引擎（解释器）来执行JS代码。JS引擎执行代码时逐行解释每一句源码（转成机器语言），然后由计算机去执行。所以JS语言归为脚本语言，会逐行解释执行 4、JS的组成 js包含三个部分： （1）、ECMAScript （ JavaScript的核心 是规范标准） ——描述了语言的<font style=\"color:#FF0000;\">基本语法</font>(var、for、if、array等)和数据类型(数字、字符串、布尔、函数、对象(obj、[]、{}、null)、未定义)。 ——只学习基础语法，做不了常用的网页交互效果，为后面的内容打基础，做铺垫 （2）、DOM （Document Object Model文档对象模型，可以去操作网页） <font style=\"color:#F33232;\">Document(文档)</font> 指的是XML和HTML的页面，当你创建一个页面并且加载到Web浏览器中， DOM就在幕后悄然而生，它会把你编写的网页文档转换成一个文档对象。 <font style=\"color:#F33232;\">Object(对象)</font> js对象大致可以分为以下三种： 用户定义对象，例如：var obj = {} 内置对象，无需创建，可直接使用，例如：Array、Math和Data等 宿主对象，浏览器提供的对象，例如:window、document DOM中主要关注的就是document， document对象的主要功能就是处理网页内容。 <font style=\"color:#F33232;\">Model（模型）</font>代表着加载到浏览器窗口的当前网页，可以利用JavaScript对它进行读取 （3）、BOM 浏览器对象模型，操作浏览器 5、js输入输出语句 （1）、js注释 多行注释，注释中的内容不会被执行，但可以在源代码中查看 默认的快捷键: Ctrl+shift+/ 单行注释，// 只对后面的内容有效 默认快捷键：ctrl+/ 注释作用： 养成良好的编写注释的习惯，可以通过注释对代码进行一些调试 （2）、输入输出语句 为了方便信息的输入输出，JS中提供了一些输入输出语句 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // 1、控制浏览器</font><font style=\"color:#FF0000;\">弹出一个警告框</font> <font style=\"color:#595959;\"> // </font><font style=\"color:#FF0000;\">alert</font><font style=\"color:#595959;\"> 警告 告诉浏览器弹出一个警告框</font> <font style=\"color:#595959;\"> // alert(\"这是我的第一行js代码\");</font> <font style=\"color:#595959;\"> //2、</font><font style=\"color:#FF0000;\">让计算机在页面中输出一个内容</font> <font style=\"color:#595959;\"> // </font><font style=\"color:#FF0000;\">document.write(\"\")</font><font style=\"color:#595959;\">;可以向body中输出一个内容</font> <font style=\"color:#595959;\"> // document.write(\"看我出不出来~~~\");</font> <font style=\"color:#595959;\"> // 3、</font><font style=\"color:#FF0000;\">向控制台输出一个内容</font> <font style=\"color:#595959;\"> // </font><font style=\"color:#FF0000;\">console.log(\"\")</font><font style=\"color:#595959;\">的作用是向控制台输出一个内容</font> <font style=\"color:#595959;\"> // console.log(\"你猜我在哪里出来呢\");</font> <font style=\"color:#595959;\"> // 4、</font><font style=\"color:#FF0000;\">用户输入数据</font> <font style=\"color:#595959;\"> // </font><font style=\"color:#FF0000;\">window.prompt(\"请输入数字\");</font> <font style=\"color:#595959;\"> //js代码是从上到下，一行行执行的，</font><font style=\"color:#FF0000;\">有执行顺序</font> <font style=\"color:#595959;\"> </script></font> 配置代码片段 设置---用户代码片段--JavaScript.json文件 6、js书写位置（4种位置） （1）、第一种方式： 可以将js 代码编<font style=\"color:#FF0000;\">写到标签的事件属性中</font>，例如onclick属性中，当我们点击按钮时，js代码才会执行 <font style=\"color:#595959;\"><button onclick=\"alert('你点我了')\">点我一下</button></font> <font style=\"color:#595959;\"><!-- 可以将js代码写在超链接的href属性中，这样当点击超链接时，会执行js代码 --></font> <font style=\"color:#595959;\"><a href=\"JavaScript:alert('你也点我了');\">你也点我一下</a></font> 注意： 写在标签的属性中，但是他们属于结构与行为耦合，不方便维护，不推荐使用 （2）、第二种方式： 可以将js代码编<font style=\"color:#FF0000;\">写到body位置，script标签里</font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> alert(\"我是script标签中内部的代码\");</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> </body></font> （3）、第三种方式： 可以将<font style=\"color:#FF0000;\">js代码编写到头部位置，script标签里</font> <font style=\"color:#595959;\"><head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>JS代码书写位置</title></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> alert(\"我是script标签中内部的代码\");</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"></head></font> （4）、第四种方式 可以将js编写到<font style=\"color:#FF0000;\">外部js文件</font>中，然后<font style=\"color:#FF0000;\">通过script标签引入</font> 优势：可以在不同的页面中同时引用，也可以利用到浏览器的缓存机制，推荐使用方式 注意：这个script标签一旦用于引入外部文件了，就不能编写代码了，即使编写了，浏览器也不能识别 <font style=\"color:#595959;\"><head></font> <font style=\"color:#595959;\"> <!-- 第四种方式--></font> <font style=\"color:#595959;\"> <script src=\"./script.js\"></script></font> <font style=\"color:#595959;\"> </head></font> 7、js基本语法 （1）、js中严格<font style=\"color:#FF0000;\">区分大小写</font> （2）、js中每一条<font style=\"color:#FF0000;\">语句以分号（;）结尾</font> -如果不写分号，浏览器会自动添加，但会消耗一些系统资源 而且有时候，浏览器会加错分号，所以在开发中分号基本都写 （3）、js中会<font style=\"color:#FF0000;\">自动忽略多个空格和换行</font>，所以我们可以利用空格和换行对代码进行格式化 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> console.log(\"控制台输出\");</font> <font style=\"color:#595959;\"> // Console.log('控制台输出'); 不能执行</font> <font style=\"color:#595959;\"></script></font> （二）、js变量和字面量 1、字面量： 字面量是在源代码中一个固定值的表示法，通俗来说，字面量一些不可更改的，比如：1 2 3 4 .....，字面量都是可以直接使用的，但是我们一般都不会直接使用字面量 //见名知意的符号 2、变量： （1）什么是变量 <font style=\"color:#FF0000;\">变量</font>就是用来<font style=\"color:#FF0000;\">存放数据的容器</font>。可以用来<font style=\"color:#FF0000;\">保存字面量</font>，而且变量的值可以任意改变，变量更加方便我们使用，所以开发中，都是通过变量去保存一个字面量，并且可以通过变量对字面量进行描述 我们可以通过变量名获取数据，甚至数据可以修改 变量的<font style=\"color:#FF0000;\">本质</font>是<font style=\"color:#FF0000;\">程序在内存中申请的一块用来存放数据的空间</font> （2）声明变量 声明变量：用<font style=\"color:#FF0000;\">var</font>关键字，<font style=\"color:#FF0000;\">声明变量</font>，使用该关键字后，计算机会自动给这个变量分配空间 var name； //声明一个名为name的变量，可通过变量名来访问内存中分配的空间 赋值： name='张三'；// = 用来把右边的值赋给左边的变量空间中，代表赋值的意思 输出结果： console.log(name); （3） 声明初始化 <script> //<font style=\"color:#FF0000;\">声明跟赋值同时进行</font> var b = 789; </script> （4）变量语法注意 1>更新变量： 一个变量变重新赋值后，它原有的值就会被覆盖，<font style=\"color:#FF0000;\">变量值将以最后一次赋值为准</font> 2>声明多个变量 只需要写一个var，<font style=\"color:#FF0000;\">多个变量</font>名之间使<font style=\"color:#FF0000;\">用</font>英文<font style=\"color:#FF0000;\">逗号隔开</font> var age = 80, height = 180; console.log(age, height);//80,180 3>声明特殊： <font style=\"color:#FF0000;\">var c; 1、只声明不赋值，输出undefined</font> console.log(c);//undefined <font style=\"color:#FF0000;\">2、输出未声明变量，报错</font> console.log(d);//报错 <font style=\"color:#FF0000;\">3、 未使用var声明，浏览器纠错，默认使用</font> e=11;console.log(e);//11 （5）变量的命名规范（标志符规范） 在js中所有的可以由我们自主命名的，都可以称为标识符， 例如：变量名、函数名、属性名都属于标识符 命名一个标识时需要遵守如下的 规则（必须遵守） a: 标识符号可以含有<font style=\"color:#FF0000;\">字母、数字、$、_ </font> b: 标识符<font style=\"color:#FF0000;\">不能以数字开头</font> c: 标识符<font style=\"color:#FF0000;\">不能是</font>ES中的<font style=\"color:#FF0000;\">关键字或者保留字</font> eg；var if class static 规范（可做可不做）： a: 标识符一般都采用驼峰命名法 首字母小写，每个单词的开头字母大写，其余字母小写 eg:helloWorld xxxYyyZzz b: js底层保存标识符，包含中文，但是千万不要这么用。 c: 变量名字要见名知意 （一）、数据类型 1、为什么需要数据类型 在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，<font style=\"color:#FF0000;\">充分利用存储空间</font>，于是定义了不同的数据类型。简单来说，数据类型就是数据的类别型号 2、变量的数据类型 <font style=\"color:#FF0000;\">JS是一种弱类型或者动态语言</font>。这就意味着不用提前声明变量的类型，在程序运行过程中，变量的数据类型是根据等号右边的值来自动确定的。 <font style=\"color:#FF0000;\">JS拥有动态类型，同时也意味着相同的变量可用作不同的类型</font> <font style=\"color:#000000;\">3、数据类型的分类</font> <font style=\"color:#000000;\">简单（一般）数据类型（Number、String、Boolean、Udefined、Null）</font> <font style=\"color:#000000;\">复杂（引用）数据类型（Object）</font> <font style=\"color:#000000;\">后续还会再增加别的数据类型....</font> <font style=\"color:#000000;\">（二）、简单数据类型</font> | 简单数据类型 | 解释说明 | 默认值 | | --- | --- | --- | | Number | 数字型，包含整数值和浮点型，如12，1.2 | 0 | | Bollean | 布尔值类型，true、false，等价于1、0 | false | | String | 字符串类型，如'王二麻'，字符串都带引号 | '' | | Undefined | 未定义，例如： var a；此时a=undefined | undefined | | Null | 空值；例如：var a=null | null | 1、数字型 Number （1）、数字型进制 常见的进制有二进制、八进制、十进制、十六进制，在JS中，<font style=\"color:#FF0000;\">八进制前面加0，十六进制前面加0x</font> （2）、数字型范围（JS中数值的最大值和最小值） <font style=\"color:#FF0000;\">Number.MAX_VALUE </font> //1.7976931348623157e+308 如果使用Number表示的数字超过了最大值，则会返回一个<font style=\"color:#FF0000;\">Infinity</font> 表示<font style=\"color:#FF0000;\">正无穷</font> 使用typeof 检查infinity也会返回number <font style=\"color:#FF0000;\">Number.MIN_VALUE</font> <font style=\"color:#FF0000;\">大于0的最小值</font> //5e-324 <font style=\"color:#FF0000;\">NaN </font>是一个<font style=\"color:#FF0000;\">特殊的数字</font>，表示Not A Number， <font style=\"color:#FF0000;\">非数值</font> 使用<font style=\"color:#FF0000;\">typeof 检查NaN也会返回number</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var a = 123;</font> <font style=\"color:#595959;\"> a = 456.789; //下面的数值会覆盖上面的</font> <font style=\"color:#595959;\"> var b = 123; //这是数字123</font> <font style=\"color:#595959;\"> console.log(typeof a); //number</font> <font style=\"color:#595959;\"> a = Number.MAX_VALUE; //最大值</font> <font style=\"color:#595959;\"> // console.log(a)</font> <font style=\"color:#595959;\"> a = Number.MIN_VALUE; //最小值</font> <font style=\"color:#595959;\"> // console.log(a)</font> <font style=\"color:#595959;\"> a = \"abc\" * \"bcd\";</font> <font style=\"color:#595959;\"> //console.log(a); //NaN</font> <font style=\"color:#595959;\"> </script></font> （3）、数字型计算 在Js中整数的运算基本可以保证精确 如果使用JS进行浮点元素，可能得到一个不精确的结果 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var c = 1 + 2; </font> <font style=\"color:#595959;\"> console.log(c);//3</font> <font style=\"color:#595959;\"> var d = 0.1 + 0.2; //</font><font style=\"color:#FF0000;\">如果使用JS进行浮点元素，可能得到一个不精确的结果</font> <font style=\"color:#595959;\"> console.log(d);//0.30000000000000004</font> <font style=\"color:#595959;\"> </script></font> （4）、isNaN()方式 用来判断NaN，并返回一个布尔值，如果判断的是NaN，则返回true，如果判断的不是NaN，则返回false console.log(isNaN(123));//false <font style=\"color:#FF0000;\"> //数字返回true</font> console.log(isNaN(NaN));//true <font style=\"color:#FF0000;\"> //非数字返回flase</font> （5）、typeof 来<font style=\"color:#FF0000;\">检查</font>一个<font style=\"color:#FF0000;\">变量的类型,并输出</font> 语法：<font style=\"color:#FF0000;\">typeof 变量</font> 检查字符串时，会返回string; 检查数值时，会返回number 2、字符串String （1）、基本语法 字符串型可以是<font style=\"color:#FF0000;\">引号中的任意文本</font>，其语法为<font style=\"color:#FF0000;\">双引号“”</font>和<font style=\"color:#FF0000;\">单引号‘’</font>，一般js中建议用单引号‘’，js<font style=\"color:#FF0000;\">可</font>以用单引号嵌套双引号，或者用双引号嵌<font style=\"color:#FF0000;\">套单引号</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // 单双引号嵌套</font> <font style=\"color:#595959;\"> var res = '古诗:\"锄禾日当午\"';</font> <font style=\"color:#595959;\"> console.log(res);</font> <font style=\"color:#595959;\"> </script></font> （2）、字符串转义符 转义符都是<font style=\"color:#FF0000;\">\\开头的</font>，<font style=\"color:#FF0000;\">写在当单双引号里面</font>的，常用的转义符及其说明如下 | 转义符 | 解释说明 | | --- | --- | | \\n | 换行符，n表示newline的意思 | | \\\\ | 斜杠\\ | | \\' | '单引号 | | \\\" | \"双引号 | | \\t | tab缩进 | | \\b | 空格，b是blank的意思 | <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //转义字符</font> <font style=\"color:#595959;\"> var str = \"hello\";</font> <font style=\"color:#595959;\"> str = \" \\''你好 \";</font> <font style=\"color:#595959;\"> console.log(str,'11');</font> <font style=\"color:#595959;\"> </script></font> （3）、字符串长度 字符串是由若干字符组成的，这些字符的数量就是字符串的长度。<font style=\"color:#FF0000;\">length属性</font>可以<font style=\"color:#FF0000;\">获取</font>整个<font style=\"color:#FF0000;\">字符串的长度</font> （4）、字符串拼接 多个字符串之间可以使<font style=\"color:#FF0000;\">用+</font>进行<font style=\"color:#FF0000;\">拼接</font>，其拼接方式为<font style=\"color:#FF0000;\">字符串+任意类型=拼接新字符串 ；</font> <font style=\"color:#000000;\">拼接前会把字符串相加的任意类型转成字符串，再拼接成一个新的字符串；</font> <font style=\"color:#000000;\">（5）、字符串拼接变量</font> <font style=\"color:#FF0000;\">字符串和变量拼接，变量不能写在引号里面，需要用 加号 拼接变量</font> eg:\"你好\"+age+\"hlleo\" <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var age = 18;</font> <font style=\"color:#595959;\"> var str = \"我今年18岁了\";</font> <font style=\"color:#595959;\"> str = \"我今年\" + age + \"岁了\";</font> <font style=\"color:#595959;\"> console.log(str);</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">3、布尔值 Boolean</font> <font style=\"color:#FF0000;\">布尔值</font>只有两个值，<font style=\"color:#FF0000;\">用来做逻辑判断</font> <font style=\"color:#FF0000;\">true</font> -表示<font style=\"color:#FF0000;\">真</font> <font style=\"color:#FF0000;\">false</font> -表示<font style=\"color:#FF0000;\">假 </font> <font style=\"color:#FF0000;\">使用typeof检查一个布尔值时，会返回boolean</font> <font style=\"color:#FF0000;\">当进行数值运算的时候，true为1，false为0</font> 4、未定义 Undefined <font style=\"color:#FF0000;\">Undefined类型的值只有一个，就是undefined</font> 当声明了一个变量，但是并不给变量赋值时，它的值就是undefined 使用typeof检查一个undefined时也会返回undefined <font style=\"color:#FF0000;\">当进行数值运算时，结果为NaN</font> 5、 空值Null null这个值专门用来<font style=\"color:#FF0000;\">表示空的对象</font> <font style=\"color:#FF0000;\">使用typeof检查一个null值时，会返回object</font> <font style=\"color:#FF0000;\">当进行数值运算时，null为0</font> （三）、数据类型转换 使用<font style=\"color:#FF0000;\">表单、prompt获取</font>过来的<font style=\"color:#FF0000;\">数据</font>默认<font style=\"color:#FF0000;\">是字符串类型</font>的，此时就不能直接进行数值运算，需要将字符串转为数值类型 <font style=\"color:#FF0000;\">强制类型转换：指将一个数据类型强制转换为其他的数据类型</font> 通常三种转换 转换为字符串类型 转换为数字型 转换为布尔型 1、转换为字符串类型 （1）、toString()方法 -调用被转换数据类型的toString()方法 语法：<font style=\"color:#FF0000;\">变量.toString()</font> -该方法不会影响到原变量，它会<font style=\"color:#FF0000;\">将转换的结果返回</font> 语法：<font style=\"color:#FF0000;\">str=变量.toString()</font> <font style=\"color:#FF0000;\">-注意：null和undefined这两个值没有toString的方法，如果调用他们会报错</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var a = 123;</font> <font style=\"color:#595959;\"> //调用a的toString()方法</font> <font style=\"color:#595959;\"> var b = a.toString(); //将a赋值转换结果赋值给b，再检查b</font> <font style=\"color:#595959;\"> a = a.toString(); //也可将a赋值转换结果赋值给a，再检查a</font> <font style=\"color:#595959;\"> console.log(typeof a);</font> <font style=\"color:#595959;\"> console.log(a);</font> <font style=\"color:#595959;\"> // 再举例</font> <font style=\"color:#595959;\"> var c = true;</font> <font style=\"color:#595959;\"> c = c.toString();</font> <font style=\"color:#595959;\"> console.log(typeof c);</font> <font style=\"color:#595959;\"> console.log(c);</font> <font style=\"color:#595959;\"> /* var d=</font><font style=\"color:#FF0000;\">null</font><font style=\"color:#595959;\">;</font> <font style=\"color:#595959;\"> d=d.</font><font style=\"color:#FF0000;\">toString()</font><font style=\"color:#595959;\">;</font> <font style=\"color:#595959;\"> console.log(</font><font style=\"color:#FF0000;\">typeof d</font><font style=\"color:#595959;\">)//</font><font style=\"color:#FF0000;\">会报错</font> <font style=\"color:#595959;\"> var e=</font><font style=\"color:#FF0000;\">undefined;</font> <font style=\"color:#595959;\"> e=e.</font><font style=\"color:#FF0000;\">toString();</font> <font style=\"color:#595959;\"> console.log</font><font style=\"color:#FF0000;\">(typeof e)</font><font style=\"color:#595959;\"> */ //</font><font style=\"color:#FF0000;\">会报错</font> <font style=\"color:#595959;\"> </script></font> （2）String() -调用<font style=\"color:#FF0000;\">String()函数</font>,并将<font style=\"color:#FF0000;\">被转换的数据作为参数传递给函数</font>, 语法：<font style=\"color:#FF0000;\">String(变量)</font> -使用String（）函数做强制类型转换时，对于Number和Boolean实际上就是调用的toString的方法 但对于null和undefined,就不会调用toString()方法， 它会将null直接转换为\"null\"， 将undefined 直接转换为\"undefined\" <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> a = 789;</font> <font style=\"color:#595959;\"> //调用String()函数，来将a转换为字符串</font> <font style=\"color:#595959;\"> a = String(a);</font> <font style=\"color:#595959;\"> a = null;</font> <font style=\"color:#595959;\"> a = String(a);</font> <font style=\"color:#595959;\"> a = undefined;</font> <font style=\"color:#595959;\"> a = String(a);</font> <font style=\"color:#595959;\"> console.log(a);</font> <font style=\"color:#595959;\"> console.log(typeof a);</font> <font style=\"color:#595959;\"> </script></font> （3）拼接字符串（<font style=\"color:#FF0000;\">隐式转换</font>） <font style=\"color:#FF0000;\">和字符串拼接的结果都是新字符串</font>,语法：<font style=\"color:#FF0000;\">变量+''</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var f=123</font> <font style=\"color:#595959;\"> f=f+''</font> <font style=\"color:#595959;\"> console.log(f,typeof f);</font> <font style=\"color:#595959;\"> </script></font> 2、转换为数字型（重点） （1）、 使用Number()函数 字符串-->数字 1:如果是<font style=\"color:#FF0000;\">纯数字</font>的字符串，则<font style=\"color:#FF0000;\">直接</font>将其<font style=\"color:#FF0000;\">转换</font>为数字 2:如果字符串中<font style=\"color:#FF0000;\">有非法的数字</font>的内容，<font style=\"color:#FF0000;\">则转换为NaN</font> 3:如果字符串是一个<font style=\"color:#FF0000;\">空串</font>，或者全是空格的字符串，则<font style=\"color:#FF0000;\">转换为0</font> 布尔值--->数字 true--1 false--0 Null --->数字 0 <font style=\"color:#FF0000;\">Undefined --->数字 NaN</font> （2）、parseInt() 可以将一个<font style=\"color:#FF0000;\">字符串</font>中的<font style=\"color:#FF0000;\">有效的整数取出来</font>，<font style=\"color:#FF0000;\">转换为Number</font> 语法：<font style=\"color:#FF0000;\">parseInt(变量)</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> a='123px';</font> <font style=\"color:#595959;\"> a=parseInt(a)//调用parseInt()函数，将a转换为Number</font> <font style=\"color:#595959;\"> </script></font> （3）、parseFloat() 把一个字符串<font style=\"color:#FF0000;\">转换</font>为一个<font style=\"color:#FF0000;\">浮点数数值型</font> 语法：<font style=\"color:#FF0000;\">parseFloat(变量)</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> a='123.345px';</font> <font style=\"color:#595959;\"> a=parseFloat(a); </font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#FF0000;\">注意：如果对非String使用parseFloat()跟parseInt(),它会先将其转换为String，然后再操作</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> a=true;</font> <font style=\"color:#595959;\"> a=parseInt(a);//NaN </font> <font style=\"color:#595959;\"> </script></font> （4）、js隐式转换 <font style=\"color:#FF0000;\">利用算术运算</font><font style=\"color:#FF0000;\"> </font><font style=\"color:#FF0000;\">-</font><font style=\"color:#FF0000;\"> </font><font style=\"color:#FF0000;\">* / 隐式转换为数值型</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> a = \"123\";</font> <font style=\"color:#595959;\"> a = a - 0;//123</font> <font style=\"color:#595959;\"> a = a / 1;//123</font> <font style=\"color:#595959;\"> a = a * 1;//123</font> <font style=\"color:#595959;\"> console.log(a, typeof a); </font> <font style=\"color:#595959;\"> </script></font> 3、转换为布尔型 <font style=\"color:#FF0000;\">Boolean()函数</font>，将其他类型<font style=\"color:#FF0000;\">转成布尔值</font> <font style=\"color:#FF0000;\">数字-->布尔除了0跟NaN是false，其他的都是true</font> <font style=\"color:#FF0000;\">字符串-->布尔除了空串是false，其余都是true</font> <font style=\"color:#FF0000;\">null和undefined都会转换为false</font> 对象会转换为true <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var a = 123; //true</font> <font style=\"color:#595959;\"> a = -123; //true</font> <font style=\"color:#595959;\"> a = 0; //flase</font> <font style=\"color:#595959;\"> a = NaN; //flase</font> <font style=\"color:#595959;\"> a = Boolean(a); //调用Boolean()函数来将a转换为布尔值</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> a = \"false\"; //true</font> <font style=\"color:#595959;\"> a = \" \"; //false</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> a = null; //false</font> <font style=\"color:#595959;\"> a = Boolean(a);</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> a = undefinde; //false</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> console.log(typeof a);</font> <font style=\"color:#595959;\"> console.log(a);</font> <font style=\"color:#595959;\"> </script></font> 算术运算中的隐式转换 加法运算 - 当一个字符串与其他类型的值进行加法运算时，其他类型的值会被隐式转换为字符串，然后进行字符串拼接。 <font style=\"color:#FF0000;\">当两个数字类型的值进行加法运算时，正常进行数学加法。</font> 如果一个操作数是对象，JavaScript会尝试调用对象的valueOf()方法或toString()方法来获取一个可以用于加法运算的值，然后再进行转换。 减法、乘法、除法运算 - 当进行减法、乘法、除法运算时，如果<font style=\"color:#FF0000;\">操作数之一不是数字类型</font>，JavaScript会尝试<font style=\"color:#FF0000;\">将其隐式转换为数字类型。</font> 比较运算中的隐式转换 相等比较（<font style=\"color:#FF0000;\">==</font>） - 当使用==进行比较时，如果操作数的类型不同，JavaScript会进行隐式转换后再比较。 不等比较（<font style=\"color:#FF0000;\">!=</font>） - 与相等比较类似，不等比较!=也会进行隐式转换。 大于<font style=\"color:#FF0000;\">（>）</font>、小于<font style=\"color:#FF0000;\">（<）</font>比较 - 在进行大小比较时，如果操作数类型不同，JavaScript会尝试将它们转换为数字类型后再比较。 ### 逻辑运算中的隐式转换 逻辑与（<font style=\"color:#FF0000;\">&&</font>）和逻辑或（<font style=\"color:#FF0000;\">||</font>）运算 在逻辑与和逻辑或运算中，操作数会被隐式转换为布尔值进行逻辑判断，但最终返回的值是操作数本身（不一定是布尔值）。 逻辑非（<font style=\"color:#FF0000;\">!</font>）运算 - 逻辑非运算会将操作数隐式转换为布尔值，然后取反。 运算符也叫操作符，通过运算符可以对一个值或者多个值进行运算，并获取运算结果，常用于实现赋值、比较、执行算数运算符等功能的符号。 比如typeof 就是一个运算符，可以获得一个值的类型,它会将该值的类型以字符串的形式返回，typeof的返回值，用来描述类型的number string boolean undefined object 常用运算符如下： 1、算数运算符 （1）、注意： 1:当对非Number类型进行运算时，会将这些值转换为Number，然后再运算 ，- *，/ % 2:<font style=\"color:#FF0000;\">任何值和NaN做运算，都是NaN</font> 3:如果对两个字符串进行加法运算，则会做拼串，会将两个字符串拼接为一个字符串，并返回 4:任何的值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var a = 123;</font> <font style=\"color:#595959;\"> var result = typeof a;</font> <font style=\"color:#595959;\"> result = 234 + 123; //357</font> <font style=\"color:#595959;\"> result = 1 + true; //2</font> <font style=\"color:#595959;\"> result = 1 + false; //1</font> <font style=\"color:#595959;\"> result = 1 + null; //null转成Number是0</font> <font style=\"color:#595959;\"> result = 1 + NaN; //NaN</font> <font style=\"color:#595959;\"> result = \"123abc\" + \"456\";//123abc456</font> <font style=\"color:#595959;\"> var sty =</font> <font style=\"color:#595959;\"> \"锄禾日当午，\" + //双引号必须在一行，否则识别不了</font> <font style=\"color:#595959;\"> \"汗滴禾下土，\" + //可以利用加号，写长的字符串，格式化结构</font> <font style=\"color:#595959;\"> \"谁知盘中餐，\" +</font> <font style=\"color:#595959;\"> \"粒粒皆辛苦。\";</font> <font style=\"color:#595959;\"> result = 123 + \"1\"; </font> <font style=\"color:#595959;\"> var c = 123;</font> <font style=\"color:#595959;\"> c = c + \"\";</font> <font style=\"color:#595959;\"> c = null + \"\";</font> <font style=\"color:#595959;\"> c = undefined + \"\";</font> <font style=\"color:#595959;\"> // console.log(\"typeof c\", typeof c);</font> <font style=\"color:#595959;\"> // console.log(\"c：\" + c); //经常使用</font> <font style=\"color:#595959;\"> result = 1 + 2 + \"3\"; //结果：33</font> <font style=\"color:#595959;\"> result = \"1\" + 2 + 3; //结果：123,</font> <font style=\"color:#595959;\"> </script></font> （2）、种类 加法 减法，可以对我们的两个值进行减法运算，并进行返回 当对非Number类型进行运算时，会将这些值转换为Number，然后再运算 乘法，可以对两个值进行乘法运算 / 除法，可以对两个值进行乘法运算 % 取模运算（取余数） <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> result = 100 - true; //结果：99</font> <font style=\"color:#595959;\"> result = 100 - \"1\"; //结果：99</font> <font style=\"color:#595959;\"> result = 2 * 2; //结果：4</font> <font style=\"color:#595959;\"> result = 2 * \"8\"; //结果：16</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> result = 2 * undefined; //结果NaN; 任何值和NaN在一起，都是NaN</font> <font style=\"color:#595959;\"> result = 2 * null; //结果:0</font> <font style=\"color:#595959;\"> result = 4 / 2; //结果：2</font> <font style=\"color:#595959;\"> result = \"2\" - \"\"; //结果：2</font> <font style=\"color:#595959;\"> result = \"2\" / 1; //结果：2</font> <font style=\"color:#595959;\"> result = 9 % 3; //结果：0</font> <font style=\"color:#595959;\"> result = 9 % 4; //结果：1</font> <font style=\"color:#595959;\"> </script></font> （3）、表达式和返回值 <font style=\"color:#FF0000;\">表达式：是由数字、运算符、变量等组成的式子</font> <font style=\"color:#FF0000;\">表达式</font>最终都会有一个<font style=\"color:#FF0000;\">结果</font>，返回给我们，我们称之为<font style=\"color:#FF0000;\">返回值</font> 2、一元运算符（只需要一个操作数） <font style=\"color:#FF0000;\">+ 正号</font> -正号不会对数字产生任何影响 <font style=\"color:#FF0000;\">对一个其他的数据类型使用+，来将其转换为Number </font> <font style=\"color:#FF0000;\">- 负号</font> -负号可以对数字进行负号的<font style=\"color:#FF0000;\">取反</font> -对非Number类型的值，会先转换为Number，然后再运算 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var a = 123;</font> <font style=\"color:#595959;\"> a = +a; //结果：123</font> <font style=\"color:#595959;\"> a = -a; //结果：-123</font> <font style=\"color:#595959;\"> var result = 1 + \"2\" + 3; //结果：‘123’</font> <font style=\"color:#595959;\"> result = 1 + +\"2\" + 3; //结果：6</font> <font style=\"color:#595959;\"> result = 1 + +true; //结果：2</font> <font style=\"color:#595959;\"> console.log(typeof +true);//number</font> <font style=\"color:#595959;\"> console.log(\"result=\" + result);//2</font> <font style=\"color:#595959;\"> </script></font> 3、递增和递减运算符 如果需要反复给数字变量添加或者减去1，可以使用递增（++）和递减（--）运算符来完成。 在JS中，递增（++）和递减（--）既可以放在变量前面，也可以放在变量后面，放在变量前面时，称<font style=\"color:#F33232;\">前置递增（递减）运算符</font>；放在变量后时，我们称之为<font style=\"color:#F33232;\">后置递增（递减）运算符</font> <font style=\"color:#FF0000;\">注意：递增和递减运算符都必须和变量配合使用</font> 开发中，大多使用后置递增/减，并且代码独占一行 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var a = 1;</font> <font style=\"color:#595959;\"> a++; //结果：2 使a自增1，a=a+1;</font> <font style=\"color:#595959;\"> a++; //结果：3 每加一个，就自增1</font> <font style=\"color:#595959;\"> console.log(\"a=\" + a);</font> <font style=\"color:#595959;\"> </script></font> （1）、自增 ++ -通过自增可以使变量在自身的基础上增加1 -对于一个变量自增以后，原变量的值会立即自增1 -自增分成两种：后++（a++）和前++（++a），无论是a++，还是++a 都会立即使原变量自增1，不同的是a++和++a的值不一样 <font style=\"color:#FF0000;\">a++的值等于原变量的值</font>（自增前的值），<font style=\"color:#FF0000;\">先返回原值，后自加</font> <font style=\"color:#FF0000;\">++a的值等于新值</font>（自增后的值），<font style=\"color:#FF0000;\">先加1，后返回值</font> （2）、自减 -- -通过自减可以使自身变量在自身的基础上减1 -自减分成两成：后--（a--）和前--（--a） 无论是a--还是--a，都会立即在原变量的值自减1 不同的是a--的值是变量的原值（自减前的值） --a的值是变量后的新值（自减以后的值） <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var a = 10;</font> <font style=\"color:#595959;\"> // a--;</font> <font style=\"color:#595959;\"> // --a;</font> <font style=\"color:#595959;\"> console.log(a--); //结果：10</font> <font style=\"color:#595959;\"> console.log(--a); //结果:8</font> <font style=\"color:#595959;\"> console.log(\"a=\" + a); //结果：8</font> <font style=\"color:#595959;\"> </script></font> 4、逻辑运算符 概念：逻辑运算符是用来进行<font style=\"color:#FF0000;\">布尔值运算的运算符</font>，其<font style=\"color:#FF0000;\">返回值也是布尔值</font>，后面开发经常用于多个条件的判断 （1）、 <font style=\"color:#FF0000;\">! ‘逻辑非’</font>，简称'非' 可以用来对一个值进行非运算 -所谓的非运算就是值<font style=\"color:#FF0000;\">对</font>一个<font style=\"color:#FF0000;\">布尔值进行取反</font>操作 true变false false变true； -如果对一个值进行两次取反，它不会变化； -如果<font style=\"color:#FF0000;\">对非布尔值</font>进行运算，则<font style=\"color:#FF0000;\">会将其转换为布尔值</font>，然后再取反， 所以我们可以利用该特点，来将一个其他的数据<font style=\"color:#F33232;\">类型转换</font>为布尔值 可以对一个任意数据类型取两次反，来讲其转换为布尔值，原理和boolean()函数一样 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var a = true;</font> <font style=\"color:#595959;\"> a = !a; //对a进行非运算，再赋值给a</font> <font style=\"color:#595959;\"> //console.log(\"a=\"+a)//结果：false</font> <font style=\"color:#595959;\"> var b = 10;</font> <font style=\"color:#595959;\"> b = !b; //false</font> <font style=\"color:#595959;\"> b = !!b; //ture</font> <font style=\"color:#595959;\"> console.log(typeof b);</font> <font style=\"color:#595959;\"> console.log(\"b=\" + b);</font> <font style=\"color:#595959;\"> </script></font> （2）、<font style=\"color:#FF0000;\"> && ‘逻辑与’</font>简称‘与’（像爱情）找<font style=\"color:#FF0000;\">false</font>， -&&可以对符号两侧的值进行运算并返回结果 -运算规则 两个值中只要有一个值为false就返回false； 只有两个值都为true时，才会返回true； <font style=\"color:#FF0000;\">js中的“与”是短路的“与”，如果第一个值是false，就不用看第二个值了</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var result = true && true; //如果两个值都是true，则返回true</font> <font style=\"color:#595959;\"> result = true && false; //只要有一个false，就返回false</font> <font style=\"color:#595959;\"> result = false && true;</font> <font style=\"color:#595959;\"> result = false && false;</font> <font style=\"color:#595959;\"> console.log(\"result=\" + result);</font> <font style=\"color:#595959;\"> //true&& alert(\"看我出不出来\");//第一个值为true，会检查返回第二个值</font> <font style=\"color:#595959;\"> //false&& alert('看我出不出来');//第一个值为false，不会检查第二个值，肯定不运行</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> </script></font> （3）、<font style=\"color:#FF0000;\"> || 逻辑或</font>，简称‘或’（像亲情）<font style=\"color:#FF0000;\">找true</font> -||可以对符号两侧的值进行或运算并返回结果 -运算规则 两个值中，只要有一个true就返回true； 如果两个值都为false，才会返回false； <font style=\"color:#FF0000;\">js中的“或”是短路的“或”，如果第一个值是true，就不用看第二个值了 </font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> result = false || false; //两个都是false，则反回false</font> <font style=\"color:#595959;\"> result = true || false; //只要有一个true，就返回true</font> <font style=\"color:#595959;\"> result = false || true;</font> <font style=\"color:#595959;\"> result = true || true;</font> <font style=\"color:#595959;\"> console.log(\"result=\" + result);</font> <font style=\"color:#595959;\"> false || alert(\"看我出不出来\"); //第一个值为false，会检查第二个值</font> <font style=\"color:#595959;\"> true || alert(\"看我出不出来\"); //第一个值为true，不会检查第二个值</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> </script></font> 5、非布尔值的与或运算符（短路运算/逻辑中断） 短路运算的原理：当由多个表示式（值）时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值了，一定程度，提高代码效率 && || 非布尔值的情况 -对于非布尔值进行\"与\",\"或\"运算时，会将其<font style=\"color:#FF0000;\">先转换为布尔值，然后再运算，并且返回原值</font> -与运算（找false）：如果第一个值为true，则必然返回第二个值； 如果第一个值为false，则直接返回第一个值； -或预算（找true） ：如果第一个值为true，则直接返回第一个值； 如果第一个值为false，则直接返回第二个值 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var result = 1 && 2; //true&&true,结果：2 ,与预算，如果两个值都是true，则返回后边的</font> <font style=\"color:#595959;\"> result = 0 && 2; //false && true，结果：0 ,与运算：如果两个值中有false，则返回靠前的false</font> <font style=\"color:#595959;\"> result = NaN && 0; //false && false 结果：NaN</font> <font style=\"color:#595959;\"> result = 1 || 2; //true||true 结果：1 如果第一个值为true，则直接返回第一个值</font> <font style=\"color:#595959;\"> result = 2 || NaN; // true||false 结果：2</font> <font style=\"color:#595959;\"> result = NaN || 1; //false||true 结果：1</font> <font style=\"color:#595959;\"> result = \"\" || \"hello\";</font> <font style=\"color:#595959;\"> result = -1 || \"你好\";</font> <font style=\"color:#595959;\"> console.log(\"result=\" + result);</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> </script></font> 课堂练习： <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var num = 7;</font> <font style=\"color:#595959;\"> var str = \"我爱你~中国~\";</font> <font style=\"color:#595959;\"> console.log(num > 5 && str.length >= num);</font> <font style=\"color:#595959;\"> console.log(num < 5 && str.length >= num);</font> <font style=\"color:#595959;\"> console.log(!(num < 10));</font> <font style=\"color:#595959;\"> console.log(!(num < 10 || str.length == num)); </font> <font style=\"color:#595959;\"> var num = 0;</font> <font style=\"color:#595959;\"> console.log(123 || num++);</font> <font style=\"color:#595959;\"> console.log(num); </font> <font style=\"color:#595959;\"> var num = 0;</font> <font style=\"color:#595959;\"> console.log(123 && num++);</font> <font style=\"color:#595959;\"> console.log(num); </font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> </script></font> 6、赋值运算符 =可以将符号右侧的值赋值给符号左侧的变量 += a += 5 等价于a =a + 5 -= a -= 5 等价于a =a - 5 = a = 5 等价于a =a * 5 /= a /= 5 等价于a =a / 5 %= a %=5 等价于a =a%5 课堂练习： <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var num = 10;</font> <font style=\"color:#595959;\"> num += 5;</font> <font style=\"color:#595959;\"> console.log(num);</font> <font style=\"color:#595959;\"> var age = 2;</font> <font style=\"color:#595959;\"> age *= 3;</font> <font style=\"color:#595959;\"> console.log(age);</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> </script></font> 7、关系运算符 通过关系运算符可以<font style=\"color:#FF0000;\">比较两个值之间的关系</font>，如果关系成立，它会<font style=\"color:#FF0000;\">返回true</font>，如果关系不成立则<font style=\"color:#FF0000;\">返回false</font> 大于号 -判断符号左侧的值是否大于右侧的 -如果关系成立，则返回true，如果关系不成立，则发挥false >= 大于等于 -判断符号左侧的值是否大于或等于右侧的值 < 小于号 <= 小于等于 注意：对于非数值的情况 <font style=\"color:#FF0000;\">-对于非数值的进行比较时，会将其转换为数字然后再比较</font> <font style=\"color:#FF0000;\">-如果符号两侧的值，都是字符串时，不会将其转换为数字比较，而会分别比较字符串的Unicode编码</font> 8、相等运算符 <font style=\"color:#FF0000;\">== </font> 相等运算符用来<font style=\"color:#FF0000;\">比较两个值是否相等</font>，如果相等会<font style=\"color:#FF0000;\">返回true</font>，否则<font style=\"color:#FF0000;\">返回false，</font> 使用==来做相等运算 当使用==来比较两个值时，如果值的<font style=\"color:#FF0000;\">类型不同</font>，则会<font style=\"color:#FF0000;\">自动进行类型转换</font>，转换为相同的类型，然后比较 <font style=\"color:#FF0000;\">!= </font> 不相等运算符用来<font style=\"color:#FF0000;\">比较两个值是否不相等</font>，如果不相等会返回true，否则返回false，使用!= 来做不相等运算 不相等也会对变量进行自动的类型转换，如果转换后相等它也会返回false。 <font style=\"color:#FF0000;\">=== </font> 全等 用来判断<font style=\"color:#FF0000;\">两个值是否全等</font>，和相等类似，<font style=\"color:#FF0000;\">不同的是不会做类型转换</font><font style=\"color:#FF0001;\">，</font>如果两个类型不同，直接返回false <font style=\"color:#FF0000;\">!== </font> 不全等 用来判断<font style=\"color:#FF0000;\">两个值是否不全等</font>，和不等类似，不同的是它<font style=\"color:#FF0000;\">不做类型转换</font>，如果两个值类型不同，直接返回true 特殊情况： <font style=\"color:#FF0000;\">1: undefined衍生自null，所以这两个值做相等判断时，会返回true</font> <font style=\"color:#FF0000;\">2: NaN不和任何值相等，包括他本身</font> 可以通过isNaN()函数来判断一个值是否是NaN 如果该值是NaN则返回true，否则是false <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> console.log(1==1);//true</font> <font style=\"color:#595959;\"> var a=10;</font> <font style=\"color:#595959;\"> console.log(a==4);//false</font> <font style=\"color:#595959;\"> console.log(\"1\"==1);//true</font> <font style=\"color:#595959;\"> console.log(true==\"1\");//true 转为Number，然后比较</font> <font style=\"color:#595959;\"> console.log(null== 0)//false 特殊情况，null没有转成Number</font> <font style=\"color:#595959;\"> console.log(undefined==null);//true</font> <font style=\"color:#595959;\"> console.log(NaN==NaN);//false</font> <font style=\"color:#595959;\"> var b=NaN;</font> <font style=\"color:#595959;\"> console.log(isNaN(b));//true </font> <font style=\"color:#595959;\"> /* console.log(10!=5);//true</font> <font style=\"color:#595959;\"> console.log(10!=10);//false</font> <font style=\"color:#595959;\"> console.log(\"1\"!=1);//false</font> <font style=\"color:#595959;\"> console.log(\"123\"==123);//true</font> <font style=\"color:#595959;\"> console.log(\"123\"===123);//false</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> console.log(1==\"1\");//true</font> <font style=\"color:#595959;\"> console.log(1!==\"1\");//true */</font> <font style=\"color:#595959;\"> </script></font> 9、三元运算符 条件运算符也叫三元运算符 <font style=\"color:#FF0000;\">-语法：条件表达式？语句1:语句2;</font> -执行的流程: 条件运算符在执行时，首<font style=\"color:#FF0000;\">先对条件表达式进行求值</font>， 如果该值为<font style=\"color:#FF0000;\">true</font>，则<font style=\"color:#FF0000;\">执行语句1</font>，并返回执行结果 如果该值为<font style=\"color:#FF0000;\">false</font>，则<font style=\"color:#FF0000;\">执行语句2</font>，并返回执行结果 如果条件的表达式的求值结果是一个非布尔值，会将其转换为布尔值，然后再运算 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //true?alert('语句1'):alert('语句2');//语句1</font> <font style=\"color:#595959;\"> var a = 60,</font> <font style=\"color:#595959;\"> b = 80,</font> <font style=\"color:#595959;\"> c = 20;</font> <font style=\"color:#595959;\"> //a>b?alert('a大'):alert(\"b大\");//b大</font> <font style=\"color:#595959;\"> var max = a > b ? a : b; //获取a b两个中的大值</font> <font style=\"color:#595959;\"> max = max > c ? max : c; //获取a b c三个值中的大值</font> <font style=\"color:#595959;\"> console.log(\"max=\" + max);</font> <font style=\"color:#595959;\"> </script></font> 10、运算符的优先级 | 优先级 | 运算符 | 顺序 | | --- | --- | --- | | 1 | 小括号 | （） | | 2 | 一元运算符 | ++ -- ！ | | 3 | 算数运算符 | 先* / % 后+ - | | 4 | 关系运算符 | > >= < <= | | 5 | 相等运算符 | == != === !== | | 6 | 逻辑运算符 | 先&& 后 || | | 7 | 赋值运算符 | = | | 8 | 逗号运算符 | , | 运算符的优先级 就和数学中一样，在JS中运算符也有优先级，比如先乘除，后加减 在js中有一个运算优先级的表, 在表中，越靠上，优先级越高，优先级越高，越优先计算， 如果<font style=\"color:#FF0000;\">优先级一样，则从左往右计算</font> 但是表不用记，如果遇到优先级问题，可以用()来改变优先级 流程控制 在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。 <font style=\"color:#F33232;\">简单理解：流程控制就是来控制我们的代码按照什么结构顺序来执行</font> 流程控制主要有三种结构，分别是<font style=\"color:#F33232;\">顺序结构、分支结构、循环结构</font>，这是三中结构代表三种代码执行的顺序 （一）、顺序流程控制 顺序结构是程序中最简单的、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的. 代码块： 我们的程序是由一条条语句构成的，语句是按照从上到下的顺序一条条执行的，在<font style=\"color:#F33232;\">js中</font>，可以<font style=\"color:#F33232;\">使用{}来为语句进行分组，</font> <font style=\"color:#F33232;\">同一个{}中的语句</font>，我们<font style=\"color:#F33232;\">称为一组语句</font>，他们要么都执行，要么都不执行一个{}中的语句，我们<font style=\"color:#F33232;\">也称</font>为一个<font style=\"color:#F33232;\">代码块</font> 在代码块的后边，就不用编写;号了， js中的代码块，只具有分组的作用，没有其他的用途，代码块内容的内容，在外部是完全可见的 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> {</font> <font style=\"color:#595959;\"> alert(\"hello\");</font> <font style=\"color:#595959;\"> console.log(\"你好\");</font> <font style=\"color:#595959;\"> var num = 100;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(num);</font> <font style=\"color:#595959;\"> </script></font> （二）、分支流程控制 由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果 1、if分支语句 条件判断语句 -使用条件判断语句可以在执行某个语句之前进行判断，如果条件成立才会执行语句，条件不成立，则语句不执行 （1）、 if语句 语法结构： <font style=\"color:#F33232;\">if(条件表达式){</font> <font style=\"color:#F33232;\">执行语句....</font> <font style=\"color:#F33232;\">};</font> 执行思路： if语句在执行时，会先对条件表达式进行求值判断，如果条件表达式的值为true，则执行if后的语句； 如果条件表达式的值为false，则不会执行if后的语句； 注意： <font style=\"color:#F33232;\">if</font>语句<font style=\"color:#F33232;\">只能控制紧随其后的那个语句</font>，如果希望if语句可以控制多条语句，可以将这些语句统一放在代码块中。 如果就一条if语句，代码块不是必须的，但在开发中尽量写清楚 代码验证：弹出一个输入框，要求用户输入年龄，如果年龄大于等于18岁，允许进网吧 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> if (true) console.log(\"好好学习，天天向上\");</font> <font style=\"color:#595959;\"> // 加上条件运算符 && ||</font> <font style=\"color:#595959;\"> var a = 20;</font> <font style=\"color:#595959;\"> if (a > 10 && a <= 20) {</font> <font style=\"color:#595959;\"> console.log(\"a在10-20之间\");</font> <font style=\"color:#595959;\"> console.log(\"4567\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 弹出一个输入框，要求用户输入年龄，如果年龄大于等于18岁，允许进网吧</font> <font style=\"color:#595959;\"> var age = prompt(\"请输入年龄\");</font> <font style=\"color:#595959;\"> if (age >= 18) {</font> <font style=\"color:#595959;\"> alert(\"欢迎光临\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> （2）、 if....else...语句 语法结构 <font style=\"color:#F33232;\">if（条件表达式）{</font> <font style=\"color:#F33232;\">执行语句1....</font> <font style=\"color:#F33232;\">}else{</font> <font style=\"color:#F33232;\">执行语句2....</font> <font style=\"color:#F33232;\">}</font> 执行思路 当该语句执行时，会先对if后的条件进行判断，如果该值为true，则执行if后的语句，如果该值为false，则执行else后的语句，两者选其一执行 代码验证：弹出一个输入框，要求用户输入年龄，如果年龄大于等于18岁，允许进网吧，否则，让回家好好学习 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var age = prompt(\"请输入年龄\");</font> <font style=\"color:#595959;\"> if (age >= 18) {</font> <font style=\"color:#595959;\"> alert(\"你已经\" + age + \"岁，欢迎光临\");</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> alert(\"你才\" + age + \"岁，回家学习吧\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> （3）、if...else if...else语句（多分支语句） 语法结构： <font style=\"color:#F33232;\">if(条件表达式){</font> <font style=\"color:#F33232;\">执行语句....</font> <font style=\"color:#F33232;\">}else if(条件表达式){</font> <font style=\"color:#F33232;\">执行语句....</font> <font style=\"color:#F33232;\">}else{</font> <font style=\"color:#F33232;\">上述都不成立，执行语句</font> <font style=\"color:#F33232;\">}</font> 执行思路： 当该语句执行时，会从上到下依次对条件表达式进行求值，如果值为true，则执行当前语句；如果值为false，则继续向下判断； 如果所有的条件都不满意，就执行最后一个else或者不执行，该语句中，<font style=\"color:#F33232;\">只会有一个代码块被执行，一旦代码块执行了， 则直接结束语句 ；else if 理论上是可以有多个的 </font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var age = prompt(\"请输入年龄\");</font> <font style=\"color:#595959;\"> if (age < 18) {</font> <font style=\"color:#595959;\"> alert(\"你还未成年\");</font> <font style=\"color:#595959;\"> } else if (age >= 18 && age <= 60) {</font> <font style=\"color:#595959;\"> alert(\"你需要努力工作，养家活口\");</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> alert(\"你可以颐养天年了\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习：根据用户输入的分数，有不同的奖励 1：90分以上，奖励宝马 2:80-90分，奖励100元 3:70-80分，奖励书包 4:60-70分，奖励练习册 5:60分以下，奖励棍棒炒肉丝 2、三元表达式 有三元运算符组成的式子，我们成为三元表达式 语法结构：<font style=\"color:#F33232;\">条件表达式？表达式1:表达式2</font> 执行思路：如果条件表达式为真，返回表达式1的值，如果条件表达式为假，返回表达式2的值 代码验证： 如果年龄达到了18岁，则显示成年了，否则返回未成年 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var age3 = prompt(\"请输入年龄\");</font> <font style=\"color:#595959;\"> age3 >= 18 ? alert(\"欢迎光临\") : alert(\"回家学习吧\");</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习：用户输入数字，如果数字小于10，则在前面补0，比如01，如果数字大于10，则不需要补，如20 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var num = prompt(\"请输入数字\");</font> <font style=\"color:#595959;\"> // if实现</font> <font style=\"color:#595959;\"> // if (num > 0 && num < 10) {</font> <font style=\"color:#595959;\"> // num = \"0\" + num;</font> <font style=\"color:#595959;\"> // }</font> <font style=\"color:#595959;\"> // 三元表达式实现</font> <font style=\"color:#595959;\"> num = num > 0 && num < 10 ? \"0\" + num : num;</font> <font style=\"color:#595959;\"> alert(num);</font> <font style=\"color:#595959;\"> </script></font> 3、switch分支语句（ switch...case...语句） switch语句也是多分支语句，它用于基于不同条件来执行不同的代码，当要针对变量设置<font style=\"color:#FF0001;\">一系列的特定值</font>的选项时，就可以用switch语句； <font style=\"color:#F33232;\">switch转换，开关的意思；case 选项的意思； break退出语句</font> 语法结构： <font style=\"color:#F33232;\">switch(条件表达式){</font> <font style=\"color:#F33232;\">case 表达式:</font> <font style=\"color:#F33232;\">执行语句....；</font> <font style=\"color:#F33232;\">break;</font> <font style=\"color:#F33232;\">case 表达式:</font> <font style=\"color:#F33232;\">执行语句....</font> <font style=\"color:#F33232;\">break;</font> <font style=\"color:#F33232;\">······</font> <font style=\"color:#F33232;\">default:</font> <font style=\"color:#F33232;\">执行语句...；</font> <font style=\"color:#F33232;\">}</font> 执行流程： 在执行时，会依次将case后的表达式的值和switch后的条件表达式的值，进行<font style=\"color:#F33232;\">全等比较</font>，如果比较结果为true，则从当前case处开始执行代码，当前case后的所有代码都会执行，我们可以在case的后边跟着一个<font style=\"color:#F33232;\">break关键字</font>，这样可以<font style=\"color:#F33232;\">确保只会执行当前case后的语句</font>，而不会执行其他的case， 如果比较结果为false，则继续向下比较匹配，如果<font style=\"color:#F33232;\">所有的比较结果都为false</font>，则<font style=\"color:#F33232;\">只执行default</font>后的语句 区别： switch语句和if语句的功能实际上有重复的，使用switch可以实现if的功能，一般情况下，两者是可以互相替换的 <font style=\"color:#F33232;\">switch···case语句通常处理case为比较确定值得情况下，而if···else···语句更加灵活，常用于范围判断</font> switch语句进行条件判断后直接执行到程序的条件语句，效率更高，而if···else语句有几种条件，有几种条件就得判断多少次 当分支比较少的时，if···else语句的执行效率比switch语句 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var num = 2;</font> <font style=\"color:#595959;\"> switch (num) {</font> <font style=\"color:#595959;\"> case 1:</font> <font style=\"color:#595959;\"> console.log(\"壹\");</font> <font style=\"color:#595959;\"> //使用break可以退出switch语句</font> <font style=\"color:#595959;\"> break;</font> <font style=\"color:#595959;\"> case 2:</font> <font style=\"color:#595959;\"> console.log(\"贰\");</font> <font style=\"color:#595959;\"> break;</font> <font style=\"color:#595959;\"> case 3:</font> <font style=\"color:#595959;\"> console.log(\"叁\");</font> <font style=\"color:#595959;\"> break;</font> <font style=\"color:#595959;\"> default:</font> <font style=\"color:#595959;\"> console.log(\"非法数字～～～\");</font> <font style=\"color:#595959;\"> break;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习： 用户输入水果，跟case里的值进行匹配，弹出对应的信息，如果没有对应的信息，弹出没有此水果。 （三）、循环语句 在实际问题中，有很多具有规律性的重复操作，因此在程序中要完成这类操作就需要重复执行某些语句 1、for循环 在程序中，一组被<font style=\"color:#F33232;\">重复执行的语句</font>被成为<font style=\"color:#F33232;\">循环体</font>，<font style=\"color:#F33232;\">能否继续重复执行</font>，取决于循环的<font style=\"color:#F33232;\">终止条件</font>，由<font style=\"color:#F33232;\">循环体及循环终止条件组成</font>的语句，我们称之为<font style=\"color:#F33232;\">循环语句</font> for循环，重复执行某些代码，通常跟计数有关系 语法结构： 在for循环中，为我们提供了专门的位置，用来放三个表达式 1:<font style=\"color:#F33232;\">初始化表达式</font>：用var声明的一个普通的变量，通常用于作为计数器使用 2:<font style=\"color:#F33232;\">条件表达式</font> ：用来决定每一次循环是否继续执行，就是<font style=\"color:#F33232;\">终止的条件</font> 3:<font style=\"color:#F33232;\">更新表达式（操作表达式）</font>：每次循环，最后执行的代码，经常用于我们计数器变量进行更新 <font style=\"color:#F33232;\">for(初始化表达式;条件表达式;更新表达式){</font> <font style=\"color:#F33232;\">循环体....</font> <font style=\"color:#F33232;\">}</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //第一种写法</font> <font style=\"color:#595959;\"> for(var i=0;i<10;i++){</font> <font style=\"color:#595959;\"> alert(i);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //第二种写法 for循环中的三个部分都可以省略，也都可以写在外部</font> <font style=\"color:#595959;\"> var i=0;</font> <font style=\"color:#595959;\"> for(;i<10;){</font> <font style=\"color:#595959;\"> alert(i++);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> //如果在for循环中，不写任何的表达式，只写两个;</font> <font style=\"color:#595959;\"> //此时循环是一个死循环，会一直执行下去，慎用</font> <font style=\"color:#595959;\"> for(;;){</font> <font style=\"color:#595959;\"> alert(\"hello\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> for循环的执行流程: 1:初始化表达式，初始化变量（初始化表达式，只会执行一次） 2:条件表达式，判断是否执行循环体， 3:如果为true，则执行循环，如果为false，终止循环 4:执行更新表达式，更新表达式执行完毕继续重复2 断点调试： <font style=\"color:#F33232;\">断点调试</font>是指自己在程序的某一行设置一个断点，调试时，<font style=\"color:#F33232;\">程序运行到这一行就会停住</font>，然后你可以一步一步往下调试，调试的过程中可以看到各个变量当前的值，出错的话，调试到出错的代码行既显示错误，停下。 扩展： 1、for循环，循环可以执行重复的代码 2、for循环，循环也可以执行不同的代码，因为由计数器变量i的存在，i每次循环值都会变化 3、for循环，因为由计数器的存在，还可以重复执行某些操作，比如做一些算数运算：例如：求1-100之间的累加和 课堂小练习： 1、求1-100之间所有数的平均值 2、求1-100之间所有偶数和奇数的和 3、求1-100之间所有能被3整除的数字的和 4、要求用户输入班级人数，之后依次输入每个学生的成绩，最后打印出该班级总的成绩以及平均成绩 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var num = +prompt(\"请输入班级人数：\");</font> <font style=\"color:#595959;\"> var sum = 0;</font> <font style=\"color:#595959;\"> var ave = 0;</font> <font style=\"color:#595959;\"> for (var i = 1; i <= num; i++) {</font> <font style=\"color:#595959;\"> var soce = +prompt(\"第\" + i + \"个同学的成绩是：\");</font> <font style=\"color:#595959;\"> sum += soce;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> ave = sum / num;</font> <font style=\"color:#595959;\"> console.log(\"总分：\" + sum);</font> <font style=\"color:#595959;\"> console.log(\"均分：\" + ave);</font> <font style=\"color:#595959;\"> </script></font> 5、一行打印五个小星星 * 双重for循环： 循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构，例如再for循环语句中，可以再嵌套一个for循环，这样的for循环语句，我们称之为双重for循环。 语法结构： <font style=\"color:#FF0000;\">for（外层的初始表达式；外层的条件表达式；外层的操作表达式）{</font> <font style=\"color:#FF0000;\">for(里层的初始表达式；里层的条件表达式；里层的操作表达式){</font> <font style=\"color:#FF0000;\">执行语句</font> <font style=\"color:#FF0000;\">}</font> <font style=\"color:#FF0000;\">}</font> 执行思路： 1、可以把里面的循环看作是外层循环的语句 2、外层循环循环一次，里面的循环执行全部 课堂小练习： | 1、第一个图形 | 2、第二个图形 | 3、第三个图形 | 4、九九乘法表 | | --- | --- | --- | --- | | <br/><br/><br/><br/> | <br/><br/><br/><br/> | <br/><br/><br/><br/>* | | <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //第一种图形 写法1</font> <font style=\"color:#595959;\"> for (var i = 0; i < 5; i++) {</font> <font style=\"color:#595959;\"> for (var j = 0; j < 5; j++) {</font> <font style=\"color:#595959;\"> document.write(\"* &nbsp;&nbsp;&nbsp;\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> document.write(\"<br/>\"); //循环完一次 输出一个换行</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 第一种图形 写法2 拼接字符串</font> <font style=\"color:#595959;\"> // * 1 <1 i=0</font> <font style=\"color:#595959;\"> // 2 <2 i=1</font> <font style=\"color:#595959;\"> // * 3 <3 i=2</font> <font style=\"color:#595959;\"> // 4 <4 i=3</font> <font style=\"color:#595959;\"> // * 5 <5 i=4</font> <font style=\"color:#595959;\"> var str = \"\";</font> <font style=\"color:#595959;\"> for (var i = 0; i < 5; i++) {</font> <font style=\"color:#595959;\"> for (var j = 0; j < 5; j++) {</font> <font style=\"color:#595959;\"> str += \"*\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 一行打印完5个星星后，就要另起一行</font> <font style=\"color:#595959;\"> str = str + \"<br/>\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> document.write(str);</font> <font style=\"color:#595959;\"> //第二种图形</font> <font style=\"color:#595959;\"> for (var i = 0; i < 5; i++) {</font> <font style=\"color:#595959;\"> for (var j = 0; j < i + 1; j++) {</font> <font style=\"color:#595959;\"> document.write(\"* &nbsp;&nbsp;&nbsp;\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> document.write(\"<br/>\"); //输出一个换行</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //第三种图形</font> <font style=\"color:#595959;\"> // * 1 j<5(5-0) i=0</font> <font style=\"color:#595959;\"> // 2 j<4(5-1) i=1</font> <font style=\"color:#595959;\"> // * 3 j<3(5-2) i=2</font> <font style=\"color:#595959;\"> // 4 j<2(5-3) i=3</font> <font style=\"color:#595959;\"> // * 5 j<1(5-4) i=4</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> for (var i = 0; i < 5; i++) {</font> <font style=\"color:#595959;\"> for (var j = 0; j < 5 - i; j++) {</font> <font style=\"color:#595959;\"> document.write(\"* &nbsp;&nbsp;&nbsp;\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> document.write(\"<br/>\"); //输出一个换行</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 9 *9 乘法表</font> <font style=\"color:#595959;\"> for(i=1;i<=9;i++){//获得1-9之间的数字 ，获得打印的行数，高度</font> <font style=\"color:#595959;\"> for(j=1;j<=i;j++){//获得i以内的所有数字，获取每行打印的次数</font> <font style=\"color:#595959;\"> // 组织打印出来的数据</font> <font style=\"color:#595959;\"> document.write(j+\"\"+i+\"=\"+ij+\"&nbsp;&nbsp;\") </font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> document.write(\"<br/>\")</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 2、while循环 while语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时，结束循环。 while语句的语法结构 <font style=\"color:#F33232;\">while（条件表达式）{</font> <font style=\"color:#F33232;\">循环体代码</font> <font style=\"color:#F33232;\">}</font> 执行思路： （1）、先执行条件表达式，如果结果为true，则执行循环体代码；如果为false，则退出循环，执行后面的代码 （2）、执行循环体代码 （3）、循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为false时，整个循环过程才会结束 注意： 1、while循环里面也有计数器，初始化变量 2、while循环里应该也有操作表达式，完成计数器的更新，<font style=\"color:#F33232;\">防止死循环</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var i=0;//1:创建初始化一个变量</font> <font style=\"color:#595959;\"> while(i<5){// 2:在循环中设置一个条件表达式</font> <font style=\"color:#595959;\"> alert(i);</font> <font style=\"color:#595959;\"> i++; // 3:定义一个更新表达式，每次更新初始化变量</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习： 1、打印人的一生，从1岁到100岁 2、计算1-100之间所有整数的和 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var i = 1,</font> <font style=\"color:#595959;\"> sum = 0;</font> <font style=\"color:#595959;\"> while (i < 100) {</font> <font style=\"color:#595959;\"> sum += i;</font> <font style=\"color:#595959;\"> i++;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(sum);</font> <font style=\"color:#595959;\"> </script></font> 3、弹出一个提示框，你爱我吗？如果输入我爱你，则提示结束，否则，一直循环 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str;</font> <font style=\"color:#595959;\"> while (str != \"我爱你\") {</font> <font style=\"color:#595959;\"> str = prompt(\"我爱你\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 3、do···while循环 do···while语句其实是while语句的一个变体，该循环会<font style=\"color:#F33232;\">先执行一次代码块</font>，然后对条件表示式进行判断，<font style=\"color:#F33232;\">如果条件为真，就会重复执行循环体，否则退出循环</font> 语法结构 <font style=\"color:#F33232;\">do{</font> <font style=\"color:#F33232;\">循环体</font> <font style=\"color:#F33232;\">}while（条件表达式）</font> 执行思路： 先执行一次循环体，再判断条件，如果条件表达式结果为真，则继续执行循环体，否则退出循环； <font style=\"color:#F33232;\">do...while可以保证循环体至少执行一次，而while不行 </font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> do {</font> <font style=\"color:#595959;\"> str = prompt(\"你爱我吗？\");</font> <font style=\"color:#595959;\"> } while (str != \"我爱你\");</font> <font style=\"color:#595959;\"> </script></font> 4、continue、break关键字 （1）、continue关键字 可以用来<font style=\"color:#F33232;\">跳过当次循环</font>，同样continue也是<font style=\"color:#F33232;\">默认只会对离他最近的循环起作用</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> for (var i = 0; i < 5; i++) {</font> <font style=\"color:#595959;\"> if (i == 2) {</font> <font style=\"color:#595959;\"> continue;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(i);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> （2）、 break关键字 可以用来<font style=\"color:#F33232;\">退出循环语句</font>；会<font style=\"color:#F33232;\">立即终止离他最近的那个循环语句</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> for (var i = 0; i < 5; i++) {</font> <font style=\"color:#595959;\"> console.log(i);</font> <font style=\"color:#595959;\"> //break;//用来结束for的循环语句，for只会循环一次</font> <font style=\"color:#595959;\"> if (i == 2) {</font> <font style=\"color:#595959;\"> break; //这个break是对整个for循环起作用的</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> for (var i = 0; i < 5; i++) {</font> <font style=\"color:#595959;\"> console.log(\"@外层循环\" + i);</font> <font style=\"color:#595959;\"> for (var j = 0; j < 5; j++) {</font> <font style=\"color:#595959;\"> break; //只会结束离他最近的内层循环</font> <font style=\"color:#595959;\"> console.log(\"内层循环\" + j);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> （3）、break指定结束循环体 可以<font style=\"color:#F33232;\">为循环语句创建一个标签名，来标识当前的循环</font>； 语法： <font style=\"color:#F33232;\">标签名:循环语句</font> 使用break语句时，break 标签名，可结束指定的循环，而不是最近的 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> outer: for (var i = 0; i < 5; i++) {</font> <font style=\"color:#595959;\"> console.log(\"@外层循环\" + i);</font> <font style=\"color:#595959;\"> for (var j = 0; j < 5; j++) {</font> <font style=\"color:#595959;\"> break outer; //指定结束外层的for循环</font> <font style=\"color:#595959;\"> console.log(\"内层循环\" + j);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 1、对象的初识 （1）、对象的定义 现实生活中，万物皆对象，对象是一个<font style=\"color:#F33232;\">具体的事物</font>，看得见摸得着的实物。例如一本书，一辆汽车，一个人可以是“对象”，一个数据库，一张网页，一个与远程服务器的连接也可以是“对象”。 例子： 明星、女朋友、班主任、苹果、手机 周星驰、小明的女朋友、这个班的班主任、这个被咬了一口的苹果、小王的手机 在JS中，对象是一组<font style=\"color:#F33232;\">无序</font>的<font style=\"color:#F33232;\">相关属性和方法</font>的集合，所有的实物都是对象，例如字符串、数值、数组、函数等 属性：事物的<font style=\"color:#F33232;\">特征</font>，在对象中用<font style=\"color:#F33232;\">属性</font>来表示（常用名词） 方法：事物的<font style=\"color:#F33232;\">行为</font>，在对象中用<font style=\"color:#F33232;\">方法</font>来表示（常用动词） 例子：手机对象 属性：大小、颜色、重量、屏幕尺寸、厚度等 方法：打电话、发短信、聊微信、玩游戏等 例子：桌子 属性：长宽，材质，颜色， 方法：放东西，写字，吃饭 例子：电脑 属性：cpu,显卡，固态，颜色，尺寸， 方法：写代码，看视频，开会议，聊天 （2）、对象的意义 保存一个值时，可以使用变量 保存多个值（一组值）时，可以使用数组。但数组元素之间信息不连贯，无连接，表达不清楚 如果保存一个人完整的信息？ JS中的<font style=\"color:#F33232;\">对象表达结构更清晰，更强大</font>。 （3）、对象的分类 对象属于一种复合的数据类型，在对象中<font style=\"color:#F33232;\">可以保存</font>多个<font style=\"color:#F33232;\">不同数据类型</font>的属性，让信息与信息之间有联系，关系明确，操作起来也更加方便 <font style=\"color:#F33232;\">1.内建对象</font>--有ES标准中定义的对象，在任何的ES的实现中都可以使用，eg:Math String Boolean function object <font style=\"color:#F33232;\">2:宿主对象</font>--由JS的运行环境提供的对象，目前来讲，主要指浏览器提供的对象，eg：BOM（浏览器对象模型） DOM(文档对象模型) 两组对象，里面各自都有很多 <font style=\"color:#F33232;\">3:自定义对象</font>--由开发人员创建的对象 2、创建对象：利用new Object创建对象 （1）、对象的基本操作 创建对象 使用<font style=\"color:#F33232;\">new</font>关键字调用的函数，就是构建函数constructor， <font style=\"color:#F33232;\">构建函数是专门用来创建对象的函数</font> 使用typeof检查一个对象时，则会返回object 向对象添加属性：<font style=\"color:#F33232;\">对象.属性名=属性值;</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> </font><font style=\"color:#F33232;\">var obj = new Object();</font> <font style=\"color:#595959;\"> obj.name = \"张三\";//向obj中添加一个name属性，name属性值为'张三'</font> <font style=\"color:#595959;\"> obj.gender = \"男\";//向obj中添加一个gender属性</font> <font style=\"color:#595959;\"> obj.age = 18;//向obj中添加一个age属性</font> <font style=\"color:#595959;\"> </script></font> 注意： 我们是利用 =赋值运算符的方法，添加对象的属性和方法 每个属性和方法之间用<font style=\"color:#F33232;\">；分号结束</font> <font style=\"color:#F33232;\">修改</font>对象属性：<font style=\"color:#F33232;\">对象.属性名=新值</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> obj.name = \"孙悟空\";</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#F33232;\">删除</font>对象的属性：<font style=\"color:#F33232;\">delete 对象.属性名</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> delete obj.name;//删除name属性</font> <font style=\"color:#595959;\"> console.log(obj.name)//undefined</font> <font style=\"color:#595959;\"> </script></font> （2）、属性名与属性值 属性名： -对象的属性名不强制性要求遵守标识符号的规范，什么名字都可以使用 -但是我们使用还是尽量按照标识符的规范去做 -如果要使用<font style=\"color:#F33232;\">特殊的属性名</font>，例如数字，不能采用\".\"的方式来操作，需要<font style=\"color:#F33232;\">用对象名['属性名']</font>来读取 使用[]这种形式去操作属性，更加灵活，在[]中可以直接传递一个变量，这样变量值是多少就会读哪个属性 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var obj = new Object();</font> <font style=\"color:#595959;\"> obj.name = \"tom\"; //向对象中添加属性</font> <font style=\"color:#595959;\"> obj[\"123\"] = \"你好\";</font> <font style=\"color:#595959;\"> var n = \"123\"; //把'123'属性赋值给n</font> <font style=\"color:#595959;\"> console.log(obj[\"123\"]); //读取obj的'123'属性</font> <font style=\"color:#595959;\"> console.log(obj[n]); //读取obj的'123'属性</font> <font style=\"color:#595959;\"> </script></font> 属性值： <font style=\"color:#F33232;\">JS对象</font>的<font style=\"color:#F33232;\">属性值</font>，可以是任意的数据类型,甚至<font style=\"color:#F33232;\">可以是对象</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> obj.test = true;</font> <font style=\"color:#595959;\"> obj.test = undefined;</font> <font style=\"color:#595959;\"> obj.test = \"true\";</font> <font style=\"color:#595959;\"> obj.test = 123;</font> <font style=\"color:#595959;\"> // 创建一个对象</font> <font style=\"color:#595959;\"> </font><font style=\"color:#F33232;\"> var obj2 = new Object();</font> <font style=\"color:#595959;\"> obj2.name = \"猪八戒\";</font> <font style=\"color:#595959;\"> obj.test = obj2;</font> <font style=\"color:#595959;\"></script></font> <font style=\"color:#F33232;\">in</font>运算符： -通过该运算符可以<font style=\"color:#F33232;\">检查</font>一个<font style=\"color:#F33232;\">对象</font>中<font style=\"color:#F33232;\">是否含有指定的属性</font>， 如果有则返回true，没有则返回false -语法：<font style=\"color:#F33232;\">\"属性名\" in 对象</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //检查obj中是否含有test2属性</font> <font style=\"color:#595959;\"> console.log(\"test2\" in obj);//false</font> <font style=\"color:#595959;\"> console.log(\"test\" in obj);//true</font> <font style=\"color:#595959;\"> </script></font> （3）、基本和引用数据类型 基本数据类型：String Number Boolean Null Undefined 引用数据类型：Object 1、JS中的变量都是保存到栈内存里的 2、基本数据类型<font style=\"color:#F33232;\">的</font><font style=\"color:#F33232;\">值</font>直接在<font style=\"color:#F33232;\">栈内</font>存中存储，值与值之间是独立存在的，<font style=\"color:#F33232;\">修改</font>一个<font style=\"color:#F33232;\">变量不会影响其他的变量</font> 3、引用数据类型<font style=\"color:#F33232;\">的</font><font style=\"color:#F33232;\">值</font>直接保存到<font style=\"color:#F33232;\">堆内存</font>中的，每创建一个新的对象，就会在堆内存中开辟一个新的空间，而<font style=\"color:#F33232;\">变量保存</font>的是<font style=\"color:#F33232;\">对象的内存地址</font>（对象的引用），<font style=\"color:#F33232;\">如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响</font> 4、比较两个基本属性类型的值时，就是比较值； 比较两个引用数据类型时，它是比较对象的内存地址，如果两个对象时一模一样的，但是地址不同，他也会返回false <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //基本类型值存储在栈内存中</font> <font style=\"color:#595959;\"> var a=123;</font> <font style=\"color:#595959;\"> var b=a;</font> <font style=\"color:#595959;\"> a++;</font> <font style=\"color:#595959;\"> console.log(\"a=\"+a);//124</font> <font style=\"color:#595959;\"> console.log(\"b=\"+b);//123 ，因为b的变化不会影响到a</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\">// 引用类型值存储在堆内存中，栈内存中保存的是指向堆内存的地址</font> <font style=\"color:#595959;\"> var obj=new Object;</font> <font style=\"color:#595959;\"> obj.name='java';</font> <font style=\"color:#595959;\"> var obj2=obj</font> <font style=\"color:#595959;\"> // 修改obj的name值</font> <font style=\"color:#595959;\"> obj.name='web'</font> <font style=\"color:#595959;\"> console.log(obj.name);//web</font> <font style=\"color:#595959;\"> console.log(obj2.name);//web</font> <font style=\"color:#595959;\"> //因为obj和obj2指向同一个对象</font> <font style=\"color:#595959;\"> </script></font> （3）、理解栈内存堆内存 1、创建对象方式二 （1）、利用字面量创建对象 对象字面量：就是花括号<font style=\"color:#FF0000;\">{}</font>里面包含了表达这个具体事物（对象）的属性和方法 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> var obj = {};//创建一个空对象</font> <font style=\"color:#595959;\"> var obj2 = {</font> <font style=\"color:#595959;\"> name: \"猪八戒\",</font> <font style=\"color:#595959;\"> age: 28,</font> <font style=\"color:#595959;\"> gender: \"男\",</font> <font style=\"color:#595959;\"> sayHi: function () {</font> <font style=\"color:#595959;\"> console.log('hi~');</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> 注意： 对象内的属性或者方法我们采取<font style=\"color:#FF0000;\">健值对</font>的形式， 键:值 <font style=\"color:#FF0000;\">属性名：属性值</font> 多个属性或者方法中间用<font style=\"color:#FF0000;\">逗号</font>隔开，最后一个属性或者方法逗号可以省略 <font style=\"color:#FF0000;\">方法</font>冒号<font style=\"color:#FF0000;\">后跟</font>的是一个<font style=\"color:#FF0000;\">匿名函数</font> 读取对象 调用对象的属性 <font style=\"color:#FF0000;\">对象名.属性名</font> <font style=\"color:#FF0000;\">对象名['属性名']</font> 调用对象的方法 <font style=\"color:#FF0000;\">对象名.方法名（）</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //读取对象属性</font> <font style=\"color:#595959;\"> console.log(obj2.name);</font> <font style=\"color:#595959;\"> console.log(obj2['age']);</font> <font style=\"color:#595959;\"> //读取对象方法</font> <font style=\"color:#595959;\"> obj.sayHi()</font> <font style=\"color:#595959;\"> </script></font> （2）、对象的方法 函数也可以成为对象的属性，如果一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象（obj）的方法，调用函数就说调用对象（obj）的方法（method）， 但是他只是名称上的区别，跟函数没有其他的区别 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> / 创建对象一/</font> <font style=\"color:#595959;\"> var obj=new Object();</font> <font style=\"color:#595959;\"> //向对象中添加属性</font> <font style=\"color:#595959;\"> obj.name=\"孙悟空\";</font> <font style=\"color:#595959;\"> obj.age=18;</font> <font style=\"color:#595959;\"> //对象的属性值可以是任何的数据类型，也可以是个函数</font> <font style=\"color:#595959;\"> obj.sayName=function(){</font> <font style=\"color:#595959;\"> console.log(obj.name);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> console.log(obj.sayName);//打印函数属性</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">obj.sayName();</font><font style=\"color:#595959;\">//调用obj.sayName()函数。也叫调用obj的sayName方法</font> <font style=\"color:#595959;\"> / 创建对象二 /</font> <font style=\"color:#595959;\"> // function sayHi(){</font> <font style=\"color:#595959;\"> // console.log('hallo')</font> <font style=\"color:#595959;\"> // }</font> <font style=\"color:#595959;\"> var obj2={</font> <font style=\"color:#595959;\"> name:'小明',</font> <font style=\"color:#595959;\"> age:18,</font> <font style=\"color:#595959;\"> sex:'男',</font> <font style=\"color:#595959;\"> job:123, </font><font style=\"color:#595959;\">方法书写</font> <font style=\"color:#595959;\"> // 第一种写法</font> <font style=\"color:#595959;\"> // </font><font style=\"color:#FF0000;\">sayHi:sayHi,</font><font style=\"color:#595959;\">（之前定义好的函数）</font><font style=\"color:#FF0000;\"> //方法：函数名 </font> <font style=\"color:#595959;\"> // 第二种写法</font> <font style=\"color:#595959;\"> // </font><font style=\"color:#FF0000;\">sayHi:function(){ //方法：匿名函数</font> <font style=\"color:#FF0000;\"> console.log(obj2.name)</font> <font style=\"color:#FF0000;\"> }</font> <font style=\"color:#595959;\"> // 第三种写法es6</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">sayHi(){ //去掉：function</font> <font style=\"color:#FF0000;\"> console.log('hallo')</font> <font style=\"color:#FF0000;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> console.log(obj2.name)</font> <font style=\"color:#595959;\"> console.log(obj2['sex'])</font> <font style=\"color:#595959;\"> console.log(obj2.sayHi)</font> <font style=\"color:#595959;\"> obj2.sayHi()</font> <font style=\"color:#595959;\"> </script></font> （3）、枚举（<font style=\"color:#FF0000;\">遍历</font>）对象属性 使用for...in 语句 语法： <font style=\"color:#FF0000;\">for(var 变量 in 对象){ }</font> for...in语句 对象中有几个属性，循环体就会执行几次，每次执行时，会将对象中的一个<font style=\"color:#FF0000;\">属性的名字</font>赋值<font style=\"color:#FF0000;\">给 变量</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var obj={</font> <font style=\"color:#595959;\"> name:\"孙悟空\",</font> <font style=\"color:#595959;\"> age:18,</font> <font style=\"color:#595959;\"> gender:\"男\",</font> <font style=\"color:#595959;\"> address:\"花果山\"</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> console.log(obj.name)</font> <font style=\"color:#595959;\"> for(var n in obj){</font> <font style=\"color:#595959;\"> console.log('属性名：'+</font><font style=\"color:#FF0000;\">n</font><font style=\"color:#595959;\">)//</font><font style=\"color:#FF0000;\">对象中每个属性的名字赋值给n</font> <font style=\"color:#595959;\"> console.log('属性值：'+</font><font style=\"color:#FF0000;\">obj[n]</font><font style=\"color:#595959;\">);//</font><font style=\"color:#FF0000;\">通过变量n读取属性值， []读取变量 </font><font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> （4）、区分变量和属性，函数和方法 变量和属性都是用来<font style=\"color:#FF0000;\">存储数据</font>的； 变量是<font style=\"color:#FF0000;\">单独声明并赋值</font>，<font style=\"color:#FF0000;\">使用</font>的时候直接写<font style=\"color:#FF0000;\">变量名</font>，是<font style=\"color:#FF0000;\">单独存在</font>的； 属性在对象中，<font style=\"color:#FF0000;\">不需要使声明</font>，<font style=\"color:#FF0000;\">使用</font>时，也是<font style=\"color:#FF0000;\">对象.属性</font>，<font style=\"color:#FF0000;\">依托对象存在</font>的； 函数和方法都是用来<font style=\"color:#FF0000;\">实现某种功能</font>的，可以做某件事，但函数是<font style=\"color:#FF0000;\">单独存在</font>的，方法是<font style=\"color:#FF0000;\">依托对象</font>存在的 （5）、this的初印象 解析器在<font style=\"color:#FF0000;\">调用函数</font>每次都会向函数内部<font style=\"color:#FF0000;\">传</font>递一个<font style=\"color:#FF0000;\">隐含的参数</font>，这个隐含的参数就是this,this是参数，浏览器传输的，直接拿来用的，this指向的是一个对象，这个对象我们称为函数执行的上下文对象。 根据函数的调用方式的不同，this会指向不同的对象: 1:当以<font style=\"color:#FF0000;\">函数的形式调用时，this是window</font> 2:当以<font style=\"color:#FF0000;\">方法</font>的形式<font style=\"color:#FF0000;\">调用</font>时， <font style=\"color:#FF0000;\">谁调用方法,this就是谁</font> 3:当以<font style=\"color:#FF0000;\">构建函数</font>的形式<font style=\"color:#FF0000;\">调用</font>时，<font style=\"color:#FF0000;\">this就是新创建的那个对象</font>，this就是当前对象，我们找的this就是当前作用域取值范围（后面讲到构造函数时，用到的） <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //需求：可以输出各自obj的名字</font> <font style=\"color:#595959;\"> //创建一个fun()函数</font> <font style=\"color:#595959;\"> function fun() {</font> <font style=\"color:#595959;\"> console.log(this.name);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //创建两个对象</font> <font style=\"color:#595959;\"> var obj = {</font> <font style=\"color:#595959;\"> name: \"孙悟空\",</font> <font style=\"color:#595959;\"> sayName: fun,</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> var obj2 = {</font> <font style=\"color:#595959;\"> name: \"沙和尚\",</font> <font style=\"color:#595959;\"> sayName: fun,</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> var name = \"全局的name属性\";</font> <font style=\"color:#595959;\"> fun(); //==window.fun() 以函数的形式调用，this就是window</font> <font style=\"color:#595959;\"> obj.sayName(); //孙悟空 以方法的形式调用，this是调用方法的对象</font> <font style=\"color:#595959;\"> obj2.sayName(); //沙和尚</font> <font style=\"color:#595959;\"> </script></font> 2、创建对象方式三 使用<font style=\"color:#FF0000;\">工厂方法</font>创建对象，通过该方法可以大批量的创建对象 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //需求：创建一个对象</font> <font style=\"color:#595959;\"> var obj = {</font> <font style=\"color:#595959;\"> name: \"孙悟空\",</font> <font style=\"color:#595959;\"> age: 18,</font> <font style=\"color:#595959;\"> gender: \"男\",</font> <font style=\"color:#595959;\"> sayName: function () {</font> <font style=\"color:#595959;\"> alert(this.name);</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> }; </font> <font style=\"color:#595959;\"> /* 需求：批量的创建对象</font> <font style=\"color:#595959;\"> 使用工厂方法创建对象</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#FF0000;\"> //函数里面加对象,靠参数生产</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">function createPerson(name,age,gender){</font> <font style=\"color:#595959;\"> //创建一个新的对象</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> var obj=new Object();</font> <font style=\"color:#595959;\"> //向对象中添加属性</font> <font style=\"color:#595959;\"> obj.name=name;</font> <font style=\"color:#595959;\"> obj.age=age;</font> <font style=\"color:#595959;\"> obj.gender=gender;</font> <font style=\"color:#595959;\"> obj.sayName=function(){</font> <font style=\"color:#595959;\"> alert(this.name);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //将新的对象返回</font> <font style=\"color:#595959;\"> return obj;</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> }</font> <font style=\"color:#595959;\"> var obj2=createPerson(\"猪八戒\",28,\"男\");</font> <font style=\"color:#595959;\"> var obj3=createPerson(\"沙和尚\",38,\"男\");</font> <font style=\"color:#595959;\"> var obj4=createPerson(\"白骨精\",18,\"女\");</font> <font style=\"color:#595959;\"> </script></font> 问题： 使用工厂方法创建的对象，使用的构造函数都是Object 所以<font style=\"color:#FF0000;\">创建的对象都是Object这个类型</font> 就导致我们无法区分多种不同类型的对象 3、创建对象方式四 （1）、利用构造函数创建对象 <font style=\"color:#FF0000;\">构造函数：</font>是一种特殊的函数，主要用来<font style=\"color:#FF0000;\">初始化对象，即为对象成员变量赋值初始值</font>，它综合new运算符一起使用。我们可以把对象中一些公共属性和方法抽取出来，然后封装到这个函数里面 构造函数语法规范： <font style=\"color:#FF0000;\">function 构造函数名(){</font> <font style=\"color:#FF0000;\">this.属性=值；</font> <font style=\"color:#FF0000;\">this.方法=function(){}</font> <font style=\"color:#FF0000;\">}</font> <font style=\"color:#FF0000;\">new 构造函数名();</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> function Person(name, age, gender) {</font> <font style=\"color:#595959;\"> //alert(this);//this就是新建的对象，然后赋值给per</font> <font style=\"color:#595959;\"> this.name = name;</font> <font style=\"color:#595959;\"> this.age = age;</font> <font style=\"color:#595959;\"> this.gender = gender;</font> <font style=\"color:#595959;\"> this.sayName = function () {</font> <font style=\"color:#595959;\"> alert(this.name)</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> var per = new Person(\"孙悟空\", 18, \"男\");</font> <font style=\"color:#595959;\"> var per2 = new Person(\"玉兔精\", 16, \"女\");</font> <font style=\"color:#595959;\"> var per3 = new Person(\"沙和尚\", 28, \"男\");</font> <font style=\"color:#595959;\"> console.log(per);</font> <font style=\"color:#595959;\"> console.log(per2);</font> <font style=\"color:#595959;\"> console.log(per3);</font> <font style=\"color:#595959;\"> </script></font> 注意： 构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上<font style=\"color:#FF0000;\">首字母大写</font> 构造函数和普通函数的区别就是调用方式的不同，普通函数是直接调用，构造函数需要使用<font style=\"color:#FF0000;\">new关键字来调用</font> 构造函数<font style=\"color:#FF0000;\">创建属性和方法</font>，必须<font style=\"color:#FF0000;\">结合this</font>使用，此时的this就是新创建的那个对象； （2）、构造函数（new关键字）的执行流程： a:立刻创建一个新的对象 b:将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建的对象 c:逐行执行函数中的代码 d:将新建的<font style=\"color:#FF0000;\">对象作为返回值返回</font> new一个对象时，会在<font style=\"color:#FF0000;\">堆</font>中开辟一片区域，new Person()会在堆中开辟一块区域 （3）、对象的实例化 使用同一个构造函数创建的对象，我们称为<font style=\"color:#FF0000;\">一类对象</font>，也将一个构造函数称为一个<font style=\"color:#FF0000;\">类</font>，例如明星汽车设计图纸 我们将通过一个<font style=\"color:#FF0000;\">构造函数创建的对象</font>，称为<font style=\"color:#FF0000;\">该类的实例</font>，例如刘德华、某一辆宝马车， 我们利用<font style=\"color:#FF0000;\">构造函数创建对象的过程</font>，我们也称为<font style=\"color:#FF0000;\">对象的实例化</font> （4）、instanceof 作用：使用instanceof可以检查一个<font style=\"color:#FF0000;\">对象</font>是否是一个<font style=\"color:#FF0000;\">类的实例</font> <font style=\"color:#FF0000;\">//亲子鉴定</font> <font style=\"color:#000000;\">语法：</font><font style=\"color:#FF0000;\">对象 instanceof 构造函数</font>,如果是，则返回true，否则返回false 注意：<font style=\"color:#FF0000;\">所有</font>的<font style=\"color:#FF0000;\">对象</font>都是<font style=\"color:#FF0000;\">Object</font>（对象源头）的后代，所以任何的对象和我们的instanceof 检查时,都是他的 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> console.log(dog instanceof Person);</font> <font style=\"color:#595959;\"> </script></font> （5）、构造函数优化 以上demo，我们创建一个Person构造函数，在Person构造函数中， 为每一个对象都添加了一个sayName的方法 目前我们的方法是在构造函数内部创建的，也就是构造函数每执行一次就会创建一个新的sayName方法，也是所有实例的sayName都是唯一的，这样就导致了构造函数执行一次就会创建一个新的方法，执行一万次就会创建一万个新的方法，而这一万个对象都是一样的，这是没有必要的，完全可以使所有的对象共享同一个方法 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> function Person(name,age,gender){</font> <font style=\"color:#595959;\"> this.name=name;</font> <font style=\"color:#595959;\"> this.age=age;</font> <font style=\"color:#595959;\"> this.gender=gender;</font> <font style=\"color:#595959;\"> // 向对象中添加一个方法</font> <font style=\"color:#595959;\"> this.sayNam=fun;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //</font><font style=\"color:#FF0000;\">将sayName方法在全局作用域中定义</font> <font style=\"color:#595959;\"> function fun(){</font> <font style=\"color:#595959;\"> alert(\"hello大家好，我是\"+this.name);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //创建一个Person实例</font> <font style=\"color:#595959;\"> var per=new Person(\"孙悟空\",18,\"男\");</font> <font style=\"color:#595959;\"> var per2=new Person(\"猪八戒\",28,\"男\");</font> <font style=\"color:#595959;\"> per.sayNam();//孙悟空</font> <font style=\"color:#595959;\"> per2.sayNam();//猪八戒</font> <font style=\"color:#595959;\"> console.log(per.sayNam==per2.sayNam);//true</font> <font style=\"color:#595959;\"> </script></font> 注意：以上优化也有一定的问题，如<font style=\"color:#FF0000;\">将函数定义在全局作用域，污染了全局作用域的命名空间</font> 而且定义在全局作用域中也很不安全 课堂小练习 1、创建一个电脑对象，该对象要有颜色、重量、品牌、型号、可以看电影，听音乐、打游戏、敲代码 <font style=\"color:#595959;\">// 创建一个电脑对象</font> <font style=\"color:#595959;\">var computer = {</font> <font style=\"color:#595959;\"> color: '黑色',</font> <font style=\"color:#595959;\"> weight: '2.5kg',</font> <font style=\"color:#595959;\"> brand: '联想',</font> <font style=\"color:#595959;\"> model: 'ThinkPad T480',</font> <font style=\"color:#595959;\"> // 看电影的方法</font> <font style=\"color:#595959;\"> watchMovie: function() {</font> <font style=\"color:#595959;\"> console.log('正在播放电影...');</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> // 听音乐的方法</font> <font style=\"color:#595959;\"> listenMusic: function() {</font> <font style=\"color:#595959;\"> console.log('正在播放音乐...');</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> // 打游戏的方法</font> <font style=\"color:#595959;\"> playGame: function() {</font> <font style=\"color:#595959;\"> console.log('正在玩游戏...');</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">// 使用电脑看电影</font> <font style=\"color:#595959;\">computer.watchMovie();</font> <font style=\"color:#595959;\">// 使用电脑听音乐</font> <font style=\"color:#595959;\">computer.listenMusic();</font> <font style=\"color:#595959;\">// 使用电脑打游戏</font> <font style=\"color:#595959;\">computer.playGame();</font> 2、创建一个按钮对象，该对象中需要包含宽、高、背景颜色和点击行为 3、创建一个车的对象，该对象要有重量、颜色、牌子、可以载人、拉货和耕田 4、原型对象 （1）、 原型对象定义 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype,这个属性对应着一个对象，这个对象就是我们所谓的原型对象(<font style=\"color:#FF0000;\">prototype是属性名，它的值是一个对象，这个对象叫原型对象</font>),<font style=\"color:#FF0000;\">默认</font>情况下，它是一个<font style=\"color:#FF0000;\">空</font>对象 如果我们的函数作为普通函数调用，prototype没有任何作用， 当<font style=\"color:#FF0000;\">函数以构造函数的形式调用</font>时，它所<font style=\"color:#FF0000;\">创建的对象</font>都会<font style=\"color:#FF0000;\">有</font>一个<font style=\"color:#FF0000;\">隐含的属性</font>，<font style=\"color:#FF0000;\">指向该构造函数的原型对象，</font>我们通过<font style=\"color:#FF0000;\">__proto__</font>来<font style=\"color:#FF0000;\">访问该属性</font> （2）、原型对象的作用 原型对象就相当于一个<font style=\"color:#FF0000;\">公共</font>的<font style=\"color:#FF0000;\">区域</font>，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中，当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有就直接使用，如果没有就去原型对象中寻找，然后使用。 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数中，这样就不用分别给每一个对象添加，也不会影响到全局作用域，就可以使每个对象，都具有这样的属性和方法了 <font style=\"color:#FF0000;\">//相当于家族财产，家族有相当于我有</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //创建函数</font> <font style=\"color:#595959;\"> function MyClass() {}</font> <font style=\"color:#595959;\"> //向MyClass的原型对象中添加属性a</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> MyClass.prototype.a = 123;</font> <font style=\"color:#595959;\"> //向MyClass中添加一个方法</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">MyClass.prototype.sayHello = function () {</font> <font style=\"color:#FF0000;\"> alert(\"hello\");</font> <font style=\"color:#FF0000;\"> };</font> <font style=\"color:#595959;\"> //console.log(MyClass.prototype, );</font> <font style=\"color:#595959;\"> //添加实例</font> <font style=\"color:#595959;\"> var mc = new MyClass(); //隐含属性__proto__</font> <font style=\"color:#595959;\"> var mc2 = new MyClass();</font> <font style=\"color:#595959;\"> console.log(MyClass.prototype,\"MyClass.prototype\");//object</font> <font style=\"color:#595959;\"> console.log(mc.__proto__,'mc.__proto__');//object</font> <font style=\"color:#595959;\"> // console.log(MyClass.prototype==mc.__proto__);//true</font> <font style=\"color:#595959;\"> // mc.sayHello();</font> <font style=\"color:#595959;\"> /*简单理解： </font> <font style=\"color:#595959;\"> MyClass 是mc，mc2的祖先，祖先有一个宝藏，里面放一些宝藏，</font> <font style=\"color:#595959;\"> 它的后代都可以看到，如果后代本身就有这个宝藏，就不用祖先藏宝库里，没有就用</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\"> </script></font> （3）、检查对象中是否含有某个属性 a:使用<font style=\"color:#FF0000;\">in检查对象</font>中<font style=\"color:#FF0000;\">是否含有某个属性</font>时，如果<font style=\"color:#FF0000;\">对象</font>中<font style=\"color:#FF0000;\">没有</font>，<font style=\"color:#FF0000;\">原型</font>中<font style=\"color:#FF0000;\">有</font>，也会返回<font style=\"color:#FF0000;\">true</font> b:可以使用对象的<font style=\"color:#FF0000;\">hasOwnproperty()</font>来<font style=\"color:#FF0000;\">检查对象自身中是否含有该属性</font>,使用该方法只有当对象自身中含有属性时，才会返回true <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> / 创建一个构造函数 /</font> <font style=\"color:#595959;\"> function MyClass() {}</font> <font style=\"color:#595959;\"> //向MyClass的原型中添加一个name属性</font> <font style=\"color:#595959;\"> MyClass.prototype.name = \"我是原型中的name\";</font> <font style=\"color:#595959;\"> var mc = new MyClass();</font> <font style=\"color:#595959;\"> mc.age = 18;</font> <font style=\"color:#595959;\"> console.log(mc.name);</font> <font style=\"color:#595959;\"> console.log(\"name\" in mc); //true</font> <font style=\"color:#595959;\"> console.log(mc.hasOwnProperty(\"name\")); //false</font> <font style=\"color:#595959;\"> </script></font> （4）、 原型链 原型对象也是对象，所以它也有原型 当我们使用一个对象的属性或方法时，会先在自身中寻找，自身中如果有，则直接使用，如果没有，则去原型对象中寻找，如果原型对象中有，则使用，如果没有，则去原型对象的原型中寻找，直到找到Object对象的原型，Object对象的原型没有原型，如果在Object中依然没有找到，则返回undefined （具体在js高级的时候讲述） <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> /* toString是属于Object原型上的一个方法。</font> <font style=\"color:#595959;\"> toString返回 '[object type]' 其中type是对象的类型,type的值可以是Object， */</font> <font style=\"color:#595959;\"> var obj = { sex: \"男\" };</font> <font style=\"color:#595959;\"> console.log(obj.toString());// [object Object]</font> <font style=\"color:#595959;\"> //返回来的确实是返回一个【表示对象】的【字符串】</font> <font style=\"color:#595959;\"></script></font> 5、垃圾回收 就像人生活时间长了，会产生垃圾一样，程序运行过程中，也会产生一些垃圾，这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生的垃圾 当一个对象没有任何的变量或者属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾这种对象过多，会占用我们大量的内存空间，导致我们程序运行变慢，这种垃圾我们必须清理 在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收 我们需要做的只是将<font style=\"color:#FF0000;\">不再使用的对象设置null</font>即可 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var obj=new Object();</font> <font style=\"color:#595959;\"> //对对象进行各种操作</font> <font style=\"color:#595959;\"> obj.prototype=123;</font> <font style=\"color:#595959;\"> console.log(obj.prototype)</font> <font style=\"color:#595959;\"> obj=null;</font> <font style=\"color:#595959;\"> </script></font> 6、创建对象方式五 class JavaScript 语言中，生成实例对象的传统方法是通过构造函数， ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 class初体验 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // //</font><font style=\"color:#FF0000;\">es5通过构造函数实现</font> <font style=\"color:#595959;\"> // function PersonO(username, password) {</font> <font style=\"color:#595959;\"> // this.username = username;</font> <font style=\"color:#595959;\"> // this.password = password;</font> <font style=\"color:#595959;\"> // }</font> <font style=\"color:#595959;\"> // // 添加方法</font> <font style=\"color:#595959;\"> // </font><font style=\"color:#FF0000;\">PersonO.prototype.getstr = function () {</font> <font style=\"color:#595959;\"> // console.log(\"用户名：\" + this.username + \",密码：\" + this.password);</font> <font style=\"color:#595959;\"> // };</font> <font style=\"color:#595959;\"> // // 实例化对象</font> <font style=\"color:#595959;\"> // const po1 = new PersonO(\"章三\", \"abc123\");</font> <font style=\"color:#595959;\"> // console.log(po1);</font> <font style=\"color:#595959;\"> // po1.getstr();</font> <font style=\"color:#595959;\"> // </font><font style=\"color:#FF0000;\">es6实现 class方法实现</font> <font style=\"color:#595959;\"> class PersonN {</font> <font style=\"color:#595959;\"> //</font><font style=\"color:#FF0000;\">构造方法 constructor名字不能修改</font> <font style=\"color:#595959;\"> // 当我们new实例对象的时候，这个方法自动执行</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">constructor(</font><font style=\"color:#595959;\">username, password</font><font style=\"color:#FF0000;\">) {</font> <font style=\"color:#595959;\"> this.username = username;</font> <font style=\"color:#595959;\"> this.password = password;</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> }</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> //方法必须使用该语法, 不能使用 ES5 的对象完整形式</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">getstr() {</font> <font style=\"color:#FF0000;\"> console.log(\"用户名：\" + this.username + \"，密码：\" + this.password);</font> <font style=\"color:#FF0000;\"> }</font> <font style=\"color:#FF0000;\"> </font><font style=\"color:#FF0000;\">//ES5 的对象完整形式 报错</font> <font style=\"color:#FF0000;\"> // getstr:function () {}</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> const pn1 = new PersonN(\"123456\", \"789012\");</font> <font style=\"color:#595959;\"> pn1.getstr();</font> <font style=\"color:#595959;\"> </script></font> 说明：使用class关键词 声明类，constructor为构造方法，一个类必须有constructor()方法， 如果没有显式定义，一个空的constructor()方法会被默认添加， this关键字则代表实例对象，getstr()为普通方法，不要用es5完整写法，getstr()存在 prototype上。 pn1.constructor === pn1.prototype.constructor // true <font style=\"color:#D4D4D4;\"> </font><font style=\"color:#9CDCFE;\">在JavaScript中</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">创建对象有多种方法</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">每种方法都有其特点和适用场景</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">以下是几种常见的对象创建方法</font><font style=\"color:#D4D4D4;\">：</font> <font style=\"color:#B5CEA8;\">1.</font><font style=\"color:#D4D4D4;\"> </font><font style=\"color:#DCDCAA;\">利用</font><font style=\"color:#CE9178;\">new Object</font><font style=\"color:#9CDCFE;\">创建对象</font><font style=\"color:#D4D4D4;\"></font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#DCDCAA;\">使用</font><font style=\"color:#CE9178;\">new</font><font style=\"color:#DCDCAA;\">关键字调用</font><font style=\"color:#CE9178;\">Object</font><font style=\"color:#9CDCFE;\">函数来创建对象</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#DCDCAA;\">可以通过</font><font style=\"color:#CE9178;\">对象.属性名 = 属性值</font><font style=\"color:#9CDCFE;\">的方式向对象添加属性</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#DCDCAA;\">通过</font><font style=\"color:#CE9178;\">对象.属性名 = 新值</font><font style=\"color:#9CDCFE;\">修改属性</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#DCDCAA;\">使用</font><font style=\"color:#CE9178;\">delete 对象.属性名</font><font style=\"color:#9CDCFE;\">删除属性</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#9CDCFE;\">对象的属性名不强制遵守标识符规范</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">但建议遵循</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> </font><font style=\"color:#9CDCFE;\">对于特殊属性名</font><font style=\"color:#D4D4D4;\">（</font><font style=\"color:#9CDCFE;\">如数字</font><font style=\"color:#D4D4D4;\">），</font><font style=\"color:#DCDCAA;\">可以使用</font><font style=\"color:#CE9178;\">对象名['属性名']</font><font style=\"color:#9CDCFE;\">的方式操作</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">这种方式更灵活</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">可在方括号中直接传递变量</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#9CDCFE;\">对象的属性值可以是任意数据类型</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">甚至可以是对象</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#DCDCAA;\">可以使用</font><font style=\"color:#CE9178;\">in</font><font style=\"color:#9CDCFE;\">运算符检查对象中是否含有指定属性</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#DCDCAA;\">语法为</font><font style=\"color:#CE9178;\">\"属性名\" in 对象</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#B5CEA8;\">2.</font><font style=\"color:#D4D4D4;\"> </font><font style=\"color:#9CDCFE;\">利用字面量创建对象</font><font style=\"color:#D4D4D4;\"></font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#DCDCAA;\">使用花括号</font><font style=\"color:#CE9178;\">{}</font><font style=\"color:#9CDCFE;\">包含对象的属性和方法</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">属性和方法以</font><font style=\"color:#D4D4D4;\"> </font><font style=\"color:#9CDCFE;\">键值对</font><font style=\"color:#D4D4D4;\"> </font><font style=\"color:#9CDCFE;\">的形式表示</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">多个属性或方法之间用逗号隔开</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">最后一个逗号可省略</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#9CDCFE;\">方法的值是一个匿名函数</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#DCDCAA;\">读取对象属性可以使用</font><font style=\"color:#CE9178;\">对象名.属性名</font><font style=\"color:#DCDCAA;\">或</font><font style=\"color:#CE9178;\">对象名['属性名']</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#DCDCAA;\">调用对象方法使用</font><font style=\"color:#CE9178;\">对象名.方法名()</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#B5CEA8;\">3.</font><font style=\"color:#D4D4D4;\"> </font><font style=\"color:#9CDCFE;\">使用工厂方法创建对象</font><font style=\"color:#D4D4D4;\"></font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#9CDCFE;\">定义一个函数</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">在函数内部创建一个新对象</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">向对象添加属性和方法</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">最后返回该对象</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#9CDCFE;\">这种方法可以批量创建对象</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#DCDCAA;\">但创建的对象类型都是</font><font style=\"color:#CE9178;\">Object</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">无法区分不同类型的对象</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#B5CEA8;\">4.</font><font style=\"color:#D4D4D4;\"> </font><font style=\"color:#9CDCFE;\">利用构造函数创建对象</font><font style=\"color:#D4D4D4;\"></font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#9CDCFE;\">构造函数是一种特殊函数</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">习惯上首字母大写</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">用于初始化对象</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">将对象的公共属性和方法封装在其中</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#DCDCAA;\">构造函数内部使用</font><font style=\"color:#CE9178;\">this</font><font style=\"color:#9CDCFE;\">关键字来引用新创建的对象</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#DCDCAA;\">通过</font><font style=\"color:#CE9178;\">this.属性 = 值</font><font style=\"color:#DCDCAA;\">和</font><font style=\"color:#CE9178;\">this.方法 = function() {}</font><font style=\"color:#9CDCFE;\">为对象添加属性和方法</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#DCDCAA;\">构造函数需要使用</font><font style=\"color:#CE9178;\">new</font><font style=\"color:#9CDCFE;\">关键字来调用</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">执行流程包括创建新对象</font><font style=\"color:#D4D4D4;\">、</font><font style=\"color:#DCDCAA;\">将新对象设置为函数中的</font><font style=\"color:#CE9178;\">this</font><font style=\"color:#D4D4D4;\">、</font><font style=\"color:#9CDCFE;\">执行函数代码</font><font style=\"color:#D4D4D4;\">、</font><font style=\"color:#9CDCFE;\">返回新对象</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#9CDCFE;\">使用同一个构造函数创建的对象称为一类对象</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">构造函数也称为类</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">创建的对象是该类的实例</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#DCDCAA;\">可以使用</font><font style=\"color:#CE9178;\">instanceof</font><font style=\"color:#9CDCFE;\">运算符检查一个对象是否是一个类的实例</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#DCDCAA;\">语法为</font><font style=\"color:#CE9178;\">对象 instanceof 构造函数</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#9CDCFE;\">构造函数优化</font><font style=\"color:#D4D4D4;\">：</font><font style=\"color:#9CDCFE;\">为避免在构造函数内部为每个对象创建相同的方法</font><font style=\"color:#D4D4D4;\">（</font><font style=\"color:#9CDCFE;\">导致方法不共享且占用过多内存</font><font style=\"color:#D4D4D4;\">），</font> <font style=\"color:#D4D4D4;\"> </font><font style=\"color:#9CDCFE;\">可以将方法定义在全局作用域并赋值给构造函数中的属性</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">但这种方式会污染全局命名空间且不安全</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#B5CEA8;\">5.</font><font style=\"color:#D4D4D4;\"> </font><font style=\"color:#DCDCAA;\">使用</font><font style=\"color:#CE9178;\">class</font><font style=\"color:#9CDCFE;\">关键字创建对象</font><font style=\"color:#D4D4D4;\">（</font><font style=\"color:#4FC1FF;\">ES6</font><font style=\"color:#D4D4D4;\">）</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#DCDCAA;\">通过</font><font style=\"color:#CE9178;\">class</font><font style=\"color:#9CDCFE;\">关键字定义类</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#DCDCAA;\">类中包含构造方法</font><font style=\"color:#CE9178;\">constructor</font><font style=\"color:#9CDCFE;\">和普通方法</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#DCDCAA;\">构造方法在</font><font style=\"color:#CE9178;\">new</font><font style=\"color:#9CDCFE;\">实例对象时自动执行</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">用于初始化对象的属性</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#9CDCFE;\">普通方法必须使用特定语法</font><font style=\"color:#D4D4D4;\">（</font><font style=\"color:#9CDCFE;\">不能使用ES5的对象完整形式</font><font style=\"color:#D4D4D4;\">），</font><font style=\"color:#DCDCAA;\">方法存在于</font><font style=\"color:#CE9178;\">prototype</font><font style=\"color:#9CDCFE;\">上</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#DCDCAA;\">一个类必须有</font><font style=\"color:#CE9178;\">constructor()</font><font style=\"color:#9CDCFE;\">方法</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">如果未显式定义</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#DCDCAA;\">会默认添加一个空的</font><font style=\"color:#CE9178;\">constructor()</font><font style=\"color:#9CDCFE;\">方法</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#D4D4D4;\"> - </font><font style=\"color:#CE9178;\">this</font><font style=\"color:#9CDCFE;\">关键字在类中代表实例对象</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#9CDCFE;\">在实际开发中</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">根据具体需求选择合适的对象创建方法</font><font style=\"color:#D4D4D4;\">。</font><font style=\"color:#9CDCFE;\">如果只是简单创建一个对象</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">字面量方式可能比较方便</font><font style=\"color:#D4D4D4;\">；</font> <font style=\"color:#9CDCFE;\">如果需要创建多个相似对象</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#DCDCAA;\">可以考虑构造函数或</font><font style=\"color:#CE9178;\">class</font><font style=\"color:#D4D4D4;\">；</font> <font style=\"color:#9CDCFE;\">如果需要更灵活的创建方式</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">工厂方法也可使用</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">但要注意其局限性</font><font style=\"color:#D4D4D4;\">。</font> <font style=\"color:#9CDCFE;\">同时</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">理解对象的创建过程和原理对于JavaScript编程非常重要</font><font style=\"color:#D4D4D4;\">，</font><font style=\"color:#9CDCFE;\">有助于更好地组织和管理代码</font><font style=\"color:#D4D4D4;\">。</font> 1、函数的概念 在JS里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码需要大量重复使用 函数：就是<font style=\"color:#F33232;\">封装</font>一段<font style=\"color:#F33232;\">可</font>被<font style=\"color:#F33232;\">重复调用</font>执行的<font style=\"color:#F33232;\">代码块</font>。通过代码块可以实现在需要的的重复使用，使用typeof检查一个函数对象时，会返回function 函数的封装是把一个或者多个功能通过<font style=\"color:#F33232;\">函数的方式封装起来</font>，<font style=\"color:#F33232;\">对外</font>只<font style=\"color:#F33232;\">提供</font>一个简单的函数<font style=\"color:#F33232;\">接口</font>，简单理解：将很多衣服打包到一个行李箱,jQuery就是一个函数封装库，对外暴露一个顶级对象$ 2、函数的使用 函数在使用时分为两步：<font style=\"color:#F33232;\">声明</font>函数和<font style=\"color:#F33232;\">调用</font>函数 （1）、声明函数（创建函数）三种方式 第一种方式 创建一个构造函数对象 ——我们在实际开发中很少使用构造函数来创建一个函数对象 ——可以将要封装的<font style=\"color:#F33232;\">代码以字符串的形式传递给构造函数</font> —— 封装到函数中的代码不会立即执行，函数中的代码会在函数调用的时候执行 <font style=\"color:#333333;\">构造函数是一个函数，当使用new关键字调用时，它用于创建对象并初始化对象的属性和方法</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> </font><font style=\"color:#F33232;\">var fun = new Function(\"console.log('hello 这是我的第一个函数')\");</font> <font style=\"color:#595959;\"> console.log(typeof fun);//function</font> <font style=\"color:#595959;\"> fun();</font> <font style=\"color:#595959;\"> </script></font> 第二种方式 使用函数声明来创建一个函数（常用） <font style=\"color:#F33232;\">function 函数名（[形参1,形参2,形参3,形参4....形参n]）{</font> <font style=\"color:#F33232;\">执行语句.....</font> <font style=\"color:#F33232;\">}</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> function fun2() {</font> <font style=\"color:#595959;\"> console.log(\"这是我的第二个函数～～～\");</font> <font style=\"color:#595959;\"> alert(\"hahahaha\");</font> <font style=\"color:#595959;\"> document.write(\"wuwuwuwu\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 第三种方式 使用函数表达式来创建一个函数（匿名函数） <font style=\"color:#F33232;\">var 变量名=function（[形参1,形参2,形参3,形参4....形参n]）{</font> <font style=\"color:#F33232;\">语句.....</font> <font style=\"color:#F33232;\">}</font> <font style=\"color:#F33232;\">注意：变量名不是函数名</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var fun3 = function () {</font> <font style=\"color:#595959;\"> console.log(\"我是匿名函数中的封装的代码\");</font> <font style=\"color:#595959;\"> }; //相当于赋值语句</font> <font style=\"color:#595959;\"> fun3(); //调用函数</font> <font style=\"color:#595959;\"> </script></font> 注意： 由于函数一般是为了实现某个功能才定义的，所以通常我们将函数名命名为动词，例如getsum （2）、调用函数 调用函数语法：<font style=\"color:#F33232;\">变量名/函数名()</font> 当调用函数时，函数中封装的代码会按照顺序执行 课堂小练习：1、利用函数计算1-100之间的累加和 3、函数的参数 （1）、参数 在<font style=\"color:#F33232;\">声明</font>函数时，可以在函数名称后面的<font style=\"color:#F33232;\">小括号</font>里添加一些<font style=\"color:#F33232;\">参数</font>，这些参数是<font style=\"color:#F33232;\">形参</font>，而在<font style=\"color:#F33232;\">调用</font>该函数时，同样也需要<font style=\"color:#F33232;\">传递</font>相应<font style=\"color:#F33232;\">的参数</font>，这些参数被称谓<font style=\"color:#F33232;\">实参</font>。 形参：形式上的参数，函数定义的时候，传递的参数，当前并不知道是什么，<font style=\"color:#F33232;\">用来接收实参的，形参类似一个变量，声明了并未赋值</font>，多个形参之间用<font style=\"color:#F33232;\">逗号隔开</font> 实参：实际上的参数，函数调用的时候传递的参数，实参是传递给形参，相当于<font style=\"color:#F33232;\">给形参赋值</font> 参数的作用：在函数内部某些值不能固定的时候，我们可以通过参数在调用函数时传递不同的值进去 语法结构： <font style=\"color:#F33232;\">function 函数名（形参1,形参2····形参n）{ </font>//声明函数的小括号里的是形参（形式上的参数） <font style=\"color:#F33232;\">执行语句.....</font> <font style=\"color:#F33232;\">}</font> <font style=\"color:#F33232;\">函数名（实参1，实参2····）</font>//在函数调用的小括号里面是实参（实际参数） 课堂小练习：1、利用函数求任意两个数的和 （2）、形参和实参匹配的问题 如果形参和实参的<font style=\"color:#F33232;\">个数一致</font>，则<font style=\"color:#F33232;\">正常</font>输出结果 如果<font style=\"color:#F33232;\">实</font>参的个数<font style=\"color:#F33232;\">多</font>于<font style=\"color:#F33232;\">形</font>参的个数，会<font style=\"color:#F33232;\">取形</font>参的<font style=\"color:#F33232;\">个数</font> 如果<font style=\"color:#F33232;\">实</font>参的个数<font style=\"color:#F33232;\">小</font>于<font style=\"color:#F33232;\">形</font>参的个数，<font style=\"color:#F33232;\">多余</font>的形参<font style=\"color:#F33232;\">默认</font>定义为<font style=\"color:#F33232;\">undefined</font> 调用函数时，解析器不会检查实参的类型，所以要注意，是否有可能会接收到非法的参数，<font style=\"color:#F33232;\">函数的实参可以是任意的数据类型</font> <font style=\"color:#F33232;\">建议</font>形参和实参个数一致 （3）、实参可以是任何类型 ——可以是一个对象,当我们的参数过多时，可以将参数封装到一个对象中，然后通过对象传递 ——<font style=\"color:#F33232;\">实参可以是一个对象，也可以是一个函数</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //将参数封装到对象中传递</font> <font style=\"color:#595959;\"> function sayhello(o) {</font> <font style=\"color:#595959;\"> //console.log(\"o=\"+o);//对象</font> <font style=\"color:#595959;\"> console.log(\"我是\" + o.name + \",今年\" + o.age + \"岁了,\" + </font> <font style=\"color:#595959;\"> \"我是一个\" + o.gender + \"人\" + \",我住在\" + o.address);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //创建一个对象</font> <font style=\"color:#595959;\"> var obj = new Object();</font> <font style=\"color:#595959;\"> obj.name = \"孙悟空\";</font> <font style=\"color:#595959;\"> obj.age = 18;</font> <font style=\"color:#595959;\"> obj.gender = \"男\";</font> <font style=\"color:#595959;\"> obj.address = \"花果山\";</font> <font style=\"color:#595959;\"> </font><font style=\"color:#F33232;\"> sayhello(obj); //可以直接全部赋值</font> <font style=\"color:#595959;\"> //实参可以是一个函数</font> <font style=\"color:#595959;\"> function fun(a) {</font> <font style=\"color:#595959;\"> //console.log(\"a=\"+a);</font> <font style=\"color:#595959;\"> a(obj);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fun(sayhello);</font> <font style=\"color:#595959;\"> /* </font> <font style=\"color:#595959;\"> sayhello()</font> <font style=\"color:#595959;\"> -调用函数</font> <font style=\"color:#595959;\"> </font><font style=\"color:#F33232;\"> -相当于使用的函数的返回值</font> <font style=\"color:#595959;\"> -机器作出的东西</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> sayhello</font> <font style=\"color:#595959;\"> -函数对象</font> <font style=\"color:#595959;\"> </font><font style=\"color:#F33232;\"> -相当于直接使用函数对象</font> <font style=\"color:#595959;\"> -机器 </font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\"> </script></font> 1、函数的返回值return （1）、返回值语法结构： <font style=\"color:#FF0000;\">function 函数名（）{</font> <font style=\"color:#FF0000;\">return 需要返回的结果</font> <font style=\"color:#FF0000;\">}</font> <font style=\"color:#FF0000;\">函数名（）</font> <font style=\"color:#595959;\">//需求：输入一个数，求1-这个数的和,在这个基础上进行+1，-1，*1，/1</font> <font style=\"color:#595959;\">var num = +prompt('输入一个数');</font> <font style=\"color:#595959;\">function getSum(num) {</font> <font style=\"color:#595959;\"> var sum = 0;</font> <font style=\"color:#595959;\"> for (var i = 1; i <= num; i++) {</font> <font style=\"color:#595959;\"> sum += i</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(sum)</font> <font style=\"color:#595959;\"> return sum;</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">var res= getSum(num)</font> <font style=\"color:#595959;\">console.log(res+1)</font> （2）、返回值注意事项： 函数只是实现某种功能，最终的结果需要返回给函数的调用者（谁调用函数，函数实现结果功能反馈给谁），<font style=\"color:#FF0000;\">函数名()=return 后面的结果</font>，通过return实现的；可以定义一个变量，让return来接受该结果 在函数中，<font style=\"color:#FF0000;\">return之后的语句就都不会执行，有终止函数的作用</font> return<font style=\"color:#FF0000;\">只能返回一个值</font>，多个值，返回的是最后一个值。如果有需求返回多个值，可以将多个值放入数组或者对象里 return后可以跟任意类型的值 如果<font style=\"color:#FF0000;\">return后不跟任何值，就相当于返回一个undefined</font> 如果函数中不写return，则也会返回undefined <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // 需求：创建一个函数，用来计算三个数的和</font> <font style=\"color:#595959;\"> function sum(a, b, c) {</font> <font style=\"color:#595959;\"> var d = a + b + c;</font> <font style=\"color:#595959;\"> //console.log(d);</font> <font style=\"color:#595959;\"> //alert(d);</font> <font style=\"color:#595959;\"> return d;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //调用函数，变量result的值就是函数的执行结果</font> <font style=\"color:#595959;\"> var result = sum(4, 7, 8);</font> <font style=\"color:#595959;\"> //函数返回什么，result的值就是什么</font> <font style=\"color:#595959;\"> console.log(\"result=\" + result);</font> <font style=\"color:#595959;\"> </script></font> （3）、返回值类型 返回值可以是任意的数据类型，也可以是一个对象，函数 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //1:返回值对象</font> <font style=\"color:#595959;\"> function fun2() {</font> <font style=\"color:#595959;\"> //return 10;</font> <font style=\"color:#595959;\"> var obj = { name: \"沙和尚\" }</font> <font style=\"color:#595959;\"> return obj;//return {name:\"沙和尚\"} </font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> var a = fun2();</font> <font style=\"color:#595959;\"> console.log(\"a=\" + a);</font> <font style=\"color:#595959;\"> //2:返回值是函数</font> <font style=\"color:#595959;\"> function fun3() {</font> <font style=\"color:#595959;\"> //在函数内部还可以声明一个函数</font> <font style=\"color:#595959;\"> function fun4() {</font> <font style=\"color:#595959;\"> alert(\"我是fun4\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //将fun4函数作为返回值返回</font> <font style=\"color:#595959;\"> return fun4;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> a = fun3();//将箱子里的冰淇机器赋值，也就是fun4</font> <font style=\"color:#595959;\"> a=fun3;//与上面的区别，整个fun3函数赋值</font> <font style=\"color:#595959;\"> console.log(a);</font> <font style=\"color:#595959;\"> </script></font> （4）、break、continue、return的区别： break、continue、return的区别： <font style=\"color:#FF0000;\">break：结束当前的循环体（for、while）</font> <font style=\"color:#FF0000;\">continue：跳出本次循环，继续执行下次循环（for、while）</font> <font style=\"color:#FF0000;\">return：不仅可以退出循环，还可以返回return语句中的值，同时还可以结束当前循环体内的代码</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> function fun() {</font> <font style=\"color:#595959;\"> alert(\"函数要执行了～～～\");</font> <font style=\"color:#595959;\"> for (var i = 0; i < 5; i++) {</font> <font style=\"color:#595959;\"> if (i == 2) {</font> <font style=\"color:#595959;\"> break;//退出当前的循环</font> <font style=\"color:#595959;\"> continue;//用于跳过当次循环</font> <font style=\"color:#595959;\"> return;//使用return可以结束整个函数</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(i);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> alert(\"函数执行完了～～～\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //fun();</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习：1、利用函数求任意两个数的最大值 2、arguments的使用 在调用函数时，浏览器每次都会传递两个隐含的参数： 1:函数的上下文对象 this 2:封装实参的对象 arguments 当我们不确定有多少个参数传递的时候，可以使用<font style=\"color:#FF0000;\">arguments</font>来获取，在JS中，arguments实际上它是当前函数的一个<font style=\"color:#F33232;\">内置对象</font>。所有函都内置了一个arguments对象，<font style=\"color:#FF0000;\">arguments对象中存储了传递的所有实参。</font> （1）、arguments 是一个<font style=\"color:#FF0000;\">伪类数组</font>对象，它也可以通过索引来操作数据，通过arguments.length可以获取实参的长度获取长度 伪数组并不是真正意义上的数组 <font style=\"color:#FF0000;\">具有数组的length属性</font> <font style=\"color:#FF0000;\">按照索引的顺序进行存储的</font> <font style=\"color:#FF0000;\">它没有真正数组的一些方法</font> （2）、在调用函数时，我们所传递的实参都会在arguments中保存 （3）、我们即使不定义形参，也可以通过grguments来使用实参，只不过比较麻烦 arguments[0]表示第一个实参 arguments[1]表示第二个实参 （4）<font style=\"color:#FF0000;\">、arguments有个属性叫callee</font>， 这个属性对应一个函数对象，就是<font style=\"color:#FF0000;\">当前正在指向函数的对象</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> function fun() {</font> <font style=\"color:#595959;\"> //这两种都是检查arguments是不是数组</font> <font style=\"color:#595959;\"> //console.log(arguments instanceof Array);//false</font> <font style=\"color:#595959;\"> //console.log(Array.isArray(arguments));//false</font> <font style=\"color:#595959;\"> //console.log(arguments.length);//用来获取实参的长度</font> <font style=\"color:#595959;\"> //console.log(arguments[0]);//hello</font> <font style=\"color:#595959;\"> console.log(arguments.callee);//指向当前这个对象</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fun(\"hello\", true);</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习：1、利用函数求任意个数的最大值 <font style=\"color:#595959;\">function getMax() {</font> <font style=\"color:#595959;\"> var max = arguments[0]</font> <font style=\"color:#595959;\"> for (var i = 0; i < arguments.length; i++) {</font> <font style=\"color:#595959;\"> if (max < arguments[i]) {</font> <font style=\"color:#595959;\"> max = arguments[i]</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> return max</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">var num = getMax(1, 2, 3, 33, 111)</font> 2、封装函数，输入一个年份，判断是否是闰年（闰年可以被4或者400整除） 面试题： 1.伪数组和真数组的区别是什么？ 2.如何获取到伪数组？ 3、函数方法call()，apply() ，bind() -这两个方法都是<font style=\"color:#FF0000;\">函数对象的方法</font>，需要通过函数对象来调用 -当对函数调用call()和apply()方法时，都会调用函数执行 -在<font style=\"color:#FF0000;\">调用call和apply()可以将一个对象指定为第一个参数</font>， <font style=\"color:#FF0000;\">此时这个对象将会成为函数执行的this</font> -<font style=\"color:#FF0000;\">call()方法可以将实参在对象之后一次传递</font> <font style=\"color:#FF0000;\">apply()方法需要将实参封装到一个数组中统一传递</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var name = \"我是window\";</font> <font style=\"color:#595959;\"> function fun(a) {</font> <font style=\"color:#595959;\"> console.log(\"a=\", a);</font> <font style=\"color:#595959;\"> alert(this.name);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> var obj = {</font> <font style=\"color:#595959;\"> name: \"我是obj1\",</font> <font style=\"color:#595959;\"> sayName: function () {</font> <font style=\"color:#595959;\"> alert(this.name);</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> var obj2 = {</font> <font style=\"color:#595959;\"> name: \"我是obj2\",</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //obj.sayName(); //obj</font> <font style=\"color:#595959;\"> //obj.sayName.call(obj2);//obj2</font> <font style=\"color:#595959;\"> //fun.call(obj, 2);//obj1，2</font> <font style=\"color:#595959;\"> //fun.apply(obj2, [2,3]);</font> <font style=\"color:#595959;\"> //fun(1);</font> <font style=\"color:#595959;\"> </script></font> 总结this的情况 <font style=\"color:#FF0000;\">1.以函数形式调用时，this永远是window</font> <font style=\"color:#FF0000;\">2.以方法的形式调用时，this是调用方法的对象</font> <font style=\"color:#FF0000;\">3.以构造函数的形式调用时，this是新创建的那个实例对象</font> <font style=\"color:#FF0000;\">4.使用call和apply调用时，this是指定的那个对象，如果不写第一个参数，默认是window</font> 4、函数调用函数 每个函数都是独立的代码块，用于完成特殊任务，因此经常会用到函数相互调用的情况 一般情况下，一个函数只做一件事 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> function fn1(){</font> <font style=\"color:#595959;\"> console.log(111);</font> <font style=\"color:#595959;\"> fn2();</font> <font style=\"color:#595959;\"> console.log('fn1');</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> function fn2(){</font> <font style=\"color:#595959;\"> console.log(222);</font> <font style=\"color:#595959;\"> console.log('fn2');</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fn1()</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习：用户输入年份，告知当年2月份多少天 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> function getDays() {</font> <font style=\"color:#595959;\"> var year = prompt(\"请输入年份\");</font> <font style=\"color:#595959;\"> if (isRunYear(year)) {</font> <font style=\"color:#595959;\"> alert(\"闰年2月有29天\");</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> alert(\"平年2月有28天\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> getDays();</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> function isRunYear(year) {</font> <font style=\"color:#595959;\"> var flag = false;</font> <font style=\"color:#595959;\"> if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {</font> <font style=\"color:#595959;\"> flag = true;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> return flag;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 5、立即执行函数 语法结构：<font style=\"color:#FF0000;\">函数对象()</font> 立即执行函数，函数定义完后，<font style=\"color:#FF0000;\">立即被调用</font>，立即调用函数，往往<font style=\"color:#FF0000;\">只会执行一次</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //第一种写法</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">(</font><font style=\"color:#595959;\">function(){</font> <font style=\"color:#595959;\"> alert(\"我是一个匿名函数～～～\");</font> <font style=\"color:#595959;\"> }</font><font style=\"color:#FF0000;\">) ()</font><font style=\"color:#595959;\">;//外面的()是把整个函数当作函数名，后面的()是调用函数的意思</font> <font style=\"color:#595959;\"> //第二种写法</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">(</font><font style=\"color:#595959;\">function () {</font> <font style=\"color:#595959;\"> alert('匿名函数执行方式二')</font> <font style=\"color:#595959;\"> }</font><font style=\"color:#FF0000;\">() )</font><font style=\"color:#595959;\">;</font> <font style=\"color:#595959;\"> //匿名函数传参</font> <font style=\"color:#595959;\"> (function(a,b){</font> <font style=\"color:#595959;\"> console.log(\"a=\"+a);</font> <font style=\"color:#595959;\"> console.log(\"b=\"+b);</font> <font style=\"color:#595959;\"> })(123,456);//不仅可以调用，还可以传值</font> <font style=\"color:#595959;\"> </script></font> 1、作用域 （1）、作用域定义 通常来说，一段程序代码中所用到的名字（变量名和函数名）并不总是有效和可用的，而<font style=\"color:#FF0000;\">限定这个名字的可用性的代码范围</font>就是这个名字的<font style=\"color:#FF0000;\">作用域</font>。 简单理解：就是代码名字（变量）在某个范围内起作用和效果 作用域的使用提高了程序<font style=\"color:#FF0000;\">逻辑</font>的局部性，<font style=\"color:#FF0000;\">增强</font>了程序的可靠性，<font style=\"color:#FF0000;\">减少</font>了命名冲突 <font style=\"color:#FF0000;\">js作用域（es6）之前：全局作用域局（函数）部作用域，es6后有块级作用域</font> （2）、全局作用域： 直接编写在script标签中或者一个单独的js文件内的Js代码 全局作用域在页面打开时创建，在页面关闭时销毁 在全局作用域中有一个<font style=\"color:#FF0000;\">全局对象window</font>，它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用它 <font style=\"color:#FF0000;\">在全局作用域中：创建的变量都会作为window对象的属性保存；创建的函数都会作为window对象的方法保存</font> 全局作用域中的变量都是全局变量；在页面的任意部分都可以访问的到 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var a=10;</font> <font style=\"color:#595959;\"> var b=10;</font> <font style=\"color:#595959;\"> // var c=\"hello\";</font> <font style=\"color:#595959;\"> console.log(window.c);//加window.，如果没有找到变量c，会undefined，不加的话，会报错</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> function fun(){</font> <font style=\"color:#595959;\"> console.log(\"我是fun函数\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> window.fun();//创建的函数都会作为window对象的方法保存</font> <font style=\"color:#595959;\"> </script></font> （3）、局部作用域（函数作用域）： 在<font style=\"color:#FF0000;\">函数内部就是局部作用域</font>。这个变量只在函数内部起作用 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁 每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的 在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量 <font style=\"color:#FF0000;\">在函数中如果要访问全局变量，可以使用window对象</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var a = 10;</font> <font style=\"color:#595959;\"> function fun() {</font> <font style=\"color:#595959;\"> var a = \"我是fun函数中的变量a\";</font> <font style=\"color:#595959;\"> //console.log(\"a=\"+a);</font> <font style=\"color:#595959;\"> function fun2() {</font> <font style=\"color:#595959;\"> // console.log(a);</font> <font style=\"color:#595959;\"> console.log(\"a=\" + window.a);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fun2(); //10</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fun();</font> <font style=\"color:#595959;\"> </script></font> 2、变量作用域 在JS中，根据作用域的不同，变量可以分为两种： （1）、全局变量： 在全局作用域下的变量，在全局下都可以使用； <font style=\"color:#FF0000;\">如果在函数内部，不使用var声明的变量，直接赋值的，也属于全局变量</font> （2）、局部变量： 在函数作用域下的变量；函数中定义<font style=\"color:#FF0000;\">形参</font>就<font style=\"color:#FF0000;\">相当于在函数作用域中声明了变量</font> （3）注意点： 从执行效率来看全局变量和局部变量 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源 局部变量，当我们程序执行完毕就会销毁，比较节约内存资源 3、作用域链 只要是代码，就至少有一个作用域 写在函数内部的局部作用域 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域 当在函数作用域中操作一个变量时，它会先在自身作用域中寻找，如果有，就直接使用，如果没有，就去它上一级作用域去寻找，如果全局作用域中依然没找到，则会报错根据在内部函数可以访问外部函数变量的这种机制，用<font style=\"color:#FF0000;\">链式查找决定哪些数据能被内部函数访问，就称做是作用域链</font> 4、预解析执行上下文与执行上下文栈 4.1、变量提升与函数提升 （1）、JS代码是由浏览器中的JS解析器来执行的，JS解析器在运行JS代码的时候分为两步：先预解析再代码执行 <font style=\"color:#FF0000;\">预解析：js引擎会把js里面所有的var 还有function提升到当前作用域的最前面</font> 代码执行：按照代码书写的顺序从上往下执行 （2）、预解析分为变量预解析（变量提升）和函数预解析（函数提升） <font style=\"color:#FF0000;\">变量提升</font>就是把<font style=\"color:#FF0000;\">所有var</font>的变量<font style=\"color:#FF0000;\">声明</font>提升到当前的作用域<font style=\"color:#FF0000;\">最前面</font>，<font style=\"color:#FF0000;\">不</font>提升<font style=\"color:#FF0000;\">赋值</font>操作 <font style=\"color:#FF0000;\">函数提升</font>就是把所有的<font style=\"color:#FF0000;\">函数声明</font>提升到当前作用域<font style=\"color:#FF0000;\">最前面</font>，<font style=\"color:#FF0000;\">不调用</font>函数 小练习： <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //说出以下代码的执行结果</font> <font style=\"color:#595959;\"> //第一题</font> <font style=\"color:#595959;\"> var a=123;</font> <font style=\"color:#595959;\"> function fun(){</font> <font style=\"color:#595959;\"> console.log(a);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fun();</font> <font style=\"color:#595959;\"> //第二题：</font> <font style=\"color:#595959;\"> var a=123;</font> <font style=\"color:#595959;\"> function fun(){</font> <font style=\"color:#595959;\"> alert(a);</font> <font style=\"color:#595959;\"> var a=456;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fun();</font> <font style=\"color:#595959;\"> alert(a);</font> <font style=\"color:#595959;\"> //第三题</font> <font style=\"color:#595959;\"> var a=123;</font> <font style=\"color:#595959;\"> function fun(){</font> <font style=\"color:#595959;\"> alert(a);</font> <font style=\"color:#595959;\"> a=456;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fun();</font> <font style=\"color:#595959;\"> alert(a);</font> <font style=\"color:#595959;\"> //第四题</font> <font style=\"color:#595959;\"> var a=123;</font> <font style=\"color:#595959;\"> function fun(a){//形参相当于声明了，没赋值</font> <font style=\"color:#595959;\"> alert(a);</font> <font style=\"color:#595959;\"> a=456;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fun();</font> <font style=\"color:#595959;\"> alert(a);</font> <font style=\"color:#595959;\"> //第五题</font> <font style=\"color:#595959;\"> var a=123;</font> <font style=\"color:#595959;\"> function fun(a){</font> <font style=\"color:#595959;\"> alert(a);</font> <font style=\"color:#595959;\"> a=456;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fun(123);</font> <font style=\"color:#595959;\"> alert(a);</font> <font style=\"color:#595959;\"> //第六题</font> <font style=\"color:#595959;\"> f1()</font> <font style=\"color:#595959;\"> console.log(c)</font> <font style=\"color:#595959;\"> console.log(b)</font> <font style=\"color:#595959;\"> console.log(a)</font> <font style=\"color:#595959;\"> function f1(){</font> <font style=\"color:#595959;\"> var a=b=c=9 //var a=9;b=9;c=9</font> <font style=\"color:#595959;\"> console.log(a) </font> <font style=\"color:#595959;\"> console.log(b) </font> <font style=\"color:#595959;\"> console.log(c)</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 4.2、执行上下文 （1）. 代码分类(位置) 全局代码 函数代码 （2）. 全局执行上下文 在执行全局代码前将window确定为全局执行上下文 对全局数据进行预处理 <font style=\"color:#FF0000;\">* var定义的全局变量==>undefined, 添加为window的属性</font> <font style=\"color:#FF0000;\">* function声明的全局函数==>赋值(fun), 添加为window的方法</font> <font style=\"color:#FF0000;\">* this==>赋值(window)</font> 开始执行全局代码 <font style=\"color:#595959;\">console.log(a1);//undefined</font> <font style=\"color:#595959;\">console.log(a2);//undefined</font> <font style=\"color:#595959;\">console.log(a3);//函数</font> <font style=\"color:#595959;\">// console.log(a4)</font> <font style=\"color:#595959;\">console.log(this);//window</font> <font style=\"color:#595959;\">var a1 = 3;</font> <font style=\"color:#595959;\">var a2 = function () {</font> <font style=\"color:#595959;\"> console.log(\"a2()\");</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">function a3() {</font> <font style=\"color:#595959;\"> console.log(\"a3()\");</font> <font style=\"color:#595959;\">}</font> （3）. 函数执行上下文 * 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象 * 对局部数据进行预处理 * 形参变量==>赋值(实参)==>添加为执行上下文的属性 * arguments==>赋值(实参列表), 添加为执行上下文的属性 * var定义的局部变量==>undefined, 添加为执行上下文的属性 * function声明的函数 ==>赋值(fun), 添加为执行上下文的方法 <font style=\"color:#FF0000;\">* this==>赋值(调用函数的对象)</font> * 开始执行函数体代码 <font style=\"color:#595959;\"> function fn(x, y) {</font> <font style=\"color:#595959;\"> console.log(x, y); //undefined</font> <font style=\"color:#595959;\"> console.log(b1); //undefined</font> <font style=\"color:#595959;\"> console.log(b2); //函数</font> <font style=\"color:#595959;\"> console.log(arguments); //内容</font> <font style=\"color:#595959;\"> console.log(this); //window</font> <font style=\"color:#595959;\"> // console.log(b3)//报错 b3全局变量，函数调用要用window对象this.b3</font> <font style=\"color:#595959;\"> var b1 = 5;</font> <font style=\"color:#595959;\"> function b2() {}</font> <font style=\"color:#595959;\"> b3 = 6;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fn();</font> 4.3、执行上下文栈 在全局代码执行前, JS引擎就会创建一个<font style=\"color:#FF0000;\">栈</font>来<font style=\"color:#FF0000;\">存储</font>管理所有的<font style=\"color:#FF0000;\">执行上下文对象</font> 在全局执行上下文(<font style=\"color:#FF0000;\">window</font>)确定后, 将其添加到栈中<font style=\"color:#FF0000;\">(压栈)</font> 在<font style=\"color:#FF0000;\">函数</font>执行上下文创建后, 将其添加到栈中(<font style=\"color:#FF0000;\">压栈</font>) 在当前函数<font style=\"color:#FF0000;\">执行完</font>后,将栈顶的对象移除(<font style=\"color:#FF0000;\">出栈</font>) 当<font style=\"color:#FF0000;\">所有</font>的代码<font style=\"color:#FF0000;\">执行完</font>后, 栈中<font style=\"color:#FF0000;\">只剩</font>下<font style=\"color:#FF0000;\">window</font> <font style=\"color:#595959;\"> <script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> //1. 进入全局执行上下文</font> <font style=\"color:#595959;\"> var a = 10;</font> <font style=\"color:#595959;\"> var bar = function (x) {</font> <font style=\"color:#595959;\"> var b = 5;</font> <font style=\"color:#595959;\"> foo(x + b); //3. 进入foo执行上下文</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> var foo = function (y) {</font> <font style=\"color:#595959;\"> var c = 5;</font> <font style=\"color:#595959;\"> console.log(a + c + y);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> bar(10); //2. 进入bar函数执行上下文</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!--</font> <font style=\"color:#595959;\">1. 依次输出什么? 123 321 1</font> <font style=\"color:#595959;\">2. 整个过程中产生了几个执行上下文? </font> <font style=\"color:#595959;\">--></font> <font style=\"color:#595959;\"> <script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> console.log(\"global begin: \" + i); //undefined</font> <font style=\"color:#595959;\"> var i = 1;</font> <font style=\"color:#595959;\"> foo(1);</font> <font style=\"color:#595959;\"> function foo(i) {</font> <font style=\"color:#595959;\"> if (i == 4) {</font> <font style=\"color:#595959;\"> return;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(\"foo() begin:\" + i); //1，2，3</font> <font style=\"color:#595959;\"> foo(i + 1);</font> <font style=\"color:#595959;\"> console.log(\"foo() end:\" + i); //3，2，1</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(\"global end: \" + i); //1</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 4.4、面试题 <font style=\"color:#595959;\"> <script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> /*</font> <font style=\"color:#595959;\"> 测试题1: </font><font style=\"color:#FF0000;\">先预处理变量, 后预处理函数</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\"> function a() {}</font> <font style=\"color:#595959;\"> var a;</font> <font style=\"color:#595959;\"> console.log(typeof a); //function</font> <font style=\"color:#595959;\"> /*</font> <font style=\"color:#595959;\"> 测试题2: 变量预处理, in操作符</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">if语句中的var b 进行变量提升，所以b在window内，</font> <font style=\"color:#595959;\"> 所以if判断中为false，不执行赋值语句，所以b为undefined</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\"> if (!(b in window)) {</font> <font style=\"color:#595959;\"> var b = 1;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(b); //undefined</font> <font style=\"color:#595959;\"> /*</font> <font style=\"color:#595959;\"> 测试题3: </font><font style=\"color:#FF0000;\">预处理, 顺序执行</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\"> var c = 1;</font> <font style=\"color:#595959;\"> function c(c) {</font> <font style=\"color:#595959;\"> console.log(c);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> c(2); //报错</font> <font style=\"color:#595959;\"> // 实际上的执行顺序如下</font> <font style=\"color:#595959;\"> // var c;</font> <font style=\"color:#595959;\"> // function c(c) {</font> <font style=\"color:#595959;\"> // console.log(c);</font> <font style=\"color:#595959;\"> // var c = 3;</font> <font style=\"color:#595959;\"> // }</font> <font style=\"color:#595959;\"> // c = 1;</font> <font style=\"color:#595959;\"> // c(2); //</font><font style=\"color:#FF0000;\">报错，名字重复，误以为调用C=1</font> <font style=\"color:#595959;\"> </script></font> 前言：对象分类 1、自定义对象 2、内置对象 内置对象是JS自带的对象。不需要声明，不需要创建，就可直接使用它，用它的属性和方法来构建我们所需的效果。例如： Array Boolean Date Math Number String RegExp Function Events 3、宿主对象 1、数组的概念 数组是指<font style=\"color:#FF0000;\">一组数据的集合</font>，它也<font style=\"color:#FF0000;\">是</font>个<font style=\"color:#FF0000;\">对象</font>，其中每个数据被称为元素，在数组中可以<font style=\"color:#FF0000;\">存放任意类型</font>的元素，数组是将一组数据存储在单个变量名下的优雅方式 数组也是一个对象，它和我们普通对象功能类似，也是用来存储一些值的，不同的是普通对象是使用字符串作为属性名的,而数组是使<font style=\"color:#FF0000;\">用数字作为索引</font>操作元素，索引：<font style=\"color:#FF0000;\">从0</font>开始的整数就是索引，数组的存储性能比普通对象要好，所以在开发中， 我们经常使用数组来存储数据 2、创建数组二种方式 （1）、利用数组字面量创建数组 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //语法：[]</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">var arr1=[];//创建一个空的数组</font> <font style=\"color:#595959;\"> //使用字面量创建数组时，可以在创建时就指定数组中的元素</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> var arr = [1, 2, 3, 4, 5, 10];//数据用逗号分隔</font> <font style=\"color:#595959;\"> console.log(arr); //[1, 2, 3, 4, 5, 10]</font> <font style=\"color:#595959;\"> console.log(arr[3]); //4</font> <font style=\"color:#595959;\"> </script></font> （2）、利用构造函数创建数组 利用构造函数创建一个空的数组 利用构造函数创建数组(直接填充数组内容,号隔开) 利用构造函数创建数组对象，设置初始长度 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> var arr = new Array();//创建一个空的数组</font> <font style=\"color:#595959;\"> arr[0] = 123;</font> <font style=\"color:#595959;\"> //可以同时添加元素，将要添加的元素作为构造函数的参数传递，元素间使用,号隔开</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">var arr2 = new Array(20, 30, 40); //[20, 30, 40]</font> <font style=\"color:#595959;\"> //创建一个长度为10的数组</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">arr3= new Array(10);</font> <font style=\"color:#595959;\"> console.log(arr3);</font> <font style=\"color:#595959;\"> </script></font> 3、数组的基本操作 （0）、索引（下标）： 用来访问数组元素的序号（数组下表从<font style=\"color:#FF0001;\">0</font>开始） <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var arr=['孙悟空','猪八戒','沙和尚','唐僧']</font> <font style=\"color:#595959;\"> //索引号：0，1，2，3</font> <font style=\"color:#595959;\"> </script></font> （1）、读取数组中的元素 数组可以通过<font style=\"color:#FF0001;\">索引</font>来访问（获取得到）、设置、修改对应的数组元素，我们可以通过\"<font style=\"color:#FF0001;\">数组名[索引]</font>\"的形式来获取数组中的元素。如果读取不存在的索引，他不会报错，而会返回undefined arr[0]==>孙悟空，arr[2]==>沙和尚 课堂小练习：定一个数组，里面存放‘周一’～‘周日’，在控制台输出‘周日’。 （2）、向数组中添加/替换元素 语法：<font style=\"color:#FF0000;\">数组[索引]=值</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> arr[0] = 10;</font> <font style=\"color:#595959;\"> arr[1] = 33;</font> <font style=\"color:#595959;\"> arr[2] = 22;</font> <font style=\"color:#595959;\"></script></font> （3）、获取数组的长度 可以使用length属性来<font style=\"color:#FF0000;\">获取</font>数组的长度,<font style=\"color:#FF0000;\">元素的个数</font> 语法：<font style=\"color:#FF0000;\">数组.length</font> 对于连续的数组，使用length可以获取数组的长度（元素的个数），对于<font style=\"color:#FF0000;\">非连续的数组，使用length会获取到数组的最大索引+1</font> 尽量不要创建非连续的数组 （4）、 修改length arr.length=5; 如果修改的length大于原长度，则多出部分会空出来 如果修改的<font style=\"color:#FF0000;\">length小于原长度</font>，则<font style=\"color:#FF0000;\">多</font>出来的<font style=\"color:#FF0000;\">元素</font>会<font style=\"color:#FF0000;\">被删除</font> （5）、 向数组的最后一个位置添加元素 语法：<font style=\"color:#FF0000;\">数组[数组.length]=值;</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> arr[arr.length] = 10;</font> <font style=\"color:#595959;\"> arr[arr.length] = 70;</font> <font style=\"color:#595959;\"> </script></font> （6）、数组中的元素 数组中的元素可以是任意的数据类型，可以是字符串，数字，对象，数字，函数等都可以 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> arr = [\"hello\", 1, true, null, undefined];</font> <font style=\"color:#595959;\"> console.log(arr);</font> <font style=\"color:#595959;\"> //1:元素也可以是对象</font> <font style=\"color:#595959;\"> var obj = {</font> <font style=\"color:#595959;\"> name: \"孙悟空\",</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> arr[arr.length] = obj; //元素的最后添加对象</font> <font style=\"color:#595959;\"> console.log(arr);</font> <font style=\"color:#595959;\"> console.log(arr[5].name);</font> <font style=\"color:#595959;\"> arr = [{ name: \"孙悟空\" }, { name: \"沙和尚\" }, { name: \"猪八戒\" }];</font> <font style=\"color:#595959;\"> console.log(arr);</font> <font style=\"color:#595959;\"> //2:元素也可以是函数</font> <font style=\"color:#595959;\"> arr = [</font> <font style=\"color:#595959;\"> function () {</font> <font style=\"color:#595959;\"> alert(1);</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> function () {},</font> <font style=\"color:#595959;\"> function () {},</font> <font style=\"color:#595959;\"> ];</font> <font style=\"color:#595959;\"> //arr[0]();//可以调用函数</font> <font style=\"color:#595959;\"> //3:元素也可以是数组,如下的数组我们称为二维数组</font> <font style=\"color:#595959;\"> arr = [</font> <font style=\"color:#595959;\"> [1, 2],</font> <font style=\"color:#595959;\"> [2, 3],</font> <font style=\"color:#595959;\"> [\"a\", \"b\"],</font> <font style=\"color:#595959;\"> ];</font> <font style=\"color:#595959;\"> console.log(arr);</font> <font style=\"color:#595959;\"> </script></font> 4、检测是否为数组 （1）、<font style=\"color:#FF0000;\">instanceof</font>运算符它可以用来<font style=\"color:#FF0000;\">检测是否为数组</font> 语法：<font style=\"color:#FF0000;\">arr instanceof Array</font> 、<font style=\"color:#FF0000;\">Array.isArray(参数)</font> <font style=\"color:#FF0000;\">用于确定传递的值是否是一个 Array</font>。<font style=\"color:#000000;\"> H5新增的方法 ie9以上版本支持</font> 语法：<font style=\"color:#FF0000;\">Array.isArray(value)</font> 5、数组的遍历 遍历：就是把数组中的每个元素从头到尾都访问一次（类似我们每天早上学生的点名） 第一种方式： <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> for (var i = 0; i < arr.length; i++) {</font> <font style=\"color:#595959;\"> console.log(arr[i]);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 第二种方式 优化版for循环 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //使用临时变量，将长度缓存起来，避免重复获取数组长度，</font> <font style=\"color:#595959;\"> //当数组较大时，优化效果会比较明显</font> <font style=\"color:#595959;\"> for (var i = 0, len = arr.length; i < len; i++) {</font> <font style=\"color:#595959;\"> console.log(arr[i]);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#FF0001;\">以下三种作为补充：</font> 第三种方式<font style=\"color:#FF0000;\"> for···in···</font> 主要针对对象比较多 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> for (var i in arr) {</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> console.log(i);//索引</font> <font style=\"color:#FF0000;\"> console.log(arr[i]);//值</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 第四种方式 <font style=\"color:#FF0000;\">for···of···</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> for (var i of arr) {</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> console.log(i);//值</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 第五种方式 <font style=\"color:#FF0000;\">forEach()</font> -这个方法需要一个函数作为参数，只支持IE8以上的浏览器，所以还是建议使用for循环来遍历 -像这种函数，<font style=\"color:#FF0000;\">由我们创建，但是不由我们调用的，我们称为回调函数</font> -数组中有几个元素函数就执行几次,每次执行时，浏览器会将遍历到的元素， 以实参的形式传递进来，我们可以来定义行参，来读取这些内容 -浏览器会在函数中中传递了三个参数; 第一个参数：就是当前正在遍历的元素 第二个参数：就是当前正在遍历的元素的索引 第三个参数：就是当前正在遍历的数组 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> arr.forEach(function (item,index,arr) {</font> <font style=\"color:#595959;\"> console.log(item); //值</font> <font style=\"color:#595959;\"> console.log(index);//索引</font> <font style=\"color:#595959;\"> console.log(arr);//当前的数组</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习： 1、求数组[2,6,3,6,4]里面所有元素的和以及平均值 2、求数组中[2,3,5,8,1,6]中最大的值 6、冒泡排序 冒泡排序： 是一种算法，把一系列的数据按照一定的顺序进行排列显示（<font style=\"color:#FF0000;\">从小到大或从大到小</font>）。 原理： 重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误，就把他们较缓过来。 走访数列的工作是重复地进行，直到没有再需要交换，也就是该数列已经排序完成。 这个算法的名字由来是因为最小的元素会经由交换慢慢“浮”到数列的顶端 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var arr = [1, 3, 6, 4, 5, 2];</font> <font style=\"color:#595959;\"> var temp;</font> <font style=\"color:#595959;\"> // 遍历出每个数据</font> <font style=\"color:#595959;\"> for (var i = 0; i < arr.length-1; i++) {</font> <font style=\"color:#595959;\"> //拿每个arr[i],跟arr中的每个数据进行一轮对比，然后交换数据，小的在前</font> <font style=\"color:#595959;\"> for (var j =0; j < arr.length-1-i; j++) {</font> <font style=\"color:#595959;\"> if (arr[j] > arr[j+1]) {</font> <font style=\"color:#595959;\"> temp = arr[j];</font> <font style=\"color:#595959;\"> arr[i] = arr[j+1];</font> <font style=\"color:#595959;\"> arr[j+1] = temp;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(arr);</font> <font style=\"color:#595959;\"> </script></font> 7、数组的方法 1）、添加删除数组 | 方法名 | 说明 | 返回值 | | --- | --- | --- | | push() | <font style=\"color:rgb(255, 0, 0);\">末尾添加</font>一个或多个元素，修改原数组 | 并返回新数组的<font style=\"color:rgb(255, 0, 0);\">长度</font> | | pop() | <font style=\"color:rgb(255, 0, 0);\">删除</font>数组<font style=\"color:rgb(255, 0, 0);\">最后</font>一个元素，把数组长度减1，<font style=\"color:rgb(255, 0, 0);\">无参数</font>，修改数组 | 并返回<font style=\"color:rgb(255, 0, 0);\">删除的元素的值</font> | | unshift() | 向数组的<font style=\"color:rgb(255, 0, 0);\">开头添加</font>一个或更多元素，修改原数组 | 并返回新数组的<font style=\"color:rgb(255, 0, 0);\">长度</font> | | shift() | <font style=\"color:rgb(255, 0, 0);\">删除</font>数组的<font style=\"color:rgb(255, 0, 0);\">第一个</font>元素，数组长度减1 <font style=\"color:rgb(255, 0, 0);\">无参数</font>，修改原数组 | 并返回<font style=\"color:rgb(255, 0, 0);\">删除的元素的值</font> | (1)、push() -该方法可以向数组的末尾中添加一个或者多个元素，并返回数组新的长度 -可以将要添加的元素作为方法的参数传递，这样这些元素将会自动添加到元素的末尾 -原数组会发生变化 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var arr = [\"孙悟空\", \"沙和尚\", \"猪八戒\"];</font> <font style=\"color:#595959;\"> //arr.push(\"唐僧\",\"蜘蛛精\",\"白骨精\");</font> <font style=\"color:#595959;\"> var result = arr.push(\"唐僧\", \"蜘蛛精\", \"白骨精\");</font> <font style=\"color:#595959;\"> console.log(arr);</font> <font style=\"color:#595959;\"> console.log(\"result=\" + result); //6</font> <font style=\"color:#595959;\"> </script></font> (2)、pop() -该方法可以删除数组的最后一个元素 ,一次就删除一个元素 -pop()没有参数 -将被删除的元素作为返回值返回 -原数组会发生变化 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> arr.pop(); //会删除最后一个元素</font> <font style=\"color:#595959;\"> arr.pop(); //调用一次会删除一个</font> <font style=\"color:#595959;\"> console.log(arr);</font> <font style=\"color:#595959;\"> </script></font> （3）unshift() -向数组开头添加一个或者多个元素，并返回新的数组长度 -向前边插入元素后，其他的元素索引会依次调整 -原数组会发生变化 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> arr.unshift(\"牛魔王\", \"二郎神\");</font> <font style=\"color:#595959;\"> console.log(arr);</font> <font style=\"color:#595959;\"> </script></font> （4）shift() -可以删除数组的第一个元素，一次就删除一个元素 -shift()没有参数 -被删除的元素作为返回值返回 -原数组会发生变化 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> arr.shift(); //删了牛魔王</font> <font style=\"color:#595959;\"> result = arr.shift(); //又删了二郎神</font> <font style=\"color:#595959;\"> console.log(arr);</font> <font style=\"color:#595959;\"> console.log(result); //二郎神</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习： 有一个包含工资的数组[1500,1800,2200,2100,1900],要求把低于2000的工资给删除，返回新数组 2）、数组剩余常用方法 （1）、slice() [slaɪs] -可以用来<font style=\"color:#FF0000;\">从数组提取指定元素</font> <font style=\"color:#FF0000;\">-不</font>会<font style=\"color:#FF0000;\">改变</font>元素<font style=\"color:#FF0000;\">原数组</font>，而是将截取到的元素封装到一个新数组中返回 -参数： <font style=\"color:#FF0000;\">参数1</font>:截取开始的位置的索引,<font style=\"color:#FF0000;\">包含开始索引</font> <font style=\"color:#FF0000;\">参数2</font>:截取结束的位置的索引，<font style=\"color:#FF0000;\">不包含结束索引</font> -第二个参数，可以省略不写，此时会截取从开始索引往后的所有元素 -<font style=\"color:#FF0000;\">索引可以传递一个负值，如果传递一个负值，则从后往前计算，-1:倒数第一个,-2:倒数第二个</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var arr=[\"孙悟空\",\"猪八戒\",\"沙和尚\",\"唐僧\",\"沙和尚\"];</font> <font style=\"color:#595959;\"> console.log(arr);</font> <font style=\"color:#595959;\"> var arr2=arr.slice(0,2);</font> <font style=\"color:#595959;\"> console.log(arr2);//孙悟空，猪八戒</font> <font style=\"color:#595959;\"> </script></font> （2）、splice() [splais] -可以用来<font style=\"color:#FF0000;\">删除数组中的指定元素</font> -会影响到原数组，会将指定元素从原数组中删除,并将<font style=\"color:#FF0000;\">删除的元素作为返回值</font>返回 -参数： <font style=\"color:#FF0000;\">第一个，表示开始位置的索引</font> <font style=\"color:#FF0000;\">第二个，表示删除的数量</font> <font style=\"color:#FF0000;\">第三个及以后...</font> <font style=\"color:#FF0000;\">可以传递一些新的元素，这些元素将会自动插入到开始位置，索引前边</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var result=arr.splice(1,1,\"牛魔王\");//从索引1开始，删除1个</font> <font style=\"color:#595959;\"> console.log(result);</font> <font style=\"color:#595959;\"> console.log(arr);</font> <font style=\"color:#595959;\"> </script></font> （3）、indexOf 查找满足条件的数组索引号 ——<font style=\"color:#FF0000;\">返回</font>在数组中可以找到的一个<font style=\"color:#FF0000;\">给定元素</font>的<font style=\"color:#FF0000;\">第一个索引</font>，如果<font style=\"color:#FF0000;\">不存在</font>，则返回<font style=\"color:#FF0000;\">-1</font> 注意：它只返回第一个满足条件的索引号 ——语法：<font style=\"color:#FF0000;\">arr.indexOf(searchElement) </font> （4）、lastIndexOf ——<font style=\"color:#FF0000;\">返回指定元素</font>在数组中的<font style=\"color:#FF0000;\">最后一个索引</font>，从数组后往前查找，如果<font style=\"color:#FF0000;\">不存在，</font>返回<font style=\"color:#FF0000;\">-1</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var arr = [\"red\", \"orange\", \"green\", \"yellow\", \"green\"];</font> <font style=\"color:#595959;\"> var res = arr.indexOf(\"red\"); //0</font> <font style=\"color:#595959;\"> res = arr.lastIndexOf(\"green\"); //4</font> <font style=\"color:#595959;\"> console.log(res);</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习：去除重复的数组 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //数组去重</font> <font style=\"color:#595959;\"> var arr = [1, 2, 3, 2, 2, 1, 3, 4, 2, 5];</font> <font style=\"color:#595959;\"> var newArr = [];</font> <font style=\"color:#595959;\"> for (var i = 0; i < arr.length; i++) {</font> <font style=\"color:#595959;\"> if (newArr.indexOf(arr[i]) == -1) {</font> <font style=\"color:#595959;\"> // 新数组的最后一位，加上没有的这个数</font> <font style=\"color:#595959;\"> // newArr[newArr.length] = arr[i];</font> <font style=\"color:#595959;\"> newArr.push(arr[i])</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(newArr);</font> <font style=\"color:#595959;\"> </script></font> （5）、concat() 可以<font style=\"color:#FF0000;\">合并两个或多个数组</font>，并将新的数组返回，也可以传其他数据类型，该方法不会对原数组产生影响 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var arr = [\"孙悟空\", \"猪八戒\"];</font> <font style=\"color:#595959;\"> var arr2 = [\"唐僧\"];</font> <font style=\"color:#595959;\"> var arr3 = [\"嫦娥\"];</font> <font style=\"color:#595959;\"> var res = arr.concat(arr2, arr3, \"牛魔王\");</font> <font style=\"color:#595959;\"> console.log(res); //['孙悟空', '猪八戒', '唐僧', '嫦娥', '牛魔王']</font> <font style=\"color:#595959;\"> </script></font> （6）、join() -该方法可以<font style=\"color:#FF0000;\">将数组转成一个字符串</font> -该方法不会对原数组产生影响，而是将<font style=\"color:#FF0000;\">转换后的字符串作为结果返回</font> <font style=\"color:#FF0000;\">-在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符</font> 如果不指定连接符，则默认使用“，”，作为连接符 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var res2 = arr.join(\"hello\");</font> <font style=\"color:#595959;\"> console.log(arr);// ['孙悟空', '猪八戒']</font> <font style=\"color:#595959;\"> console.log(res2);//孙悟空hello猪八戒</font> <font style=\"color:#595959;\"> </script></font> （7）、toString 数组转字符串 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> console.log(arr.toString(), \"toString\");//孙悟空,猪八戒 toString</font> <font style=\"color:#595959;\"> </script></font> （8）、split() ——使用<font style=\"color:#FF0000;\">指定</font>的<font style=\"color:#FF0000;\">分隔符</font>字符串<font style=\"color:#FF0000;\">将</font>一个<font style=\"color:#FF0000;\">String对象分割成子字符串数组</font>，<font style=\"color:#FF0000;\">以</font>一个<font style=\"color:#FF0000;\">指定的分割字串来决定每个拆分的位置 </font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"red,orange,yellow\";</font> <font style=\"color:#595959;\"> var res4 = str.split(\",\");</font> <font style=\"color:#595959;\"> console.log(res4, \"res4\");// ['red', 'orange', 'yellow'] 'res4'</font> <font style=\"color:#595959;\"> </script></font> （9）、reverse() -该方法用来<font style=\"color:#FF0000;\">反转数组</font>（前边的去后边，后边的去前边） -该方法会直接修改原数组！ （10）、sort() -可以用来对数组中的元素进行<font style=\"color:#FF0000;\">排序</font> -会影响原数组，默认会按照<font style=\"color:#FF0000;\">Unicode编码</font>进行排序，即使对纯数字的数组，使用sort()排序，也会按照Unicode编码进行排序， 所以对数字排序时，可能会得到错误的结果，可以<font style=\"color:#FF0000;\">自己来指定排序的规则</font> 可以在sort()添加回调函数，来制定排序规则，回调函数中需要定义<font style=\"color:#FF0000;\">两个形参数</font>，浏览器将会分别使用数组中的元素作为实参去调用回调函数 使用哪个元素调用不确定，但是肯定的是在数组中，a一定在b前边 如果需要升序，则返回a-b， 如果需要降序排列，则返回b-a <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> arr5 = [5, 4, 5, 2, 1, 6, 8, 3];</font> <font style=\"color:#595959;\"> arr5.sort(function (a, b) {</font> <font style=\"color:#595959;\"> return a - b;</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> console.log(arr5);</font> <font style=\"color:#595959;\"> arr5.sort(function (a, b) {</font> <font style=\"color:#595959;\"> return Math.random() - 0.5; //返回值的正负概率分别为50%，故升降序排列是随机的</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> console.log(arr5); //新数组随机排序</font> <font style=\"color:#595959;\"> </script></font> JS中的对象分为3种：自定义对象、内置对象、浏览器对象 起那面两种对象是JS基础内容，属于ECMAScript；第三个浏览器对象属于我们JS独有的； 内置对象就是指JS语言自带的一些对象，这些对象供开发者使用，并提供一些常用的或是最基本而必要的功能（属性和方法 ），程序员不用管具体怎么实现，直接使用就可以了。帮助我们快速开发 JS中提供了多个内置对象：Math、Date、Array、String,Boolean,Number 参考文档：https://developer.mozilla.org/zh-CN/docs/Web/Tutorials 查阅文档的方法： 查阅该方法的功能 查看里面参数的意义和类型 查看返回值的意义和类型 通过demo进行测试 1、Math对象 Math和其他的对象不同，它<font style=\"color:#FF0000;\">不是一个构造函数，它属于一个工具类，不用创建对象</font>，它里面封装了数学运算相关的属性和方法 比如 <font style=\"color:#FF0000;\">Math.PI表示圆周率</font> <font style=\"color:#FF0000;\">Math.abs()</font>可以用来计算一个数的<font style=\"color:#FF0000;\">绝对值</font> <font style=\"color:#FF0000;\">Math.ceil()</font> 可以用来对一个数<font style=\"color:#FF0000;\">向上取整</font>，小数位只要有值，就自动进1 <font style=\"color:#FF0000;\">Math.floor()</font> 可以对一个数进行<font style=\"color:#FF0000;\">向下取整</font>，小数部分会被舍掉 <font style=\"color:#FF0000;\">Math.round()</font> 可以对一个数进行<font style=\"color:#FF0000;\">四舍五入取整</font>,其他数字都是四舍五入，但.5特殊，它往大了取，1.5取成2，-1.5取-1 <font style=\"color:#FF0000;\">Math.random()</font> 可以生成一个<font style=\"color:#FF0000;\">0-1之间的随机数</font>（左闭右开，能取0，取不到1）<font style=\"color:#FF0000;\">[0,1)</font> -生成一个<font style=\"color:#FF0000;\">0-x</font>之间的随机数<font style=\"color:#FF0000;\">Math.round(Math.random()*x)</font> -生成一个<font style=\"color:#FF0000;\">x-y</font>之间的随机数<font style=\"color:#FF0000;\">Math.floor(Math.random()*（y-x+1)+x</font> <font style=\"color:#FF0000;\">Math.max()</font> 可以获取多个数中的<font style=\"color:#FF0000;\">最大值</font> <font style=\"color:#FF0000;\">Math.min()</font> 可以获取多个数中的<font style=\"color:#FF0000;\">最小值</font> <font style=\"color:#FF0000;\">Math.pow(x,y)</font> <font style=\"color:#FF0000;\">返回x的y次幂</font> <font style=\"color:#FF0000;\">Math.sqrt()</font> 对一个数进行<font style=\"color:#FF0000;\">开方运算</font> 课堂小练习： 1、程序随机生成一个1-10之间的数字，并让用户输入一个数字 如果大于该数字，就提示，数字大了，继续猜 如果小于该数字，就提示，数字小了，继续猜 如果等于该数字，就提示猜对了，结束程序 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var trueNum = Math.floor(Math.random() * 100 + 1);</font> <font style=\"color:#595959;\"> var num = +prompt(\"请输入数字\");</font> <font style=\"color:#595959;\"> console.log(trueNum);</font> <font style=\"color:#595959;\"> while (true) {</font> <font style=\"color:#595959;\"> if (trueNum < num) {</font> <font style=\"color:#595959;\"> alert(\"大了\");</font> <font style=\"color:#595959;\"> num = +prompt(\"请输入数字\");</font> <font style=\"color:#595959;\"> } else if (trueNum > num) {</font> <font style=\"color:#595959;\"> alert(\"小了\");</font> <font style=\"color:#595959;\"> num = +prompt(\"请输入数字\");</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> alert(\"恭喜你\");</font> <font style=\"color:#595959;\"> break;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 2、Date对象 在js中使用Date它是一个<font style=\"color:#FF0000;\">构造函数</font>，所以必须要<font style=\"color:#FF0000;\">实例化后才能使用</font>，用来<font style=\"color:#FF0000;\">处理日期和时间</font> (1)、创建一个Date对象 —直接使用构造函数创建一个Date对象，则<font style=\"color:#FF0000;\">会封装为当前代码执行的时间</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var d = new Date();</font> <font style=\"color:#595959;\"> </script></font> (2)、创建指定的时间对象 -需要<font style=\"color:#FF0000;\">在构造函数中传递</font>一个<font style=\"color:#FF0000;\">表示时间的字符串或数字</font>作为参数 -日期的格式三种写法：如下： <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var d2 = new Date(\"</font><font style=\"color:#FF0000;\">10/23/2023</font><font style=\"color:#595959;\"> 9:00:00\");//</font><font style=\"color:#FF0000;\">字符串型</font> <font style=\"color:#595959;\"> var d4 = new Date(\"</font><font style=\"color:#FF0000;\">2023-11-09</font><font style=\"color:#595959;\"> 8:59:00\");//</font><font style=\"color:#FF0000;\">字符串型</font> <font style=\"color:#595959;\"> var d3 = new Date(</font><font style=\"color:#FF0000;\">2023, 11, 09</font><font style=\"color:#595959;\">);//</font><font style=\"color:#FF0000;\">数字型</font> <font style=\"color:#595959;\"> </script></font> (3):时间对象的方法 <font style=\"color:#FF0000;\">getFullYear()</font>-获取<font style=\"color:#FF0000;\">当前</font>日期对象的<font style=\"color:#FF0000;\">年份</font> <font style=\"color:#FF0000;\">getMonth() </font>-获取<font style=\"color:#FF0000;\">当前</font>时间对象的<font style=\"color:#FF0000;\">月份</font> -会返回一个<font style=\"color:#FF0000;\">0-11</font>的值 <font style=\"color:#FF0000;\">0表示1月</font>，1表示2月，<font style=\"color:#FF0000;\">11表示12月</font>，<font style=\"color:#FF0000;\">要返回的月份+1</font> <font style=\"color:#FF0000;\">getDate()</font>-获取<font style=\"color:#FF0000;\">当前</font>日期对象是<font style=\"color:#FF0000;\">几号</font>(0-31) <font style=\"color:#FF0000;\">getDay()</font>-获取<font style=\"color:#FF0000;\">当前</font>日期对象是<font style=\"color:#FF0000;\">周几</font> -会返回一个<font style=\"color:#FF0000;\">0-6</font>的值，<font style=\"color:#FF0000;\">0表示周日</font> 1表示周一，6表示周六 <font style=\"color:#FF0000;\">getHours()</font> 获取<font style=\"color:#FF0000;\">当前小时</font> <font style=\"color:#FF0000;\">getMinutes() </font>获取<font style=\"color:#FF0000;\">当前分钟</font> <font style=\"color:#FF0000;\">getSeconds()</font>获取<font style=\"color:#FF0000;\">当前秒钟</font> 时间戳 <font style=\"color:#FF0000;\">时间戳</font>，指的是<font style=\"color:#FF0000;\">从</font>格林威治<font style=\"color:#FF0000;\">标准时间</font>的1970年1月1日0时:0分:0秒<font style=\"color:#FF0000;\">到当前日期</font>所花费的<font style=\"color:#FF0000;\">豪秒数</font> <font style=\"color:#FF0000;\">1s=1000ms</font>，计算机底层在保存时间时，使用的都是时间戳 <font style=\"color:#FF0000;\">getTime() </font>-获取<font style=\"color:#FF0000;\">当前</font>日期对象的<font style=\"color:#FF0000;\">时间戳</font> nowTime.getTime() <font style=\"color:#FF0000;\">Date.now()</font> 获取<font style=\"color:#FF0000;\">当前代码执行</font>时的时间的<font style=\"color:#FF0000;\">时间戳</font> <font style=\"color:#FF0000;\">nowTime.valueOf() </font>获取<font style=\"color:#FF0000;\">当前日期</font>对象的<font style=\"color:#FF0000;\">时间戳</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var nowTime = new Date();</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> //获取当前的时间戳(4种方法)</font> <font style=\"color:#595959;\"> var time = +new Date();</font> <font style=\"color:#595959;\"> var time1 = Date.now();//h5新增的</font> <font style=\"color:#595959;\"> var time2 = nowTime.valueOf();</font> <font style=\"color:#595959;\"> var time3 = nowTime.getTime();</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> //利用时间戳来测试代码的执行的性能</font> <font style=\"color:#595959;\"> var start = Date.now();</font> <font style=\"color:#595959;\"> var end = Date.now();</font> <font style=\"color:#595959;\"> // console.log(\"执行了\" + (end - start));</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习：自制一个倒计时 现在的时间 传入的时间 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // 封装倒计时函数</font> <font style=\"color:#595959;\"> function countDown(time) {</font> <font style=\"color:#595959;\"> var nowTime = +new Date(); //当前时间的毫秒数</font> <font style=\"color:#595959;\"> var inputTime = +new Date(time); //输入时间的毫秒数</font> <font style=\"color:#595959;\"> var times = (inputTime - nowTime) / 1000; //输入时间与当前时间的秒数</font> <font style=\"color:#595959;\"> var d = parseInt(times / 60 / 60 / 24); //天</font> <font style=\"color:#595959;\"> var h = parseInt((times / 60 / 60) % 24); //时</font> <font style=\"color:#595959;\"> h = h < 10 ? \"0\" + h : h;</font> <font style=\"color:#595959;\"> var m = parseInt((times / 60) % 60); //分</font> <font style=\"color:#595959;\"> m = m < 10 ? \"0\" + m : m;</font> <font style=\"color:#595959;\"> var s = parseInt(times % 60); //当前的秒</font> <font style=\"color:#595959;\"> s = s < 10 ? \"0\" + s : s;</font> <font style=\"color:#595959;\"> return \"剩余时间： \" + d + \"天\" + h + \"时\" + m + \"分\" + s + \"秒\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> var res = countDown(\"2023/9/24\");</font> <font style=\"color:#595959;\"> console.log(res);</font> <font style=\"color:#595959;\"> </script></font> 3、基本包装类 基本数据类型：String Number Boolean Null Undefined 引用数据类型：Object 1）、包装类 在js中为我们提供了三个包装类，通过这三个包装类可以基本数据类型转换为对象 String()可以将基本数据类型字符串转换为String对象 Number()可以将基本数据类型数字转换为Number对象 Boolean()可以将基本数据类型布尔值转换为Boolean对象 注意：我们在实际应用中不会使用基本数据类型的对象，如果使用基本数据类型的对象，在做一些比较时，会带来一些不可预估的结果 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //创建一个Number类型的对象</font> <font style=\"color:#595959;\"> var num=new Number(3);</font> <font style=\"color:#595959;\"> var str=new String(\"hello\");</font> <font style=\"color:#595959;\"> var bool=new Boolean(true)</font> <font style=\"color:#595959;\"> num.hello=\"abc你好\"</font> <font style=\"color:#595959;\"> console.log(typeof num)//object</font> <font style=\"color:#595959;\"> console.log(num.hello)//abc你好</font> <font style=\"color:#595959;\"> </script></font> 注意：方法和属性只能添加给对象，不能添加给基本数据类型,当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，然后再调用对象的属性跟方法调用完以后，再将其转换为基本数据类型 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var s=123</font> <font style=\"color:#595959;\"> s=s.toString()</font> <font style=\"color:#595959;\"> console.log(s,typeof s);</font> <font style=\"color:#595959;\"> </script></font> 2）、字符串方法 （1）、length属性 可以获取<font style=\"color:#FF0000;\">字符串的长度</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"hello\";</font> <font style=\"color:#595959;\"> / </font><font style=\"color:#FF0000;\">在底层字符串是以字符数组的形式保存</font><font style=\"color:#595959;\">的 [\"h\",\"e\",\"l\",\"l\",\"o\"] /</font> <font style=\"color:#595959;\"> console.log(str.length); //5</font> <font style=\"color:#595959;\"> </script></font> （2）、charAt() 可以<font style=\"color:#FF0000;\">返回字符串中指定位置的字符</font>，<font style=\"color:#FF0000;\">根据索引获取</font>指定的字符 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"hello\";</font> <font style=\"color:#595959;\"> var res = str.charAt(0); //h</font> <font style=\"color:#595959;\"> console.log(str[0]); //h</font> <font style=\"color:#595959;\"> </script></font> （3）、concat() -可以用来<font style=\"color:#FF0000;\">连接两个或者多个字符串</font> -作用和+一样 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"hello\";</font> <font style=\"color:#595959;\"> res = str.concat(\",你好\", \",再见\"); //hello,你好,再见</font> <font style=\"color:#595959;\"> </script></font> （4）、indexof() -该方法可以<font style=\"color:#FF0000;\">检索</font>一个<font style=\"color:#FF0000;\">字符串中是否含有指定内容</font> -如果字符串中含有该内容，则会<font style=\"color:#FF0000;\">返回其第一次出现的索引</font>，如果<font style=\"color:#FF0000;\">没有</font>找到指定的内容，则<font style=\"color:#FF0000;\">返回-1</font> -可以指定<font style=\"color:#FF0000;\">第二个参数</font>，<font style=\"color:#FF0000;\">指定开始查找的位置</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"hello\";</font> <font style=\"color:#595959;\"> res = str.indexOf(\"p\"); //-1</font> <font style=\"color:#595959;\"> </script></font> （5）、 lastIndexOf() -该方法的用法和indexOf()一样，不同的是lastIndexOf是<font style=\"color:#FF0000;\">从后往前找</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"hello\";</font> <font style=\"color:#595959;\"> res = str.lastIndexOf(\"l\"); //3</font> <font style=\"color:#595959;\"> </script></font> （6）、 slice() -可以<font style=\"color:#FF0000;\">从字符串中截取指定的内容 </font> -<font style=\"color:#FF0000;\">不</font>会<font style=\"color:#FF0000;\">影响原字符串</font>，而是<font style=\"color:#FF0000;\">将截取到的内容返回</font> -参数： 第一个，开始位置的索引（包括开始位置） 第二个，结束位置的索引（不包括结束的位置） -如果省略第二个参数，则会截取后边所有的 -也可以传递一个<font style=\"color:#FF0000;\">负数</font>作为参数，负数的话将会<font style=\"color:#FF0000;\">从后边计算</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"hello\";</font> <font style=\"color:#595959;\"> res = str.slice(0, 2); //he</font> <font style=\"color:#595959;\"> </script></font> （7）、substring() -用来截取一个字符串，跟slice()类似 -参数： 第一个，开始位置的索引（包括开始位置） 第二个，结束位置的索引（不包括结束的位置） -如果省略第二个参数，则会截取后边所有的 -跟slice()不同的是这个方法<font style=\"color:#FF0000;\">不能接收负值</font>作为参数 如果传递了一个<font style=\"color:#FF0000;\">负值</font>，则<font style=\"color:#FF0000;\">默认使用0</font> 而且他还会<font style=\"color:#FF0000;\">自动调整参数</font>的位置，如果第二个参数小于第一个，则自动交换 （8）、substr() -用来<font style=\"color:#FF0000;\">截取字符串</font> -参数： <font style=\"color:#FF0000;\">1:截取开始位置的索引</font> <font style=\"color:#FF0000;\">2:截取的长度 </font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"hello\";</font> <font style=\"color:#595959;\"> res = str.substr(0, 3); //hel</font> <font style=\"color:#595959;\"> </script></font> （9）、 split() -可以将一个<font style=\"color:#FF0000;\">字符串拆分为</font>一个<font style=\"color:#FF0000;\">数组</font> -参数 <font style=\"color:#FF0000;\">需要一个字符串作为参数，将会根据该字符串去拆分字符串</font> 如果传递一个空串作为参数，则会将每个字符都拆分为数组中的一个元素 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"abc,bcd,efg,hij\";</font> <font style=\"color:#595959;\"> res = str.split(\",\");</font> <font style=\"color:#595959;\"> </script></font> （10）、replace（'被替换的字符'，'替换为的字符'） 它只会<font style=\"color:#FF0000;\">替换第一个字符</font> （11）、 toUpperCase() -将一个字符串<font style=\"color:#FF0000;\">转换为大写</font>并返回 （12）、 toLowerCase() -将一个字符串<font style=\"color:#FF0000;\">转换为小写</font>并返回 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"ABCDEFG\";</font> <font style=\"color:#595959;\"> res = str.toLowerCase();</font> <font style=\"color:#595959;\"> console.log(res);</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习： 1、查找字符串\"adcdserddsfehdsd\"中所有d出现的位置以及次数 2、判断一个字符串\"adcdserddsfehdsd\"中出现次数最多的字符，并统计其次数 3、有一个字符串\"adcdserddsfehdsd\"，把其中的所有的d替换成- <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //1、查找字符串\"adcdserddsfehdsd\"中所有d出现的位置以及次数</font> <font style=\"color:#595959;\"> var str = \"adcdserddsfehdsd\";</font> <font style=\"color:#595959;\"> var index = str.indexOf(\"d\");</font> <font style=\"color:#595959;\"> var num =1</font> <font style=\"color:#595959;\"> while (index !== -1) {</font> <font style=\"color:#595959;\"> console.log(index);</font> <font style=\"color:#595959;\"> index = str.indexOf(\"d\", index + 1);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log('num'+num);</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //2、判断一个字符串\"adcdserddsfehdsd\"中出现次数最多的自负，并统计其次数</font> <font style=\"color:#595959;\"> // 思路：</font> <font style=\"color:#595959;\"> // 利用charAt()遍历这个字符串</font> <font style=\"color:#595959;\"> // 把每个字符都存储给对象，如果对象没有该属性，就为1，如果存在了就+1</font> <font style=\"color:#595959;\"> // 遍历对象，得到最大值和该字符</font> <font style=\"color:#595959;\"> var str = \"adcdserddsfehdsd\";</font> <font style=\"color:#595959;\"> var obj = {};</font> <font style=\"color:#595959;\"> var max = 0;</font> <font style=\"color:#595959;\"> var ch=''</font> <font style=\"color:#595959;\"> for (var i = 0; i <script str.length; i++) {</font> <font style=\"color:#595959;\"> var chars = str.charAt(i);</font> <font style=\"color:#595959;\"> if (obj[chars]) {</font> <font style=\"color:#595959;\"> obj[chars]++;</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> obj[chars] = 1;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> for (var j in obj) {</font> <font style=\"color:#595959;\"> if (obj[j] > max) {</font> <font style=\"color:#595959;\"> max = obj[j];</font> <font style=\"color:#595959;\"> ch=j</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(\"max:\" + max, \"值:\"+ch);</font> <font style=\"color:#595959;\"> </script></font> （一）、数据类型内存 1、简单类型与复杂类型 <font style=\"color:#F33232;\">简单</font>类型又叫做<font style=\"color:#F33232;\">基本数据</font>类型或者<font style=\"color:#F33232;\">值</font>类型，<font style=\"color:#F33232;\">复杂</font>类型又叫做<font style=\"color:#F33232;\">引用</font>类型 值类型：简单数据类型/基本数据类型，在存储时变量中存储的时值本身，因此叫做值类型 string、number、boolean、undefined、null 注意：简单数据类型 null 返回的是一个空的对象object 如果有个变量我们以后打算存储为对象，暂时没想好放啥，就可以给null 引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型，通过new关键字创建的对象（系统对象、自定义对象），如Obect、Array、Date等 2、堆和栈 <font style=\"color:#404040;\">简单理解栈的存取方式</font> 简单理解下堆 <font style=\"color:#404040;\">堆数据结构是一种树状结构。它的存取数据的方式，则与书架与书非常相似</font> 堆栈空间分配区别： 栈（操作系统）：<font style=\"color:#F33232;\">简单数据类型存放在栈里面，</font><font style=\"color:#000000;\">里面直接开辟一个空间存放的是值</font> <font style=\"color:#000000;\">堆（操作系统）：存储复杂类型（对象），一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</font> <font style=\"color:#FF0001;\">复杂数据类型存放在堆里面，</font><font style=\"color:#000000;\">它是先是在</font><font style=\"color:#FF0001;\">栈里面存放地址，</font><font style=\"color:#000000;\">十六进制表示，然后这个地址</font><font style=\"color:#FF0001;\">指向堆里面的数据</font> <font style=\"color:#FF0001;\">总结：</font> 1、JS中的变量都是保存到栈内存里的 2、基本数据类型<font style=\"color:#FF0000;\">的值</font>直接在<font style=\"color:#FF0000;\">栈内存</font>中存储，值与值之间是<font style=\"color:#FF0000;\">独立</font>存在的，修改一个变量不会影响其他的变量 3、引用数据类型<font style=\"color:#FF0000;\">的值</font>直接保存到<font style=\"color:#FF0000;\">堆内存</font>中的，每创建一个新的对象，就会在堆内存中开辟一个新的空间，而<font style=\"color:#FF0000;\">变量保存</font>的是<font style=\"color:#FF0000;\">对象</font>的<font style=\"color:#FF0000;\">内存地址</font>（对象的引用），如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响 4、比较两个基本属性类型的值时，就是比较值； 比较两个引用数据类型时，它是比较对象的内存地址，如果两个对象时一模一样的，但是地址不同，他也会返回false <font style=\"color:#000000;\">课堂小练习 </font> <font style=\"color:#000000;\">1、画图掌握简单数据类型</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var a = 123;</font> <font style=\"color:#595959;\"> var b = a;</font> <font style=\"color:#595959;\"> a++;</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">2、画图掌握复杂数据类型</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var obj = new Object();//{}</font> <font style=\"color:#595959;\"> obj.name = \"java\";</font> <font style=\"color:#595959;\"> var obj2 = obj;</font> <font style=\"color:#595959;\"> obj2.name = \"web\";</font> <font style=\"color:#595959;\"> console.log(obj.name);//web</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> var obj=new Object </font> <font style=\"color:#595959;\"> obj.name='java'</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> var obj2=new Object </font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> var obj2='java'</font> <font style=\"color:#595959;\"> </script></font> 1、概念 正则表达式（规则表达式） ——用于定义一些字符串的规则，计算机可以根据正则表达式，来检查一个字符串是否符合规则，将字符串中符合规则的内容提取出来 2、创建正则 （1）、方式一：构造函数创建 <font style=\"color:#FF0000;\">var 变量=new RegExp(\"正则表达式\",\"匹配模式\");</font> <font style=\"color:#FF0000;\">参数一：规则</font> <font style=\"color:#FF0000;\">参数二：</font> <font style=\"color:#FF0000;\">i 忽略大小写</font> <font style=\"color:#FF0000;\">g 全局匹配模式</font> 使用typeof检查正则对象，会返回object <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var reg=new RegExp(\"a\",\"i\");//可以用来检查一个字符串中是否含有a，忽略大小写</font> <font style=\"color:#595959;\"> console.log(typeof reg);//object</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">（2）、</font>方式二：字面量来创建 <font style=\"color:#FF0000;\">语法：var 变量=/正则表达式/匹配模式</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var reg = /a/i;</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#FF0000;\">正则test()方法：</font> 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果<font style=\"color:#FF0000;\">符合返回true</font>，否则返回false <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var reg = /a/i;</font> <font style=\"color:#595959;\"> var str = \"abc\";</font> <font style=\"color:#595959;\"> var res = reg.test(str);</font> <font style=\"color:#595959;\"> console.log(res);//true</font> <font style=\"color:#595959;\"> console.log(reg.test(\"cb\"));//false</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">3、正则语法</font> （1）、使用 ｜ 表示 或者 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //需求：创建一个正则表达式，检查一个字符串中是否有a或者b或者c</font> <font style=\"color:#595959;\"> var reg = /a|b|c/i;</font> <font style=\"color:#595959;\"> console.log(reg.test(\"bcd\"));</font> <font style=\"color:#595959;\"> </script></font> （2）、[]里的内容也是或的关系 [ab]==a|b <font style=\"color:#FF0000;\">[a-z] 任意小写字母</font> <font style=\"color:#FF0000;\">[A-Z] 任意大写字母</font> <font style=\"color:#FF0000;\">[A-z] 任意字母</font> <font style=\"color:#FF0000;\">[0-9] 任意数字</font> （3）、 [^] 除了 查找任何不在方括号之间的字符 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> reg = /[^ab]/; //除了a或b,只要有ab以外的存在</font> <font style=\"color:#595959;\"> console.log(reg.test(\"abc\")); //true</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">（4）、量词</font> -通过量词可以设置一个内容出现的次数， 量词只对它前边的一个内容起作用 <font style=\"color:#FF0000;\">{n}正好出现n次</font> <font style=\"color:#FF0000;\">{m,n}出现m-n次</font> <font style=\"color:#FF0000;\">{m,}m次以上</font> <font style=\"color:#FF0000;\">+ 至少出现一次，相当于{1,}</font> <font style=\"color:#FF0000;\">* 0个或多个，相当于{0,}</font> <font style=\"color:#FF0000;\">？ 0个或1个，相当于{0,1}</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var reg = /a{3}/; //==/aaa/</font> <font style=\"color:#595959;\"> reg = /ab{3}/; //abbb</font> <font style=\"color:#595959;\"> reg = /(ab){3}/; //ababab</font> <font style=\"color:#595959;\"> reg = /ab{1,3}c/; //b出现1-3次皆可</font> <font style=\"color:#595959;\"> reg = /ab+c/; //至少一个b</font> <font style=\"color:#595959;\"> reg = /a?bc/; //0个或1个a</font> <font style=\"color:#595959;\"> reg = /a*bc/; //有没有a都行</font> <font style=\"color:#595959;\"> //console.log(reg.test(\"bc\"));</font> <font style=\"color:#595959;\"> </script></font> （5）、^、$ <font style=\"color:#FF0000;\">^ 表示开头</font> <font style=\"color:#FF0000;\">$ 表示结尾</font> <font style=\"color:#FF0000;\">如果在正则表达式中，同时使用^$,则要求字符串必须完全符合正则表达式</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> reg = /^a/; //匹配开头的a</font> <font style=\"color:#595959;\"> reg = /a$/; //匹配结尾的a</font> <font style=\"color:#595959;\"> reg = /^aa$/;</font> <font style=\"color:#595959;\"> reg = /^a|a$/; //以a开头或者以a结尾</font> <font style=\"color:#595959;\"> console.log(reg.test(\"a\"));</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习 1、创建一个正则表达式，用来检查一个字符串是否是一个合法手机号 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> /* 课堂小练习：手机号的规则</font> <font style=\"color:#595959;\"> 1:以1开头;</font> <font style=\"color:#595959;\"> 2:第二位3-9的任意数字;</font> <font style=\"color:#595959;\"> 3:三位以后任意数字9个;</font> <font style=\"color:#595959;\"> ^1 [3-9] [0-9]{9}$</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\"> var phoneStr = \"183o6789012\";</font> <font style=\"color:#595959;\"> var phoneReg = /^1[3-9][0-9]{9}$/;</font> <font style=\"color:#595959;\"> console.log(phoneReg.test(phoneStr));</font> <font style=\"color:#595959;\"> </script></font> （6）、. 表示任意字符 （7）、\\ 转义字符 注意：使用构造函数时，由于它的参数是一个字符串，而\\是字符串中转义字符， 如果要使用\\则需要使用\\\\来代替 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var reg = /\\./; // .</font> <font style=\"color:#595959;\"> reg = /\\\\/; // \\</font> <font style=\"color:#595959;\"> reg = new RegExp(\"\\.\"); //在字符串中，要用\\作为转义字符</font> <font style=\"color:#595959;\"></script></font> （8）、四组 \\ 语法 <font style=\"color:#FF0000;\">\\w -任意字母，数字，_ </font> <font style=\"color:#FF0000;\">\\W -除了字母、数字、_</font> <font style=\"color:#FF0000;\">\\d -任意数字[0-9]</font> <font style=\"color:#FF0000;\">\\D -除了数字[^(0-9)]</font> <font style=\"color:#FF0000;\">\\s -空格</font> <font style=\"color:#FF0000;\">\\S -除了空格</font> <font style=\"color:#FF0000;\">\\b -单词边界</font> <font style=\"color:#FF0000;\">\\B -除了单词边界</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> / 需求：创建一个正则表达式检查一个字符串中是否有单词child /</font> <font style=\"color:#595959;\"> reg = /\\bchild\\b/; //保证前后都没有，这是独立的单词</font> <font style=\"color:#595959;\"> // console.log(reg.test(\"hello,children\"))</font> <font style=\"color:#595959;\"> / 需求：去除字符串中的空格/</font> <font style=\"color:#595959;\"> str = \" he llo \";</font> <font style=\"color:#595959;\"> //str=str.replace(/\\s/g,\"\");//去除所有空格</font> <font style=\"color:#595959;\"> //去除开头的空格</font> <font style=\"color:#595959;\"> //str=str.replace(/^\\s*/,\"\")//去除开头所有空格</font> <font style=\"color:#595959;\"> //str=str.replace(/\\s*$/,\"\")//去掉结尾的空格</font> <font style=\"color:#595959;\"> //str = str.trim();//去除开头和结尾的空格</font> <font style=\"color:#595959;\"> console.log(str);</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">4、正则与字符串相关的方法</font> （1）、 split() <font style=\"color:#FF0000;\">-可以将一个字符串拆分为一个数组 </font> -方法中可以传递一个正则表达式作为参数，这样方法将会根据<font style=\"color:#F33232;\">正则表达式</font>去拆分字符串 <font style=\"color:#FF0000;\">-这个方法即使不指定全局匹配，也会全都拆分</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"1a2b3c4d5r6f7\";</font> <font style=\"color:#595959;\"> var res = str.split(\"c\"); //['1a2b3', '4d5r6f']</font> <font style=\"color:#595959;\"> //根据任意字母来将字符串拆分</font> <font style=\"color:#595959;\"> res = str.split(/[A-z]/); //['1', '2', '3', '4', '5', '6', '7']</font> <font style=\"color:#595959;\"> </script></font> （2）、search() -可<font style=\"color:#FF0000;\">以搜索字符串中是否含有指定内容</font> -如果搜索到指定内容，则会返回<font style=\"color:#FF0000;\">第一次</font>出现的<font style=\"color:#FF0000;\">索引</font>，如果<font style=\"color:#FF0000;\">没有</font>搜索到，返回<font style=\"color:#FF0000;\">-1</font> -它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串 <font style=\"color:#FF0000;\">-search()只会查找第一个，即使设置全局匹配也没用</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"hello abc hello abc aec afc\";</font> <font style=\"color:#595959;\"> res = str.search(\"abc\"); //6</font> <font style=\"color:#595959;\"> res = str.search(\"abcd\"); //-1</font> <font style=\"color:#595959;\"> res = str.search(/a[bef]c/); //6</font> <font style=\"color:#595959;\"> </script></font> （3）、 match() -可以根据正则表达式，从一个字符串中将符合条件的内容提取出来 -默认情况下，我们的<font style=\"color:#FF0000;\">match只会找到第一个符合要求的内容，</font>找到以后就停止检索，我们可以<font style=\"color:#FF0000;\">设置</font>正则表达式为<font style=\"color:#FF0000;\">全局</font>匹配模式，从而<font style=\"color:#FF0000;\">匹配到所有的内容</font>，可以为一个正则表达式设置多个匹配模式，且顺序都可以 <font style=\"color:#FF0000;\">-match()会讲匹配到的内容封装到一个数组中返回，即使只查询到一个结果</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"1a2b3c4d5r6f7A8B9\";</font> <font style=\"color:#595959;\"> res = str.match(/[a-z]/gi); //['a', 'b', 'c', 'd', 'r', 'f', 'A', 'B']</font> <font style=\"color:#595959;\"> //console.log(Array.isArray(res));//true</font> <font style=\"color:#595959;\"> //console.log(res[0]);//a</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">课堂小练习：筛选出数字</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // 需求：筛选出数字</font> <font style=\"color:#595959;\"> var str = \"hhsdfx12453knls442k\";</font> <font style=\"color:#595959;\"> //方式一</font> <font style=\"color:#595959;\"> var strArr = str.split(\"\");</font> <font style=\"color:#595959;\"> let num = strArr.filter(function (a) {</font> <font style=\"color:#595959;\"> return !Number.isNaN(parseInt(a));</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> console.log(num.join(\"\"));</font> <font style=\"color:#595959;\"> //方式二</font> <font style=\"color:#595959;\"> console.log(str.match(/\\d/g).join(\"\"));</font> <font style=\"color:#595959;\"> </script></font> （4）、 replace() <font style=\"color:#FF0000;\">-可以将字符串中指定内容替换为新的内容</font> <font style=\"color:#FF0000;\">-参数：</font> <font style=\"color:#FF0000;\">1:被替换的内容，可以接受正则表达式为参数</font> <font style=\"color:#FF0000;\">2:新的内容</font> <font style=\"color:#FF0000;\">-默认只会替换第一个</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var str = \"1a2a3a4d5r6f7A8B9\";</font> <font style=\"color:#595959;\"> res = str.replace(\"a\", \"@\");</font> <font style=\"color:#595959;\"> res = str.replace(/a/gi, \"@\"); //1@2@3@4d5r6f7@8B9</font> <font style=\"color:#595959;\"> res = str.replace(/[a-z]/gi, \"\"); //空串，就都删了</font> <font style=\"color:#595959;\"> console.log(res);</font> <font style=\"color:#595959;\"> </script></font> （一）、DOM简介 1、什么是DOM <font style=\"color:#FF0000;\">文档对象模型</font>（Document Object Model ，简称DOM），它就是一些系列<font style=\"color:#FF0000;\">编程接口</font>，有了这些接口，就可以<font style=\"color:#FF0000;\">改变页面内容，结构和样式</font> DOM树： 文档：一个页面就是一个文档，DOM中使用document表示 元素：页面中所有的标签都是元素，DOM中使用element表示 节点：网页中所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示 <font style=\"color:#FF0000;\">DOM把以上内容都看作是对象</font> <font style=\"color:#000000;\">2、事件前言</font> <font style=\"color:#FF0000;\">事件，就是用户和浏览器之间的交互行为</font>，比如：点击按钮，鼠标移动，关闭窗口..... 事件非常多，为了方便演示，先学简单的事件，后面再详细学习 <font style=\"color:#000000;\">第一种方式：</font> <font style=\"color:#000000;\">标签中</font>对应的属性中<font style=\"color:#000000;\">设置一些js代码</font>，这样当事件被触发时，这些代码将会被执行 这种方式：<font style=\"color:#FF0000;\">结构与行为耦合，不方便维护，不推荐使用</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> <button id=\"btn\" onclick=\"alert('哈喽');\">我是一个按钮</button> //onclick点击事件，点击的时候触发</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">第二种方式：</font> 可以为按钮的对应事件<font style=\"color:#000000;\">绑定处理函数</font>的形式来响应事件，这样当<font style=\"color:#000000;\">事件被触发</font>时，其<font style=\"color:#000000;\">对应的函数将会被调用</font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <button id=\"btn\">我是一个按钮</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">//第一步：获取按钮对象</font> <font style=\"color:#595959;\"> var btn=document.getElementById(\"btn\");</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> //第二步：绑定一个单击事件</font> <font style=\"color:#595959;\"> //像这种为单击事件绑定的函数，我们称为单击响应函数</font> <font style=\"color:#595959;\"> btn.onclick=function(){</font> <font style=\"color:#595959;\"> alert(\"你好\")</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script> </font> <font style=\"color:#595959;\"></body></font> 3、文档的加载 浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行,如果<font style=\"color:#000000;\">将script标签写到页面的上边</font>，在代码执行时，页面还没有加载，页面没有加载DOM对象也没有加载，会导致<font style=\"color:#000000;\">无法获取到DOM对象</font>。 <font style=\"color:#000000;\">第一种加载情况：</font> 将<font style=\"color:#000000;\">js</font>代码编写到<font style=\"color:#000000;\">页面的下部</font>就是为了，可以在页面加载完毕以后再执行js代码 <font style=\"color:#595959;\"><button id=\"btn\">点我一下</button></font> <font style=\"color:#595959;\"> <script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> //获取id为btn的按钮</font> <font style=\"color:#595959;\"> var btn = document.getElementById(\"btn\");</font> <font style=\"color:#595959;\"> //为按钮绑定一个单击响应函数</font> <font style=\"color:#595959;\"> btn.onclick = function () {</font> <font style=\"color:#595959;\"> alert(\"hello\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">第二种加载写法：</font> <font style=\"color:#000000;\">onload事件会在整个页面加载完成之后才触发， 为window绑定一个onload事件</font>，该事件对应的响应函数将会<font style=\"color:#000000;\">在页面加载完成之后执行</font>，这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> window.onload = function () {</font> <font style=\"color:#595959;\"> //获取id为btn的按钮</font> <font style=\"color:#595959;\"> var btn = document.getElementById(\"btn\");</font> <font style=\"color:#595959;\"> //为按钮绑定一个单击响应函数</font> <font style=\"color:#595959;\"> btn.onclick = function () {</font> <font style=\"color:#595959;\"> alert(\"hello\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> （二）、获取元素 DOM在我们实际开发中主要用来操作元素。一般有以下方法获取DOM 1、getElementById() 通过<font style=\"color:#FF0001;\">id</font>属性获取一个元素节点对象，参数：id是大小写敏感的<font style=\"color:#FF0001;\">字符串</font>，返回的是一个元素对象 补充1：innerHTML 可读写，一方面可获取到元素内部的html代码，另一方面可以操作更改元素内容，包括标签，保留空格和换行，比较常用 补充2：innerText 可读写，它和innerHTMl类似，不同的是更改元素内容的时候，它会自动将html标签，空格和换行去除 补充3：console.dir打印我们返回的元素对象，更好的查看里面的属性和方法 2、 getElementsByTagName() （1）、根据标签名来获取<font style=\"color:#FF0001;\">一组</font>元素节点对象 <font style=\"color:#FF0001;\">返回</font>一个<font style=\"color:#FF0001;\">类数组(伪数组)</font>对象，所有查询到的元素都会封装到对象中，即使查询到的元素只有一个，也会封装到伪数组中返回;如果页面中<font style=\"color:#FF0001;\">没有</font>这个元素，则会<font style=\"color:#FF0001;\">返回</font>一个<font style=\"color:#FF0001;\">空</font>的<font style=\"color:#FF0001;\">伪数组</font>； <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> var btn02 = document.getElementById(\"btn02\");</font> <font style=\"color:#595959;\"> btn02.onclick = function () {</font> <font style=\"color:#595959;\"> var lis = document.getElementsByTagName(\"li\");</font> <font style=\"color:#595959;\"> //打印lis</font> <font style=\"color:#595959;\"> //alert(lis.length);</font> <font style=\"color:#595959;\"> //遍历lis</font> <font style=\"color:#595959;\"> for (var i = 0; i < lis.length; i++) {</font> <font style=\"color:#595959;\"> console.log(lis[i].innerHTML);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> （2）获取某个元素（父元素）内部所有指定标签名的元素 element.getElementsByTagName('标签名') 注意：父元素必须<font style=\"color:#FF0001;\">是单个对象（必须指明是哪一个元素对象）</font>，获取的时候<font style=\"color:#FF0001;\">不包括父元素自己</font> <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> //获取id为city的元素</font> <font style=\"color:#595959;\"> var city = document.getElementById(\"city\");</font> <font style=\"color:#595959;\"> / 1:city.getElementsByTagName(); 获取元素下的一组节点 /</font> <font style=\"color:#595959;\"> var lis = city.getElementsByTagName(\"li\");</font> <font style=\"color:#595959;\"> </script></font> 3、getElementsByName() 通过<font style=\"color:#FF0001;\">name属性</font>获取一组元素节点对象 补充2： innerHTML用于获取元素内部的HTML内容的，对于<font style=\"color:#FF0001;\">自结束标签</font>，这个属性<font style=\"color:#FF0001;\">没有意义</font> 补充3：如果需要读取元素节点属性，语法：<font style=\"color:#FF0001;\"> 元素.属性名，</font> 例如：元素.id ；元素.name ；元素.src ;元素.href等 表单属性：type、value、checked、selected、disabled等 注意：<font style=\"color:#FF0001;\">class属性不能采用这种方式，读取class属性时需要使用 元素.className</font> <font style=\"color:#FF0001;\">value值：就是输入文本框中的内容，要修改value值 element.value = \"～～\";</font> <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> var btn03 = document.getElementById(\"btn03\");</font> <font style=\"color:#595959;\"> btn03.onclick = function () {</font> <font style=\"color:#595959;\"> var inputs = document.getElementsByName(\"gender\");</font> <font style=\"color:#595959;\"> //alert(inputs.length);</font> <font style=\"color:#595959;\"> for (var i = 0; i < inputs.length; i++) {</font> <font style=\"color:#595959;\"> //alert(inputs[i].innerHTML);</font> <font style=\"color:#595959;\"> // alert(inputs[i].value);</font> <font style=\"color:#595959;\"> alert(inputs[i].className);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> 4、getElementsByClassName() 通过<font style=\"color:#FF0001;\">class</font>属性获取一组元素节点对象（不支持IE8及以下浏览器） <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> var btn04 = document.getElementById(\"btn04\");</font> <font style=\"color:#595959;\"> btn04.onclick = function () {</font> <font style=\"color:#595959;\"> var classs = document.getElementsByClassName(\"inner\");</font> <font style=\"color:#595959;\"> for (var i = 0; i < classs.length; i++) {</font> <font style=\"color:#595959;\"> alert(classs[i].className);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> 5、childNodes、children返回父元素下的所有子节点 （1）、<font style=\"color:#FF0001;\">childNodes</font>属性会<font style=\"color:#FF0001;\">获取包括文本节点在内的所有节点</font>，DOM标准，标签间的空白也会被当成文本节点 （2）、<font style=\"color:#FF0001;\">children</font>属性可以<font style=\"color:#FF0001;\">获取当前元素的所有子元素</font>，不包括空白文档了 6、firstChild、firstElementChild返回父元素下的第一个子节点 （1）、<font style=\"color:#FF0001;\">firstChild 第一个子节点(包括空白的文本节点)</font> （2）、<font style=\"color:#FF0001;\">firstElementChild 获取当前元素的第一个子元素</font> 7、返回某元素的父节点 语法：<font style=\"color:#FF0001;\">某元素.parentNode</font> 8、返回某元素的前一个兄弟节点 （1）、 <font style=\"color:#FF0001;\">previousSibling </font>[ˈpriːviəs] ['sibliŋ] 返回前一个兄弟节点 也有可能<font style=\"color:#FF0001;\">获取到空白的文本</font> （2）、 <font style=\"color:#FF0001;\">previousElementSibling </font>返回前一个兄弟元素，<font style=\"color:#FF0001;\">不包括空白文本</font>，注意：不支持ie8及以下的浏览器 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> var div = document.querySelector(\".box1 div\")</font> <font style=\"color:#595959;\"> var div = document.querySelector(\".box1\")</font> <font style=\"color:#595959;\"> var div=document.querySelectorAll(\".box1\")</font> <font style=\"color:#595959;\"> </script></font> 9、获取body标签 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0001;\">//方法一</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0001;\">var body=document.getElementsByTagName(\"body\")[0];</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0001;\"> //方法二</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0001;\"> var body = document.body</font> <font style=\"color:#595959;\"> </script></font> 10、获取html根标签 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0001;\"> var html = document.documentElement;</font> <font style=\"color:#595959;\"> </script></font> 11、获取页面中所有的元素 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0001;\">//第一种方式</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0001;\">var all=document.all;</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0001;\">//第二种方式</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0001;\"> var all = document.getElementsByTagName(\"*\")</font> <font style=\"color:#595959;\"> </script></font> 12、document.querySelector() -需要一个选择器的字符串作为参数，可以根据一<font style=\"color:#FF0001;\">个</font><font style=\"color:#FF0001;\">css选择器</font>来查询 一个元素节点对象 -该方法总会<font style=\"color:#FF0001;\">返回唯一的元素</font>，如果满足条件的元素是多个，那么它<font style=\"color:#FF0001;\">只会返回第一个</font> -IE8以上的都适用 13、document.querySelectorAll() -该方法和<font style=\"color:#FF0001;\">qureySelector</font>()用法类似，不同的是它将会将<font style=\"color:#FF0001;\">符合条件的所有元素封装到一个伪数组中返回</font> -即使符合条件的元素只有一个，它也会<font style=\"color:#FF0001;\">返回数组</font> <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> var div = document.querySelector(\".box1 div\")</font> <font style=\"color:#595959;\"> var div = document.querySelector(\".box1\")</font> <font style=\"color:#595959;\"> var div=document.querySelectorAll(\".box1\")</font> <font style=\"color:#595959;\"> </script></font> 课堂小练习： 1、分时显示不同图片，显示不同问候语 根据不同时间、页面显示不同的图片、同时显示不同的问候语。上午时间打开页面，显示上午好，显示上午的图片；下午显示下午的，晚上显示晚上的 2、防小米显示密码：点击按钮将密码框切换为文本框，并可以查看密码明文 <font style=\"color:#595959;\"><input type=\"password\" id=\"passwordInput\" /></font> <font style=\"color:#595959;\"><button onclick=\"togglePassword()\">显示密码</button></font> <font style=\"color:#595959;\">function togglePassword() {</font> <font style=\"color:#595959;\"> var passwordInput = document.getElementById(\"passwordInput\");</font> <font style=\"color:#595959;\"> if (passwordInput.type === \"password\") {</font> <font style=\"color:#595959;\"> passwordInput.type = \"text\";</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> passwordInput.type = \"password\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">}</font> 1、事件概述 JS使我们有能力创建动态页面，而事件是可以被JS侦测的行为 简单理解：触发----响应机制 网页中每个元素都可以产生某些可以触发JS的事件，例如点击事件 事件是由三部分组成 事件源 事件类型 事件处理程序称为事件三要素 <font style=\"color:#FF0000;\">事件源： 事件被触发的对象 谁被触发</font> <font style=\"color:#FF0000;\">事件类型：如何触发，什么事件例如鼠标点击，鼠标经过，键盘按下等</font> <font style=\"color:#FF0000;\">事件处理程序：通过函数赋值的方式完成</font> 执行事件的步骤： <font style=\"color:#FF0000;\">获取</font>事件源 注册事件（<font style=\"color:#FF0000;\">绑定</font>事件） 添加事件处理程序（采取<font style=\"color:#FF0000;\">函数赋值</font>形式） <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> //第一步：获取按钮对象</font> <font style=\"color:#595959;\"> var btn=document.getElementById(\"btn\");</font> <font style=\"color:#595959;\"> //第二步：绑定一个单击事件</font> <font style=\"color:#595959;\"> //第三步：添加事件处理程序</font> <font style=\"color:#595959;\"> btn.onclick=function(){//像这种为单击事件绑定的函数，我们称为单击响应函数</font> <font style=\"color:#595959;\"> alert(\"你好\")</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 常见的事件 | 鼠标事件 | 触发条件 | | --- | --- | | <font style=\"color:rgb(243, 50, 50);\">onclick</font> | <font style=\"color:rgb(255, 0, 0);\">当单击鼠标时运行脚本。</font> | | onmousedown | 当按下鼠标按钮时运行脚本。 | | onmouseup | 当松开鼠标按钮时运行脚本。 | | onmousemove | 当鼠标指针移动时运行脚本。 | | <font style=\"color:rgb(223, 42, 63);\">onmouseover</font> | 当鼠标指针移至元素之上时运行脚本，不可以阻止冒泡。 | | onmouseout | 当鼠标指针移出元素时运行脚本，不可以阻止冒泡。 | | <font style=\"color:rgb(243, 50, 50);\">onmouseenter</font> | 当鼠标<font style=\"color:rgb(255, 0, 0);\">指针移至元素之上</font>时运行脚本，可以阻止冒泡。 | | <font style=\"color:rgb(243, 50, 50);\">onmouseleave</font> | 当鼠标<font style=\"color:rgb(255, 0, 0);\">指针移出</font>元素时运行脚本，可以阻止冒泡。 | | onmousewheel | 当转动鼠标滚轮时运行脚本。 | | onscroll | 当滚动元素的滚动条时运行脚本。 | | 键盘事件 | 触发条件 | | <font style=\"color:rgb(243, 50, 50);\">onkeyup</font> | 某个键盘<font style=\"color:rgb(255, 0, 0);\">按键被松开</font>时触发 （document，window） | | <font style=\"color:rgb(243, 50, 50);\">onkeydown</font> | 某个<font style=\"color:rgb(255, 0, 0);\">键盘按键被按下</font>时触发，<font style=\"color:rgb(51, 51, 51);\">通常不会触发事件冒泡，除非特别处理‌</font> | | onkeypress | 某个键盘按键被按下时触发，<font style=\"color:rgb(51, 51, 51);\">会触发事件冒泡</font> | | 表单事件 | 触发条件 | | <font style=\"color:rgb(243, 50, 50);\">onfocus</font> | 表单<font style=\"color:rgb(255, 0, 0);\">获得焦点</font>触发 | | <font style=\"color:rgb(243, 50, 50);\">onblur</font> | 表单<font style=\"color:rgb(255, 0, 0);\">失去焦点</font>触发 | | oninput | 表单每次输入触发 | | <font style=\"color:rgb(243, 50, 50);\">onchange</font> | 表单<font style=\"color:rgb(255, 0, 0);\">内容发生改变时</font>触发 | | onselect | 表单<font style=\"color:rgb(255, 0, 0);\">文本被选取</font>时触发 | | onreset | 表单重置时触发 | | onsubmit | 表单提交时触发 | 2、操作元素 JS的DOM操作可以改变网页内容、结构和样式，我们可以利用DOM操作元素来改变元素里面的内容、属性等 2.1、改变元素内容 <font style=\"color:#FF0000;\">element.innerText</font> 从起始位置到终止位置的内容，会<font style=\"color:#FF0000;\">去除html标签，</font>同时<font style=\"color:#FF0000;\">空格和换行也会去掉</font> <font style=\"color:#FF0000;\">element.innerHTML</font> 从起始位置到终止位置的全部内容，<font style=\"color:#FF0000;\">包括html标签，保留空格和换行</font> 2.1.1 基本使用 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- 需求：点击button，切换内容 --></font> <font style=\"color:#595959;\"> <button>点我切换内容</button></font> <font style=\"color:#595959;\"> <div>天气炎热</div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 1、获取元素</font> <font style=\"color:#595959;\"> var btn = document.querySelector(\"button\");</font> <font style=\"color:#595959;\"> var div = document.querySelector(\"div\");</font> <font style=\"color:#595959;\"> // 2、绑定事件</font> <font style=\"color:#595959;\"> //3、事件处理函数</font> <font style=\"color:#595959;\"> btn.onclick = function () {</font> <font style=\"color:#595959;\"> //console.log(div.innerText);</font> <font style=\"color:#595959;\"> //console.log(div.innerHTML);</font> <font style=\"color:#595959;\"> //方式一、操作元素内容--innerText</font> <font style=\"color:#595959;\"> // div.innerText = \"天气凉爽\";</font> <font style=\"color:#595959;\"> //方式二、操作元素内容--innerHTML</font> <font style=\"color:#595959;\"> div.innerHTML = \"天气凉爽\";</font> <font style=\"color:#595959;\"> }; </font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 2.1.2 两者区别 写：innerText 不识别html标签，innerHTML识别html标签 读：innerText，innerHTML可以获取元素内面的内容，innerText去除空格、换行和标签，innerHTML可以获取到元素里面的标签，同时保留空格和换行 2.2、改变元素其他属性 src、href、id、alt、title等属性 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- 需求：点击对应的按钮，可以切换图片已经更改title值 --></font> <font style=\"color:#595959;\"> <button id=\"dog\">小狗</button></font> <font style=\"color:#595959;\"> <button id=\"cat\">小猫</button><br /><br /></font> <font style=\"color:#595959;\"> <img src=\"./img/pic_01.jpg\" title=\"小狗\" /></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 1、获取元素</font> <font style=\"color:#595959;\"> var dog = document.querySelector(\"#dog\");</font> <font style=\"color:#595959;\"> var cat = document.querySelector(\"#cat\");</font> <font style=\"color:#595959;\"> var img = document.querySelector(\"img\");</font> <font style=\"color:#595959;\"> //2、绑定事件、处理函数</font> <font style=\"color:#595959;\"> dog.onclick = function () {</font> <font style=\"color:#595959;\"> img.src = \"./img/pic_01.jpg\";</font> <font style=\"color:#595959;\"> img.title = \"小狗\";</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> cat.onclick = function () {</font> <font style=\"color:#595959;\"> img.src = \"./img/pic_02.jpg\";</font> <font style=\"color:#595959;\"> img.title = \"小猫\";</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 2.3、操作表单元素属性 type、value、checked、selected、disabled等 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- 需求：1、点击按钮，更换input里的显示内容为：‘内容被修改了’ </font> <font style=\"color:#595959;\"> 需求2:点击按钮，按钮就被禁用了</font> <font style=\"color:#595959;\"> --></font> <font style=\"color:#595959;\"> <button>按钮</button></font> <font style=\"color:#595959;\"> <input type=\"text\" value=\"请输入内容\" /></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 1、获取元素</font> <font style=\"color:#595959;\"> var btn = document.querySelector(\"button\");</font> <font style=\"color:#595959;\"> var int = document.querySelector(\"input\");</font> <font style=\"color:#595959;\"> // 绑定点击事件，处理函数</font> <font style=\"color:#595959;\"> btn.onclick = function () {</font> <font style=\"color:#595959;\"> int.value = \"内容被修改了\";</font> <font style=\"color:#595959;\"> btn.disabled = true;</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 2.4、操作样式属性操作 可以通过JS修改元素的大小、颜色、位置等样式 <font style=\"color:#FF0000;\">element.style 行内样式操作 </font> （1）、JS里面的样式采取<font style=\"color:#FF0000;\">小驼峰命名</font>发，比如fontSize、backgroundClolor （2）、JS修改style样式操作，产生的是行内样式，css权重比较高 <font style=\"color:#FF0000;\">element.className 类名样式操作</font> （1）、如果样式修改较多，可以采取操作类名的方式更改元素样式 （2）、class因为是个保留字，因此使用className来操作元素类名属性 （3）、className 会直接更改元素的类名，<font style=\"color:#FF0000;\">会覆盖原先的类名</font>，如果<font style=\"color:#FF0000;\">想保留</font>原先的类名，再添加更改的时，需要<font style=\"color:#FF0000;\">把原先类名加上</font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <div class=\"box\">box</div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 需求1：点击div，div颜色变色，用行内样式实现</font> <font style=\"color:#595959;\"> var box = document.querySelector(\".box\");</font> <font style=\"color:#595959;\"> box.onclick = function () {</font> <font style=\"color:#595959;\"> box.style.backgroundColor = \"red\";</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> // 需求2:鼠标移入，div的宽高发生变化，字体大小变化，字体加粗</font> <font style=\"color:#595959;\"> box.onmouseover = function () {</font> <font style=\"color:#595959;\"> // js里有个this的存在，在不同的情况下，指代不同的内容</font> <font style=\"color:#595959;\"> //在事件函数里，this指代调用者，也就是指向事件源</font> <font style=\"color:#595959;\"> this.className = \"box1\";</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 2.5、排他思想 如果有同一组元素，想要某一个元素实现某种样式，需要用到循环的排他思想算法 <font style=\"color:#000000;\">步骤：</font> <font style=\"color:#FF0000;\">清除所有元素的样式</font> <font style=\"color:#FF0000;\">给当前元素设置样式</font> 注意顺序不能颠倒 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- 需求：给当前点击的按钮，添加背景色 --></font> <font style=\"color:#595959;\"> <button>按钮1</button></font> <font style=\"color:#595959;\"> <button>按钮2</button></font> <font style=\"color:#595959;\"> <button>按钮3</button></font> <font style=\"color:#595959;\"> <button>按钮4</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //1、获取到所有的按钮</font> <font style=\"color:#595959;\"> var btns = document.querySelectorAll(\"button\");</font> <font style=\"color:#595959;\"> //2、通过循环，给所有的按钮绑定点击事件，处理函数</font> <font style=\"color:#595959;\"> for (var i = 0; i < btns.length; i++) {</font> <font style=\"color:#595959;\"> btns[i].onclick = function () {</font> <font style=\"color:#595959;\"> // 2.1清楚所有按钮的背景色</font> <font style=\"color:#595959;\"> for (var i = 0; i < btns.length; i++) {</font> <font style=\"color:#595959;\"> btns[i].style.backgroundColor = \"\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //2.2</font> <font style=\"color:#595959;\"> this.style.backgroundColor = \"red\";</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 2.6、操作自定义属性 1、获取属性值： 方式一：<font style=\"color:#FF0000;\">element.属性</font> 获取属性值（获取元素<font style=\"color:#FF0000;\">自身自带</font>的属性，例如id，href，src等） 方式二：<font style=\"color:#FF0000;\">element.getAttribute('属性')</font> 主要<font style=\"color:#FF0000;\">获取自定义</font>的属性，我们程序员自己家的属性,也可以获取元素自带属性 2、设置属性值 方式一：<font style=\"color:#FF0000;\">element.属性='值' 设置属性值</font> 方式二：e<font style=\"color:#FF0000;\">lement.setAttribute('属性','值')</font> 设置<font style=\"color:#FF0000;\">自定义属性</font>，也可以设置元素自带属性 3、移除某个属性 <font style=\"color:#FF0000;\">element.removeAttribute(\"属性\"); 移除某个属性</font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- 需求1：获取a标签对应的href属性值以及index属性值</font> <font style=\"color:#595959;\"> 需求2：设置a标签对应的href属性值为京东，以及修改index属性值为2</font> <font style=\"color:#595959;\"> 需求3：移除abc属性 </font> <font style=\"color:#595959;\"> --></font> <font style=\"color:#595959;\"> <a href=\"https://www.baidu.com/\" index=\"1\" abc=\"123\">百度</a></font> <font style=\"color:#595959;\"> <br /><br /></font> <font style=\"color:#595959;\"> <button id=\"btn1\">获取</button></font> <font style=\"color:#595959;\"> <button id=\"btn2\">设置</button></font> <font style=\"color:#595959;\"> <button id=\"btn3\">移除</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var a = document.querySelector(\"a\");</font> <font style=\"color:#595959;\"> var btn1 = document.querySelector(\"#btn1\");</font> <font style=\"color:#595959;\"> var btn2 = document.querySelector(\"#btn2\");</font> <font style=\"color:#595959;\"> var btn3 = document.querySelector(\"#btn3\");</font> <font style=\"color:#595959;\"> btn1.onclick = function () {</font> <font style=\"color:#595959;\"> // 需求1</font> <font style=\"color:#595959;\"> console.log(a.href, \"自带属性\");</font> <font style=\"color:#595959;\"> console.log(a.getAttribute(\"index\"), \"自定义属性\");</font> <font style=\"color:#595959;\"> console.log(a.getAttribute(\"href\"), \"自带属性\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> btn2.onclick = function () {</font> <font style=\"color:#595959;\"> // 需求2</font> <font style=\"color:#595959;\"> a.href = \"https://www.jd.com/\";</font> <font style=\"color:#595959;\"> a.setAttribute(\"index\", \"2\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> btn3.onclick = function () {</font> <font style=\"color:#595959;\"> // 需求3</font> <font style=\"color:#595959;\"> a.removeAttribute(\"abc\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 4、设置h5自定义属性 为了区分自定义属性，还是元素自带属性 H5给我们新增了自定义属性规范： H5规定自定义属性<font style=\"color:#FF0000;\">以data-开头作为属性名并附值 </font> 获取自定义属性 方式一：<font style=\"color:#FF0000;\">element.getAttribute('属性') </font> 方式二：<font style=\"color:#FF0000;\">element.dataset.去除掉data-的属性名</font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <div data-index=\"abc\" data-last-name=\"王\"></div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var div = document.querySelector(\"div\");</font> <font style=\"color:#595959;\"> //设置自定义属性</font> <font style=\"color:#595959;\"> div.setAttribute(\"data-id\", \"hello\");</font> <font style=\"color:#595959;\"> //获取自定义属性</font> <font style=\"color:#595959;\"> //方式一：element.getAttribute(\"自定义属性名\")</font> <font style=\"color:#595959;\"> console.log(div.getAttribute(\"data-index\"));</font> <font style=\"color:#595959;\"> //方式二：element.dataset.属性名</font> <font style=\"color:#595959;\"> console.log(div.dataset); //得到一个对象</font> <font style=\"color:#595959;\"> console.log(div.dataset.index); //读取对象</font> <font style=\"color:#595959;\"> console.log(div.dataset[\"id\"]); //读取对象</font> <font style=\"color:#595959;\"> console.log(div.dataset.lastName); //驼峰命名法读取</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"></body></font> 节点操作 1、创建节点 <font style=\"color:#FF0000;\">docment.createElement('节点')</font> <font style=\"color:#FF0000;\">参数：标签名字符串</font> 这些元素原先不存在，是根据需求动态生成的，所以也成为动态创建元素节点，会将创建好的对象作为返回值返回 2、创建文本 <font style=\"color:#FF0000;\">document.createTextNode()可以用来创建一个文本节点对象</font> <font style=\"color:#FF0000;\">参数：文本内容字符串，并将新的节点返回</font> 3、添加节点 (先有父母才能生孩子) <font style=\"color:#FF0000;\">father.appendChild(child) 追加元素 类似数组中的push()</font> 将一个节点添加到指定父节点的<font style=\"color:#FF0000;\">子节点列表的末尾</font>。类似css里面的after伪元素 <font style=\"color:#FF0000;\">father.insertBefore(child,指定元素)</font> 将一个节点<font style=\"color:#FF0000;\">添加到父节点的指定子节点前面</font>。类似css里面的before伪元素 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- </font> <font style=\"color:#595959;\"> 需求1：在段落p的后面添加一个span标签，添加span的文本内容‘我是一个span’</font> <font style=\"color:#595959;\"> 需求2：在段落p的前面添加一个h1标签，添加h1的文本内容，‘我是一个h1’</font> <font style=\"color:#595959;\"> --></font> <font style=\"color:#595959;\"> <div id=\"box\"></font> <font style=\"color:#595959;\"> <p>段落</p></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <button>添加span</button></font> <font style=\"color:#595959;\"> <button>添加h1</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var btns = document.querySelectorAll(\"button\");</font> <font style=\"color:#595959;\"> var p = document.querySelector(\"p\");</font> <font style=\"color:#595959;\"> var box = document.getElementById(\"box\");</font> <font style=\"color:#595959;\"> //需求1</font> <font style=\"color:#595959;\"> btns[0].onclick = function () {</font> <font style=\"color:#595959;\"> // 1.1创建节点</font> <font style=\"color:#595959;\"> var span = document.createElement(\"span\");</font> <font style=\"color:#595959;\"> // 1.2 创建文本内容</font> <font style=\"color:#595959;\"> var spanTest = document.createTextNode(\"我是一个span\");</font> <font style=\"color:#595959;\"> //1.3将文本内容放入到span节点里</font> <font style=\"color:#595959;\"> span.appendChild(spanTest);</font> <font style=\"color:#595959;\"> // 1.2追加节点</font> <font style=\"color:#595959;\"> box.appendChild(span);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //需求2</font> <font style=\"color:#595959;\"> btns[1].onclick = function () {</font> <font style=\"color:#595959;\"> // 2.1 创建节点</font> <font style=\"color:#595959;\"> var h1 = document.createElement(\"h1\");</font> <font style=\"color:#595959;\"> //2.2创建h1文本内容</font> <font style=\"color:#595959;\"> var h1Test = document.createTextNode(\"我是一个h1\");</font> <font style=\"color:#595959;\"> //2.3 将h1Test放入到节点内</font> <font style=\"color:#595959;\"> h1.appendChild(h1Test);</font> <font style=\"color:#595959;\"> //2.4 添加节点</font> <font style=\"color:#595959;\"> box.insertBefore(h1, p);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\">创造节点</font> <font style=\"color:#595959;\">创造/完善节点内容</font> <font style=\"color:#595959;\">确定节点和内容的关系</font> <font style=\"color:#595959;\">确定新节点与原有内容的关系</font> 4、替换节点 <font style=\"color:#FF0000;\">replaceChild() </font> -可以使用指定的子节点替换已有的子节点 -语法：<font style=\"color:#FF0000;\">父节点.replaceChild(新节点，旧节点) 通知父亲换新号（舍旧迎新）</font> 5、删除节点 写法一、<font style=\"color:#FF0000;\">father.removeChild(child) 通过父亲买走孩子</font> 写法二、<font style=\"color:#FF0000;\">child.parentNode.removeChild(child) 通过孩子找父亲买走他</font> <font style=\"color:#FF0000;\">可以在DOM中删除一个子节点，返回删除的节点</font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- 需求一：点击按钮1，将《金瓶梅》替换为《水浒传》</font> <font style=\"color:#595959;\"> 需求二：点击按钮2，删除《金瓶梅》</font> <font style=\"color:#595959;\"> --></font> <font style=\"color:#595959;\"> <button>按钮1</button></font> <font style=\"color:#595959;\"> <button>按钮2</button></font> <font style=\"color:#595959;\"> <ul></font> <font style=\"color:#595959;\"> <li>《红楼梦》</li></font> <font style=\"color:#595959;\"> <li>《三国演义》</li></font> <font style=\"color:#595959;\"> <li>《西游记》</li></font> <font style=\"color:#595959;\"> <li>《金瓶梅》</li></font> <font style=\"color:#595959;\"> </ul></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var btns = document.querySelectorAll(\"button\");</font> <font style=\"color:#595959;\"> var ul = document.querySelector(\"ul\");</font> <font style=\"color:#595959;\"> var jpm = ul.children[3];</font> <font style=\"color:#595959;\"> btns[0].onclick = function () {</font> <font style=\"color:#595959;\"> // 创建《水浒传》节点</font> <font style=\"color:#595959;\"> var newLi = document.createElement(\"li\");</font> <font style=\"color:#595959;\"> var newLiTest = document.createTextNode(\"《水浒传》\");</font> <font style=\"color:#595959;\"> newLi.appendChild(newLiTest);</font> <font style=\"color:#595959;\"> // 替换节点</font> <font style=\"color:#595959;\"> ul.replaceChild(newLi, jpm);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> btns[1].onclick = function () {</font> <font style=\"color:#595959;\"> // 删除节点写法一</font> <font style=\"color:#595959;\"> ul.removeChild(jpm);</font> <font style=\"color:#595959;\"> // 删除节点写法二</font> <font style=\"color:#595959;\"> // jpm.parentNode.removeChild(jpm);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 6、克隆节点 <font style=\"color:#FF0000;\">node.cloneNode() </font>返回调用该方法的节点的一个副本 参数：<font style=\"color:#FF0000;\">布尔值</font> <font style=\"color:#FF0000;\">false 只克隆节点本身，不克隆里面的子节点</font> <font style=\"color:#FF0000;\">true 拷贝节点，拷贝内容</font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- 需求:点击按钮克隆div元素--></font> <font style=\"color:#595959;\"> <div id=\"box\">box盒子</div></font> <font style=\"color:#595959;\"> <button>克隆</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var box = document.getElementById(\"box\");</font> <font style=\"color:#595959;\"> document.querySelector(\"button\").onclick = function () {</font> <font style=\"color:#595959;\"> // 克隆节点</font> <font style=\"color:#595959;\"> // var newBox = box.cloneNode();</font> <font style=\"color:#595959;\"> var newBox = box.cloneNode(true);</font> <font style=\"color:#595959;\"> //添加克隆节点</font> <font style=\"color:#595959;\"> box.parentNode.appendChild(newBox);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 7、创建节点另外几种方式 （1）、element.innerHTML 允许更改html元素的内容,可以设置或返回表格行的开始和结束标签之间的HTML，可以解析html标签 （2）、 element.innerText 获取或设置元素的文本----以纯文本的方式直接显示，不可以解析html标签 （3）、document.write() 直接将内容写入页面的内容流，但是文档执行完毕，则会导致页面全部重绘 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- </font> <font style=\"color:#595959;\"> 需求1：获取ul里面的li内容</font> <font style=\"color:#595959;\"> 需求2:在ul里添加《水浒传》到页面中</font> <font style=\"color:#595959;\"> innerHTML、document.write() </font> <font style=\"color:#595959;\"> --></font> <font style=\"color:#595959;\"> <button>获取</button></font> <font style=\"color:#595959;\"> <button>添加</button></font> <font style=\"color:#595959;\"> <ul></font> <font style=\"color:#595959;\"> <li>《红楼梦》</li></font> <font style=\"color:#595959;\"> </ul></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var btns = document.querySelectorAll(\"button\");</font> <font style=\"color:#595959;\"> var ul = document.querySelector(\"ul\");</font> <font style=\"color:#595959;\"> // 需求1</font> <font style=\"color:#595959;\"> btns[0].onclick = function () {</font> <font style=\"color:#595959;\"> var test1 = ul.innerHTML;</font> <font style=\"color:#595959;\"> // console.log(test1, \"test1\");</font> <font style=\"color:#595959;\"> var test2 = ul.innerText;</font> <font style=\"color:#595959;\"> // console.log(test2, \"test2\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //需求2</font> <font style=\"color:#595959;\"> btns[1].onclick = function () {</font> <font style=\"color:#595959;\"> // </font><font style=\"color:#FF0000;\">第一种写法（创新标签并用innerHTML直接修改新标签内容）</font> <font style=\"color:#595959;\"> // var li = document.createElement(\"li\");</font> <font style=\"color:#595959;\"> // li.innerHTML = \"《水浒传》\";</font> <font style=\"color:#595959;\"> // ul.appendChild(li);</font> <font style=\"color:#595959;\"> // </font><font style=\"color:#FF0000;\">第二种写法（不创建新标签，直接用字符串拼接方法’+’ 修改元素自身的innerHTML内容）</font> <font style=\"color:#595959;\"> let liElement=<li>《水浒传》</li></font> <font style=\"color:#595959;\"> ul.innerHTML = ul.innerHTML+liElement;</font> <font style=\"color:#595959;\"> // </font><font style=\"color:#FF0000;\">第三种写法 （通过document.Write()直接输出内容 ）</font> <font style=\"color:#595959;\"> let bodyElement=document.body.innerHTML+liElement</font> <font style=\"color:#595959;\"> document.write(bodyElement);</font> <font style=\"color:#595959;\"> //</font><font style=\"color:#FF0000;\">第四种 利用（insertAdjacentHTML() ）</font> <font style=\"color:#595959;\"> ul.insertAdjacentHTML('beforebegin',liElement) </font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> (3 )、insertAdjacentHTML() /əˈdʒeɪsnt/ insertAdjacentHTML() 是Element的API中的一个方法，可以将<font style=\"color:#FF0000;\">字符串文本转化为你想要的节点</font>（Node），并且<font style=\"color:#FF0000;\">插入到你想要插入的位置中</font>。而且它并<font style=\"color:#FF0000;\">不会</font>向innerHTML一样会<font style=\"color:#FF0000;\">替换掉已有的节点，而是会插入到指定位置。</font> <font style=\"color:#FF0000;\">语法：element.insertAdjacentHTML(position,text)</font> 参数1: position顾名思义，就是想要插入的位置，一共有4个固定的值 <font style=\"color:#FF0000;\">'beforebegin'</font>：元素element<font style=\"color:#FF0000;\">自己的前面</font>。 <font style=\"color:#FF0000;\">'afterbegin'</font>：<font style=\"color:#FF0000;\">插入</font>到元素element里面的<font style=\"color:#FF0000;\">第一个子节点之前</font>（也就是总是会插入到最前面，例如我插入5个节点，顺序是1、2、3、4、5，那么我就需要以5、4、3、2、1的顺序插入，有一种栈结构先进后出的感觉）。 <font style=\"color:#FF0000;\">'beforeend'</font>：<font style=\"color:#FF0000;\">插入</font>元素element里面的<font style=\"color:#FF0000;\">最后一个子节点之后</font>（这个比较容易理解，就是插入到最后一个节点后，例如我插入5个节点，顺序是1、2、3、4、5，那就正常的1、2、3、4、5就好啦，但是注意是在已有节点的后面哦）。 <font style=\"color:#FF0000;\">'afterend'</font>：元素element<font style=\"color:#FF0000;\">自己的后面</font>。 参数2:text文本 可以结合`字符串使用 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <button>获取</button></font> <font style=\"color:#595959;\"> <button>添加</button></font> <font style=\"color:#595959;\"> <ul></font> <font style=\"color:#595959;\"> <li>《红楼梦》</li></font> <font style=\"color:#595959;\"> </ul></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var btns = document.querySelectorAll(\"button\");</font> <font style=\"color:#595959;\"> var ul = document.querySelector(\"ul\");</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> btns[1].onclick = function () {</font> <font style=\"color:#595959;\"> // </font><font style=\"color:#FF0000;\">第三种写法 insertAdjacentHTML()</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">var li = <li>《水浒传》</li>;</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">ul.insertAdjacentHTML('beforeend',li);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 事件高级 1、注册事件方式 （1）、传统注册方式： 利用on开头的事件，例如onclick 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var btns = document.querySelectorAll(\"button\");</font> <font style=\"color:#595959;\"> btns[0].onclick = function () {</font> <font style=\"color:#595959;\"> alert(\"1\");//不执行</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> btns[0].onclick = function () {</font> <font style=\"color:#595959;\"> alert(\"2\");//执行</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> （2）、addEventListener方法监听注册方式： <font style=\"color:#FF0000;\">addEventListener(type,listener[,useCapture])</font> 同一个元素同一个事件可以注册多个处理函数，按注册顺序依次执行 参数： <font style=\"color:#FF0000;\">type</font><font style=\"color:#FF0001;\">：</font>事件<font style=\"color:#FF0000;\">类型字符串</font>，例如click、mouseover，注意这里<font style=\"color:#FF0000;\">不用带on</font> <font style=\"color:#FF0000;\">listener</font><font style=\"color:#FF0001;\">：</font>事件<font style=\"color:#FF0000;\">处理函数</font>，事件<font style=\"color:#FF0000;\">发生</font>时，会<font style=\"color:#FF0000;\">调用</font>该监听函数 <font style=\"color:#FF0000;\">useCapture</font><font style=\"color:#FF0001;\">：</font><font style=\"color:#FF0000;\">可选</font>，是否在捕获阶段触发事件，需要一个布尔值<font style=\"color:#FF0000;\">；默认</font>是<font style=\"color:#FF0000;\">false</font>，在<font style=\"color:#FF0000;\">冒泡</font>阶段处理程序；如果是<font style=\"color:#FF0000;\">true</font>，就是在<font style=\"color:#FF0000;\">捕获</font>阶段处理程序（后面事件流时，详细说） 注意：ie8及以下不支持 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> btns[1].addEventListener(</font> <font style=\"color:#595959;\"> \"click\",</font> <font style=\"color:#595959;\"> function () {</font> <font style=\"color:#595959;\"> alert(1);</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> false</font> <font style=\"color:#595959;\"> );</font> <font style=\"color:#595959;\"> btns[1].addEventListener(</font> <font style=\"color:#595959;\"> \"click\",</font> <font style=\"color:#595959;\"> function () {</font> <font style=\"color:#595959;\"> alert(2);</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> false</font> <font style=\"color:#595959;\"> );</font> <font style=\"color:#595959;\"> </script></font> （3）、attachEvent 方法监听注册方式：(一般不用) <font style=\"color:#FF0000;\">attachEvent(type,listener)</font>在<font style=\"color:#FF0000;\">ie8</font>中可以使用，其他浏览器不能用 参数 <font style=\"color:#FF0000;\">type</font>：<font style=\"color:#FF0000;\">事件的字符串，要on</font> <font style=\"color:#FF0000;\">listener：回调函数</font> 注意：这个方法也可以同时为一个事件绑定多个处理函数，不同的是它后绑定先执行 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //在ie8中可以使用，其他浏览器不能用</font> <font style=\"color:#595959;\"> btns[2].attachEvent(\"onclick\", function () {</font> <font style=\"color:#595959;\"> alert(\"attachEvent 1\");</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> btns[2].attachEvent(\"onclick\", function () {</font> <font style=\"color:#595959;\"> alert(\"attachEvent 2\");</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> 2、解绑事件（删除事件） （1）、传统注册方式解绑 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> eventTarget.onclick=null</font> <font style=\"color:#595959;\"> btns[0].onclick = function () {</font> <font style=\"color:#595959;\"> alert(\"1\");</font> <font style=\"color:#595959;\"> //解绑事件</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">btns[0].onclick = null;</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> （2）、addEventListener方法注册解绑 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> eventTarget.removeEventListener(type,listener)</font> <font style=\"color:#595959;\"> btns[1].addEventListener(\"click\", fun);</font> <font style=\"color:#595959;\"> function fun() {</font> <font style=\"color:#595959;\"> alert(1);</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> btns[1].removeEventListener(\"click\", fun);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> （3）、attachEvent 方法注册解绑 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> eventTarget.detachEvent(eventName,callback)</font> <font style=\"color:#595959;\"> btns[2].attachEvent(\"onclick\", fun1);</font> <font style=\"color:#595959;\"> function fun1() {</font> <font style=\"color:#595959;\"> alert(\"attachEvent 1\");</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">btns[2].detachEvent(\"onclick\", fun1);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> 3、DOM事件流 1>、事件流概述 <font style=\"color:#FF0000;\">事件流</font>描述的是<font style=\"color:#FF0000;\">从页面中接收事件的顺序</font> 事件发生时会在元素节点之间按照<font style=\"color:#FF0001;\">特定的顺序</font>传播，这个传播的过程叫事件流 例如：给idiv绑定一个事件，时间流顺序如下 DOM事件流分为3个阶段 （1）、<font style=\"color:#FF0000;\">捕获</font>阶段：<font style=\"color:#777777;\">从触发事件的目标元素开始，事件被从目标元素的所有祖先元素依次往下传递（</font><font style=\"color:#FF0000;\">从外向内</font><font style=\"color:#777777;\">）</font> （2）、<font style=\"color:#FF0000;\">当前目标阶段</font>：<font style=\"color:#333333;\">触发自己的事件</font> （3）、<font style=\"color:#FF0000;\">冒泡</font>阶段：<font style=\"color:#333333;\"> </font><font style=\"color:#777777;\">当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发（从内向外）</font> 2> 代码演示 <font style=\"color:#FF0000;\">js代码中只能执行捕获或者冒泡其中的一个阶段</font>，其中onclick和attachEvent只能得到冒泡阶段，我们可以通过addEventListener(type,listener[,useCapture])中的第三个参数来分别演示冒泡和捕获 <font style=\"color:#FF0000;\">useCapture</font><font style=\"color:#FF0001;\">：</font>可选，是否在捕获阶段触发事件，需要一个布尔值，默认是false，在冒泡阶段处理程序，如果是true，就是在捕获阶段处理程序 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- 给box、box1绑定点击事件，弹出对应的信息</font> <font style=\"color:#595959;\"> 需求1：弹出box、box1信息</font> <font style=\"color:#595959;\"> 需求2：弹出box1、box信息 --></font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> <div class=\"box\"></font> <font style=\"color:#595959;\"> <div class=\"box1\"></div></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var boxs = document.querySelectorAll(\"div\");</font> <font style=\"color:#595959;\"> // 需求1</font> <font style=\"color:#595959;\"> // boxs[0].addEventListener(</font> <font style=\"color:#595959;\"> // \"click\",</font> <font style=\"color:#595959;\"> // function () {</font> <font style=\"color:#595959;\"> // alert(\"我是box\");</font> <font style=\"color:#595959;\"> // },</font> <font style=\"color:#595959;\"> // true</font> <font style=\"color:#595959;\"> // );</font> <font style=\"color:#595959;\"> // boxs[1].addEventListener(</font> <font style=\"color:#595959;\"> // \"click\",</font> <font style=\"color:#595959;\"> // function () {</font> <font style=\"color:#595959;\"> // alert(\"我是box1\");</font> <font style=\"color:#595959;\"> // },</font> <font style=\"color:#595959;\"> // true</font> <font style=\"color:#595959;\"> // );</font> <font style=\"color:#595959;\"> //需求2</font> <font style=\"color:#595959;\"> boxs[0].addEventListener(</font> <font style=\"color:#595959;\"> \"click\",</font> <font style=\"color:#595959;\"> function () {</font> <font style=\"color:#595959;\"> alert(\"我是box\");</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> false</font> <font style=\"color:#595959;\"> );</font> <font style=\"color:#595959;\"> boxs[1].addEventListener(</font> <font style=\"color:#595959;\"> \"click\",</font> <font style=\"color:#595959;\"> function () {</font> <font style=\"color:#595959;\"> alert(\"我是box1\");</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> false</font> <font style=\"color:#595959;\"> );</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#FF0001;\">注意：</font> <font style=\"color:#000000;\">实际开发中我们很少使用事件捕获，我们更关注事件冒泡</font> <font style=\"color:#000000;\">有些事件是没有冒泡的，比如onblur、onfoucs、onmuseenter、onmouseleave</font> <font style=\"color:#000000;\">事件冒泡有时我们需要，有时需要避免</font> 4、事件对象 1）、概念 简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象，它有很多的属性和方法 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> box1.onmousemove = function (event) {};</font> <font style=\"color:#595959;\"> </script></font> 2）、注意： <font style=\"color:#FF0000;\">event </font>就是一个<font style=\"color:#FF0000;\">事件对象</font>，写在我们侦听函数的小括号里面，当形参来看，这个形参，我们可以自己命名，例如event、evt、e等 事件对象是当事件<font style=\"color:#FF0000;\">触发</font>了，<font style=\"color:#FF0000;\">系统自动</font>给我们<font style=\"color:#FF0000;\">创建</font>的，不需要我们去传入实参 事件对象在ie低版本中有兼容性问题，其<font style=\"color:#FF0000;\">兼容性</font>的写法：<font style=\"color:#FF0000;\">event = event || window.event;</font>，一般不用考虑 3）、事件对象常用的几组属性 <font style=\"color:#FF0000;\">e.target</font>：<font style=\"color:#FF0000;\">返回触发事件的对象</font> <font style=\"color:#FF0000;\">e.type：返回事件的类型</font>，比如：click、mouseover，<font style=\"color:#FF0000;\">不带on</font> e.cancelBubble：阻止冒泡 ie6-8使用（了解） e.returnValue：阻止默认行为， ie6-8使用（了解） <font style=\"color:#FF0000;\">e.preventDefault</font><font style=\"color:#FF0001;\">()：</font><font style=\"color:#FF0000;\">阻止默认行为 非 ie6-8使用</font> <font style=\"color:#FF0000;\">e.stopPropagation()：阻止冒泡 非 ie6-8使用</font> <font style=\"color:#FF0000;\">e.offsetX、e.offsetY：获取鼠标相对于当前元素的位置</font> e.<font style=\"color:#000000;\">clientX、</font>e.<font style=\"color:#000000;\">clientY：获取鼠标相对于浏览器可见窗口的坐标</font> e.<font style=\"color:#000000;\">pageX、</font>e.<font style=\"color:#000000;\">pageY：获取鼠标相对于文档页面的坐标</font> e.<font style=\"color:#000000;\">screenX,</font>e.<font style=\"color:#000000;\">screenY：返回鼠标相对于电脑屏幕的x坐标</font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <div class=\"box\"></font> <font style=\"color:#595959;\"> <div class=\"box1\"></div></font> <font style=\"color:#595959;\"> <a href=\"https://www.baidu.com/\">百度</a></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var boxs = document.querySelectorAll(\"div\");</font> <font style=\"color:#595959;\"> var a = document.querySelector(\"a\");</font> <font style=\"color:#595959;\"> boxs[0].addEventListener(\"click\", function (e) {</font> <font style=\"color:#595959;\"> //e.target</font> <font style=\"color:#595959;\"> console.log(e.target, \"e\");</font> <font style=\"color:#595959;\"> console.log(this, \"this\");</font> <font style=\"color:#595959;\"> //e.type</font> <font style=\"color:#595959;\"> console.log(e.type, \"e.type\");</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> a.onclick = function (e) {</font> <font style=\"color:#595959;\"> // 阻止默认行为</font> <font style=\"color:#595959;\"> e.preventDefault();</font> <font style=\"color:#595959;\"> // 阻止默认行为</font> <font style=\"color:#595959;\"> // return false;</font> <font style=\"color:#595959;\"> // 阻止冒泡</font> <font style=\"color:#595959;\"> e.stopPropagation();</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> （1）、偏移量offset系列 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <div id=\"box1\"></div></font> <font style=\"color:#595959;\"> <div id=\"box2\"></div></font> <font style=\"color:#595959;\"> <script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> / 需求：当鼠标在box1中移动时，在box2中来显示鼠标的坐标 /</font> <font style=\"color:#595959;\"> //获取两个div</font> <font style=\"color:#595959;\"> var box1 = document.getElementById(\"box1\");</font> <font style=\"color:#595959;\"> var box2 = document.getElementById(\"box2\")；</font> <font style=\"color:#595959;\"> box1.onmousemove = function (event) {</font> <font style=\"color:#595959;\"> // event = event || window.event;</font> <font style=\"color:#595959;\"> var x = event.clientX;</font> <font style=\"color:#595959;\"> var y = event.clientY;</font> <font style=\"color:#595959;\"> //在box2中显示鼠标的坐标</font> <font style=\"color:#595959;\"> box2.innerHTML = \"x=\" + x + \",\" + \"y=\" + y;</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 5、事件委托（代理、委派） 不给每个子节点单独设置事件监听，而是<font style=\"color:#FF0000;\">将事件统一绑定给元素的共同的祖先元素，然后利用冒泡原理影响设置每个子节点</font> 通过事件委派可以减少事件绑定的次数，提高程序的性能 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- 需求：为每个超链接都绑定单击响应函数 --></font> <font style=\"color:#595959;\"> <button id=\"btn01\">增加链接</button></font> <font style=\"color:#595959;\"> <ul id=\"u1\"></font> <font style=\"color:#595959;\"> <li><a href=\"#\" class=\"link\">链接一</a></li></font> <font style=\"color:#595959;\"> <li><a href=\"#\" class=\"link\">链接二</a></li></font> <font style=\"color:#595959;\"> <li><a href=\"#\" class=\"link\">链接三</a></li></font> <font style=\"color:#595959;\"> </ul></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //点击按钮，新建超链接</font> <font style=\"color:#595959;\"> var btn01 = document.getElementById(\"btn01\");</font> <font style=\"color:#595959;\"> var u1 = document.querySelector(\"#u1\");</font> <font style=\"color:#595959;\"> btn01.onclick = function () {</font> <font style=\"color:#595959;\"> //新建一个li</font> <font style=\"color:#595959;\"> var li = document.createElement(\"li\");</font> <font style=\"color:#595959;\"> li.innerHTML = '<a href=\"#\" class=\"link\">新建超链接</a>';</font> <font style=\"color:#595959;\"> u1.appendChild(li);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //为ul绑定单击响应函数</font> <font style=\"color:#595959;\"> u1.onclick = function (event) {</font> <font style=\"color:#595959;\"> console.log(event.target);</font> <font style=\"color:#595959;\"> if (event.target.className == \"link\") {</font> <font style=\"color:#595959;\"> alert(\"hi\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 6、常用的键盘事件 | 键盘事件 | 触发条件 | | --- | --- | | <font style=\"color:rgb(255, 0, 0);\">onkeyup</font> | 某个键盘按键<font style=\"color:rgb(255, 0, 0);\">被松开</font>时触发 | | <font style=\"color:rgb(255, 0, 0);\">onkeydown</font> | 某个键盘按键<font style=\"color:rgb(255, 0, 0);\">被按下</font>时触发 | | <font style=\"color:rgb(255, 0, 0);\">onkeypress</font> | 某个键盘按键<font style=\"color:rgb(255, 0, 0);\">被按下</font>时触发 | <font style=\"color:#FF0000;\">e.keyCode返回该键的ASCII值 键盘上每个字符有对应的数字</font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <input type=\"text\" /></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> document.onkeydown = function (e) {</font> <font style=\"color:#595959;\"> console.log(e.keyCode);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //需求： 使文本框不能输入数字</font> <font style=\"color:#595959;\"> var int = document.querySelector(\"input\");</font> <font style=\"color:#595959;\"> int.onkeydown = function (e) {</font> <font style=\"color:#595959;\"> if (e.keyCode >= 48 && e.keyCode <= 57) {</font> <font style=\"color:#595959;\"> /* 在文本框输入内容，属于keyCode的默认行为</font> <font style=\"color:#595959;\"> return false则会取消默认行为 */</font> <font style=\"color:#595959;\"> return false;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 5.1、元素的三大系列 5.1.1offset系列 5.1.1.1、offset初相识 使用offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等 <font style=\"color:#F33232;\">获得元素距离带有定位祖先元素的位置</font> <font style=\"color:#000000;\">获得元素自身的大小（宽度高度）</font> <font style=\"color:#F33232;\">注意：返回的数值都不带单位</font> offset系列常用属性 | <font style=\"color:rgb(0, 0, 0);\">offset系列属性</font> | <font style=\"color:rgb(0, 0, 0);\">作用</font> | | --- | --- | | <font style=\"color:rgb(0, 0, 0);\">element.offsetParent</font> | <font style=\"color:rgb(0, 0, 0);\">返回作为该元素带有定位的父级元素，如果父级没有定位，则返回body</font> | | <font style=\"color:rgb(255, 0, 1);\">element.offsetTop</font> | <font style=\"color:rgb(0, 0, 0);\">返回元素相对于有定位父元素上方的偏移量</font> | | <font style=\"color:rgb(255, 0, 1);\">element.offsetLeft</font> | <font style=\"color:rgb(0, 0, 0);\">返回元素相对于有定位父元素左方的偏移量</font> | | <font style=\"color:rgb(0, 0, 0);\">element.offsetWidth</font> | <font style=\"color:rgb(0, 0, 0);\">返回自身包括padding、边框、内容区的宽度、返回数值不带单位</font> | | <font style=\"color:rgb(0, 0, 0);\">element.offsetHeight</font> | <font style=\"color:rgb(0, 0, 0);\">返回自身包括padding、边框、内容区的高度、返回数值不带单位</font> | 5.1.1.2、offset与style区别 | <font style=\"color:rgb(0, 0, 0);\">offset</font> | <font style=\"color:rgb(0, 0, 0);\">style</font> | | --- | --- | | <font style=\"color:rgb(223, 42, 63);\">offset可以得到任意样式表中的样式值(行内，内部)</font> | <font style=\"color:rgb(0, 0, 0);\">style只能得到行内样式表中的样式值</font> | | <font style=\"color:rgb(0, 0, 0);\">offset系列获得的数值时没有单位的</font> | <font style=\"color:rgb(0, 0, 0);\">style.width获得的是带有单位的字符串</font> | | <font style=\"color:rgb(0, 0, 0);\">offsetWidth包含padding+border+width</font> | <font style=\"color:rgb(0, 0, 0);\">style.width获得不包含padding和border的值</font> | | <font style=\"color:rgb(0, 0, 0);\">offsetWidth等属性时只读属性，只能获取不能赋值</font> | <font style=\"color:rgb(0, 0, 0);\">style.width是可读写属性，可以获取也可以赋值</font> | | <font style=\"color:rgb(0, 0, 0);\">我们想要获取元素大小为止，用offset更合适</font> | <font style=\"color:rgb(0, 0, 0);\">要给元素更改值，则需要用style改变</font> | <font style=\"color:#595959;\"><style></font> <font style=\"color:#595959;\"> * {</font> <font style=\"color:#595959;\"> margin: 0;</font> <font style=\"color:#595959;\"> padding: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .box {</font> <font style=\"color:#595959;\"> width: 200px;</font> <font style=\"color:#595959;\"> height: 200px;</font> <font style=\"color:#595959;\"> border: 1px solid red;</font> <font style=\"color:#595959;\"> margin: 50px auto;</font> <font style=\"color:#595959;\"> position: relative;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .box1 {</font> <font style=\"color:#595959;\"> width: 100px;</font> <font style=\"color:#595959;\"> height: 100px;</font> <font style=\"color:#595959;\"> background-color: orange;</font> <font style=\"color:#595959;\"> position: absolute;</font> <font style=\"color:#595959;\"> top: 0;</font> <font style=\"color:#595959;\"> bottom: 0;</font> <font style=\"color:#595959;\"> left: 0;</font> <font style=\"color:#595959;\"> right: 0;</font> <font style=\"color:#595959;\"> margin: auto;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <div class=\"box\"></font> <font style=\"color:#595959;\"> <div class=\"box1\"></div></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <div class=\"box2\" style=\"width: 50px; height: 50px; background-color: red; border: 10px solid green\"></div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var box = document.querySelector(\".box\");</font> <font style=\"color:#595959;\"> var box1 = document.querySelector(\".box1\");</font> <font style=\"color:#595959;\"> var box2 = document.querySelector(\".box2\");</font> <font style=\"color:#595959;\"> // 一、 通过offset获取值</font> <font style=\"color:#595959;\"> // 1、获取该元素带有定位的父级元素，如果父级没有定位，则返回body</font> <font style=\"color:#595959;\"> // console.log(box1.offsetParent, \"offsetParent\");</font> <font style=\"color:#595959;\"> // 2、返回元素相对于定位父元素上方的偏移量</font> <font style=\"color:#595959;\"> // console.log(box1.offsetTop, \"offsetTop\");</font> <font style=\"color:#595959;\"> // 3、返回元素相对于定位父元素左方的偏移量</font> <font style=\"color:#595959;\"> // console.log(box1.offsetLeft, \"offsetLeft\");</font> <font style=\"color:#595959;\"> // 4、返回自身的宽度（包括内容区，边框，padding）</font> <font style=\"color:#595959;\"> // console.log(box.offsetWidth, \"offsetWidth\");</font> <font style=\"color:#595959;\"> // 5、返回自身的高度（包括内容区，边框，padding）</font> <font style=\"color:#595959;\"> // console.log(box.offsetHeight, \"offsetHeight\");</font> <font style=\"color:#595959;\"> // 二、通过style获取值</font> <font style=\"color:#595959;\"> // 1、style只能获取行内样式表中的样式值</font> <font style=\"color:#595959;\"> // 不包括padding和border</font> <font style=\"color:#595959;\"> // console.log(box2.style.width); //50px</font> <font style=\"color:#595959;\"> //2、 可读可写</font> <font style=\"color:#595959;\"> // box2.style.width = \"200px\";</font> <font style=\"color:#595959;\"> </script></font> 作业： 1、模态框拖拽 2、放大镜效果 5.1.2、client系列 5.1.2.1、client初相识 使用client系列的相关属性来获取元素可视区的相关信息，可以动态的得到该元素的边框大小，元素大小等 | <font style=\"color:rgb(0, 0, 0);\">client系列属性</font> | <font style=\"color:rgb(0, 0, 0);\">作用</font> | | --- | --- | | <font style=\"color:rgb(0, 0, 0);\">element.clientTop</font> | <font style=\"color:rgb(0, 0, 0);\">返回元素上边框的大小</font> | | <font style=\"color:rgb(0, 0, 0);\">element.clientLeft</font> | <font style=\"color:rgb(0, 0, 0);\">返回元素左边框的大小</font> | | <font style=\"color:rgb(255, 0, 1);\">element.clientWidth</font> | <font style=\"color:rgb(0, 0, 0);\">返回自身包括padding，内容区宽度，不含边框，返回数值不带单位</font> | | <font style=\"color:rgb(255, 0, 1);\">element.clientHeight</font> | <font style=\"color:rgb(0, 0, 0);\">返回自身包括padding，内容区高度，不含边框，返回数值不带单位</font> | <font style=\"color:#595959;\"><head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>client</title></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> .box {</font> <font style=\"color:#595959;\"> width: 100px;</font> <font style=\"color:#595959;\"> height: 100px;</font> <font style=\"color:#595959;\"> background-color: red;</font> <font style=\"color:#595959;\"> border: 10px solid orange;</font> <font style=\"color:#595959;\"> padding: 20px;</font> <font style=\"color:#595959;\"> margin: 100px auto;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <div class=\"box\"></div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var box = document.querySelector(\".box\");</font> <font style=\"color:#595959;\"> // 1、返回元素上边框大小</font> <font style=\"color:#595959;\"> //console.log(box.clientTop); //10</font> <font style=\"color:#595959;\"> // 2、返回元素左边框大小</font> <font style=\"color:#595959;\"> //console.log(box.clientLeft); //10</font> <font style=\"color:#595959;\"> // 3、返回自身的宽度，包括padding，内容区，不含边框</font> <font style=\"color:#595959;\"> // console.log(box.clientWidth); //140</font> <font style=\"color:#595959;\"> // 3、返回自身的高度，包括padding，内容区，不含边框</font> <font style=\"color:#595959;\"> // console.log(box.clientHeight); //140</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 5.1.2.2、client的应用-flexible.js解析 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // 立即执行函数 传入window，document参数</font> <font style=\"color:#595959;\">(function flexible(window, document) {</font> <font style=\"color:#595959;\"> // 获取html根标签 我们是通过更改html根标签的大小来改变页面大小的</font> <font style=\"color:#595959;\"> var docEl = document.documentElement;</font> <font style=\"color:#595959;\"> // 获取物理像素比，window.devicePixelRatio获取当前的dpr值，如果没有就是1</font> <font style=\"color:#595959;\"> var dpr = window.devicePixelRatio || 1;</font> <font style=\"color:#595959;\"> // adjust body font size</font> <font style=\"color:#595959;\"> //设置body字体大小</font> <font style=\"color:#595959;\"> function setBodyFontSize() {</font> <font style=\"color:#595959;\"> // 如果页面中有body这个元素，就设置body的字体大小</font> <font style=\"color:#595959;\"> if (document.body) {</font> <font style=\"color:#595959;\"> document.body.style.fontSize = 12 * dpr + \"px\";</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> // 如果页面中没有body这个元素，则等着我们页面主要dom元素加载完后，设置页面字体大小</font> <font style=\"color:#595959;\"> document.addEventListener(\"DOMContentLoaded\", setBodyFontSize);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> setBodyFontSize();</font> <font style=\"color:#595959;\"> // set 1rem = viewWidth / 10</font> <font style=\"color:#595959;\"> // 设置html元素的文字大小</font> <font style=\"color:#595959;\"> function setRemUnit() {</font> <font style=\"color:#595959;\"> // 将页面的大小平均划分为10等份，为整个页面的大小</font> <font style=\"color:#595959;\"> // 设置html根字体大小的变化</font> <font style=\"color:#595959;\"> var rem = docEl.clientWidth / 10;</font> <font style=\"color:#595959;\"> docEl.style.fontSize = rem + \"px\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> setRemUnit();</font> <font style=\"color:#595959;\"> // reset rem unit on page resize</font> <font style=\"color:#595959;\"> // 如果页面尺寸大小发生了变化，要重新设置rem大小</font> <font style=\"color:#595959;\"> window.addEventListener(\"resize\", setRemUnit);</font> <font style=\"color:#595959;\"> // pageshow 是我们重新加载页面触发的事件</font> <font style=\"color:#595959;\"> window.addEventListener(\"pageshow\", function (e) {</font> <font style=\"color:#595959;\"> // 如果是从缓存取过来的页面，也需要重新计算rem大小，为了兼容浏览器的</font> <font style=\"color:#595959;\"> if (e.persisted) {</font> <font style=\"color:#595959;\"> setRemUnit();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> // detect 0.5px supports</font> <font style=\"color:#595959;\"> // 有些移动端浏览器不支持0.5像素的写法， 通过一下代码，进行兼容</font> <font style=\"color:#595959;\"> if (dpr >= 2) {</font> <font style=\"color:#595959;\"> // 创建一个假的body元素，用于临时添加测试元素以检测某些样式效果</font> <font style=\"color:#595959;\"> var fakeBody = document.createElement(\"body\");</font> <font style=\"color:#595959;\"> // 创建一个测试用的div元素</font> <font style=\"color:#595959;\"> var testElement = document.createElement(\"div\");</font> <font style=\"color:#595959;\"> // 设置测试元素的边框样式，目的是检测在当前环境下边框的实际渲染高度</font> <font style=\"color:#595959;\"> testElement.style.border = \".5px solid transparent\";</font> <font style=\"color:#595959;\"> // 将测试元素添加到假body中</font> <font style=\"color:#595959;\"> fakeBody.appendChild(testElement);</font> <font style=\"color:#595959;\"> // 将假body添加到文档的body元素中，以便在当前页面环境中渲染测试元素</font> <font style=\"color:#595959;\"> docEl.appendChild(fakeBody);</font> <font style=\"color:#595959;\"> // 检测测试元素的渲染高度是否为1，这可以用来判断设备的像素比或浏览器的渲染特性</font> <font style=\"color:#595959;\"> if (testElement.offsetHeight === 1) {</font> <font style=\"color:#595959;\"> // 如果测试元素的高度为1，表明可能存在高像素比屏幕或其他渲染特性</font> <font style=\"color:#595959;\"> // 在这种情况下，为docEl添加类名\"hairlines\"，以便通过CSS提供更合适的样式</font> <font style=\"color:#595959;\"> docEl.classList.add(\"hairlines\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 清理测试元素，移除假body，以避免对页面其他部分造成潜在影响</font> <font style=\"color:#595959;\"> docEl.removeChild(fakeBody);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">})(window, document);</font> <font style=\"color:#595959;\"> </script></font> 5.1.3、scroll系列 5.1.3.1、 scroll初相识 利用scroll系列的相关属性可以动态的得到该元素的大小，滚动距离等 | <font style=\"color:rgb(0, 0, 0);\">scroll系列属性</font> | <font style=\"color:rgb(0, 0, 0);\">作用</font> | | --- | --- | | <font style=\"color:rgb(255, 0, 1);\">element.scrollTop</font> | <font style=\"color:rgb(0, 0, 0);\">返回被卷去的上侧距离，返回数值不带单位</font> | | <font style=\"color:rgb(255, 0, 1);\">element.scrollLeft</font> | <font style=\"color:rgb(0, 0, 0);\">返回被卷去的左侧距离，返回数值不带单位</font> | | <font style=\"color:rgb(0, 0, 0);\">element.scrollWidth</font> | <font style=\"color:rgb(0, 0, 0);\">返回自身实际的宽度（</font><font style=\"color:rgb(243, 50, 50);\">实际内容的宽度</font><font style=\"color:rgb(0, 0, 0);\">），不含边框，返回数值不带单位</font> | | <font style=\"color:rgb(0, 0, 0);\">element.scrollHeight</font> | <font style=\"color:rgb(0, 0, 0);\">返回自身实际的高度（</font><font style=\"color:rgb(243, 50, 50);\">实际内容的宽度</font><font style=\"color:rgb(0, 0, 0);\">），不含边框，返回数值不带单位</font> | <font style=\"color:#595959;\"><head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>scroll</title></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> .box1 {</font> <font style=\"color:#595959;\"> width: 200px;</font> <font style=\"color:#595959;\"> height: 200px;</font> <font style=\"color:#595959;\"> background-color: #bfa;</font> <font style=\"color:#595959;\"> border: 10px solid red;</font> <font style=\"color:#595959;\"> padding: 20px;</font> <font style=\"color:#595959;\"> overflow: auto;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> p {</font> <font style=\"color:#595959;\"> width: 400px;</font> <font style=\"color:#595959;\"> height: 400px;</font> <font style=\"color:#595959;\"> background-color: orange;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <div class=\"box1\"></font> <font style=\"color:#595959;\"> <p>其那了，种法苟反作。</p></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var box = document.querySelector(\".box1\");</font> <font style=\"color:#595959;\"> // 1、返回自身实际的宽度（实际内容的宽度），不含边框，返回数值不带单位</font> <font style=\"color:#595959;\"> // console.log(\"scrollWidth\", box.scrollWidth);</font> <font style=\"color:#595959;\"> // console.log(\"clientWidth\", box.clientWidth);</font> <font style=\"color:#595959;\"> // 2、返回自身实际的高度（实际内容的宽度），不含边框，返回数值不带单位</font> <font style=\"color:#595959;\"> // console.log(\"scrollHeight\", box.scrollHeight);</font> <font style=\"color:#595959;\"> // console.log(\"clientHeight\", box.clientHeight);</font> <font style=\"color:#595959;\"> // 3、返回被卷去的上侧距离，返回数值不带单位</font> <font style=\"color:#595959;\"> // console.log(\"scrollTop\", box.scrollTop);</font> <font style=\"color:#595959;\"> // 4、返回被卷去的左侧距离，返回数值不带单位</font> <font style=\"color:#595959;\"> // console.log(\"scrollLeft\", box.scrollLeft);</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> // 滚动事件触发时，打印被卷去的距离</font> <font style=\"color:#595959;\"> // box.addEventListener(\"scroll\", function () {</font> <font style=\"color:#595959;\"> // console.log(\"scrollTop\", box.scrollTop);</font> <font style=\"color:#595959;\"> // console.log(\"scrollLeft\", box.scrollLeft);</font> <font style=\"color:#595959;\"> // });</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 作业： 1、京东侧边导航条 5.1.4、小结 | <font style=\"color:rgb(0, 0, 0);\">三大系列大小对比</font> | <font style=\"color:rgb(0, 0, 0);\">作用</font> | | --- | --- | | <font style=\"color:rgb(0, 0, 0);\">element.offsetWidth</font> | <font style=\"color:rgb(0, 0, 0);\">返回自身包括padding，边框，内容区的宽度，返回数值不带单位</font> | | <font style=\"color:rgb(0, 0, 0);\">element.clientWidth</font> | <font style=\"color:rgb(0, 0, 0);\">返回自身包括padding，内容区宽度，不含边框，返回数值不带单位</font> | | <font style=\"color:rgb(0, 0, 0);\">element.scrollWidth</font> | <font style=\"color:rgb(0, 0, 0);\">返回自身实际宽度，不含边框，返回数值不带单位</font> | offset系列进行用于获得元素位置 offsetLeft offsetTop client经常用于获取元素大小 clientWidth clientHeight sroll经常用于获取滚动距离 scrollTop 事件对象的相关大小： 5.2、动画函数封装 5.2.1、简单动画实现 核心原理：通过定时器<font style=\"color:#FF0000;\">setInterval()</font>不断移动盒子位置 实现步骤： <font style=\"color:#000000;\">获得盒子当前位置、</font> <font style=\"color:#000000;\">让盒子在当前位置上加上1个移动距离、</font> <font style=\"color:#000000;\">利用定时器不断重复这个操作、</font> <font style=\"color:#000000;\">加一个结束定时器的条件</font> <font style=\"color:#000000;\">需要给元素加定位，利用left值变化改变元素的位置</font> <font style=\"color:#595959;\"><!-- 需求：小盒子从左向右移动，移动到500px的地方，停下 --></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var box = document.querySelector(\"div\");</font> <font style=\"color:#595959;\"> var timer = setInterval(function () {</font> <font style=\"color:#595959;\"> if (box.offsetLeft === 500) {</font> <font style=\"color:#595959;\"> clearInterval(timer);</font> <font style=\"color:#595959;\"> return;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> box.style.left = box.offsetLeft + 10 + \"px\";</font> <font style=\"color:#595959;\"> }, 30);</font> <font style=\"color:#595959;\"> </script></font> 5.2.2、简单动画函数封装 <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>02.封装简单动画函数</title></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> * {</font> <font style=\"color:#595959;\"> margin: 0;</font> <font style=\"color:#595959;\"> padding: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> div {</font> <font style=\"color:#595959;\"> width: 100px;</font> <font style=\"color:#595959;\"> height: 100px;</font> <font style=\"color:#595959;\"> background-color: #bfa;</font> <font style=\"color:#595959;\"> position: relative;</font> <font style=\"color:#595959;\"> left: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> span {</font> <font style=\"color:#595959;\"> background-color: pink;</font> <font style=\"color:#595959;\"> position: relative;</font> <font style=\"color:#595959;\"> left: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <div>动画1</div></font> <font style=\"color:#595959;\"> <span>动画2</span></font> <font style=\"color:#595959;\"> <!-- 封装函数，传入不同的对象，目标停止值，都可以调用动画 --></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> function animation(obj, target) {</font> <font style=\"color:#595959;\"> var timer = setInterval(function () {</font> <font style=\"color:#595959;\"> if (obj.offsetLeft === target) {</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">clearInterval(timer);</font> <font style=\"color:#595959;\"> return;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> obj.style.left = obj.offsetLeft + 10 + \"px\";</font> <font style=\"color:#595959;\"> }, 30);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> var box = document.querySelector(\"div\");</font> <font style=\"color:#595959;\"> var s1 = document.querySelector(\"span\");</font> <font style=\"color:#595959;\"> animation(box, 500);</font> <font style=\"color:#595959;\"> animation(s1, 300);</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> 5.2.3、优化动画函数 动画函数给不同的元素记录不同定时器 如果多个元素都使用这个动画函数，每次都要var 声明定时器，我们可以给不同元素使用不同的定时器（自己用自己的定时器） 核心原理：利用js是一门动态语言，可以很方便的给当前对象添加属性 <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>03.优化动画函数</title></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> * {</font> <font style=\"color:#595959;\"> padding: 0;</font> <font style=\"color:#595959;\"> margin: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> div {</font> <font style=\"color:#595959;\"> width: 100px;</font> <font style=\"color:#595959;\"> height: 100px;</font> <font style=\"color:#595959;\"> background-color: #bfa;</font> <font style=\"color:#595959;\"> position: relative;</font> <font style=\"color:#595959;\"> left: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> span {</font> <font style=\"color:#595959;\"> background-color: pink;</font> <font style=\"color:#595959;\"> position: relative;</font> <font style=\"color:#595959;\"> left: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <div>动画1</div></font> <font style=\"color:#595959;\"> <br /></font> <font style=\"color:#595959;\"> <button>点击按钮，执行动画函数</button><br /></font> <font style=\"color:#595959;\"> <span>动画2</span></font> <font style=\"color:#595959;\"> <!-- 优化1:根据传入的不同对象，将timer作为属性添加给不同的对象，减少开辟的空间 --></font> <font style=\"color:#595959;\"> <!-- 优化2:保证只有一个定时器在执行 --></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> function animation(obj, target) {</font> <font style=\"color:#595959;\"> //在开启动画前，先关闭前一个定时器，保证只有一个定时器在执行</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">clearInterval(obj.timer);</font> <font style=\"color:#595959;\"> obj.timer = setInterval(function () {</font> <font style=\"color:#595959;\"> if (obj.offsetLeft >= target) {</font> <font style=\"color:#595959;\"> clearInterval(obj.timer);</font> <font style=\"color:#595959;\"> //优化3:当达到目标值后，再点击也不会执行了</font> <font style=\"color:#595959;\"> return;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> obj.style.left = obj.offsetLeft + 10 + \"px\";</font> <font style=\"color:#595959;\"> }, 30);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> var box = document.querySelector(\"div\");</font> <font style=\"color:#595959;\"> var s1 = document.querySelector(\"span\");</font> <font style=\"color:#595959;\"> var btn = document.querySelector(\"button\");</font> <font style=\"color:#595959;\"> btn.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> animation(s1, 300);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> animation(box, 500);</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> 5.2.4、缓动效果原理 缓动动画就是让元素<font style=\"color:#FF0000;\">运动速度有所变化</font>，最常见的是让速度慢慢停下来 思路： 让盒子每次移动的距离慢慢变小，速度就会慢慢落下来 <font style=\"color:#FF0000;\">核心算法：（目标值-现在的位置）/10 作为每次移动的距离步长</font> 停止的条件是：让当前盒子位置等于目标位置就停止定时器 <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>04.缓动画实现</title></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> * {</font> <font style=\"color:#595959;\"> padding: 0;</font> <font style=\"color:#595959;\"> margin: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> div {</font> <font style=\"color:#595959;\"> width: 100px;</font> <font style=\"color:#595959;\"> height: 100px;</font> <font style=\"color:#595959;\"> background-color: pink;</font> <font style=\"color:#595959;\"> position: relative;</font> <font style=\"color:#595959;\"> left: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <button>点击按钮，执行动画函数</button><br /></font> <font style=\"color:#595959;\"> <div>动画2</div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> function animation(obj, target) {</font> <font style=\"color:#595959;\"> clearInterval(obj.timer);</font> <font style=\"color:#595959;\"> obj.timer = setInterval(function () {</font> <font style=\"color:#595959;\"> // 定义step，来代表每次移动的距离值，（目标值-现在的位置）/10</font> <font style=\"color:#595959;\"> var step = (target - obj.offsetLeft) / 10;</font> <font style=\"color:#595959;\"> if (obj.offsetLeft == target) {</font> <font style=\"color:#595959;\"> clearInterval(obj.timer);</font> <font style=\"color:#595959;\"> return;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> obj.style.left = obj.offsetLeft + step + \"px\";</font> <font style=\"color:#595959;\"> }, 30);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> var s1 = document.querySelector(\"div\");</font> <font style=\"color:#595959;\"> var btn = document.querySelector(\"button\");</font> <font style=\"color:#595959;\"> btn.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> animation(s1, 500);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> 5.2.5、动画函数优化 <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>05.优化缓动动画动画函数</title></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> * {</font> <font style=\"color:#595959;\"> padding: 0;</font> <font style=\"color:#595959;\"> margin: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> div {</font> <font style=\"color:#595959;\"> width: 100px;</font> <font style=\"color:#595959;\"> height: 100px;</font> <font style=\"color:#595959;\"> background-color: pink;</font> <font style=\"color:#595959;\"> position: absolute;</font> <font style=\"color:#595959;\"> left: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <button id=\"btn01\">点击按钮，执行动画函数 500</button><br /></font> <font style=\"color:#595959;\"> <button id=\"btn02\">点击按钮，执行动画函数 800</button><br /></font> <font style=\"color:#595959;\"> <div>丹洋其</div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">//优化三 加回调函数，可以在执行动画后，再执行其他内容</font> <font style=\"color:#595959;\"> function animation(obj, target, callback) {</font> <font style=\"color:#595959;\"> clearInterval(obj.timer);</font> <font style=\"color:#595959;\"> obj.timer = setInterval(function () {</font> <font style=\"color:#595959;\"> // 定义step，来代表每次移动的距离值</font> <font style=\"color:#FF0000;\"> // 优化一：对于step会涉及到小数，将小数向上取整</font> <font style=\"color:#595959;\"> // var step = Math.ceil((target - obj.offsetLeft) / 10);</font> <font style=\"color:#FF0000;\"> // 优化二：动画还是会涉及到往回走，如果往回走，则step会是负值，要向小取整</font> <font style=\"color:#595959;\"> var step = (target - obj.offsetLeft) / 10;</font> <font style=\"color:#595959;\"> step = step > 0 ? Math.ceil(step) : Math.floor(step);</font> <font style=\"color:#595959;\"> if (obj.offsetLeft == target) {</font> <font style=\"color:#595959;\"> clearInterval(obj.timer);</font> <font style=\"color:#FF0000;\"> // 如果传入了回调，则执行回调，否则，就不执行</font> <font style=\"color:#595959;\"> if (callback) {</font> <font style=\"color:#595959;\"> callback();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> // console.log(222);</font> <font style=\"color:#595959;\"> obj.style.left = obj.offsetLeft + step + \"px\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }, 15);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> var s1 = document.querySelector(\"div\");</font> <font style=\"color:#595959;\"> var btn01 = document.querySelector(\"#btn01\");</font> <font style=\"color:#595959;\"> var btn02 = document.querySelector(\"#btn02\");</font> <font style=\"color:#595959;\"> btn01.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> animation(s1, 500);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> btn02.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> animation(s1, 800, function () {</font> <font style=\"color:#595959;\"> alert(\"111\");</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> 5.2.6、animation.js文件并使用 animation.js <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> function animation(obj, target, callback) {</font> <font style=\"color:#595959;\"> clearInterval(obj.timer);</font> <font style=\"color:#595959;\"> obj.timer = setInterval(function () {</font> <font style=\"color:#595959;\"> var step = (target - obj.offsetLeft) / 10;</font> <font style=\"color:#595959;\"> step = step > 0 ? Math.ceil(step) : Math.floor(step);</font> <font style=\"color:#595959;\"> if (obj.offsetLeft == target) {</font> <font style=\"color:#595959;\"> clearInterval(obj.timer);</font> <font style=\"color:#595959;\"> if (callback) {</font> <font style=\"color:#595959;\"> callback();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> console.log(222);</font> <font style=\"color:#595959;\"> obj.style.left = obj.offsetLeft + step + \"px\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }, 15);</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\"> </script></font> 简单使用 <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> .nav {</font> <font style=\"color:#595959;\"> width: 30px;</font> <font style=\"color:#595959;\"> height: 30px;</font> <font style=\"color:#595959;\"> background-color: blueviolet;</font> <font style=\"color:#595959;\"> position: fixed;</font> <font style=\"color:#595959;\"> text-align: center;</font> <font style=\"color:#595959;\"> line-height: 30px;</font> <font style=\"color:#595959;\"> right: 0px;</font> <font style=\"color:#595959;\"> top: 40%;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .con {</font> <font style=\"color:#595959;\"> position: absolute;</font> <font style=\"color:#595959;\"> left: 0px;</font> <font style=\"color:#595959;\"> top: 0;</font> <font style=\"color:#595959;\"> width: 200px;</font> <font style=\"color:#595959;\"> height: 30px;</font> <font style=\"color:#595959;\"> background-color: blueviolet;</font> <font style=\"color:#595959;\"> z-index: -1;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> <script src=\"./animation.js\"></script></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <div class=\"nav\"></font> <font style=\"color:#595959;\"> <span></font><font style=\"color:#595959;\">⬅️</font><font style=\"color:#595959;\"></span></font> <font style=\"color:#595959;\"> <div class=\"con\">移入弹出</div></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var s1 = document.querySelector(\"span\");</font> <font style=\"color:#595959;\"> var nav = document.querySelector(\".nav\");</font> <font style=\"color:#595959;\"> var con = document.querySelector(\".con\");</font> <font style=\"color:#595959;\"> nav.addEventListener(\"mouseenter\", function () {</font> <font style=\"color:#595959;\"> animation(con, -170, function () {</font> <font style=\"color:#595959;\"> s1.innerHTML = \"</font><font style=\"color:#595959;\">➡️</font><font style=\"color:#595959;\">\";</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> nav.addEventListener(\"mouseleave\", function () {</font> <font style=\"color:#595959;\"> animation(con, 0, function () {</font> <font style=\"color:#595959;\"> s1.innerHTML = \"</font><font style=\"color:#595959;\">⬅️</font><font style=\"color:#595959;\">\";</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> 5.3、JSON数据 5.3.1、JSON （1）、定义： JSON数据格式 JavaScript Object Notation缩写 即<font style=\"color:#FF0000;\"> js对象表示法</font> 由于JS中的对象只有JS自己认识，其他的语言都不认识，所以引入了JSON，<font style=\"color:#FF0000;\">JSON</font>就是一个<font style=\"color:#FF0000;\">特殊格式</font>的<font style=\"color:#FF0000;\">字符串</font>，这个字符串可以<font style=\"color:#FF0000;\">被任意的语言所识别</font>， 并且<font style=\"color:#FF0000;\">可以转换为任意语言中的对象</font>，JSON在开发中<font style=\"color:#FF0000;\">主要用来数据的交互</font>，是一种轻量级的数据交换格式 （2）、特点： 1、易于程序员阅读和编写。 2、易于计算机解析和生成。 3、其实是javascript的子集：原生javascript支持JSON （3）、作用： json是一种与语言无关的数据交换的格式， 1、使用ajax进行前后台数据交换 2、移动端与服务端的数据交换 （4）、JSON的语法规则： JSON的语法规则十分简单，可称得上“优雅完美”，总结起来有： JSON有两种结构： 1、<font style=\"color:#FF0000;\">对象格式：{“key1”：obj1, “key2”:obj2, “key3”:obj3…}</font> 2、<font style=\"color:#FF0000;\">数组/集合格式: [obj1,obj2,obj3…]</font> JSON中允许的值：<font style=\"color:#FF0000;\">字符串，数值，布尔值，null，对象，数组</font>， JSON和JS对象的格式一样，只不过JSON字符串中的<font style=\"color:#FF0000;\">属性名必须加双引号</font>，其他的和JS语法一致 规则如下: 1）映射用冒号（“：”）表示。名称:值 2）并列的数据之间用逗号（“，”）分隔。名称1:值1,名称2:值2 3） 映射的集合（对象）用大括号（“{}”）表示。{名称1:值1,名称2:值2} 4） 并列数据的集合（数组）用方括号(“[]”)表示。 （5）、JSON的方法 将JSON字符串转换为JS中的对象，在JS中，为我们提供了一个工具类，就叫JSON ，这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON <font style=\"color:#FF0000;\">JSON.parse()</font> 可以将以<font style=\"color:#FF0000;\">JSON字符串===》js对象</font> 它需要一个<font style=\"color:#FF0000;\">JSON字符串作为参数，会将该字符串转换为JS对象并返回</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var json = '{\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"}';</font> <font style=\"color:#595959;\"> var o = JSON.parse(json);</font> <font style=\"color:#595959;\"> console.log(o); //{name: '孙悟空', age: 18, gender: '男'}</font> <font style=\"color:#595959;\"> console.log(o.gender); //男</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#FF0000;\">JSON.stringify() </font> <font style=\"color:#FF0000;\">可以将一个JS对象===》JSON字符串</font> <font style=\"color:#FF0000;\">需要一个js对象作为参数，会返回一个JSON字符串</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var obj3 = { name: \"猪八戒\", age: 28, gender: \"男\" };</font> <font style=\"color:#595959;\"> obj3 = JSON.stringify(obj3);</font> <font style=\"color:#595959;\"> console.log(obj3); //{\"name\":\"猪八戒\",\"age\":28,\"gender\":\"男\"}</font> <font style=\"color:#595959;\"> </script></font> 5.3.2、XML 5.3.2.1 什么是xml eXtensible Markup Language，可扩展标记型语言 （1）标记型语言：html是标记型语言，都是使用标签进行操作。 xml里面的操作也是使用标签进行操作。 （2）可扩展：html里面的标签，每个标签有自己特定的含义， 比如<br/> <hr/> 在xml中标签自己定义的，比如 <aa> <猫> （3）xml的主要的功能是存储数据（不是显示数据） 5.3.2.2 xml的应用在三个地方 第一，xml用于作为系统之间传输数据的格式 第二，xml用于表示生活中有关系的数据，数据的存储。 第三，xml经常使用在系统的配置文件 第四，android 手机应用程序开发，页面的内容展示，都是xml 5.3.3、JSON与XML比较 JSON常备拿来与XML做比较，因为JSON的诞生本来就或多或少要有取代XML的意思。 相比XML，JSON的优势如下： 1、没有结束标签，长度更短，读写更快。 2、能够直接被JavaScript解析器解析。 3、可以使用数组。 JSON: { “id” : 12, “name” : “gao”, “age” : 30, “gender” : “男”, “interests” : [“篮球”, “爬山”, “旅游”] } XML： <font style=\"color:#595959;\"><root></font> <font style=\"color:#595959;\"> <id>12</id></font> <font style=\"color:#595959;\"> <name>gao</name></font> <font style=\"color:#595959;\"> <age>30</age></font> <font style=\"color:#595959;\"> <gender>男</gender></font> <font style=\"color:#595959;\"> <interest>篮球</interest></font> <font style=\"color:#595959;\"> <interest>爬山</interest></font> <font style=\"color:#595959;\"> <interest>旅游</interest></font> <font style=\"color:#595959;\"> </root></font> JSON可以直接使用数组，但是XML没有直接定义数组， 如果数组很长，我们的代码中就要添加大量的没有实际意义的开始和结束标签，这对于网络传输是不利的。 XML主要是用在配置文件。 5.4、本地存储 localstorage、Sessionstorage是Web Storage，H5的本地存储机制。是本地存储，存储在客户端，以键/值对的形式存储的，通常以字符串存储。 是针对HTML4中 Cookie 存储机制的一个改善，由于Cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的 Web Storage 存储机制。 5.4.1、Cookie （1）、定义 Cookie实际上是一小段的文本信息，是服务器发送到用户浏览器并保存在本地的一小块数据。 客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。当浏览器下次向同一服务器再发起请求时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。 （2）、作用 保存用户登录状态 跟踪用户行为 定制页面 创建购物车：使用cookie来记录用户需要购买的商品，再结帐的时候可以统一提交。(淘宝网就是使用cookie记录了用户曾经浏览过的商品，方便随时进行比较) 5.4.2、window.sessionStorage ●<font style=\"color:#000000;\">生命周期为</font><font style=\"color:#F33232;\">关闭浏览器窗口</font> <font style=\"color:#000000;\">●在同一个窗口（页面）下数据可以共享</font> <font style=\"color:#000000;\">●存储空间相对较小</font> <font style=\"color:#000000;\">●以键值对的形式存储使用</font> sessionStorage.setItem(key,value); //存储数据 sessionStorage.getItem(key);//获取数据 sessionStorage.removeItem(key);//删除数据 sessionStorage.clear();//清除数据 5.4.3、window.localStorage ●<font style=\"color:#000000;\">生命周期</font><font style=\"color:#F33232;\">永久生效</font><font style=\"color:#000000;\">，除非手动删除，否则关闭页面也会存在</font> <font style=\"color:#000000;\">●可以多窗口（页面）共享（同一个浏览器可以共享）</font> <font style=\"color:#000000;\">●存储空间较大</font> <font style=\"color:#000000;\">●以健值对的形式存储使用</font> localStorage.setItem(key,value); //存储数据 localStorage.getItem(key);//获取数据 localStorage.removeItem(key);//删除数据 localStorage.clear();//清除数据 5.4.4、记住用户名案例 如果勾选记住用户名，下次用户打开浏览器，就在文本框里自动显示上次登录的用户名 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <input type=\"text\" id=\"username\" /></font> <font style=\"color:#595959;\"> <input type=\"checkbox\" id=\"checkbox\" />记住用户名</font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var userInt = document.getElementById(\"username\");</font> <font style=\"color:#595959;\"> var checkbox = document.getElementById(\"checkbox\");</font> <font style=\"color:#595959;\"> // 判断本地是否存储了username，存了就取出来赋值给input，并勾选复选框</font> <font style=\"color:#595959;\"> if (localStorage.getItem(\"username\")) {</font> <font style=\"color:#595959;\"> userInt.value = localStorage.getItem(\"username\");</font> <font style=\"color:#595959;\"> checkbox.checked = true;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> checkbox.addEventListener(\"change\", function () {</font> <font style=\"color:#595959;\"> if (this.checked) {</font> <font style=\"color:#595959;\"> localStorage.setItem(\"username\", userInt.value);</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> localStorage.removeItem(\"username\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 1、模态框(弹出框) （1）、需求： <font style=\"color:#000000;\">点击弹出层，会弹出模态框，并且显示灰色半透明的遮挡层</font> <font style=\"color:#000000;\">点击关闭按钮，可以关闭模态框，并且同时关闭半透明遮挡层</font> <font style=\"color:#000000;\">鼠标放在模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动</font> <font style=\"color:#000000;\">鼠标松开，可以停止拖动模态框移动</font> 思路： <font style=\"color:#000000;\">点击弹出层，模态框和遮挡层就会显示出来 display:block</font> <font style=\"color:#000000;\">点击关闭按钮，模态框和遮罩层会隐藏起来 display:none</font> <font style=\"color:#000000;\">在页面中拖拽的原理：鼠标按下并且移动，之后松开鼠标</font> <font style=\"color:#000000;\">触发事件是鼠标按下mousedown，鼠标移动mousemove 鼠标松开 mouseup</font> <font style=\"color:#000000;\">拖拽过程，鼠标移动过程中，获得最新的值赋值给模态框的left和top值，这样模态框就可以跟着鼠标走了</font> <font style=\"color:#000000;\">鼠标按下触发的事件源是h2</font> <font style=\"color:#000000;\">鼠标的坐标减去鼠标内的坐标，才是模态框真正的位置</font> <font style=\"color:#000000;\">鼠标按下，我们要得到鼠标在盒子的坐标</font> <font style=\"color:#000000;\">鼠标移动，就让模态框的坐标设置为：鼠标坐标减去盒子坐标即可，注意移动时间写到按下</font> <font style=\"color:#000000;\">鼠标松开，就停止拖拽，可以让鼠标移动事件解除</font> （2）、es5 <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> * {</font> <font style=\"color:#595959;\"> margin: 0;</font> <font style=\"color:#595959;\"> padding: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> h1 {</font> <font style=\"color:#595959;\"> cursor: pointer;</font> <font style=\"color:#595959;\"> margin: 50px auto;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> / 模态框 /</font> <font style=\"color:#595959;\"> .modal-box {</font> <font style=\"color:#595959;\"> display: none;</font> <font style=\"color:#595959;\"> width: 400px;</font> <font style=\"color:#595959;\"> height: 300px;</font> <font style=\"color:#595959;\"> background-color: #bfa;</font> <font style=\"color:#595959;\"> position: absolute;</font> <font style=\"color:#595959;\"> left: 50%;</font> <font style=\"color:#595959;\"> top: 50%;</font> <font style=\"color:#595959;\"> transform: translate(-50%, -50%);</font> <font style=\"color:#595959;\"> z-index: 99;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> button {</font> <font style=\"color:#595959;\"> position: absolute;</font> <font style=\"color:#595959;\"> right: 50px;</font> <font style=\"color:#595959;\"> top: 30px;</font> <font style=\"color:#595959;\"> width: 80px;</font> <font style=\"color:#595959;\"> line-height: 40px;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> / 遮罩层 /</font> <font style=\"color:#595959;\"> .bg {</font> <font style=\"color:#595959;\"> display: none;</font> <font style=\"color:#595959;\"> position: absolute;</font> <font style=\"color:#595959;\"> width: 100%;</font> <font style=\"color:#595959;\"> height: 100%;</font> <font style=\"color:#595959;\"> left: 0;</font> <font style=\"color:#595959;\"> top: 0;</font> <font style=\"color:#595959;\"> background-color: #000;</font> <font style=\"color:#595959;\"> opacity: 0.3;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .title {</font> <font style=\"color:#595959;\"> background-color: aqua;</font> <font style=\"color:#595959;\"> line-height: 60px;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <h1>点击，弹出模态框</h1></font> <font style=\"color:#595959;\"> <!-- 弹出框 --></font> <font style=\"color:#595959;\"> <div class=\"modal-box\"></font> <font style=\"color:#595959;\"> <button>关闭</button></font> <font style=\"color:#595959;\"> <h2 class=\"title\">我是一个可爱的模态框·····</h2></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <!-- 遮罩层 --></font> <font style=\"color:#595959;\"> <div class=\"bg\"></div></font> <font style=\"color:#595959;\"> <!-- js --></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 1、获取元素</font> <font style=\"color:#595959;\"> var h1 = document.querySelector(\"h1\");</font> <font style=\"color:#595959;\"> var modalBox = document.querySelector(\".modal-box\");</font> <font style=\"color:#595959;\"> var btn = document.querySelector(\"button\");</font> <font style=\"color:#595959;\"> var bg = document.querySelector(\".bg\");</font> <font style=\"color:#595959;\"> var title = document.querySelector(\".title\");</font> <font style=\"color:#595959;\"> // 2、点击显示，隐藏模态框</font> <font style=\"color:#595959;\"> h1.onclick = function () {</font> <font style=\"color:#595959;\"> modalBox.style.display = \"block\";</font> <font style=\"color:#595959;\"> bg.style.display = \"block\";</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> btn.onclick = function () {</font> <font style=\"color:#595959;\"> modalBox.style.display = \"none\";</font> <font style=\"color:#595959;\"> bg.style.display = \"none\";</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> // 3、开始拖拽模态框</font> <font style=\"color:#595959;\"> //（1）、当我们鼠标按下，就获得鼠标在盒子内的坐标</font> <font style=\"color:#595959;\"> title.addEventListener(\"mousedown\", function (e) {</font> <font style=\"color:#595959;\"> var x = e.pageX - modalBox.offsetLeft;</font> <font style=\"color:#595959;\"> var y = e.pageY - modalBox.offsetTop;</font> <font style=\"color:#595959;\"> // (2)、鼠标移动的时候，把鼠标在页面中的坐标，减去鼠标在盒子内的坐标</font> <font style=\"color:#595959;\"> // 就是不断的求modalBox.offsetLeft ，modalBox.offsetTop</font> <font style=\"color:#595959;\"> // 不能直接用offset</font> <font style=\"color:#595959;\"> // 直接用offset得到的是盒子本来的坐标，盒子要动起来，才能改变offset的值，</font> <font style=\"color:#595959;\"> // 当我们是想要先改变offset然后用他来改变盒子的位置，所以不能直接用offset</font> <font style=\"color:#595959;\"> // 而是用鼠标的位置来动态的输入offset</font> <font style=\"color:#595959;\"> function move(e) {</font> <font style=\"color:#595959;\"> modalBox.style.left = e.pageX - x + \"px\";</font> <font style=\"color:#595959;\"> modalBox.style.top = e.pageY - y + \"px\";</font> <font style=\"color:#595959;\"> // 这样设置，会导致，初始化移动时，就把鼠标的位置，赋值给盒子的中心，有个跳跃的过程</font> <font style=\"color:#595959;\"> // modalBox.style.left = e.pageX + \"px\";</font> <font style=\"color:#595959;\"> // modalBox.style.top = e.pageY + \"px\";</font> <font style=\"color:#595959;\"> // modalBox.offsetLeft 是固定的值，不会变化的，需要先动盒子才能得到新的modalBox.offsetLeft</font> <font style=\"color:#595959;\"> // modalBox.style.left = modalBox.offsetLeft + \"px\";</font> <font style=\"color:#595959;\"> // modalBox.style.top = modalBox.offsetTop + \"px\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> document.addEventListener(\"mousemove\", move);</font> <font style=\"color:#595959;\"> // （3）、鼠标弹起，就让鼠标移动事件移除</font> <font style=\"color:#595959;\"> document.addEventListener(\"mouseup\", function () {</font> <font style=\"color:#595959;\"> document.removeEventListener(\"mousemove\", move);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> （3）、es6 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> let that;</font> <font style=\"color:#595959;\"> class Modal {</font> <font style=\"color:#595959;\"> constructor() {</font> <font style=\"color:#595959;\"> that = this;</font> <font style=\"color:#595959;\"> // 获取元素</font> <font style=\"color:#595959;\"> this.clickH1 = document.getElementById(\"clickH1\");</font> <font style=\"color:#595959;\"> this.btn = document.getElementById(\"btn\");</font> <font style=\"color:#595959;\"> this.modalBox = document.querySelector(\".modal-box\");</font> <font style=\"color:#595959;\"> this.bg = document.querySelector(\".bg\");</font> <font style=\"color:#595959;\"> this.title = document.querySelector(\".title\");</font> <font style=\"color:#595959;\"> // 调用监听函数</font> <font style=\"color:#595959;\"> this.event();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 监听函数</font> <font style=\"color:#595959;\"> event() {</font> <font style=\"color:#595959;\"> this.clickH1.addEventListener(\"click\", this.clickH1Fun);</font> <font style=\"color:#595959;\"> this.btn.addEventListener(\"click\", this.btnFun);</font> <font style=\"color:#595959;\"> this.title.addEventListener(\"mousedown\", this.titleFun);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 点击出现遮罩层</font> <font style=\"color:#595959;\"> clickH1Fun() {</font> <font style=\"color:#595959;\"> that.bg.style.display = \"block\";</font> <font style=\"color:#595959;\"> that.modalBox.style.display = \"block\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 点击关闭按钮</font> <font style=\"color:#595959;\"> btnFun() {</font> <font style=\"color:#595959;\"> that.bg.style.display = \"none\";</font> <font style=\"color:#595959;\"> that.modalBox.style.display = \"none\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //鼠标按下title</font> <font style=\"color:#595959;\"> titleFun(e) {</font> <font style=\"color:#595959;\"> // 获取鼠标在模态框中的位置方式一</font> <font style=\"color:#595959;\"> let x = e.offsetX;</font> <font style=\"color:#595959;\"> let y = e.offsetY;</font> <font style=\"color:#595959;\"> // 获取鼠标在模态框中的位置方式二</font> <font style=\"color:#595959;\"> // let x = e.pageX - that.modalBox.offsetLeft;</font> <font style=\"color:#595959;\"> // let y = e.pageY - that.modalBox.offsetTop;</font> <font style=\"color:#595959;\"> console.log(x, y);</font> <font style=\"color:#595959;\"> document.addEventListener(\"mousemove\", moveFun);</font> <font style=\"color:#595959;\"> function moveFun(e) {</font> <font style=\"color:#595959;\"> // console.log(111);</font> <font style=\"color:#595959;\"> let left = e.pageX - x;</font> <font style=\"color:#595959;\"> let right = e.pageY - y;</font> <font style=\"color:#595959;\"> that.modalBox.style.left = left + \"px\";</font> <font style=\"color:#595959;\"> that.modalBox.style.top = right + \"px\";</font> <font style=\"color:#595959;\"> that.modalBox.style.margin = 0; //left 值变化，由于过度约束，需要重新设置margin</font> <font style=\"color:#595959;\"> // that.modalBox.style.transform='translate(0%, 0%)'//left 值变化，由于过度约束，需要重新设置偏移量</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> document.addEventListener(\"mouseup\", upFun);</font> <font style=\"color:#595959;\"> function upFun() {</font> <font style=\"color:#595959;\"> document.removeEventListener(\"mousemove\", moveFun);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> new Modal();</font> <font style=\"color:#595959;\"></script></font> 2、放大镜 （1）html/css <font style=\"color:#000000;\">整个案例可以分为三个功能模块</font> <font style=\"color:#000000;\">鼠标经过小图片盒子，灰色的遮罩层和大图片盒子显示，离开隐藏2个盒子功能</font> <font style=\"color:#000000;\">灰色的遮挡层跟随鼠标移动功能</font> <font style=\"color:#000000;\">移动灰色遮挡层，大图片跟随移动功能</font> <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>放大镜案例</title></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> * {</font> <font style=\"color:#595959;\"> margin: 0;</font> <font style=\"color:#595959;\"> padding: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> / 小图 /</font> <font style=\"color:#595959;\"> .camera {</font> <font style=\"color:#595959;\"> width: 300px;</font> <font style=\"color:#595959;\"> height: 300px;</font> <font style=\"color:#595959;\"> position: relative;</font> <font style=\"color:#595959;\"> border: 1px solid black;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .cameraImg img {</font> <font style=\"color:#595959;\"> width: 300px;</font> <font style=\"color:#595959;\"> height: 300px;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> / 遮罩层 /</font> <font style=\"color:#595959;\"> .zoom {</font> <font style=\"color:#595959;\"> width: 100px;</font> <font style=\"color:#595959;\"> height: 100px;</font> <font style=\"color:#595959;\"> background-color: #ccc;</font> <font style=\"color:#595959;\"> opacity: 0.8;</font> <font style=\"color:#595959;\"> position: absolute;</font> <font style=\"color:#595959;\"> top: 0px;</font> <font style=\"color:#595959;\"> left: 0px;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> / 大图 /</font> <font style=\"color:#595959;\"> .bDiv {</font> <font style=\"color:#595959;\"> width: 500px;</font> <font style=\"color:#595959;\"> height: 500px;</font> <font style=\"color:#595959;\"> background-color: bisque;</font> <font style=\"color:#595959;\"> position: absolute;</font> <font style=\"color:#595959;\"> left: 350px;</font> <font style=\"color:#595959;\"> top: 0;</font> <font style=\"color:#595959;\"> overflow: hidden;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .bImg {</font> <font style=\"color:#595959;\"> position: absolute;</font> <font style=\"color:#595959;\"> top: 0;</font> <font style=\"color:#595959;\"> left: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <div class=\"camera\"></font> <font style=\"color:#595959;\"> <!-- 小图 --></font> <font style=\"color:#595959;\"> <div class=\"cameraImg\"></font> <font style=\"color:#595959;\"> <img src=\"./img0.jpg\" alt=\"\" /></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <!-- 放大镜 --></font> <font style=\"color:#595959;\"> <div class=\"zoom\"></div></font> <font style=\"color:#595959;\"> <!-- 大图 --></font> <font style=\"color:#595959;\"> <div class=\"bDiv\"></font> <font style=\"color:#595959;\"> <img src=\"./img1.jpg\" alt=\"\" class=\"bImg\" /></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <!-- 引入js --></font> <font style=\"color:#595959;\"> <script src=\"./放大镜.js\"></script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> （2）、es5 js <font style=\"color:#595959;\">window.onload = function () {</font> <font style=\"color:#595959;\"> var camera = document.querySelector(\".camera\");</font> <font style=\"color:#595959;\"> var zoom = document.querySelector(\".zoom\");</font> <font style=\"color:#595959;\"> var bDiv = document.querySelector(\".bDiv\");</font> <font style=\"color:#595959;\"> var bImg = document.querySelector(\".bImg\");</font> <font style=\"color:#595959;\"> // 1:给camera绑定鼠标移入移除事件，让鼠标移除时，放大镜跟展示页都消失</font> <font style=\"color:#595959;\"> camera.onmouseenter = function () {</font> <font style=\"color:#595959;\"> zoom.style.display = \"block\";</font> <font style=\"color:#595959;\"> bDiv.style.display = \"block\";</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> camera.onmouseleave = function () {</font> <font style=\"color:#595959;\"> // zoom.style.display = \"none\";</font> <font style=\"color:#595959;\"> // bDiv.style.display = \"none\";</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> // 2:设置放大镜zoom能跟着鼠标移动，并设置范围活动</font> <font style=\"color:#595959;\"> camera.onmousemove = function (event) {</font> <font style=\"color:#595959;\"> //2.1 获得鼠标的页面坐标x,y</font> <font style=\"color:#595959;\"> var x = event.pageX;</font> <font style=\"color:#595959;\"> var y = event.pageY;</font> <font style=\"color:#595959;\"> // console.log(x, y);</font> <font style=\"color:#595959;\"> //2.2 获取图相对于页面的左边，上边相对距离</font> <font style=\"color:#595959;\"> var offsetX = camera.offsetLeft;</font> <font style=\"color:#595959;\"> var offsetY = camera.offsetTop;</font> <font style=\"color:#595959;\"> // console.log(offsetX, offsetY);</font> <font style=\"color:#595959;\"> // 2.3 获取遮挡层的宽度跟高度</font> <font style=\"color:#595959;\"> var zoomW = zoom.offsetWidth;</font> <font style=\"color:#595959;\"> var zoomH = zoom.offsetHeight;</font> <font style=\"color:#595959;\"> // console.log(zoomW,zoomH);</font> <font style=\"color:#595959;\"> // 2.4 计算遮挡物的xy坐标</font> <font style=\"color:#595959;\"> var left = x - offsetX - zoomW / 2;</font> <font style=\"color:#595959;\"> var top = y - offsetY - zoomH / 2;</font> <font style=\"color:#595959;\"> // 2.5 设置判断left top的限制值</font> <font style=\"color:#595959;\"> / 遮盖物的最大移动距离，父元素camera的宽度减去遮盖物的宽度(300-100) /</font> <font style=\"color:#595959;\"> if (left >= 200) {</font> <font style=\"color:#595959;\"> left = 200;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> if (left <= 0) {</font> <font style=\"color:#595959;\"> left = 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> if (top >= 200) {</font> <font style=\"color:#595959;\"> top = 200;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> if (top <= 0) {</font> <font style=\"color:#595959;\"> top = 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //2.6 将宽高赋值给放大镜</font> <font style=\"color:#595959;\"> zoom.style.left = left + \"px\";</font> <font style=\"color:#595959;\"> zoom.style.top = top + \"px\";</font> <font style=\"color:#595959;\"> /* 3、根据比例移动大图 </font> <font style=\"color:#595959;\"> 遮罩层的移动距离 /遮罩层最大移动距离 = 大图片移动距离/大图片最大移动距离</font> <font style=\"color:#595959;\"> 根据上面的等式，可以演算出</font> <font style=\"color:#595959;\"> 大图片的移动距离=（遮罩层的移动距离 /遮罩层最大移动距离）大图片最大移动距离 /</font> <font style=\"color:#595959;\"> //3.1 计算大图在大盒子里移动的最大距离</font> <font style=\"color:#595959;\"> / 大图的宽度，减去bDiv框子的宽度/</font> <font style=\"color:#595959;\"> var bImgMw = bImg.offsetWidth - bDiv.offsetWidth;</font> <font style=\"color:#595959;\"> var bImgMh = bImg.offsetHeight - bDiv.offsetHeight;</font> <font style=\"color:#595959;\"> // console.log(bDiv.offsetWidth);</font> <font style=\"color:#595959;\"> // 3.2 根据比例移动大图</font> <font style=\"color:#595959;\"> var bX = (left / 200) * bImgMw;</font> <font style=\"color:#595959;\"> var bY = (top / 200) * bImgMh;</font> <font style=\"color:#595959;\"> // 3.3 将bX，bY赋值给大图的宽高</font> <font style=\"color:#595959;\"> bImg.style.left = -bX + \"px\";</font> <font style=\"color:#595959;\"> bImg.style.top = -bY + \"px\";</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\">};</font> （3）、es6.js <font style=\"color:#595959;\">window.onload = function () {</font> <font style=\"color:#595959;\"> var that;</font> <font style=\"color:#595959;\"> class Camera {</font> <font style=\"color:#595959;\"> constructor() {</font> <font style=\"color:#595959;\"> // 保存this</font> <font style=\"color:#595959;\"> that = this;</font> <font style=\"color:#595959;\"> // 获取整个盒子</font> <font style=\"color:#595959;\"> this.camera = document.querySelector(\".camera\");</font> <font style=\"color:#595959;\"> this.zoom = document.querySelector(\".zoom\");</font> <font style=\"color:#595959;\"> this.bDiv = document.querySelector(\".bDiv\");</font> <font style=\"color:#595959;\"> this.bImg = document.querySelector(\".bImg\");</font> <font style=\"color:#595959;\"> //初始化放大镜的位置left，top</font> <font style=\"color:#595959;\"> this.left = 0;</font> <font style=\"color:#595959;\"> this.top = 0;</font> <font style=\"color:#595959;\"> //初始化监听函数</font> <font style=\"color:#595959;\"> this.addevent();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 监听事件</font> <font style=\"color:#595959;\"> addevent() {</font> <font style=\"color:#595959;\"> //1.1、移入显示放大镜，移出隐藏放大镜</font> <font style=\"color:#595959;\"> this.camera.addEventListener(\"mouseenter\", that.showZoom);</font> <font style=\"color:#595959;\"> this.camera.addEventListener(\"mouseleave\", that.hiddZoom);</font> <font style=\"color:#595959;\"> //2、移入，放大镜随着鼠标移动</font> <font style=\"color:#595959;\"> this.camera.addEventListener(\"mousemove\", that.zoomMove);</font> <font style=\"color:#595959;\"> //2、放大镜移动，大图也随着移动</font> <font style=\"color:#595959;\"> this.camera.addEventListener(\"mousemove\", that.bDivMove);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //1.2 鼠标移入，显示放大镜及大图</font> <font style=\"color:#595959;\"> showZoom() {</font> <font style=\"color:#595959;\"> that.zoom.style.display = \"block\";</font> <font style=\"color:#595959;\"> that.bDiv.style.display = \"block\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> hiddZoom() {</font> <font style=\"color:#595959;\"> that.zoom.style.display = \"none\";</font> <font style=\"color:#595959;\"> that.bDiv.style.display = \"none\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 1.2 放大镜随着鼠标移动</font> <font style=\"color:#595959;\"> zoomMove(e) {</font> <font style=\"color:#595959;\"> // 如果直接赋值，会出现闪烁，由于只有鼠标动了，才会获取到offseX/Y的值，移动之前为0</font> <font style=\"color:#595959;\"> // let left = e.offsetX;</font> <font style=\"color:#595959;\"> // let top = e.offsetY;</font> <font style=\"color:#595959;\"> // （1）、鼠标在页面中的坐标</font> <font style=\"color:#595959;\"> var x = e.pageX;</font> <font style=\"color:#595959;\"> var y = e.pageY;</font> <font style=\"color:#595959;\"> //(2)、大盒子camera在在页面中的位置</font> <font style=\"color:#595959;\"> var offsetLeft = that.camera.offsetLeft;</font> <font style=\"color:#595959;\"> var offsetTop = that.camera.offsetTop;</font> <font style=\"color:#595959;\"> //（3）、计算zoom的大小</font> <font style=\"color:#595959;\"> var zoomWidth = that.zoom.offsetWidth;</font> <font style=\"color:#595959;\"> var zoomHeight = that.zoom.offsetHeight;</font> <font style=\"color:#595959;\"> //（4）、计算盒子中鼠标的位置</font> <font style=\"color:#595959;\"> that.left = x - offsetLeft - zoomWidth / 2;</font> <font style=\"color:#595959;\"> that.top = y - offsetTop - zoomHeight / 2;</font> <font style=\"color:#595959;\"> //(5)、限制放大镜的移动范围，camera-zoom</font> <font style=\"color:#595959;\"> if (that.left <= 0) {</font> <font style=\"color:#595959;\"> that.left = 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> if (that.left >= 200) {</font> <font style=\"color:#595959;\"> that.left = 200;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> if (that.top <= 0) {</font> <font style=\"color:#595959;\"> that.top = 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> if (that.top >= 200) {</font> <font style=\"color:#595959;\"> that.top = 200;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //(6)、将计算出的鼠标位置赋值给zoom</font> <font style=\"color:#595959;\"> that.zoom.style.left = that.left + \"px\";</font> <font style=\"color:#595959;\"> that.zoom.style.top = that.top + \"px\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 3、放大镜移动，大图也随着移动</font> <font style=\"color:#595959;\"> // zoom移动距离/zoom最大移动距离 = 大图移动距离/大图最大移动距离</font> <font style=\"color:#595959;\"> bDivMove() {</font> <font style=\"color:#595959;\"> // 计算大图的最大移动距离 大图-大图盒子大小</font> <font style=\"color:#595959;\"> var bimgMaxWidth = that.bImg.offsetWidth - that.bDiv.offsetWidth;</font> <font style=\"color:#595959;\"> var bimgMaxHeight = that.bImg.offsetHeight - that.bDiv.offsetHeight;</font> <font style=\"color:#595959;\"> // 计算大图移动距离（zoom移动距离/zoom最大移动距离）*大图最大移动距离</font> <font style=\"color:#595959;\"> var bimgLeft = (that.left / 200) * bimgMaxWidth;</font> <font style=\"color:#595959;\"> var bimgTop = (that.top / 200) * bimgMaxHeight;</font> <font style=\"color:#595959;\"> that.bImg.style.left = -bimgLeft + \"px\";</font> <font style=\"color:#595959;\"> that.bImg.style.top = -bimgTop + \"px\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> new Camera();</font> <font style=\"color:#595959;\">};</font> 3、京东侧边导航条 需求： <font style=\"color:#000000;\">原先侧边栏是绝对定位</font> <font style=\"color:#000000;\">当页面滚动到一定位置，侧边栏改为固定定位</font> <font style=\"color:#000000;\">页面继续滚动，会让返回顶部显示出来</font> 思路： <font style=\"color:#000000;\">需要用到页面滚动事件scroll，因为是页面滚动，所以事件源是document</font> <font style=\"color:#000000;\">滚动到某个位置，就是判断页面被卷去的上部值</font> <font style=\"color:#000000;\">页面被卷去的头部：可以通过window.pageYOffset获得，如果是被卷去的左侧window.pageXOffset</font> <font style=\"color:#000000;\">注意：元素被卷去的头部是element.scrollTop,如果是页面被卷去的头部则是window.pageYOffset</font> <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>侧边栏案例</title></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> * {</font> <font style=\"color:#595959;\"> padding: 0;</font> <font style=\"color:#595959;\"> margin: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> header,</font> <font style=\"color:#595959;\"> footer {</font> <font style=\"color:#595959;\"> width: 1000px;</font> <font style=\"color:#595959;\"> height: 200px;</font> <font style=\"color:#595959;\"> background-color: pink;</font> <font style=\"color:#595959;\"> margin: 0 auto;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> main {</font> <font style=\"color:#595959;\"> width: 1000px;</font> <font style=\"color:#595959;\"> height: 800px;</font> <font style=\"color:#595959;\"> background-color: #bfa;</font> <font style=\"color:#595959;\"> margin: 0 auto;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> nav {</font> <font style=\"color:#595959;\"> width: 60px;</font> <font style=\"color:#595959;\"> height: 200px;</font> <font style=\"color:#595959;\"> background-color: blue;</font> <font style=\"color:#595959;\"> position: absolute;</font> <font style=\"color:#595959;\"> right: 0;</font> <font style=\"color:#595959;\"> top: 250px;</font> <font style=\"color:#595959;\"> line-height: 30px;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> span {</font> <font style=\"color:#595959;\"> display: block;</font> <font style=\"color:#595959;\"> width: 60px;</font> <font style=\"color:#595959;\"> height: 60px;</font> <font style=\"color:#595959;\"> background-color: red;</font> <font style=\"color:#595959;\"> margin-top: 140px;</font> <font style=\"color:#595959;\"> text-align: center;</font> <font style=\"color:#595959;\"> display: none;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <header>头部</header></font> <font style=\"color:#595959;\"> <nav></font> <font style=\"color:#595959;\"> <span</font> <font style=\"color:#595959;\"> >返回 <br /></font> <font style=\"color:#595959;\"> 顶部</span</font> <font style=\"color:#595959;\"> ></font> <font style=\"color:#595959;\"> </nav></font> <font style=\"color:#595959;\"> <main>主体</main></font> <font style=\"color:#595959;\"> <footer>底部</footer></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 1、获取元素</font> <font style=\"color:#595959;\"> var span = document.querySelector(\"span\");</font> <font style=\"color:#595959;\"> var nav = document.querySelector(\"nav\");</font> <font style=\"color:#595959;\"> var main = document.querySelector(\"main\");</font> <font style=\"color:#595959;\"> // 主体以上被卷去的距离</font> <font style=\"color:#595959;\"> var mainTop = main.offsetTop;</font> <font style=\"color:#595959;\"> // 侧边导航以上被卷去的距离</font> <font style=\"color:#595959;\"> var navTop = nav.offsetTop;</font> <font style=\"color:#595959;\"> console.log(navTop);</font> <font style=\"color:#595959;\"> // 2、页面滚动事件 scroll</font> <font style=\"color:#595959;\"> document.addEventListener(\"scroll\", function () {</font> <font style=\"color:#595959;\"> // window.pageYOffset 获取页面被滚去的距离</font> <font style=\"color:#595959;\"> // 3、判断距离，变化定位</font> <font style=\"color:#595959;\"> if (window.pageYOffset >= mainTop) {</font> <font style=\"color:#595959;\"> // 3.1将定位改成固定定位</font> <font style=\"color:#595959;\"> nav.style.position = \"fixed\";</font> <font style=\"color:#595959;\"> // 3.2 改成固定定位后，会有跳动，需要重新设置定位的top值,否则还是原值</font> <font style=\"color:#595959;\"> nav.style.top = navTop - mainTop + \"px\";</font> <font style=\"color:#595959;\"> // 3.3 出现返回顶部字样</font> <font style=\"color:#595959;\"> span.style.display = \"block\";</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> nav.style.position = \"absolute\";</font> <font style=\"color:#595959;\"> nav.style.top = \"300px\";</font> <font style=\"color:#595959;\"> span.style.display = \"none\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> 4、轮播图 （1）、搭建轮播图的结构 <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>轮播图结构</title></font> <font style=\"color:#595959;\"> <!-- <script src=\"../js/tools.js\"></script> --></font> <font style=\"color:#595959;\"> <script src=\"../js/animation.js\"></script></font> <font style=\"color:#595959;\"> <script src=\"./01.轮播图.js\"></script></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> * {</font> <font style=\"color:#595959;\"> padding: 0;</font> <font style=\"color:#595959;\"> margin: 0;</font> <font style=\"color:#595959;\"> list-style: none;</font> <font style=\"color:#595959;\"> text-decoration: none;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> #outer {</font> <font style=\"color:#595959;\"> width: 590px;</font> <font style=\"color:#595959;\"> height: 470px;</font> <font style=\"color:#595959;\"> border: 10px solid red;</font> <font style=\"color:#595959;\"> margin: 50px auto;</font> <font style=\"color:#595959;\"> position: relative;</font> <font style=\"color:#595959;\"> overflow: hidden;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> #outer > ul {</font> <font style=\"color:#595959;\"> width: 500%;</font> <font style=\"color:#595959;\"> position: absolute;</font> <font style=\"color:#595959;\"> left: 0;</font> <font style=\"color:#595959;\"> top: 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> #outer > ul > li {</font> <font style=\"color:#595959;\"> float: left;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .dot {</font> <font style=\"color:#595959;\"> position: absolute;</font> <font style=\"color:#595959;\"> bottom: 30px;</font> <font style=\"color:#595959;\"> left: 50%;</font> <font style=\"color:#595959;\"> transform: translate(-50%, -50%);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .dot > a {</font> <font style=\"color:#595959;\"> display: inline-block;</font> <font style=\"color:#595959;\"> width: 15px;</font> <font style=\"color:#595959;\"> height: 15px;</font> <font style=\"color:#595959;\"> border-radius: 50%;</font> <font style=\"color:#595959;\"> background-color: #999;</font> <font style=\"color:#595959;\"> margin: 0 5px;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .dot > .active,</font> <font style=\"color:#595959;\"> .dot > a:hover {</font> <font style=\"color:#595959;\"> background-color: orange;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .prev,</font> <font style=\"color:#595959;\"> .next {</font> <font style=\"color:#595959;\"> width: 40px;</font> <font style=\"color:#595959;\"> height: 40px;</font> <font style=\"color:#595959;\"> background-color: rgba(0, 0, 0, 0.4);</font> <font style=\"color:#595959;\"> text-align: center;</font> <font style=\"color:#595959;\"> position: absolute;</font> <font style=\"color:#595959;\"> font-size: 30px;</font> <font style=\"color:#595959;\"> color: #999;</font> <font style=\"color:#595959;\"> / 隐藏左右按钮 /</font> <font style=\"color:#595959;\"> display: none;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .prev > a,</font> <font style=\"color:#595959;\"> .next > a {</font> <font style=\"color:#595959;\"> color: #fff;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .prev {</font> <font style=\"color:#595959;\"> left: 10px;</font> <font style=\"color:#595959;\"> top: 42%;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .next {</font> <font style=\"color:#595959;\"> right: 10px;</font> <font style=\"color:#595959;\"> top: 42%;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <div id=\"outer\"></font> <font style=\"color:#595959;\"> <!-- 图片部分 --></font> <font style=\"color:#595959;\"> <ul></font> <font style=\"color:#595959;\"> <li></font> <font style=\"color:#595959;\"> <a href=\"#\"><img src=\"./img/1.jpg\" alt=\"\" /></a></font> <font style=\"color:#595959;\"> </li></font> <font style=\"color:#595959;\"> <li></font> <font style=\"color:#595959;\"> <a href=\"#\"><img src=\"./img/2.jpg\" alt=\"\" /></a></font> <font style=\"color:#595959;\"> </li></font> <font style=\"color:#595959;\"> <li></font> <font style=\"color:#595959;\"> <a href=\"#\"><img src=\"./img/3.jpg\" alt=\"\" /></a></font> <font style=\"color:#595959;\"> </li></font> <font style=\"color:#595959;\"> <li></font> <font style=\"color:#595959;\"> <a href=\"#\"><img src=\"./img/4.jpg\" alt=\"\" /></a></font> <font style=\"color:#595959;\"> </li></font> <font style=\"color:#595959;\"> <!-- <li></font> <font style=\"color:#595959;\"> <a href=\"#\"><img src=\"./img/1.jpg\" alt=\"\" /></a></font> <font style=\"color:#595959;\"> </li> --></font> <font style=\"color:#595959;\"> </ul></font> <font style=\"color:#595959;\"> <!-- 导航点 class=\"active\"--></font> <font style=\"color:#595959;\"> <div class=\"dot\"></font> <font style=\"color:#595959;\"> <!-- <a href=\"#\" ></a></font> <font style=\"color:#595959;\"> <a href=\"#\"></a></font> <font style=\"color:#595959;\"> <a href=\"#\"></a></font> <font style=\"color:#595959;\"> <a href=\"#\"></a> --></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <!-- 左右导航 --></font> <font style=\"color:#595959;\"> <ol class=\"prevNext\"></font> <font style=\"color:#595959;\"> <li class=\"prev\"></font> <font style=\"color:#595959;\"> <a href=\"#\"> &lt;</a></font> <font style=\"color:#595959;\"> </li></font> <font style=\"color:#595959;\"> <li class=\"next\"></font> <font style=\"color:#595959;\"> <a href=\"#\">&gt;</a></font> <font style=\"color:#595959;\"> </li></font> <font style=\"color:#595959;\"> </ol></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> （2）、es5写法 功能需求： <font style=\"color:#000000;\">鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮</font> <font style=\"color:#000000;\">点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理</font> <font style=\"color:#000000;\">图片播放的同时，下面的小圆圈模块跟随一起变化</font> <font style=\"color:#000000;\">点击小圆圈，可以播放相应图片</font> <font style=\"color:#000000;\">鼠标不经过轮播图，轮播图也会自动播放图片</font> <font style=\"color:#000000;\">鼠标经过，轮播图模块，自动播放停止</font> <font style=\"color:#595959;\">window.addEventListener(\"load\", function () {</font> <font style=\"color:#595959;\"> var prev = this.document.querySelector(\".prev\");</font> <font style=\"color:#595959;\"> var next = this.document.querySelector(\".next\");</font> <font style=\"color:#595959;\"> var outer = this.document.querySelector(\"#outer\");</font> <font style=\"color:#595959;\"> //需求1 鼠标移入，左右按钮出现隐藏</font> <font style=\"color:#595959;\"> outer.addEventListener(\"mouseenter\", function () {</font> <font style=\"color:#595959;\"> prev.style.display = \"block\";</font> <font style=\"color:#595959;\"> next.style.display = \"block\";</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> outer.addEventListener(\"mouseleave\", function () {</font> <font style=\"color:#595959;\"> prev.style.display = \"none\";</font> <font style=\"color:#595959;\"> next.style.display = \"none\";</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> //需求2 动态生成pot，小圆圈</font> <font style=\"color:#595959;\"> // 2.1、获取元素</font> <font style=\"color:#595959;\"> var ulL = outer.querySelector(\"ul\");</font> <font style=\"color:#595959;\"> var dot = outer.querySelector(\".dot\");</font> <font style=\"color:#595959;\"> for (var i = 0; i < ulL.children.length; i++) {</font> <font style=\"color:#595959;\"> // 2.2、动态的创建a标签</font> <font style=\"color:#595959;\"> var a = this.document.createElement(\"a\");</font> <font style=\"color:#595959;\"> // 给a添加索引，方便下面计算点击圆圈，移动图片</font> <font style=\"color:#595959;\"> a.setAttribute(\"index\", i);</font> <font style=\"color:#595959;\"> // 2.3 插入节点</font> <font style=\"color:#595959;\"> dot.appendChild(a);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 2.4 给第一个小点，设置选中样式</font> <font style=\"color:#595959;\"> dot.children[0].className = \"active\";</font> <font style=\"color:#595959;\"> //需求3 给点击的小圆圈加上类名 active 排他思想</font> <font style=\"color:#595959;\"> var as = dot.querySelectorAll(\"a\");</font> <font style=\"color:#595959;\"> for (var i = 0; i < as.length; i++) {</font> <font style=\"color:#595959;\"> as[i].addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> for (var j = 0; j < as.length; j++) {</font> <font style=\"color:#595959;\"> dot.children[j].className = \"\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> this.className = \"active\";</font> <font style=\"color:#595959;\"> //需求4 点击小圆圈，移动图片 move(obj, attr, target, speed, callback)</font> <font style=\"color:#595959;\"> //4.1 获取点击a的索引，这个索引是创建a时添加的，用来表示每个a</font> <font style=\"color:#595959;\"> var index = this.getAttribute(\"index\");</font> <font style=\"color:#595959;\"> // 4.2 ulL的移动距离，小圆圈的索引号*图片的宽度</font> <font style=\"color:#595959;\"> animation(ulL, -index * 590);</font> <font style=\"color:#595959;\"> // move(ulL, \"left\", -index * 590, 10);</font> <font style=\"color:#595959;\"> // 获取到index后，需要同步赋值给下面的num跟current</font> <font style=\"color:#595959;\"> // 以便可以同步小圆点，跟点击下一张的变化</font> <font style=\"color:#595959;\"> num = index;</font> <font style=\"color:#595959;\"> current = index;</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 克隆第一张图片,不在结构里加</font> <font style=\"color:#595959;\"> // 循环生成小圆点的时候，还没有克隆这个图片。所有不会自动生成的小圆圈</font> <font style=\"color:#595959;\"> var firstImg = ulL.children[0].cloneNode(true);</font> <font style=\"color:#595959;\"> ulL.appendChild(firstImg);</font> <font style=\"color:#595959;\"> //需求5 点击左右按钮，实现上下一张切换</font> <font style=\"color:#595959;\"> var num = 0;</font> <font style=\"color:#595959;\"> var current = 0; //用来标记小圆圈</font> <font style=\"color:#595959;\"> next.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> //无缝滚动 如果走到了最后一张图片，此时我们的ul要快速复原left改为0</font> <font style=\"color:#595959;\"> if (num >= ulL.children.length - 1) {</font> <font style=\"color:#595959;\"> ulL.style.left = 0;</font> <font style=\"color:#595959;\"> num = 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> num++;</font> <font style=\"color:#595959;\"> animation(ulL, -num * 590);</font> <font style=\"color:#595959;\"> // move(ulL, \"left\", -num * 590, 20);</font> <font style=\"color:#595959;\"> // 点击右侧按钮，小圆圈跟着跳动</font> <font style=\"color:#595959;\"> current++;</font> <font style=\"color:#595959;\"> // 如果curent的数值跟小圆圈的数量一样，走到了克隆的那张图片，要还原为0</font> <font style=\"color:#595959;\"> if (current == dot.children.length) {</font> <font style=\"color:#595959;\"> current = 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> for (var i = 0; i < dot.children.length; i++) {</font> <font style=\"color:#595959;\"> dot.children[i].className = \"\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> dot.children[current].className = \"active\";</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> //需求6 左侧按钮的功能</font> <font style=\"color:#595959;\"> prev.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> if (num == 0) {</font> <font style=\"color:#595959;\"> num = ulL.children.length - 1;</font> <font style=\"color:#595959;\"> ulL.style.left = -num * 590 + \"px\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> num--;</font> <font style=\"color:#595959;\"> animation(ulL, -num * 590);</font> <font style=\"color:#595959;\"> // move(ulL, \"left\", -num * 590, 20);</font> <font style=\"color:#595959;\"> // 点击右侧按钮，小圆圈跟着跳动</font> <font style=\"color:#595959;\"> current--;</font> <font style=\"color:#595959;\"> // 如果curent的数值跟小圆圈的数量一样，要还原为0</font> <font style=\"color:#595959;\"> if (current < 0) {</font> <font style=\"color:#595959;\"> current = dot.children.length - 1;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> for (var i = 0; i < dot.children.length; i++) {</font> <font style=\"color:#595959;\"> dot.children[i].className = \"\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> dot.children[current].className = \"active\";</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> //需求7 自动播放功能</font> <font style=\"color:#595959;\"> var timer = setInterval(function () {</font> <font style=\"color:#595959;\"> // 手动调用点击事件</font> <font style=\"color:#595959;\"> next.click();</font> <font style=\"color:#595959;\"> }, 2000);</font> <font style=\"color:#595959;\"> //需求8 鼠标移入，自动播放停止</font> <font style=\"color:#595959;\"> outer.addEventListener(\"mouseenter\", function () {</font> <font style=\"color:#595959;\"> clearInterval(timer);</font> <font style=\"color:#595959;\"> timer = null;</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> //需求9 鼠标移出，重新开启定时器</font> <font style=\"color:#595959;\"> outer.addEventListener(\"mouseleave\", function () {</font> <font style=\"color:#595959;\"> timer = setInterval(function () {</font> <font style=\"color:#595959;\"> // 手动调用点击事件</font> <font style=\"color:#595959;\"> next.click();</font> <font style=\"color:#595959;\"> }, 2000);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\">});</font> （3）、es6写法 <font style=\"color:#595959;\"> window.onload = function () {</font> <font style=\"color:#595959;\"> var that;</font> <font style=\"color:#595959;\"> class Swiper {</font> <font style=\"color:#595959;\"> constructor() {</font> <font style=\"color:#595959;\"> // 保存this</font> <font style=\"color:#595959;\"> that = this;</font> <font style=\"color:#595959;\"> // 1.1 获取对应元素</font> <font style=\"color:#595959;\"> this.prev = document.querySelector(\".prev\");</font> <font style=\"color:#595959;\"> this.next = document.querySelector(\".next\");</font> <font style=\"color:#595959;\"> this.outer = document.querySelector(\"#outer\");</font> <font style=\"color:#595959;\"> //2.1 获取导航点父元素</font> <font style=\"color:#595959;\"> this.dot = document.querySelector(\".dot\");</font> <font style=\"color:#595959;\"> this.imgList = document.querySelector(\".imgList\");</font> <font style=\"color:#595959;\"> // 2.4 调用创建小圆点函数</font> <font style=\"color:#595959;\"> this.creatDot();</font> <font style=\"color:#595959;\"> // 3.1 获取图片导航小圆点</font> <font style=\"color:#595959;\"> this.dots = document.querySelectorAll(\".dot a\");</font> <font style=\"color:#595959;\"> // 4.1 用于标识当前的图片位置</font> <font style=\"color:#595959;\"> this.num = 0;</font> <font style=\"color:#595959;\"> this.current = 0; //用于标识当前小圆点的位置</font> <font style=\"color:#595959;\"> // 5、克隆轮播图第一张照片</font> <font style=\"color:#595959;\"> this.cloneFirstImg();</font> <font style=\"color:#595959;\"> // 调用监听函数</font> <font style=\"color:#595959;\"> this.addevent();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 所有监听函数</font> <font style=\"color:#595959;\"> addevent() {</font> <font style=\"color:#595959;\"> console.log(this);</font> <font style=\"color:#595959;\"> // 1.2 监听鼠标是否移入</font> <font style=\"color:#595959;\"> this.outer.addEventListener(\"mouseenter\", that.pervNextShow);</font> <font style=\"color:#595959;\"> this.outer.addEventListener(\"mouseleave\", that.pervNextNode);</font> <font style=\"color:#595959;\"> // 3.3 监听是否点击了小圆点</font> <font style=\"color:#595959;\"> for (var i = 0; i < this.dots.length; i++) {</font> <font style=\"color:#595959;\"> // 保存i值，方便找对应的图片</font> <font style=\"color:#595959;\"> this.dots[i].index = i;</font> <font style=\"color:#595959;\"> // 默认第一个按钮为选中状态</font> <font style=\"color:#595959;\"> this.dots[0].className = \"active\";</font> <font style=\"color:#595959;\"> // 点击切换背景色</font> <font style=\"color:#595959;\"> this.dots[i].addEventListener(\"click\", that.updatBackgroundColor);</font> <font style=\"color:#595959;\"> // 点击切换图片</font> <font style=\"color:#595959;\"> this.dots[i].addEventListener(\"click\", that.updatImg);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 4、点击next</font> <font style=\"color:#595959;\"> this.next.addEventListener(\"click\", that.nextFun);</font> <font style=\"color:#595959;\"> // 5、点击prev</font> <font style=\"color:#595959;\"> this.prev.addEventListener(\"click\", that.prevFun);</font> <font style=\"color:#595959;\"> // 8、调用自动轮播函数</font> <font style=\"color:#595959;\"> this.timer = null; //定义标识定时器</font> <font style=\"color:#595959;\"> this.autoPlay();</font> <font style=\"color:#595959;\"> // 9、移入outer，暂停自动轮播</font> <font style=\"color:#595959;\"> this.outer.addEventListener(\"mouseenter\", that.stopAutoPlay);</font> <font style=\"color:#595959;\"> // 10、移出outer，继续自动轮播</font> <font style=\"color:#595959;\"> this.outer.addEventListener(\"mouseleave\", that.startAutoPlay);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 所有功能函数</font> <font style=\"color:#595959;\"> // 注意函数中的this指向</font> <font style=\"color:#595959;\"> // 1.3 上下一张出现</font> <font style=\"color:#595959;\"> pervNextShow() {</font> <font style=\"color:#595959;\"> that.prev.style.display = \"block\";</font> <font style=\"color:#595959;\"> that.next.style.display = \"block\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> pervNextNode() {</font> <font style=\"color:#595959;\"> that.prev.style.display = \"none\";</font> <font style=\"color:#595959;\"> that.next.style.display = \"none\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 2、根据图片创建导航点</font> <font style=\"color:#595959;\"> creatDot() {</font> <font style=\"color:#595959;\"> var imgNum = this.imgList.children.length;</font> <font style=\"color:#595959;\"> for (var i = 0; i < imgNum; i++) {</font> <font style=\"color:#595959;\"> var a = <a href=\"#\" ></a>;</font> <font style=\"color:#595959;\"> this.dot.insertAdjacentHTML(\"afterBegin\", a);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 3.4 点击小圆点，切换颜色</font> <font style=\"color:#595959;\"> updatBackgroundColor(e) {</font> <font style=\"color:#595959;\"> // （1）、先解决默认行为，超链接跳转的问题</font> <font style=\"color:#595959;\"> e.preventDefault();</font> <font style=\"color:#595959;\"> // (2)、点击颜色切换</font> <font style=\"color:#595959;\"> for (var i = 0; i < that.dots.length; i++) {</font> <font style=\"color:#595959;\"> that.dots[i].className = \"\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> this.className = \"active\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 3.5 点击小圆点，切换图片</font> <font style=\"color:#595959;\"> updatImg() {</font> <font style=\"color:#595959;\"> // (3)、根据图片导航点的索引移动图片</font> <font style=\"color:#595959;\"> animation(that.imgList, -590 * this.index);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 4、点击下一张，切换图片</font> <font style=\"color:#595959;\"> nextFun() {</font> <font style=\"color:#595959;\"> // 根据num的值，判断num是否++</font> <font style=\"color:#595959;\"> var len = that.imgList.children.length;</font> <font style=\"color:#595959;\"> if (that.num >= len - 1) {</font> <font style=\"color:#595959;\"> that.imgList.style.left = 0;</font> <font style=\"color:#595959;\"> that.num = 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> that.num++;</font> <font style=\"color:#595959;\"> animation(that.imgList, -that.num * 590);</font> <font style=\"color:#595959;\"> // 点击下一张照片后，更换小圆点背景色</font> <font style=\"color:#595959;\"> that.current++;</font> <font style=\"color:#595959;\"> if (that.current == that.dots.length) that.current = 0;</font> <font style=\"color:#595959;\"> //调用更换小圆点颜色函数</font> <font style=\"color:#595959;\"> that.changeBackgroundColor();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 5、为解决轮播图最后一张快速问题，多赋值一张照片</font> <font style=\"color:#595959;\"> cloneFirstImg() {</font> <font style=\"color:#595959;\"> var firstImg = that.imgList.children[0].cloneNode(true);</font> <font style=\"color:#595959;\"> that.imgList.appendChild(firstImg);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 6、更换小圆点颜色</font> <font style=\"color:#595959;\"> changeBackgroundColor() {</font> <font style=\"color:#595959;\"> for (var i = 0; i < that.dots.length; i++) {</font> <font style=\"color:#595959;\"> that.dots[i].className = \"\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> that.dots[that.current].className = \"active\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 7、点击prev，上一张照片</font> <font style=\"color:#595959;\"> prevFun() {</font> <font style=\"color:#595959;\"> // 根据num的值，判断显示图片</font> <font style=\"color:#595959;\"> if (that.num == 0) {</font> <font style=\"color:#595959;\"> that.num = that.imgList.children.length - 1;</font> <font style=\"color:#595959;\"> that.imgList.style.left = -that.num * 590 + \"px\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> that.num--;</font> <font style=\"color:#595959;\"> animation(that.imgList, -that.num * 590);</font> <font style=\"color:#595959;\"> // 同步图片小圆点的背景色</font> <font style=\"color:#595959;\"> if (that.current <= 0) {</font> <font style=\"color:#595959;\"> that.current = that.dots.length;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> that.current--;</font> <font style=\"color:#595959;\"> //调用更换小圆点颜色函数</font> <font style=\"color:#595959;\"> that.changeBackgroundColor();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 8、自动轮播，每隔2s，调动一次next函数</font> <font style=\"color:#595959;\"> autoPlay() {</font> <font style=\"color:#595959;\"> that.timer = setInterval(function () {</font> <font style=\"color:#595959;\"> that.nextFun();</font> <font style=\"color:#595959;\"> }, 2000);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 9、鼠标移入轮播图，停止自动轮播</font> <font style=\"color:#595959;\"> stopAutoPlay() {</font> <font style=\"color:#595959;\"> // console.log(that.timer);</font> <font style=\"color:#595959;\"> clearInterval(that.timer);</font> <font style=\"color:#595959;\"> that.timer = null;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 10、鼠标移出轮播图，开始自动轮播</font> <font style=\"color:#595959;\"> startAutoPlay() {</font> <font style=\"color:#595959;\"> that.autoPlay();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> new Swiper();</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">/* </font> <font style=\"color:#595959;\">功能需求：</font> <font style=\"color:#595959;\">- 鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮</font> <font style=\"color:#595959;\">- 点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理</font> <font style=\"color:#595959;\">- 图片播放的同时，下面的小圆圈模块跟随一起变化</font> <font style=\"color:#595959;\">- 点击小圆圈，可以播放相应图片</font> <font style=\"color:#595959;\">- 鼠标不经过轮播图，轮播图也会自动播放图片</font> <font style=\"color:#595959;\">- 鼠标经过，轮播图模块，自动播放停止</font> <font style=\"color:#595959;\">-无缝切换</font> <font style=\"color:#595959;\">*/</font> <font style=\"color:#595959;\">window.addEventListener('load',function(){</font> <font style=\"color:#595959;\"> let that;</font> <font style=\"color:#595959;\"> class swiper{</font> <font style=\"color:#595959;\"> constructor(){</font> <font style=\"color:#595959;\"> that=this;</font> <font style=\"color:#595959;\"> this.imgList=document.querySelector('.imgList');</font> <font style=\"color:#595959;\"> this.dotList=document.querySelector('.dot');</font> <font style=\"color:#595959;\"> //获取图片的大小</font> <font style=\"color:#595959;\"> this.imgWidth=this.imgList.children[0].offsetWidth;</font> <font style=\"color:#595959;\"> //获取左右导航按钮</font> <font style=\"color:#595959;\"> this.leftBtn=document.querySelector('.prev');</font> <font style=\"color:#595959;\"> this.rightBtn=document.querySelector('.next');</font> <font style=\"color:#595959;\"> this.outer=document.querySelector('#outer');</font> <font style=\"color:#595959;\"> this.num=0;//图片索引</font> <font style=\"color:#595959;\"> this.currentdot=0;//当前圆点索引</font> <font style=\"color:#595959;\"> this.timer=null;</font> <font style=\"color:#595959;\"> this.autoPlay();</font> <font style=\"color:#595959;\"> this.crrateDot();</font> <font style=\"color:#595959;\"> this.cloneImg();</font> <font style=\"color:#595959;\"> this.addevent()</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> addevent(){</font> <font style=\"color:#595959;\"> this.dotList.addEventListener('click',this.clickDot)</font> <font style=\"color:#595959;\"> this.dotList.addEventListener('click',this.clickDotchangeImg)</font> <font style=\"color:#595959;\"> // 鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮</font> <font style=\"color:#595959;\"> this.outer.addEventListener('mouseenter',this.showBtn)</font> <font style=\"color:#595959;\"> this.outer.addEventListener('mouseleave',this.hideBtn)</font> <font style=\"color:#595959;\"> //鼠标经过，轮播图模块，自动播放停止</font> <font style=\"color:#595959;\"> this.outer.addEventListener('mouseenter',this.outplay)</font> <font style=\"color:#595959;\"> this.outer.addEventListener('mouseleave',this.inplay)</font> <font style=\"color:#595959;\"> //点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理</font> <font style=\"color:#595959;\"> this.rightBtn.addEventListener('click',this.nextImg)</font> <font style=\"color:#595959;\"> this.leftBtn.addEventListener('click',this.prevImg)</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //各种事件</font> <font style=\"color:#595959;\"> //创建小圆点</font> <font style=\"color:#595959;\"> crrateDot(){</font> <font style=\"color:#595959;\"> let imgNum = this.imgList.children.length;</font> <font style=\"color:#595959;\"> console.log(imgNum);</font> <font style=\"color:#595959;\"> for(let i=0;i<imgNum;i++){</font> <font style=\"color:#595959;\"> let str=\"\";</font> <font style=\"color:#595959;\"> str=</font> <font style=\"color:#595959;\"> <a href=\"#\" index=\"${i}\"></a></font> <font style=\"color:#595959;\"> `</font> <font style=\"color:#595959;\"> this.dotList.innerHTML+=str;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> // 默认给第一个圆点添加active类</font> <font style=\"color:#595959;\"> this.dotList.children[0].className=\"active\";</font> <font style=\"color:#595959;\"> console.log(this.dotList);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //点击小圆点颜色高亮并切换图片</font> <font style=\"color:#595959;\"> clickDot(e){</font> <font style=\"color:#595959;\"> // 阻止默认行为</font> <font style=\"color:#595959;\"> e.preventDefault();</font> <font style=\"color:#595959;\"> // 颜色高亮</font> <font style=\"color:#595959;\"> console.log(e.target.nodeName)</font> <font style=\"color:#595959;\"> if(e.target.nodeName=='A'){</font> <font style=\"color:#595959;\"> let dots=that.dotList.children;</font> <font style=\"color:#595959;\"> for(let i=0;i<dots.length;i++){</font> <font style=\"color:#595959;\"> dots[i].className=\"\";</font> <font style=\"color:#595959;\"> } </font> <font style=\"color:#595959;\"> e.target.className=\"active\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //切换图片</font> <font style=\"color:#595959;\"> clickDotchangeImg(e){</font> <font style=\"color:#595959;\"> let index=e.target.getAttribute(\"index\");</font> <font style=\"color:#595959;\"> console.log(index);</font> <font style=\"color:#595959;\"> animation(that.imgList,-index*that.imgWidth)</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮</font> <font style=\"color:#595959;\"> //出现左右按钮</font> <font style=\"color:#595959;\"> showBtn(){</font> <font style=\"color:#595959;\"> that.leftBtn.style.display=\"block\";</font> <font style=\"color:#595959;\"> that.rightBtn.style.display=\"block\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // x隐藏左右按钮</font> <font style=\"color:#595959;\"> hideBtn(){</font> <font style=\"color:#595959;\"> that.leftBtn.style.display=\"none\";</font> <font style=\"color:#595959;\"> that.rightBtn.style.display=\"none\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //点击右侧按钮一次，图片往左播放一张</font> <font style=\"color:#595959;\"> nextImg(){</font> <font style=\"color:#595959;\"> if(that.num<that.imgList.children.length-1){</font> <font style=\"color:#595959;\"> that.num++;</font> <font style=\"color:#595959;\"> }else{</font> <font style=\"color:#595959;\"> that.imgList.style.left=0;</font> <font style=\"color:#595959;\"> that.num=1;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> animation(that.imgList,-that.num*that.imgWidth);</font> <font style=\"color:#595959;\"> let dotsLength=that.dotList.children.length;</font> <font style=\"color:#595959;\"> if(that.currentdot<dotsLength-1){</font> <font style=\"color:#595959;\"> that.currentdot++;</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> }else{</font> <font style=\"color:#595959;\"> that.currentdot=0;</font> <font style=\"color:#595959;\"> } </font> <font style=\"color:#595959;\"> that.changeColor() </font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //点击左侧按钮一次，图片往右播放一张</font> <font style=\"color:#595959;\"> prevImg(){</font> <font style=\"color:#595959;\"> if(that.num>0){</font> <font style=\"color:#595959;\"> that.num--;</font> <font style=\"color:#595959;\"> }else{</font> <font style=\"color:#595959;\"> that.imgList.style.left=-(that.imgList.children.length-2)*that.imgWidth+'px';</font> <font style=\"color:#595959;\"> that.num=that.imgList.children.length-2;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> animation(that.imgList,-that.num*that.imgWidth)</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> let dotsLength=that.dotList.children.length;</font> <font style=\"color:#595959;\"> if(that.currentdot>0){</font> <font style=\"color:#595959;\"> that.currentdot--;</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> }else{</font> <font style=\"color:#595959;\"> that.currentdot=that.dotList.children.length-1;;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> that.changeColor()</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //按钮点击小圆点颜色高亮，</font> <font style=\"color:#595959;\"> changeColor(){</font> <font style=\"color:#595959;\"> let dots=that.dotList.children;</font> <font style=\"color:#595959;\"> for(let i=0;i<dots.length;i++){</font> <font style=\"color:#595959;\"> dots[i].className=\"\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> dots[that.currentdot].className=\"active\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //轮播图自动播放</font> <font style=\"color:#595959;\"> autoPlay(){</font> <font style=\"color:#595959;\"> that.timer=setInterval(function(){</font> <font style=\"color:#595959;\"> that.nextImg();</font> <font style=\"color:#595959;\"> },1000)</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //鼠标经过，轮播图模块，自动播放停止</font> <font style=\"color:#595959;\"> outplay(){</font> <font style=\"color:#595959;\"> clearInterval(that.timer);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //input输入框内容变化，轮播图自动播放</font> <font style=\"color:#595959;\"> inplay(){</font> <font style=\"color:#595959;\"> that.autoPlay();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //实现无缝滚动效果</font> <font style=\"color:#595959;\"> cloneImg(){</font> <font style=\"color:#595959;\"> let fistimg=that.imgList.children[0].cloneNode(true);</font> <font style=\"color:#595959;\"> console.log(fistimg);</font> <font style=\"color:#595959;\"> that.imgList.appendChild(fistimg);</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> new swiper()</font> <font style=\"color:#595959;\">})</font> （4）、节流阀优化 防止轮播图按钮连续点击造成播放过快 节流阀目的，当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发 核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数 开始设置一个变量 var flag =true if（flag）{ flag = false,do something} 关闭水龙头 利用回调函数动画执行完毕， falg=true 打开水龙头 <font style=\"color:#595959;\">// 10、节流阀优化点击过快问题</font> <font style=\"color:#595959;\">var flag = true;</font> <font style=\"color:#595959;\">next.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> if (flag) {</font> <font style=\"color:#595959;\"> flag = false; // 关闭水龙头</font> <font style=\"color:#595959;\"> //无缝滚动 如果走到了最后一张图片，此时我们的ul要快速复原left改为0</font> <font style=\"color:#595959;\"> if (num >= ulL.children.length - 1) {</font> <font style=\"color:#595959;\"> ulL.style.left = 0;</font> <font style=\"color:#595959;\"> num = 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> num++;</font> <font style=\"color:#595959;\"> animation(ulL, -num * 590, function () {</font> <font style=\"color:#595959;\"> flag = true;</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> // move(ulL, \"left\", -num * 590, 20);</font> <font style=\"color:#595959;\"> // 点击右侧按钮，小圆圈跟着跳动</font> <font style=\"color:#595959;\"> current++;</font> <font style=\"color:#595959;\"> // 如果curent的数值跟小圆圈的数量一样，走到了克隆的那张图片，要还原为0</font> <font style=\"color:#595959;\"> if (current == dot.children.length) {</font> <font style=\"color:#595959;\"> current = 0;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> for (var i = 0; i < dot.children.length; i++) {</font> <font style=\"color:#595959;\"> dot.children[i].className = \"\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> dot.children[current].className = \"active\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">});</font> <font style=\"color:#595959;\">//需求6 左侧按钮的功能</font> <font style=\"color:#595959;\">prev.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> if (flag) {</font> <font style=\"color:#595959;\"> flag = false;</font> <font style=\"color:#595959;\"> if (num == 0) {</font> <font style=\"color:#595959;\"> num = ulL.children.length - 1;</font> <font style=\"color:#595959;\"> ulL.style.left = -num * 590 + \"px\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> num--;</font> <font style=\"color:#595959;\"> animation(ulL, -num * 590, function () {</font> <font style=\"color:#595959;\"> flag = true;</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> // move(ulL, \"left\", -num * 590, 20);</font> <font style=\"color:#595959;\"> // 点击右侧按钮，小圆圈跟着跳动</font> <font style=\"color:#595959;\"> current--;</font> <font style=\"color:#595959;\"> // 如果curent的数值跟小圆圈的数量一样，要还原为0</font> <font style=\"color:#595959;\"> if (current < 0) {</font> <font style=\"color:#595959;\"> current = dot.children.length - 1;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> for (var i = 0; i < dot.children.length; i++) {</font> <font style=\"color:#595959;\"> dot.children[i].className = \"\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> dot.children[current].className = \"active\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">});</font> Bom操作（window、定时器、js执行机制、location对象、navigator、history） 1、BOM概述 （1）、BOM简介 BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是window。 <font style=\"color:#F33232;\">BOM由一系列的对象构成</font>，并且每个对象都提供了很多方法与属性 BOM缺乏标准，JS语法的标准化组织是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分 （2）、DOM与BOM的区别 | 类别 | DOM | BOM | | --- | --- | --- | | 1 | <font style=\"color:rgb(243, 50, 50);\">文档</font>对象模型 | <font style=\"color:rgb(243, 50, 50);\">浏览器</font>对象模型 | | 2 | DOM是把<font style=\"color:rgb(243, 50, 50);\">文档</font>当做一个<font style=\"color:rgb(243, 50, 50);\">对象</font>来看待 | 把<font style=\"color:rgb(243, 50, 50);\">浏览器</font>当做一个<font style=\"color:rgb(243, 50, 50);\">对象</font>来看待 | | 3 | 顶级对象是<font style=\"color:rgb(243, 50, 50);\">document</font> | 顶级对象是<font style=\"color:rgb(243, 50, 50);\">window</font> | | 4 | 主要学习<font style=\"color:rgb(243, 50, 50);\">操作页面元素</font> | 学习<font style=\"color:rgb(243, 50, 50);\">浏览器窗口交互</font>的一些对象 | | 5 | W3C标准规范 | 各浏览器厂商在各自浏览器上定义的标准，兼容性较差 | （3）、BOM的构成(对象) BOM比DOM更大，它包含DOM | window | | | | | | --- | --- | --- | --- | --- | | document | location | navigation | screen | history | Window 代表的是整个浏览器的窗口，同时windonw也是网页的全局对象 window 对象是浏览器的顶级对象，它具有双重角色 它是js访问浏览器窗口的一个接口 它是一个全局对象。定义在全局作用域中的变量，函数都会变成window对象的属性和方法，在调用的时候，可以省略window，前面学习的对话框都属于window对象方法，如alert（），prompt（）等 <font style=\"color:#F33232;\">注意：window下的一个特殊属性window.name，所以定义变量时，尽量不用name这个变量名</font> <font style=\"color:#F33232;\">Navigator</font>（浏览器的意思） -代表的<font style=\"color:#F33232;\">当前浏览器</font>的<font style=\"color:#F33232;\">信息</font>，通过该对象可以来<font style=\"color:#F33232;\">识别</font>不同的<font style=\"color:#F33232;\">浏览器</font> <font style=\"color:#F33232;\">Location</font> -代表浏览器的<font style=\"color:#F33232;\">地址栏</font>信息，通过location可以<font style=\"color:#F33232;\">获取</font>地址栏信息，或者<font style=\"color:#F33232;\">跳转</font>页面 <font style=\"color:#F33232;\">History</font> -代表浏览器的<font style=\"color:#F33232;\">历史记录</font>，可以通过该对象操作浏览器的历史记录 由于隐私的原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或者向后翻页 而且该操作只在当次访问有效 <font style=\"color:#F33232;\">Screen</font> -代表用户的<font style=\"color:#F33232;\">屏幕</font>的<font style=\"color:#F33232;\">信息</font>，通过该对象可以<font style=\"color:#F33232;\">获取</font>到用户的显示器的相关信息 注意：这些BOM对象在浏览器中都是作为window对象的属性来保存的，可以通过window对象来使用，也可以直接使用 2、window对象的常见事件 （1）、onload窗口加载事件 window.onload=function(){} 传统注册事件方式（只能写一次，如果有多个，会以最后一个为准） 或 window.addEventListener(\"load\",function(){} ) 当文档内容完全加载完成会触发该事件（包括图像，脚本文件、css文件等），就调用的处理函数 (2)、DOMContentLoaded窗口加载事件 window.addEventListener(\"DOMContentLoaded\",function(){} ) 当DOM加载完成，不包括样式表、图片、flash等等。ie9以上支持 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //1、 onload写法</font> <font style=\"color:#595959;\"> // window.onload = function () {</font> <font style=\"color:#595959;\"> // var box = document.querySelector(\".box\");</font> <font style=\"color:#595959;\"> // box.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> // this.style.backgroundColor = \"pink\";</font> <font style=\"color:#595959;\"> // });</font> <font style=\"color:#595959;\"> // };</font> <font style=\"color:#595959;\"> //2、addEventListener 写法</font> <font style=\"color:#595959;\"> // window.addEventListener(\"load\", function () {</font> <font style=\"color:#595959;\"> // var box = document.querySelector(\".box\");</font> <font style=\"color:#595959;\"> // box.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> // this.style.backgroundColor = \"pink\";</font> <font style=\"color:#595959;\"> // });</font> <font style=\"color:#595959;\"> // });</font> <font style=\"color:#595959;\"> //3、DOMContentLoaded写法</font> <font style=\"color:#595959;\"> document.addEventListener(\"DOMContentLoaded\", function () {</font> <font style=\"color:#595959;\"> var box = document.querySelector(\".box\");</font> <font style=\"color:#595959;\"> box.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> this.style.backgroundColor = \"pink\";</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> <!-- 需求：点击box，box背景色变化，js交互可以放在任意位置 --></font> <font style=\"color:#595959;\"> <div class=\"box\">box</div></font> <font style=\"color:#595959;\"> </body></font> (3)、调整窗口大小事件 window.onresize=function(){} 或 window.addEventListener(\"resize\",function(){} ) 调整窗口大小（像素）就会触发，调用内部处理函数，可以用来完成响应式效果 <font style=\"color:#595959;\"><!--需求：当前屏幕大小在800以内的时候，box消失，否则显示 --></font> <font style=\"color:#595959;\"> <div>box</div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var box = document.querySelector(\"div\");</font> <font style=\"color:#595959;\"> window.addEventListener(\"resize\", function () {</font> <font style=\"color:#595959;\"> if (window.innerWidth < 800) {</font> <font style=\"color:#595959;\"> box.style.display = \"none\";</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> box.style.display = \"block\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> 3、定时器 （1）、 setInterval() 定时调用 js的程序的执行速度是非常非常快的，如果希望一段程序，可以每间隔一段时间执行一次，可以使用定时调用 <font style=\"color:#F33232;\">setInterval(回调函数，间隔时间) </font>定时调用，可以将一个函数，每隔一段时间执行一次 参数： 第一个：回调函数，该函数会每隔一段时间调用一次 第二个：每次调用间隔时间，单位是毫秒 返回值： <font style=\"color:#F33232;\">返回</font>一个<font style=\"color:#F33232;\">Number类型</font>的<font style=\"color:#F33232;\">值</font> 这个数字用来作为定时器的唯一标识 clearInterval()可以用来关闭一个定时器 方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器 <font style=\"color:#595959;\"><!-- 需求：页面出现出现数字，每秒自增1 --></font> <font style=\"color:#595959;\"> <h1 id=\"count\"></h1></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var count = document.getElementById(\"count\");</font> <font style=\"color:#595959;\"> var num = 1;</font> <font style=\"color:#595959;\"> var timer = setInterval(function () {</font> <font style=\"color:#595959;\"> count.innerHTML = num++;</font> <font style=\"color:#595959;\"> if (num == 5) {</font> <font style=\"color:#595959;\"> clearInterval(timer);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }, 1000);</font> <font style=\"color:#595959;\"> console.log(timer);//1</font> <font style=\"color:#595959;\"> </script></font> （2）、 setTimeout() 延时调用 概念：延时调用,一个函数不马上执行，而是隔一段时间以后再执行 ，而且<font style=\"color:#F33232;\">只会执行一次</font> <font style=\"color:#F33232;\">window.setTimeout(回调函数，延迟毫秒数)</font> 参数： 1、回调函数直接写函数，或者写函数名皆可 2、延迟秒数若省略，默认是0，<font style=\"color:#F33232;\">单位</font>是<font style=\"color:#F33232;\">毫秒</font> 返回值：数字标识，可以用clearTimeout(timer)关闭定时器 <font style=\"color:#F33232;\">区别：定时调用会执行多次，而延时调用只会调用一次</font> 延时调用和定时调用可以互相代替，在开发中，可根据自己的需要去选择 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var num = 0;</font> <font style=\"color:#595959;\"> var timer = setTimeout(function () {</font> <font style=\"color:#595959;\"> console.log(num++);</font> <font style=\"color:#595959;\"> }, 1000);</font> <font style=\"color:#595959;\"> </font><font style=\"color:#F33232;\"> //使用clearTimeout()来关闭一个延时调用</font> <font style=\"color:#595959;\"> clearTimeout(timer);</font> <font style=\"color:#595959;\"> </script></font> 4、JS执行机制 （1）、JS是单线程 JS语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是JS这门脚本语言诞生的使命所致——用来处理页面中用户的交互，以及操作DOM而诞生的。 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果JS执行的时间过长，这样会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉 （2）、同步和异步 为了解决这个问题，利用多核CPU的计算能力，HTML5提出了Web Worker标准，允许JS脚本创建多个线程，于是，jS中出现了同步和异步 <font style=\"color:#F33232;\">同步</font>：前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的，同步的。比如：我们要烧水煮饭，等水开了（10分钟后），再去切菜，炒菜 <font style=\"color:#F33232;\">异步</font>：你在做一件事情时，因为这件事会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如烧水的10分钟内，去切菜，炒菜 <font style=\"color:#F33232;\">同步任务</font>：<font style=\"color:#4D4D4D;\">在主线程上排队执行任务，只有前一个任务执行完毕，才能执行后一个任务</font> <font style=\"color:#F33232;\">异步任务</font>：<font style=\"color:#F33232;\">不进入主线程，而是进入\"任务队列\"的任务，只有\"任务队列\"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</font> 一般而言，异步任务有以下三种类型 setTimeout和setInterval DOM事件 普通事件如：click、resize，资源加载事件：onload等 ES6中的<font style=\"color:#F33232;\">Promise</font> Ajax异步请求 异步任务相关回调函数添加到任务队列中（消息队列） （3）、JS执行机制 先执行<font style=\"color:#F33232;\">执行栈中的同步任务</font> 异步任务（回调函数）放入任务队列中 一旦执行栈中的所有<font style=\"color:#F33232;\">同步任务执行完毕</font>，系统就会<font style=\"color:#F33232;\">按次序</font>读取任务队列中的异步任务，于是被读取的<font style=\"color:#F33232;\">异步任务结束等待状态，进入执行栈</font>，开始执行 （4）、事件循环 首先，执行栈开始顺序执行 判断是否为同步，异步则进入异步线程，最终事件回调给事件触发线程的任务队列等待执行，同步继续执行 执行栈为空，询问任务队列中是否有事件回调 任务队列中有事件回调则把回调加入执行栈末尾继续<font style=\"color:#F33232;\">从第一步开始执行</font> <font style=\"color:#F33232;\">任务队列中没有事件回调则不停发起询问</font> <font style=\"color:#595959;\"><button>点击</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var setTimeoutCallBack = function () {</font> <font style=\"color:#595959;\"> console.log(\"我是定时器回调\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> var btn = document.querySelector(\"button\");</font> <font style=\"color:#595959;\"> btn.onclick = function () {</font> <font style=\"color:#595959;\"> console.log(\"我是点击事件\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> // 同步任务</font> <font style=\"color:#595959;\"> console.log(\"我是同步任务1\");</font> <font style=\"color:#595959;\"> // 异步定时任务</font> <font style=\"color:#595959;\"> setTimeout(setTimeoutCallBack, 1000);</font> <font style=\"color:#595959;\"> // 同步任务</font> <font style=\"color:#595959;\"> console.log(\"我是同步任务2\");</font> <font style=\"color:#595959;\"> </script></font> JS引擎线程 只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行，这样反反复复就是我们所谓的<font style=\"color:#F33232;\">事件循环(Event Loop)</font> 5、location对象 1）、location对象初识 window对象给我们提供了一个location属性用于<font style=\"color:#F33232;\">获取或设置窗体的URL</font>，并且可以用于解析URL。因为这个对象<font style=\"color:#F33232;\">返回</font>的是一个<font style=\"color:#F33232;\">对象</font>，所以我们称为location对象 2）、URL <font style=\"color:#F33232;\">统一资源定位符</font>（Uniform Resource Locator，简称URL）是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息支出文件的位置以及浏览器应该如何处理它。<font style=\"color:#4D4D4D;\">简单地说URL就是web地址，俗称“网址”。</font> URL由三部分组成：<font style=\"color:#F33232;\">资源类型、存放资源的主机域名、资源文件名</font>。 URL的一般语法格式为： protocol :// hostname[:port] / path / [;parameters][?query]#fragment <font style=\"color:#F33232;\">协议：//主机名或 IP 地址[:端口号]/路径/[;参数][?查询]#信息片断</font> https://pro.jd.com/mall/active/2vx2zyXR2KhRouYS6LrSEdnLF1P5/index.html 格式说明: （1）、protocol（协议） 指定使用的传输协议，最常用的HTTP协议，它是目前WWW中应用最广的协议。 http 通过 HTTP 访问该资源。 格式 HTTP:// https 通过安全的 HTTPS 访问该资源。 格式 HTTPS:// ftp 通过 FTP访问资源。格式 FTP:// 一般来说，https开头的URL要比http开头的更安全，因为这样的URL传输信息是采用了加密技术。 （2）、hostname（主机名） 是指存放资源的服务器的域名系统(DNS) <font style=\"color:#F33232;\">主机名或 IP 地址</font>。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password@hostname）。 （3）、port（端口号） HTTP缺省工作在TCP协议80端口，用户访问网站http:// 打头的都是标准HTTP服务。 HTTPS缺省工作在TCP协议443端口。 （4）、path（路径） 由<font style=\"color:#F33232;\">零或多个“/”符号隔开的字符串</font>，一般用来表示主机上的一个目录或文件地址。 （5）、parameters（参数） 这是用于指定特殊参数的可选项。parameters 一般在 HTTP 协议里使用较少，更多在特定协议场景，例如 ftp://user:password@example.com;type=d/file.txt 里，;type=d 就是参数，用于指定文件类型为目录。 （6）、query(查询) 可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&”符号隔开，每个参数的名和值用“=”符号隔开。 （7）、fragment（信息片断） 信息片断，<font style=\"color:#F33232;\">字符串</font>，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。 3）location对象的属性 | location对象属性 | 返回值 | | --- | --- | | <font style=\"color:rgb(243, 50, 50);\">location.href</font> | <font style=\"color:rgb(243, 50, 50);\">返回</font><font style=\"color:rgb(77, 77, 77);\">当前加载</font><font style=\"color:rgb(243, 50, 50);\">页面</font><font style=\"color:rgb(77, 77, 77);\">的完整</font><font style=\"color:rgb(243, 50, 50);\">URL</font><br/><font style=\"color:rgb(77, 77, 77);\">location.href 与 window.location.href等价</font> | | <font style=\"color:rgb(77, 77, 77);\">location.hash</font> | <font style=\"color:rgb(77, 77, 77);\">返回URL中的hash（#号后 跟零或多个字符），如果不包含则返回空字符串</font> | | <font style=\"color:rgb(77, 77, 77);\">location.host</font> | <font style=\"color:rgb(77, 77, 77);\">返回服务器名称和端口号</font> | | <font style=\"color:rgb(77, 77, 77);\">location.hostname</font> | <font style=\"color:rgb(77, 77, 77);\">返回不带端口号的服务器名称</font> | | <font style=\"color:rgb(77, 77, 77);\">location.pathname</font> | <font style=\"color:rgb(77, 77, 77);\">返回URL中的目录和（或）文件名</font> | | <font style=\"color:rgb(77, 77, 77);\">location.port</font> | <font style=\"color:rgb(77, 77, 77);\">返回URL中指定的端口号，如果没有返回空字符串</font> | | <font style=\"color:rgb(77, 77, 77);\">location.protocol</font> | <font style=\"color:rgb(77, 77, 77);\">返回页面使用的协议</font> | | <font style=\"color:rgb(77, 77, 77);\">location.search</font> | <font style=\"color:rgb(77, 77, 77);\">返回URL的查询字符串，</font>查询以 ？ 开头的字符串 | | location对象方法 | 功能 | | <font style=\"color:rgb(243, 50, 50);\">location.assign()</font> | 用来<font style=\"color:rgb(243, 50, 50);\">跳转</font>到其他的<font style=\"color:rgb(243, 50, 50);\">页面</font>，作用和直接修改location一样,有历史记录（也称重定向页面） | | <font style=\"color:rgb(243, 50, 50);\">location.replace()</font> | <font style=\"color:rgb(243, 50, 50);\">重新定向URL</font><font style=\"color:rgb(77, 77, 77);\">，</font><font style=\"color:rgb(243, 50, 50);\">不会在历史记录中生成新纪录</font><font style=\"color:rgb(77, 77, 77);\">（没有后退按钮）</font> | | <font style=\"color:rgb(243, 50, 50);\">location.reload()</font> | <font style=\"color:rgb(243, 50, 50);\">重新加载当前</font><font style=\"color:rgb(77, 77, 77);\">显示的</font><font style=\"color:rgb(243, 50, 50);\">页面</font><font style=\"color:rgb(77, 77, 77);\">，</font>如果在方法中传递一个<font style=\"color:rgb(243, 50, 50);\">true</font>，作为参数，则会<font style=\"color:rgb(243, 50, 50);\">强制刷新</font>缓存 | 6、navigator对象 navigator代表的<font style=\"color:#F33232;\">当前浏览器</font>的<font style=\"color:#F33232;\">信息</font>，通过该对象可以来<font style=\"color:#F33232;\">识别</font>不同的<font style=\"color:#F33232;\">浏览器</font>，由于历史原因，navigator对象中的大部分属性都已经不能帮助我们识别浏览器了，一般我们只会用userAgent 来判断浏览器的信息，userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent 7、history对象 window对象给我们提供了一个history对象，<font style=\"color:#F33232;\">与浏览器历史记录进行交互</font>，该对象包含用户（在浏览器窗口中）访问过的URL | history对象属性 | 作用 | | --- | --- | | length | 可以获取当前访问的网页的链接数量 | | history对象方法 | 作用 | | <font style=\"color:rgb(243, 50, 50);\">back()</font> | 可以用来<font style=\"color:rgb(243, 50, 50);\">退到上一个页面</font>，作用和浏览器的<font style=\"color:rgb(243, 50, 50);\">回退</font>按钮一样 | | <font style=\"color:rgb(243, 50, 50);\">forward()</font> | 可以<font style=\"color:rgb(243, 50, 50);\">跳转</font>到<font style=\"color:rgb(243, 50, 50);\">下一个页面</font>，作用和浏览器的<font style=\"color:rgb(243, 50, 50);\">前进</font>按钮一样 | | <font style=\"color:rgb(243, 50, 50);\">go()</font> | 可以<font style=\"color:rgb(243, 50, 50);\">跳转</font>到<font style=\"color:rgb(243, 50, 50);\">指定</font>的<font style=\"color:rgb(243, 50, 50);\">页面</font>，它需要<font style=\"color:rgb(243, 50, 50);\">一个整数作为参数</font><br/><font style=\"color:rgb(243, 50, 50);\">正数</font>：<font style=\"color:rgb(243, 50, 50);\">向前</font>跳转n个页面<br/><font style=\"color:rgb(243, 50, 50);\">负数</font>：<font style=\"color:rgb(243, 50, 50);\">向后</font>跳转n个页面 |"
    },
    {
      "title": "js高级",
      "path": "JavaScriptES6+/js高级.md",
      "category": "JavaScriptES6+",
      "tags": [],
      "date": null,
      "description": "《（一）js高级01-基础深入》\n\n1、基础深入js数据类型有哪些数据类型分为两种：基本数据类型与引用数据类型。\n\n基本数据类型有：number、string、boolean、null、undefined。\n\n引用数据类型有：array、function等（除了基本数据类型都是引用数据类型）\n\n基本数据类型的主要特点是赋值方式是传值，并且值存在栈中。\n\n引用数据类型的主要特点是赋值方式是传址，并且",
      "content": "《（一）js高级01-基础深入》 1、基础深入js数据类型有哪些数据类型分为两种：基本数据类型与引用数据类型。 基本数据类型有：number、string、boolean、null、undefined。 引用数据类型有：array、function等（除了基本数据类型都是引用数据类型） 基本数据类型的主要特点是赋值方式是传值，并且值存在栈中。 引用数据类型的主要特点是赋值方式是传址，并且值存在堆中。 js数据类型判断JavaScript 中常用的数据类型判断方法有以下 5 种： 1.typeof 操作符：可以返回一个<font style=\"color:#FF0000;\">字符串</font>，用于表明所操作数的类型。 2.instanceof 操作符：可以判断一个对象是否属于某个类（或其子类）。 3.Object.prototype.toString.call() 方法：可以返回一个表示调用它的对象所属类的字符串。 4.constructor 属性：可以返回对创建该对象的数组函数的引用。 5.Array.isArray() 方法：可以判断一个值是否为数组。 6.===也可以做全等的类型判断 这些方法的区别如下： 1.typeof <font style=\"color:#FF0000;\">只能</font>区分<font style=\"color:#FF0000;\">基本数据类型</font>，<font style=\"color:#FF0000;\">不</font>能<font style=\"color:#FF0000;\">区分具体</font>的<font style=\"color:#FF0000;\">对象</font>类型。 2.instanceof <font style=\"color:#FF0000;\">只能</font>用于<font style=\"color:#FF0000;\">判断对象类型</font>，<font style=\"color:#FF0000;\">无法判断基本</font>数据类型 3.Object.prototype.toString() 方法可以返回对象类型的具体字符串 4.constructor 属性可以返回对象所属类的构造函数 5.Array.isArray() 可以判断一个值是否为数组 <font style=\"color:#595959;\">let obj = {</font> <font style=\"color:#595959;\"> name: 'dawn',</font> <font style=\"color:#595959;\"> age: 21</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> let fn = function () {</font> <font style=\"color:#595959;\"> console.log('我是 function 类型');</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> console.log(</font><font style=\"color:#FF0000;\">Object.prototype.toString.call(1)</font><font style=\"color:#595959;\">); // </font><font style=\"color:#FF0000;\">[object Number]</font> <font style=\"color:#595959;\"> console.log(Object.prototype.toString.call('Hello tomorrow')); // [object String ]</font> <font style=\"color:#595959;\"> console.log(Object.prototype.toString.call(true)); // [object Boolean]</font> <font style=\"color:#595959;\"> console.log(Object.prototype.toString.call(undefined)); // [object Undefined]</font> <font style=\"color:#595959;\"> console.log(Object.prototype.toString.call(fn)); // [object Function]</font> <font style=\"color:#595959;\"> console.log(Object.prototype.toString.call(new Date)); // [object Date]</font> <font style=\"color:#595959;\"> console.log(Object.prototype.toString.call(null)); // [object Null]</font> <font style=\"color:#595959;\"> console.log(Object.prototype.toString.call([1, 2, 3])); // [object Array]</font> <font style=\"color:#595959;\"> console.log(Object.prototype.toString.call(obj)); // [object Object]</font> 如何判断是否是一个数组 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 <font style=\"color:#595959;\">var arr = [1,2,3];</font> <font style=\"color:#FF0000;\">arr instanceof Array // true</font> <font style=\"color:#595959;\">var obj = {};</font> <font style=\"color:#595959;\">obj instanceof Array // false</font> <font style=\"color:#595959;\">Array.isArray()</font> <font style=\"color:#595959;\">Array.isArray([1,2,3]);</font> constructor 在其对应对象的原型下面，是自动生成的。 <font style=\"color:#595959;\">var arr = [1,2,3];</font> <font style=\"color:#FF0000;\">arr.constructor === Array</font> <font style=\"color:#595959;\">Object.prototype.toString.call([ ])</font> 在任何值上调用Object原生的toString()方法，都会<font style=\"color:#FF0000;\">返回</font>一个<font style=\"color:#FF0000;\">[Object NativeConstructorName]</font>格式的字符串。每个类在内部都一个[[class]]属性，这个属性中指定了上述 字符串中的构造函数名。 <font style=\"color:#595959;\">var value = [1,2,3];</font> <font style=\"color:#FF0000;\">alert(Object.prototype.toString.call(value)); // \"[object Array]\"</font> Object.prototype.toString.call([1, 2, 3]) <font style=\"color:#FF0000;\">Array.isArray(). 返回值：true，false</font> js的运行机制是什么 js运行机制，即事件循环机制。js是单线程执行的，这意味着同一时间内只能做一件事，但这并不是说单线程就会阻塞，而要实现单线程且非阻塞的方法就是事件循环机制。 在js中，会把任务分为同步和异步，这两者的执行环境不同，同步任务会进入主线程，异步任务会进入事件队列(EventQueue)，当主线程代码<font style=\"color:#FF0000;\">执行完毕</font>后，会去事件队列中读取对应的异步任务，并推到主线程中执行，不断重复过程，称为事件循环机制(EventLoop) 。 undefined和null有什么区别 null表示为空，代表此处不应该有值的存在，⼀个对象可以是null，代表是个空对象，⽽<font style=\"color:#FF0000;\">null</font>本身也<font style=\"color:#FF0000;\">是对象</font>。 undefined表示『不存在』，JavaScript是⼀⻔动态类型语⾔，成员除了表示存在的空值外，还有可能根本就不存在(因为存不存在只在运⾏期才知道)，这就是undefined的意义所在。 ==和===有什么区别 双等仅仅是看值是否相等，值相等即可无需比较类型。三等是值类型与数据类型进行双层比较。 js中布尔值为false的六种情况 undefined（未定义找不到值时出现）、 null(代表空值) NaN(无法计算时候出现表示非数值，typeof(NaN)是number类型) false(布尔值的false,注意：‘false’的布尔值为true(''这是字符串)) 0（数字） 空串 ''、\"\"、`（单双引号，注意中间有空格是true） null typeof为什么是一个object 因为在javaScript中，不同的对象都是使用二进制存储的，如果二进制前三位都是0的话，系统会判断为是Object类型，而null的二进制全是0，自然也就判断为Object js中的this指向有哪些 函数直接调用，this是window 函数是作为对象的方法调用，this是调用方法的对象 new构造函数时，this是实例对象 call (),apply(),bind()可以改变this的指向 事件函数中，this指向事件源 定时器(setTimeout setInterval)环境this指向window 箭头函数中没有自己的this，它指向其外层作用域的this 改变this指向的方法有哪些，区别是什么 共同点： call、apply、bind都是用来改变函数的this对象的指向的，第一个参数都是this要指向的对象，都可以参加后续参数传参 不同点： bind是返回对应函数，<font style=\"color:#FF0000;\">不会执行</font>，需要手动去调用； apply、call则是<font style=\"color:#FF0000;\">立即调用</font>调用 apply和call功能一样，只是传入的参数列表形式不同，call 需要把参数<font style=\"color:#FF0000;\">按</font>顺<font style=\"color:#FF0000;\">序传递</font>进去，而 apply 则是把参数放在<font style=\"color:#FF0000;\">数组</font>里。 构造函数中的new做了什么 1、创建了一个新的空对象； 2、将构造函数的原型对象赋值到实例对象的原型链上； 3、改变了构造函数的this指向，指向新的实例对象； 4、依次执行代码，赋值 5、将实例对象返回（return）； <font style=\"color:#FF0000;\">创对象，加原型，改this，执行代码并返回对象</font> arguments的特点 JavaScript中，arguments对象是比较特别的一个对象，实际上是当前<font style=\"color:#FF0000;\">函数</font>的一个内置属性，（与this一样，都是内置属性）。也就是说所有函数都内置了一个arguments对象，arguments对象中<font style=\"color:#FF0000;\">存储</font>了传递的所有<font style=\"color:#FF0000;\">实参</font>。arguments是一个<font style=\"color:#FF0000;\">伪数组</font>，因此可以进行遍历，并且有length属性。 arguments只是伪数组，并不是真正的数组，因此不能调用数组的方法。 contiune/break/return区别 return关键词，用于结束循环语句,函数执行过程遇到return,则直接结束函数执行(即剩下部分不再执行)，将return后的值作为函数调用的返回值 continue结束当次循环,继续执行下次循环 break表示跳出本轮循环,注意只能结束离break最近一层循环 数组有哪些方法 push()、unshift、shift()、pop()、splice()、join()、reverse() map()、filter()、some()、every()、findindex()、reduce()等 map()对比forEach() map<font style=\"color:#FF0000;\">有返回值</font>，可以<font style=\"color:#FF0000;\">开辟新空间</font>，return出来一个length和原数组一致的数组，即便数组元素是undefined或者是null。 forEach默认<font style=\"color:#FF0000;\">无返回值</font>，返回结果为undefined，可以通过在函数体内部使用索引修改数组元素。 map的处理速度比forEach快，而且返回一个新的数组，方便链式调用其他数组新方法 数组转字符串字符串转数组 join() 方法可以把数组转换为字符串 split() 方法可以把字符串转换为数组 阻止事件冒泡和默认事件的方法 e.stopPropagation()来阻止事件冒泡。作用当然是阻止我们触发它上级的事件 e.preventDefault()阻止默认行为事件的方法，例如：超链接不跳转 <font style=\"color:#FF0000;\">return false </font>；这个方法比较暴力，他会<font style=\"color:#FF0000;\">同时阻止</font>事件<font style=\"color:#FF0000;\">冒泡</font>也会阻止<font style=\"color:#FF0000;\">默认事件</font>，针对：on事件绑定的情况 innerHTML innerText区别 innerHTML用来获取标签元素或设置标签元素，包含文本和Html标签。在读取元素的时候，会将文本和Html标签一起读取出来；在设置元素的时候，会覆盖掉原来的元素中文本和标签，如果新的内容包含标签，会<font style=\"color:#FF0000;\">解析</font>Html<font style=\"color:#FF0000;\">标签</font>，只显示文本，而不将标签显示出来。 innerText用来设置或获取标签内文本内容, 但它去除Html标签。在读取元素的时候，<font style=\"color:#FF0000;\">只会读取文本</font>；在设置元素的时候，会覆盖掉原来的元素中文本和标签，如果新的内容包含标签，不会解析Html标签，也就是说，里面的标签并不是html中的标签，而只是一个文本。 js事件代理（事件委托） 把事件处理任务添加到上一级的元素中，这样就避免了把事件添加到多个子集元素上，底层原理是利用了事件冒泡机制（事件冒泡是从最具体的元素（触发事件的目标元素）开始，逐级向上传播到祖先元素） 优点： 减少注册时间，节约内存 简化dom节点更新，相应事件的更新 对于新增的节点，可以不用再次绑定事件 缺点： 对于不冒泡的事件不给予支持 层级太多肯能会被中间的某层阻止掉 理论上会导致浏览器会频繁的调用处理函数，虽然可能不需要处理 本地存储的方法及特点 sessionStorage，localStorage，cookie sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除，单页面内共享数据 localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除；内存较大；多页面可以共享数据 数组去重有哪些方法 1.利用<font style=\"color:#FF0000;\">新旧数组遍历对比法</font> <font style=\"color:#595959;\">arr=[1,5,1,3,5,4,3,9,8]</font> <font style=\"color:#595959;\">let newArr = [];</font> <font style=\"color:#595959;\">/* </font> <font style=\"color:#595959;\">indexOf用于查找数组元素第一次出现的位置，没找到则返回值为-1，</font> <font style=\"color:#595959;\">参数有两个，第一个为元素项目，参数二（可选）需要查找的位置，负数从-1往前面加 </font> <font style=\"color:#595959;\">*/</font> <font style=\"color:#595959;\">for (let i=0;i<arr.length;i++) {</font> <font style=\"color:#595959;\"> if (newArr.indexOf(arr[i]) === -1) {</font> <font style=\"color:#595959;\"> newArr.push(arr[i]);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">console.log(newArr);//[1, 5, 3, 4, 9, 8]</font> 2.利用新语法 <font style=\"color:#FF0000;\">new Set()</font> <font style=\"color:#595959;\">arr=[1,5,1,3,5,4,3,9,8]</font> <font style=\"color:#595959;\">let mySet = new Set(arr); // 非重复的类数组</font> <font style=\"color:#595959;\">console.log(mySet,'mySet');//{{1, 5, 3, 4, 9,8}</font> <font style=\"color:#595959;\">// let newArr = Array.from(mySet); // set转数组</font> <font style=\"color:#595959;\">let newArr = [...mySet]; // 或者是这种解构方法</font> <font style=\"color:#595959;\">console.log(newArr);//[1, 5, 3, 4, 9, 8]</font> 3.filter与indexOf结合 <font style=\"color:#595959;\">/* 这个过滤就很巧妙，利用索引与每一项出现的首次位置（indexOf作用）进行对比，</font> <font style=\"color:#595959;\">当符合条件的时候返回出去</font> <font style=\"color:#595959;\">*/ </font> <font style=\"color:#595959;\">arr=[1,5,1,3,5,4,3,9,8]</font> <font style=\"color:#595959;\">var newArr = arr.filter((item, index) => {</font> <font style=\"color:#595959;\"> return arr.indexOf(item) === index;</font> <font style=\"color:#595959;\">})</font> <font style=\"color:#595959;\">console.log(newArr);//[1, 5, 3, 4, 9, 8]</font> 4.includes()的妙用 <font style=\"color:#595959;\">arr=[1,5,1,3,5,4,3,9,8]</font> <font style=\"color:#595959;\">let newArr = [];</font> <font style=\"color:#595959;\">for (let i=0;i<arr.length;i++) {</font> <font style=\"color:#595959;\"> if (!newArr.includes(arr[i])) {</font> <font style=\"color:#595959;\"> newArr.push(arr[i]);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">console.log(newArr);//[1, 5, 3, 4, 9, 8]</font> 5.利用对象属性来进行判断 <font style=\"color:#595959;\">arr=[1,5,1,3,5,4,3,9,8]</font> <font style=\"color:#595959;\">let obj = {}; // 对象的key值是唯一的</font> <font style=\"color:#595959;\">let newArr = [];</font> <font style=\"color:#595959;\">for (let i=0;i<arr.length;i++) {</font> <font style=\"color:#595959;\"> if (!obj[arr[i]]) {//找到对象中没有的</font> <font style=\"color:#595959;\"> obj[arr[i]] = arr[i];//添加到对象中</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">console.log(obj)//{1: 1, 3: 3, 4: 4, 5: 5, 8: 8, 9: 9}</font> 事件三要素 事件是有三部分组成事件源事件类型事件处理程序这就是所谓的事件三要素。 事件源：事件被触发的对象例如一个按钮 事件类型: 如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下 事件处理程序: 通过一个函数赋值的方式 完成 dom事件流 定义： 事件流指的是从页面中接受事件的顺序，事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即为DOM事件流。 阶段： 1.捕获阶段：事件从Document节点自上而下向目标节点传播的阶段 2.当前目标阶段：真正的目标节点正在处理事件的阶段 3.冒泡阶段：事件从目标节点自下而上向Document节点传播的阶段 作用域预解析 作用域是变量起作用和效果的范围，目的是提高程序的可靠性，为了减少命名冲突。JavaScript中有两种作用域(ES6之前没有块级作用域)：全局作用域和局部作用域。 JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。 预解析：JS 代码执行之前，浏览器会默认把var 和 function 声明的变量在内存中进行提升到当前作用域的最前面进行声明。 代码执行：从上到下执行JS语句。 （一）、原型与原型链 1、prototype属性 （1）. 函数的prototype属性 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象或者显示原型) 原型对象prototype中有一个属性constructor, 它指向函数对象 <font style=\"color:#595959;\">// 每个函数都有一个prototype属性, </font> <font style=\"color:#595959;\">//它默认指向一个对象(即称为: 原型对象)</font> <font style=\"color:#595959;\">console.log(Date.prototype, typeof Date.prototype);</font> <font style=\"color:#595959;\">function fn() {}</font> <font style=\"color:#595959;\">console.log(fn.prototype, typeof fn.prototype);</font> <font style=\"color:#595959;\">// 原型对象中有一个属性constructor, 它指向函数对象</font> <font style=\"color:#595959;\">console.log(Date.prototype.constructor === Date);</font> <font style=\"color:#595959;\">console.log(fn.prototype.constructor === fn);</font> （2）. 给原型对象添加属性(一般都是方法) 作用: 函数的所有实例对象自动拥有原型中的属性(方法) <font style=\"color:#595959;\">function F() {}</font> <font style=\"color:#595959;\">F.prototype.age = 12; //添加属性</font> <font style=\"color:#595959;\">F.prototype.setAge = function (age) {</font> <font style=\"color:#595959;\"> // 添加方法</font> <font style=\"color:#595959;\"> this.age = age;</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">// 创建函数的实例对象</font> <font style=\"color:#595959;\">var f = new F();</font> <font style=\"color:#595959;\">console.log(f.age);//12</font> <font style=\"color:#595959;\">f.setAge(23);</font> <font style=\"color:#595959;\">console.log(f.age);//23</font> 2、显式原型与隐式原型 （1）. <font style=\"color:#F33232;\">每个函数</font>function都有一个prototype，即显式原型,是给程序员使用的 （2）. <font style=\"color:#F33232;\">每个实例</font>对象都有一个__proto__，可称为隐式原型，是js本身用的，一般情况，程序员不去使用 （3）. 对象的隐式原型的值为其对应构造函数的显式原型的值 （4）. 内存结构(图) <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> function Fn() {</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">var fn = new Fn()</font> <font style=\"color:#595959;\">console.log(Fn.prototype, fn.__proto__)</font> <font style=\"color:#595959;\">console.log(Fn.prototype===fn.__proto__)//true</font> <font style=\"color:#595959;\">Fn.prototype.test = function () {</font> <font style=\"color:#595959;\"> console.log('test()')</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">fn.test()</font> <font style=\"color:#595959;\"> </script></font> （5）. 总结: 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象 对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值 __proto__<font style=\"color:#333333;\">和</font>constructor<font style=\"color:#333333;\">属性是</font><font style=\"color:#FF0000;\">对象</font><font style=\"color:#333333;\">所独有的；</font> prototype<font style=\"color:#333333;\">属性是</font><font style=\"color:#FF0000;\">函数</font><font style=\"color:#333333;\">所独有的，因为函数也是一种对象，所以函数也拥有</font>__proto__<font style=\"color:#333333;\">和</font>constructor<font style=\"color:#333333;\">属性。</font> prototype属性的<font style=\"color:#FF0000;\">作用</font>就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ ===Foo.prototype。 constructor属性的含义就是<font style=\"color:#FF0000;\">指向该对象的构造函数</font>，所有函数（此时看成对象了）最终的构造函数都指向<font style=\"color:#FF0000;\">Function</font>。 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前) 3、原型链 （1）. 原型链，别名: 隐式原型链(图解) __proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。 作用: 查找对象的属性(方法) <font style=\"color:#595959;\">function Fn() {</font> <font style=\"color:#595959;\"> this.test1 = function () {</font> <font style=\"color:#595959;\"> console.log('test1()')</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">Fn.prototype.test2 = function () {</font> <font style=\"color:#595959;\"> console.log('test2()')</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">var fn = new Fn()</font> <font style=\"color:#595959;\">fn.test1()</font> <font style=\"color:#595959;\">fn.test2()</font> <font style=\"color:#595959;\">console.log(fn.toString())</font> <font style=\"color:#595959;\">fn.test3()//报错</font> (2）. 构造函数/原型/实体对象的关系(图解) 4、属性问题 （1）. 读取对象的属性值时: 会自动到原型链中查找 （2）. 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值 （3）. 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上 <font style=\"color:#595959;\">function Person(name, age) {</font> <font style=\"color:#595959;\"> this.name = name;</font> <font style=\"color:#595959;\"> this.age = age;</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">Person.prototype.setName = function (name) {</font> <font style=\"color:#595959;\"> this.name = name;</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">Person.prototype.sex = '男';</font> <font style=\"color:#595959;\">var p1 = new Person('Tom', 12)</font> <font style=\"color:#595959;\">p1.setName('Jack')</font> <font style=\"color:#595959;\">console.log(p1.name, p1.age, p1.sex,111)</font> <font style=\"color:#595959;\">p1.sex = '女'</font> <font style=\"color:#595959;\">console.log(p1.name, p1.age, p1.sex,222)</font> 5、探索instanceof instanceof是如何判断的? 表达式: A instanceof B <font style=\"color:#FF0000;\">如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</font> Function是通过new自己产生的实例 <font style=\"color:#595959;\">//案例1</font> <font style=\"color:#595959;\">function Foo() { }</font> <font style=\"color:#595959;\">var f1 = new Foo();</font> <font style=\"color:#595959;\">console.log(f1 instanceof Foo);//true</font> <font style=\"color:#595959;\">console.log(f1 instanceof Object);//true</font> <font style=\"color:#595959;\">//案例2</font> <font style=\"color:#595959;\">console.log(Object instanceof Function)//true</font> <font style=\"color:#595959;\">console.log(Object instanceof Object)//true</font> <font style=\"color:#595959;\">console.log(Function instanceof Object)//true</font> <font style=\"color:#595959;\">console.log(Function instanceof Function)//true</font> <font style=\"color:#595959;\">function Foo() {}</font> <font style=\"color:#595959;\">console.log(Object instanceof Foo);//false</font> <font style=\"color:#595959;\">console.log(Foo instanceof Object);//true</font> 6、面试题 <font style=\"color:#595959;\">var A = function () {};</font> <font style=\"color:#595959;\">A.prototype.n = 1;</font> <font style=\"color:#595959;\">var b = new A(); //b.n=1</font> <font style=\"color:#595959;\">A.prototype = {</font> <font style=\"color:#595959;\"> n: 2,</font> <font style=\"color:#595959;\"> m: 3,</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">var c = new A();</font> <font style=\"color:#595959;\">// console.log(b.__proto__,c.__proto__);//{n:1},{n:2,m:3}</font> <font style=\"color:#595959;\">console.log(A.prototype); //{n:2,m:3}</font> <font style=\"color:#595959;\">console.log(b.n, b.m, c.n, c.m);</font> <font style=\"color:#595959;\">// 1/undefined/2/3</font> （二）、执行上下文与执行上下文栈 1、变量提升与函数提升 （1）. 变量声明提升 通过var定义(声明)的变量, 在定义语句之前就可以访问到 值: undefined （2）. 函数声明提升 通过function声明的函数, 在之前就可以直接调用 值: 函数定义(对象) <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> /*</font> <font style=\"color:#595959;\"> 面试题: 输出什么?</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\"> var a = 4;</font> <font style=\"color:#595959;\">function fn() {</font> <font style=\"color:#595959;\"> console.log(a);</font> <font style=\"color:#595959;\"> var a = 5;</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">fn(); // undefined</font> <font style=\"color:#595959;\">/变量提升/</font> <font style=\"color:#595959;\">console.log(a1); //可以访问, 但值是undefined</font> <font style=\"color:#595959;\">/函数提升/</font> <font style=\"color:#595959;\">a2(); // 可以直接调用</font> <font style=\"color:#595959;\">var a1 = 3;</font> <font style=\"color:#595959;\">function a2() {</font> <font style=\"color:#595959;\"> console.log(\"a2()\");</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\"></script></font> （3）. 问题: 变量提升和函数提升是如何产生的? 理解下面的执行上下文 2、执行上下文 （1）. 代码分类(位置) 全局代码 函数代码 （2）. 全局执行上下文 在执行全局代码前将window确定为全局执行上下文 对全局数据进行预处理 var定义的全局变量==>undefined, 添加为window的属性 function声明的全局函数==>赋值(fun), 添加为window的方法 this==>赋值(window) 开始执行全局代码 <font style=\"color:#595959;\"> console.log(a1);//undefined</font> <font style=\"color:#595959;\"> console.log(a2);//undefined</font> <font style=\"color:#595959;\">console.log(a3);//函数</font> <font style=\"color:#595959;\">// console.log(a4)</font> <font style=\"color:#595959;\">console.log(this);//window</font> <font style=\"color:#595959;\">var a1 = 3;</font> <font style=\"color:#595959;\">var a2 = function () {</font> <font style=\"color:#595959;\"> console.log(\"a2()\");</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">function a3() {</font> <font style=\"color:#595959;\"> console.log(\"a3()\");</font> <font style=\"color:#595959;\">}</font> （3）. 函数执行上下文 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象 对局部数据进行预处理 形参变量==>赋值(实参)==>添加为执行上下文的属性 arguments==>赋值(实参列表), 添加为执行上下文的属性 var定义的局部变量==>undefined, 添加为执行上下文的属性 function声明的函数 ==>赋值(fun), 添加为执行上下文的方法 this==>赋值(调用函数的对象) 开始执行函数体代码 <font style=\"color:#595959;\">function fn(x, y) {</font> <font style=\"color:#595959;\"> console.log(x, y); //undefined</font> <font style=\"color:#595959;\"> console.log(b1); //undefined</font> <font style=\"color:#595959;\"> console.log(b2); //函数</font> <font style=\"color:#595959;\"> console.log(arguments); //内容</font> <font style=\"color:#595959;\"> console.log(this); //window</font> <font style=\"color:#595959;\"> // console.log(b3)//报错</font> <font style=\"color:#595959;\"> var b1 = 5;</font> <font style=\"color:#595959;\"> function b2() {}</font> <font style=\"color:#595959;\"> b3 = 6;</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">fn();</font> 3、执行上下文栈 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象 在全局执行上下文(window)确定后, 将其添加到栈中(压栈) 在函数执行上下文创建后, 将其添加到栈中(压栈) 在当前函数执行完后,将栈顶的对象移除(出栈) 当所有的代码执行完后, 栈中只剩下window <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> //1. 进入全局执行上下文</font> <font style=\"color:#595959;\"> var a = 10;</font> <font style=\"color:#595959;\">var bar = function (x) {</font> <font style=\"color:#595959;\"> var b = 5;</font> <font style=\"color:#595959;\"> foo(x + b); //3. 进入foo执行上下文</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">var foo = function (y) {</font> <font style=\"color:#595959;\"> var c = 5;</font> <font style=\"color:#595959;\"> console.log(a + c + y);</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">bar(10); //2. 进入bar函数执行上下文</font> <font style=\"color:#595959;\"></script></font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!--</font> <font style=\"color:#595959;\"> 1. 依次输出什么? 123 321 1</font> <font style=\"color:#595959;\"> 2. 整个过程中产生了几个执行上下文? 5</font> <font style=\"color:#595959;\"> --></font> <font style=\"color:#595959;\"> <script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> console.log(\"global begin: \" + i); //undefined</font> <font style=\"color:#595959;\"> var i = 1;</font> <font style=\"color:#595959;\"> foo(1);</font> <font style=\"color:#595959;\"> function foo(i) {</font> <font style=\"color:#595959;\"> if (i == 4) {</font> <font style=\"color:#595959;\"> return;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(\"foo() begin:\" + i); //1，2，3</font> <font style=\"color:#595959;\"> foo(i + 1);</font> <font style=\"color:#595959;\"> console.log(\"foo() end:\" + i); //3，2，1</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(\"global end: \" + i); //1</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 4、面试题 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> /*</font> <font style=\"color:#595959;\"> 测试题1: 先预处理变量, 后预处理函数</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\"> function a() {}</font> <font style=\"color:#595959;\">var a;</font> <font style=\"color:#595959;\">console.log(typeof a); //function</font> <font style=\"color:#595959;\">/*</font> <font style=\"color:#595959;\"> 测试题2: 变量预处理, in操作符</font> <font style=\"color:#595959;\"> if语句中的var b 进行变量提升，所以b在window内，</font> <font style=\"color:#595959;\"> 所以if判断中为false，不执行赋值语句，所以b为undefined</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\">if (!(b in window)) {</font> <font style=\"color:#595959;\"> var b = 1;</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">console.log(b); //undefined</font> <font style=\"color:#595959;\">/*</font> <font style=\"color:#595959;\"> 测试题3: 预处理, 顺序执行</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\">var c = 1;</font> <font style=\"color:#595959;\">function c(c) {</font> <font style=\"color:#595959;\"> console.log(c);</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">c(2); //报错</font> <font style=\"color:#595959;\">// 实际上的执行顺序如下</font> <font style=\"color:#595959;\">// var c;</font> <font style=\"color:#595959;\">// function c(c) {</font> <font style=\"color:#595959;\">// console.log(c);</font> <font style=\"color:#595959;\">// var c = 3;</font> <font style=\"color:#595959;\">// }</font> <font style=\"color:#595959;\">// c = 1;</font> <font style=\"color:#595959;\">// c(2); //报错</font> <font style=\"color:#595959;\"></script></font> （三）、作用域与作用域链 1、作用域 （1）. 理解 就是一块\"地盘\", 一个代码段所在的区域 它是静态的(相对于上下文对象), 在编写代码时就确定了 （2）. 分类 全局作用域 局部作用域 没有块作用域，其实就是大括号作用域(ES6有了) （3）. 作用 隔离变量，不同作用域下同名变量不会有冲突 <font style=\"color:#595959;\">var a = 10,</font> <font style=\"color:#595959;\"> b = 20</font> <font style=\"color:#595959;\">function fn(x) {</font> <font style=\"color:#595959;\"> var a = 100,</font> <font style=\"color:#595959;\"> c = 300;</font> <font style=\"color:#595959;\"> console.log('fn()', a, b, c, x)//100，20，300，10</font> <font style=\"color:#595959;\"> function bar(x) {</font> <font style=\"color:#595959;\"> var a = 1000,</font> <font style=\"color:#595959;\"> d = 400</font> <font style=\"color:#595959;\"> console.log('bar()', a, b, c, d, x)</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> bar(100); //1000，20，300，400，100</font> <font style=\"color:#595959;\"> bar(200);//1000，20，300，400，200</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">fn(10)</font> 2、作用域与执行上下文 （1）. 区别1 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建 函数执行上下文环境是在调用函数时, 函数体代码执行之前创建 （2）. 区别2 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化 上下文环境是动态的, 调用函数时创建, 函数调用结束时上下文环境就会被自动释放 （3）. 联系 上下文环境(对象)是从属于所在的作用域 全局上下文环境==>全局作用域 函数上下文环境==>对应的函数使用域 3、作用域链 （1）. 理解 多个上下级关系的作用域形成的链, 它的方向是<font style=\"color:#DF2A3F;\">从下向上的(从内到外) </font> 查找变量时就是沿着作用域链来查找的 （2）. 查找一个变量的查找规则 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常 <font style=\"color:#595959;\">var a = 2;</font> <font style=\"color:#595959;\">function fn1() {</font> <font style=\"color:#595959;\"> var b = 3;</font> <font style=\"color:#595959;\"> function fn2() {</font> <font style=\"color:#595959;\"> var c = 4;</font> <font style=\"color:#595959;\"> console.log(c);//4</font> <font style=\"color:#595959;\"> console.log(b);//3</font> <font style=\"color:#595959;\"> console.log(a);//2</font> <font style=\"color:#595959;\"> console.log(d);//报错</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fn2();</font> <font style=\"color:#595959;\">}</font> 4、面试题 <font style=\"color:#595959;\">//第一题</font> <font style=\"color:#595959;\">var x = 10;</font> <font style=\"color:#595959;\">function fn() {</font> <font style=\"color:#595959;\"> console.log(x);//10</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">function show(f) {</font> <font style=\"color:#595959;\"> var x = 20;</font> <font style=\"color:#595959;\"> f();</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">show(fn);</font> <font style=\"color:#595959;\">//第二题</font> <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> /说说它们的输出情况/</font> <font style=\"color:#595959;\"> var fn = function () {</font> <font style=\"color:#595959;\"> console.log(fn);</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">fn(); //函数</font> <font style=\"color:#595959;\">var obj = {</font> <font style=\"color:#595959;\"> fn2: function () {</font> <font style=\"color:#595959;\"> // 在自己身上找，找不到fn2,然后去全局找，也找不到所以报错</font> <font style=\"color:#595959;\"> console.log(fn2); //报错</font> <font style=\"color:#595959;\"> // 通过this在自己身上找，找到了fn2</font> <font style=\"color:#595959;\"> // console.log(this.fn2)//输出函数本身</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">obj.fn2();</font> <font style=\"color:#595959;\"></script></font> （四）、闭包 0、闭包引入 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <button>测试1</button></font> <font style=\"color:#595959;\"> <button>测试2</button></font> <font style=\"color:#595959;\"> <button>测试3</button></font> <font style=\"color:#595959;\"> <!--需求: 点击某个按钮, 提示\"点击的是第n个按钮\"--></font> <font style=\"color:#595959;\"> <script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> var btns = document.getElementsByTagName(\"button\");</font> <font style=\"color:#595959;\">//有问题</font> <font style=\"color:#595959;\">// for (var i = 0, length = btns.length; i < length; i++) {</font> <font style=\"color:#595959;\">// btns[i].onclick = function () {</font> <font style=\"color:#595959;\">// alert(\"第\" + (i + 1) + \"个\");</font> <font style=\"color:#595959;\">// };</font> <font style=\"color:#595959;\">// }</font> <font style=\"color:#595959;\">//解决一: 保存下标</font> <font style=\"color:#595959;\">/*for(var i=0,length=btns.length;i<length;i++) {</font> <font style=\"color:#595959;\"> var btn = btns[i]</font> <font style=\"color:#595959;\"> btn.index = i</font> <font style=\"color:#595959;\"> btn.onclick = function () {</font> <font style=\"color:#595959;\"> alert('第'+(this.index+1)+'个')</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }*/</font> <font style=\"color:#595959;\">//解决办法: 利用闭包</font> <font style=\"color:#595959;\">for (var i = 0, length = btns.length; i < length; i++) {</font> <font style=\"color:#595959;\"> (function (i) {</font> <font style=\"color:#595959;\"> //行参i</font> <font style=\"color:#595959;\"> var btn = btns[i];</font> <font style=\"color:#595959;\"> btn.onclick = function () {</font> <font style=\"color:#595959;\"> alert(\"第\" + (i + 1) + \"个\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> })(i); //实参i</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\"></script></font> <font style=\"color:#595959;\"> </body></font> 1、理解闭包 （1）. 如何产生闭包? 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 外部函数调用 就产生了闭包 （2）. 闭包到底是什么? 使用chrome调试查看 理解一: 闭包是嵌套的内部函数(绝大部分人) 理解二: 包含被引用变量(函数)的对象(极少数人) 注意: 闭包存在于嵌套的内部函数中 <font style=\"color:#595959;\">function fn1 () {</font> <font style=\"color:#595959;\"> var a = 3</font> <font style=\"color:#595959;\"> function fn2 () {</font> <font style=\"color:#595959;\"> console.log(a)</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> fn2()</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">fn1()</font> （3）. 产生闭包的条件? 函数嵌套 内部函数引用了外部函数的数据(变量/函数) 调用了外部的函数 2、常见的闭包 （1）. 将函数作为另一个函数的返回值 <font style=\"color:#595959;\">function fn1() {</font> <font style=\"color:#595959;\"> var a = 2</font> <font style=\"color:#595959;\"> function fn2() {</font> <font style=\"color:#595959;\"> a++</font> <font style=\"color:#595959;\"> console.log(a)</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> return fn2</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">var f = fn1()</font> <font style=\"color:#595959;\">f() // 3 </font> <font style=\"color:#595959;\">f() // 4</font> 当f()第二次执行的时候，a加1了，也就说明了：闭包里的数据没有消失，而是保存在了内存中。 如果没有闭包，代码执行完倒数第三行后，变量a就消失了。 上面的代码中，虽然调用了内部函数两次，但是，闭包对象只创建了一个。 也就是说，要看闭包对象创建了一个，就看：外部函数执行了几次（与内部函数执行几次无关）。 （2）. 将函数作为实参传递给另一个函数调用 <font style=\"color:#595959;\">function showMsgDelay(msg, time) {</font> <font style=\"color:#595959;\"> setTimeout(function () {</font> <font style=\"color:#595959;\"> console.log(msg)</font> <font style=\"color:#595959;\"> }, time)</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">showMsgDelay('hello', 1000)</font> <font style=\"color:#595959;\">//上面的代码中，闭包是里面的function，因为它是嵌套的子函数，而且引用了外部函数的变量msg。</font> 3、闭包的作用 （1）. 使用函数内部的变量在函数执行完后, 仍然存活在内存中<font style=\"color:#FF0000;\">(延长了局部变量的生命周期)</font> （2）. 让函数<font style=\"color:#FF0000;\">外部</font>可以操作(<font style=\"color:#FF0000;\">读写</font>)到函数<font style=\"color:#FF0000;\">内部</font>的<font style=\"color:#FF0000;\">数据</font>(变量/函数) 问题: 函数执行完后, 函数内部声明的局部变量是否还存在? 一般是不存在的，存在闭包中的变量才可能存在 在函数外部能直接访问函数内部的局部变量吗? 不能，但我们可以通过闭包让外部操作它 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> function fun1() {</font> <font style=\"color:#595959;\"> var a = 3;</font> <font style=\"color:#595959;\"> function fun2() {</font> <font style=\"color:#595959;\"> a++; //引用外部函数的变量--->产生闭包</font> <font style=\"color:#595959;\"> console.log(a);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> return fun2;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">var f = fun1(); //由于f引用着内部的函数-->内部函数以及闭包都没有成为垃圾对象</font> <font style=\"color:#595959;\">f(); //间接操作了函数内部的局部变量</font> <font style=\"color:#595959;\">f();</font> <font style=\"color:#595959;\"></script></font> 4、闭包的生命周期 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用) 死亡: 在嵌套的内部函数成为垃圾对象时 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> function fun1() {</font> <font style=\"color:#595959;\"> //此处闭包已经产生</font> <font style=\"color:#595959;\"> var a = 3;</font> <font style=\"color:#595959;\"> function fun2() {</font> <font style=\"color:#595959;\"> a++;</font> <font style=\"color:#595959;\"> console.log(a);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> return fun2;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">var f = fun1();</font> <font style=\"color:#595959;\">f();</font> <font style=\"color:#595959;\">f();</font> <font style=\"color:#595959;\">f = null; //此时闭包对象死亡</font> <font style=\"color:#595959;\"></script></font> 5、闭包的应用-自动移js模块 创建具有特定功能的js文件 将所有的数据和功能都封装在一个函数内部(私有的) 只向外暴露一个包信n个方法的对象或函数 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能 <font style=\"color:#595959;\">/</font> <font style=\"color:#595959;\"> * 自定义模块1</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\">function coolModule() {</font> <font style=\"color:#595959;\"> //私有的数据</font> <font style=\"color:#595959;\"> var msg = 'bdqn'</font> <font style=\"color:#595959;\"> var names = ['I', 'Love', 'you']</font> <font style=\"color:#595959;\"> //私有的操作数据的函数</font> <font style=\"color:#595959;\"> function doSomething() {</font> <font style=\"color:#595959;\"> console.log(msg.toUpperCase())</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> function doOtherthing() {</font> <font style=\"color:#595959;\"> console.log(names.join(' '))</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //向外暴露包含多个方法的对象</font> <font style=\"color:#595959;\"> return {</font> <font style=\"color:#595959;\"> doSomething: doSomething,</font> <font style=\"color:#595959;\"> doOtherthing: doOtherthing</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\"><script type=\"text/javascript\" src=\"05_coolModule.js\"></script></font> <font style=\"color:#595959;\"> <script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> var module = coolModule()</font> <font style=\"color:#595959;\">module.doSomething()</font> <font style=\"color:#595959;\">module.doOtherthing()</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> /</font> <font style=\"color:#595959;\"> * 自定义模块2</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\"> (function (window) {</font> <font style=\"color:#595959;\"> //私有的数据</font> <font style=\"color:#595959;\"> var msg = 'bdqn'</font> <font style=\"color:#595959;\"> var names = ['I', 'Love', 'you']</font> <font style=\"color:#595959;\"> //操作数据的函数</font> <font style=\"color:#595959;\"> function a() {</font> <font style=\"color:#595959;\"> console.log(msg.toUpperCase())</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> function b() {</font> <font style=\"color:#595959;\"> console.log(names.join(' '))</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> window.coolModule2 = {</font> <font style=\"color:#595959;\"> doSomething: a,</font> <font style=\"color:#595959;\"> doOtherthing: b</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> })(window)</font> <font style=\"color:#595959;\"> <script type=\"text/javascript\" src=\"05_coolModule2.js\"></script></font> <font style=\"color:#595959;\"> <script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> coolModule2.doSomething()</font> <font style=\"color:#595959;\">coolModule2.doOtherthing()</font> <font style=\"color:#595959;\"> </script></font> 6、闭包的缺点 （1）. 缺点 函数执行完后, 函数内的局部变量没有释放<font style=\"color:#FF0000;\">, 占用内存时间会变长</font> <font style=\"color:#FF0000;\">容易</font>造成<font style=\"color:#FF0000;\">内存泄露</font> （2）. 解决 能不用闭包就不用 及时释放 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> function fn1() {</font> <font style=\"color:#595959;\"> var a = 2;</font> <font style=\"color:#595959;\"> function fn2() {</font> <font style=\"color:#595959;\"> a++;</font> <font style=\"color:#595959;\"> console.log(a);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> return fn2;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">var f = fn1();</font> <font style=\"color:#595959;\">f(); // 3</font> <font style=\"color:#595959;\">f(); // 4</font> <font style=\"color:#595959;\">f = null // 释放</font> <font style=\"color:#595959;\"> </script></font> 7、闭包面试题 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> /*</font> <font style=\"color:#595959;\"> 说说它们的输出情况</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\"> //代码片段一</font> <font style=\"color:#595959;\"> var name = \"The Window\";</font> <font style=\"color:#595959;\"> var object = {</font> <font style=\"color:#595959;\"> name: \"My Object\",</font> <font style=\"color:#595959;\"> getNameFunc: function () {</font> <font style=\"color:#595959;\"> return function () {</font> <font style=\"color:#595959;\"> return this.name;</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> console.log(object.getNameFunc()()); //The Window</font> <font style=\"color:#595959;\"> //代码片段二</font> <font style=\"color:#595959;\"> var name2 = \"The Window\";</font> <font style=\"color:#595959;\"> var object2 = {</font> <font style=\"color:#595959;\"> name2: \"My Object\",</font> <font style=\"color:#595959;\"> getNameFunc: function () {</font> <font style=\"color:#595959;\"> var that = this;</font> <font style=\"color:#595959;\"> return function () {</font> <font style=\"color:#595959;\"> return that.name2;</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> console.log(object2.getNameFunc()()); //My Object</font> <font style=\"color:#595959;\"> </script></font> 面试题：什么是闭包，有哪些缺点 一个函数(子函数)访问另一个函数(父函数)中的变量，外部函数调用，此时就有闭包产生，那么这个变 量所在的函酸我们就称之为闭包函数 优缺点: 优点：闭包的主要作用是延伸了变量的生命周期，可以让外部操作函数内部的变量 缺点：变量生命周期，可能会产生内存泄漏 如何解决:用完之后手动释放，尽量少用 8、内存溢出与内存泄露 内存溢出 一种程序运行出现的错误 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误 内存泄露 占用的内存没有及时释放 内存泄露积累多了就容易导致内存溢出 常见的内存泄露: 意外的全局变量 没有及时清理的计时器或回调函数 闭包 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> // 1. 内存溢出</font> <font style=\"color:#595959;\"> /*var obj = {}</font> <font style=\"color:#595959;\"> for (var i = 0; i < 100000; i++) {</font> <font style=\"color:#595959;\"> obj[i] = new Array(10000000)</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log('------')*/</font> <font style=\"color:#595959;\"> // 2. 内存泄露</font> <font style=\"color:#595959;\"> // 意外的全局变量，变成了全局变量</font> <font style=\"color:#595959;\"> function fn() {</font> <font style=\"color:#595959;\"> a = []; //不小心没有var定义</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">fn();</font> <font style=\"color:#595959;\">// 没有及时清理的计时器</font> <font style=\"color:#595959;\">var iId = setInterval(function () {</font> <font style=\"color:#595959;\"> console.log(\"----\");</font> <font style=\"color:#595959;\">}, 1000);</font> <font style=\"color:#595959;\">clearInterval(iId);</font> <font style=\"color:#595959;\"></script></font> （五）、递归 1、什么是递归函数? 递归是函数的高级用法，本质上是函数自已调用自已，它的行为非常类似循环 2、递归函数的特性 （1）. 重复执行 （2）.调用自身 （3）. 【必须】要有条件控制，避免死循环，如果递归函数没有条件控制,那么他就是死循环 递归本身是一种循环操作，简单情况下可以替换循环语句的使用 注意：递归慎用，能用循环解决的事情，尽量别用递归 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // 递归函数 :在函数内部调用自己,通过条件控制避免死循环</font> <font style=\"color:#595959;\"> // 一直造成foo函数重复调用-- 死循环</font> <font style=\"color:#595959;\"> var i = 0;</font> <font style=\"color:#595959;\"> function foo() {</font> <font style=\"color:#595959;\"> if (i >= 3) return;//限制条件</font> <font style=\"color:#595959;\"> i++;</font> <font style=\"color:#595959;\"> console.log(\"递归函数\");</font> <font style=\"color:#595959;\"> foo(); // 2.内部调用自己</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> foo(); // 1.外部调用</font> <font style=\"color:#595959;\"> // 递归三特性-- 重复执行 / 调用自身 / 条件控制避免死循环!</font> <font style=\"color:#595959;\"> </script></font> 3、递归函数常用案例 （1）、利用递归函数求1-100的和 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // 利用递归函数求1-100的和</font> <font style=\"color:#595959;\"> let i = 0</font> <font style=\"color:#595959;\">let sum = 0</font> <font style=\"color:#595959;\">function getSum() {</font> <font style=\"color:#595959;\"> if (i >= 100) { return sum } // 后边只有一句话,可以省略大括号</font> <font style=\"color:#595959;\"> i++</font> <font style=\"color:#595959;\"> sum += i</font> <font style=\"color:#595959;\"> getSum()</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">getSum()</font> <font style=\"color:#595959;\">console.log(sum);</font> <font style=\"color:#595959;\"></script></font> (2)、斐波拉契数列 <font style=\"color:#595959;\"><!-- 经典案例2：斐波拉契数列</font> <font style=\"color:#595959;\"> 1，1，2，3，5，8，13，21，34，55，89...求第n项 --></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //递归方法</font> <font style=\"color:#595959;\"> function fib(n) {</font> <font style=\"color:#595959;\"> if (n === 1 || n === 2) return n;</font> <font style=\"color:#595959;\"> return fib(n - 1) + fib(n - 2);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(fib(10)); //34</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> //非递归方法</font> <font style=\"color:#595959;\"> function fib(n) {</font> <font style=\"color:#595959;\"> var a = 0;</font> <font style=\"color:#595959;\"> var b = 1;</font> <font style=\"color:#595959;\"> var c = a + b;</font> <font style=\"color:#595959;\"> for (var i = 3; i < n; i++) {</font> <font style=\"color:#595959;\"> a = b;</font> <font style=\"color:#595959;\"> b = c;</font> <font style=\"color:#595959;\"> c = a + b;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> return c;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(fib(10)); //34</font> <font style=\"color:#595959;\"> </script></font> （3）、爬楼梯 <font style=\"color:#595959;\"><!-- 经典案例3：爬楼梯</font> <font style=\"color:#595959;\">JS递归假如楼梯有 n 个台阶，每次可以走 1 个或 2 个台阶，</font> <font style=\"color:#595959;\">请问走完这 n 个台阶有几种走法 --></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> function fun(n) {</font> <font style=\"color:#595959;\"> if (n == 1) return 1;</font> <font style=\"color:#595959;\"> if (n == 2) return 2;</font> <font style=\"color:#595959;\"> return fun(n - 1) + fun(n - 2);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> （一）、对象创建模式 方式一: Object构造函数模式 套路: 先创建空Object对象, 再动态添加属性/方法 适用场景: 起始时不确定对象内部数据 问题: 语句太多 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> /*</font> <font style=\"color:#595959;\"> 一个人: name:\"Tom\", age: 12</font> <font style=\"color:#595959;\"> */</font> <font style=\"color:#595959;\"> var p = new Object()</font> <font style=\"color:#595959;\">p.name = 'Tom'</font> <font style=\"color:#595959;\">p.age = 12</font> <font style=\"color:#595959;\">p.setName = function (name) {</font> <font style=\"color:#595959;\"> this.name = name</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">p.setaAge = function (age) {</font> <font style=\"color:#595959;\"> this.age = age</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">console.log(p)</font> <font style=\"color:#595959;\"> </script></font> 方式二: 对象字面量模式 套路: 使用{}创建对象, 同时指定属性/方法 适用场景: 起始时对象内部数据是确定的 问题: 如果创建多个对象, 有重复代码 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> var p = {</font> <font style=\"color:#595959;\"> name: 'Tom',</font> <font style=\"color:#595959;\"> age: 23,</font> <font style=\"color:#595959;\"> setName: function (name) {</font> <font style=\"color:#595959;\"> this.name = name</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">console.log(p.name）</font> <font style=\"color:#595959;\">console.log(p.name, p.age)</font> <font style=\"color:#595959;\">var p2 = {</font> <font style=\"color:#595959;\"> name: 'BOB',</font> <font style=\"color:#595959;\"> age: 24,</font> <font style=\"color:#595959;\"> setName: function (name) {</font> <font style=\"color:#595959;\"> this.name = name</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\"> </script></font> 方式三: 工厂模式 套路: 通过工厂函数动态创建对象并返回 适用场景: 需要创建多个对象 问题: 对象没有一个具体的类型, 都是Object类型 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> // 工厂函数: 返回一个需要的数据的函数</font> <font style=\"color:#595959;\"> function createPerson(name, age) {</font> <font style=\"color:#595959;\"> var p = {</font> <font style=\"color:#595959;\"> name: name,</font> <font style=\"color:#595959;\"> age: age,</font> <font style=\"color:#595959;\"> setName: function (name) {</font> <font style=\"color:#595959;\"> this.name = name</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> return p</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">var p1 = createPerson('Tom', 12)</font> <font style=\"color:#595959;\">var p2 = createPerson('JAck', 13)</font> <font style=\"color:#595959;\">console.log(p1)</font> <font style=\"color:#595959;\">console.log(p2)</font> <font style=\"color:#595959;\"> </script></font> 方式四: 自定义构造函数模式 套路: 自定义构造函数, 通过new创建对象 适用场景: 需要创建多个类型确定的对象 问题: 每个对象都有相同的数据, 浪费内存 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> function Person(name, age) {</font> <font style=\"color:#595959;\"> this.name = name</font> <font style=\"color:#595959;\"> this.age = age</font> <font style=\"color:#595959;\"> this.setName = function (name) {</font> <font style=\"color:#595959;\"> this.name = name</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">var p1 = new Person('Tom', 12)</font> <font style=\"color:#595959;\">var p2 = new Person('Tom2', 13)</font> <font style=\"color:#595959;\">console.log(p1, p1 instanceof Person)</font> <font style=\"color:#595959;\"> </script></font> 方式五: 构造函数+原型的组合模式 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上 适用场景: 需要创建多个类型确定的对象 <font style=\"color:#595959;\">function Person (name, age) {</font> <font style=\"color:#595959;\"> this.name = name</font> <font style=\"color:#595959;\"> this.age = age</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">Person.prototype.setName = function (name) {</font> <font style=\"color:#595959;\"> this.name = name</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">var p1 = new Person('Tom', 12)</font> <font style=\"color:#595959;\">var p2 = new Person('JAck', 23)</font> <font style=\"color:#595959;\">p1.setName('TOM3')</font> <font style=\"color:#595959;\">console.log(p1)</font> 方式六：class创建 （二）、继承模式 方式1: 原型链继承 套路 定义父类型构造函数 给父类型的原型添加方法 定义子类型的构造函数 创建父类型的实例对象赋值给子类型的原型 将子类型原型的构造属性设置为子类型 给子类型原型添加方法 创建子类型的对象: 可以调用父类型的方法 关键 子类型的原型为父类型的一个实例对象 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> //1、定义父类型构造函数</font> <font style=\"color:#595959;\"> function Father() {</font> <font style=\"color:#595959;\"> this.superProp = \"The super prop\";</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">//2、给父类型的原型添加方法</font> <font style=\"color:#595959;\">Father.prototype.showFatherProp = function () {</font> <font style=\"color:#595959;\"> console.log(this.superProp);</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">// 3、定义子类型的构造函数</font> <font style=\"color:#595959;\">function Son() {</font> <font style=\"color:#595959;\"> this.SonProp = \"The Son prop\";</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">//4、 子类的原型为父类的实例*</font> <font style=\"color:#595959;\">Son.prototype = new Father();</font> <font style=\"color:#595959;\">//5、 修正Son.prototype.constructor为Son本身</font> <font style=\"color:#595959;\">Son.prototype.constructor = Son;</font> <font style=\"color:#595959;\">//console.log(Son.prototype.constructor);</font> <font style=\"color:#595959;\">//6、在子类原型上可以添加自己的方法</font> <font style=\"color:#595959;\">Son.prototype.showSonProp = function () {</font> <font style=\"color:#595959;\"> console.log(this.SonProp);</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">//7、 创建子类型的实例</font> <font style=\"color:#595959;\">var s = new Son();</font> <font style=\"color:#595959;\">// 调用父类型的方法</font> <font style=\"color:#595959;\">s.showSonProp();</font> <font style=\"color:#595959;\">// 调用子类型的方法</font> <font style=\"color:#595959;\">s.showFatherProp();</font> <font style=\"color:#595959;\"></script></font> 方式2: 借用构造函数继承(假的) 套路: 定义父类型构造函数 定义子类型构造函数 在子类型构造函数中调用父类型构造 关键: 在子类型构造函数中通用call()调用父类型构造函数 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> // 1、定义父类构造函数</font> <font style=\"color:#595959;\"> function Person(name, age) {</font> <font style=\"color:#595959;\"> this.name = name;</font> <font style=\"color:#595959;\"> this.age = age;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">// 2、定义子类构造函数</font> <font style=\"color:#595959;\">function Student(name, age, price) {</font> <font style=\"color:#595959;\"> //3、在子类型构造函数的内部调用父类型构造函数。</font> <font style=\"color:#595959;\"> Person.call(this, name, age);</font> <font style=\"color:#595959;\"> // this是Student的实例对象</font> <font style=\"color:#595959;\"> // console.log(this, \"this\");</font> <font style=\"color:#595959;\"> // 添加Student自己的属性</font> <font style=\"color:#595959;\"> this.price = price;</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">// 4、可以使用父类的属性</font> <font style=\"color:#595959;\">var s = new Student(\"Tom\", 20, 12000);</font> <font style=\"color:#595959;\">// console.log(s.name, s.age, s.price);</font> <font style=\"color:#595959;\"></script></font> 方式3: 原型链+借用构造函数的组合继承 利用原型链实现对父类型对象的方法继承 利用call()借用父类型构建函数初始化相同属性 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> // 1、定义父类构造函数</font> <font style=\"color:#595959;\"> function Person(name, age) {</font> <font style=\"color:#595959;\"> this.name = name;</font> <font style=\"color:#595959;\"> this.age = age;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> Person.prototype.setName = function (name) {</font> <font style=\"color:#595959;\"> this.name = name;</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //2、 定义子类构造函数</font> <font style=\"color:#595959;\"> function Student(name, age, price) {</font> <font style=\"color:#595959;\"> //3、得到父类型的属性</font> <font style=\"color:#595959;\"> Person.call(this, name, age);</font> <font style=\"color:#595959;\"> //3.1 添加子类自己的属性</font> <font style=\"color:#595959;\"> this.price = price;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 4、得到父类型的方法</font> <font style=\"color:#595959;\"> Student.prototype = new Person();</font> <font style=\"color:#595959;\"> // 5、修正constructor</font> <font style=\"color:#595959;\"> Student.prototype.constructor = Student;</font> <font style=\"color:#595959;\"> // 5.1 子类原型上自己的方法</font> <font style=\"color:#595959;\"> Student.prototype.setPrice = function (price) {</font> <font style=\"color:#595959;\"> this.price = price;</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> // 可以使用父类的属性和方法</font> <font style=\"color:#595959;\"> var s = new Student(\"Tom\", 12, 10000);</font> <font style=\"color:#595959;\"> s.setPrice(11000);</font> <font style=\"color:#595959;\"> s.setName(\"Bob\");</font> <font style=\"color:#595959;\"> console.log(s);</font> <font style=\"color:#595959;\"> console.log(s.constructor);</font> <font style=\"color:#595959;\"> </script></font> （一）、进程与线程 进程（process）： 程序的一次执行, 它占有一片独有的内存空间，可以通过windows任务管理器查看进程 线程（thread）： 是进程内的一个独立的执行单元， CPU的基本调度单位, 是程序执行的一个完整流程 进程与线程 一个进程中一般<font style=\"color:#FF0000;\">至少</font>有一个运行的线程: 主线程，进程启动后自动创建 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的 一个进程内的数据可以供其中的多个线程直接共享 多个进程之间的数据是不能直接共享的 线程池：保存多个线程对象的容器，实现线程对象的反复利用 多进程运行：一应用程序可以同时启动多个实例运行 多线程：在一个进程内，同时有多个线程运行 4.比较单线程与多线程 多线程 优点：能有效<font style=\"color:#FF0000;\">提升CPU</font>的<font style=\"color:#FF0000;\">利用率</font> 缺点：创建多线程开销/线程间切换开销/死锁与状态同步问题 单线程 优点：顺序变成<font style=\"color:#FF0000;\">简单易懂</font> 缺点：效率低 5、js是单线程运行 但在H5中的web workers可以是多线程运行 6、浏览器运行是单进程还是多进程? 有的是单进程 firefox 老版IE 有的是多进程 chrome 新版IE 浏览器运行都是多线程运行的 （二）、浏览器内核 什么是浏览器内核? 支持浏览器运行的最核心的程序 不同的浏览器可能不太一样 Chrome, Safari: webkit firefox: Gecko IE: Trident 360,搜狗等国内浏览器: Trident + webkit 内核由很多模块组成 html,css文档解析模块 : 负责页面文本的解析 dom/css模块 : 负责dom/css在内存中的相关处理 布局和渲染模块 : 负责页面的布局和效果的绘制 js引擎模块：负责js程序的编译与运行 定时器模块 : 负责定时器的管理 网络请求模块 : 负责服务器请求(常规/Ajax) 事件响应模块 : 负责事件的管理 ···· （三）、js单线程执行 1、为什么js要用单线程模式, 而不用多线程模式? JavaScript的单线程，<font style=\"color:#FF0000;\">与它的用途有关</font>。 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。 这决定了它只能是单线程，<font style=\"color:#FF0000;\">否则会带来很复杂的同步问题</font> 2、代码的分类: 初始化代码 回调代码 3、 js引擎执行代码的基本流程 先执行初始化代码: 包含一些特别的代码 设置定时器 绑定监听 发送ajax请求 后面在某个时刻才会执行回调代码 如何证明js执行是单线程的? setTimeout()的回调函数是在主线程执行的 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> setTimeout(function () {</font> <font style=\"color:#595959;\"> console.log('timeout 3')</font> <font style=\"color:#595959;\"> }, 3000)</font> <font style=\"color:#595959;\">setTimeout(function () {</font> <font style=\"color:#595959;\"> console.log('timeout 2')</font> <font style=\"color:#595959;\"> alert('2222')</font> <font style=\"color:#595959;\">}, 2000)</font> <font style=\"color:#595959;\">alert('提示...')//暂停当前住线程的执行，同时暂停计时，恢复程序后，继续计时</font> <font style=\"color:#595959;\">console.log('alert之后')</font> <font style=\"color:#595959;\"> </script></font> （四）、定时器 定时器真是定时执行的吗? 定时器并不能保证真正定时执行 一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受) <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> document.getElementById('btn').onclick = function () {</font> <font style=\"color:#595959;\"> var start = Date.now() </font> <font style=\"color:#595959;\"> console.log('启动定时器前')</font> <font style=\"color:#595959;\"> setTimeout(function () {</font> <font style=\"color:#595959;\"> console.log('定时器执行了: ', Date.now()-start)</font> <font style=\"color:#595959;\"> }, 100)</font> <font style=\"color:#595959;\"> //定时器启动之后做一个长时间的工作</font> <font style=\"color:#595959;\"> for (var i = 0; i < 1000000000; i++) {</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log('完成长时间工作', Date.now()-start)</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 定时器回调函数是在分线程执行的吗? 在主线程执行的, js是单线程的 定时器是如何实现的? 事件循环模型 （五）、事件循环模型 所有代码分类 初始化执行代码(<font style=\"color:#FF0000;\">同步代码</font>):包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码 回调执行代码(<font style=\"color:#FF0000;\">异步代码</font>): 处理回调逻辑 dom事件，定时器，延时器 ajax,promise js引擎执行代码的基本流程: 初始化代码===>回调代码 <font style=\"color:#595959;\"><script type=\"text/javascript\"></font> <font style=\"color:#595959;\"> function fn1() {</font> <font style=\"color:#595959;\"> console.log('fn1()')</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">fn1()</font> <font style=\"color:#595959;\">document.getElementById('btn').onclick = function () {</font> <font style=\"color:#595959;\"> console.log('处理点击事件')</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">setTimeout(function () {</font> <font style=\"color:#595959;\"> console.log('到点了')</font> <font style=\"color:#595959;\">}, 2000)</font> <font style=\"color:#595959;\">function fn2() {</font> <font style=\"color:#595959;\"> console.log('fn2()')</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">fn2()</font> <font style=\"color:#595959;\"> </script></font> 模型的2个重要组成部分: 事件管理模块 回调队列 模型的运转流程 执行初始化代码, 将事件回调函数交给对应模块管理 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行 重要概念： 执行栈：execution stack 所有的代码都在此空间中执行 浏览器内核：browser core js引擎模块（在主线程处理）其他模块（在主/分线程处理） 任务队列（task queue）/消息队列（message queue）/事件队列（event loop） 同一个callback queue 事件轮询 (event loop）从任务队列中循环取出毁掉函数放入执行栈中处理（一个接一个） 事件驱动模型 ：下面的整张图的流程 请求响应模型 ：浏览器请求数据，服务器接受请求，处理请求，返回数据，浏览器展示数据 （六）、H5 Web Workers 多线程 1、介绍 Web Workers是H5提供的一个js多线程解决方案 我们可以将一些大计算量的代码交给web worker运行而不冻结用户界面，但子线程完全受主线程控制，且不得操作DOM，所以，这个新标准并没有改变JS单线程的本质 2、使用 创建在分线程执行的js文件 在主线程中的js中发消息并设置回调 3、图解 4、不足 不能跨域加载js worker内代码不能访问DOM 不是每个浏览器都支持这个新特性 不会堵塞主线程，传给分线程额外运算，效率会慢一些 1、数据类型 数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和对象数据类型。 <font style=\"color:#F33232;\">基本数据</font>类型的特点：直接存储在<font style=\"color:#FF0000;\">栈</font>(stack)中的数据 <font style=\"color:#F33232;\">引用数据</font>类型的特点：<font style=\"color:#FF0000;\">存</font>储的是<font style=\"color:#FF0000;\">该对象</font>在<font style=\"color:#FF0000;\">栈</font>中<font style=\"color:#FF0000;\">引用</font>，<font style=\"color:#FF0000;\">真实</font>的<font style=\"color:#FF0000;\">数据存</font>放在<font style=\"color:#FF0000;\">堆</font>内存里 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 2、深浅拷贝的区别 深浅拷贝主要区别在复杂数据类型，对于基本数据类型，没有区别，改变拷贝的数据，都不会改变原数据 浅拷贝（shallow copy）： 浅拷贝只拷贝引用（地址值），当拷贝的新对象发生改变时，原对象也会发生相同的改变，也就是说，<font style=\"color:#FF0000;\">浅拷贝会影响原来的元素</font> 深拷贝（deep copy）： 每一级的数据都会拷贝，拷贝后，<font style=\"color:#FF0000;\">两个对象拥有不同的地址</font>，当拷贝出来的对象发生改变时，原对象内容不会改变，<font style=\"color:#FF0000;\">两者互不影响</font> 3、实现浅拷贝 （1）、直接赋值法： <font style=\"color:#595959;\">var arr = [1,2,3]</font> <font style=\"color:#595959;\">var newarr = arr;</font> <font style=\"color:#595959;\">newarr[1] = 5;</font> <font style=\"color:#595959;\">console.log(arr,newarr);//[1, 5, 3]，[1, 5, 3]</font> (2)、Object.assign() Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是<font style=\"color:#FF0000;\">浅拷贝</font>，<font style=\"color:#FF0000;\">拷贝</font>的是<font style=\"color:#FF0000;\">对象</font>的属性的<font style=\"color:#FF0000;\">引用</font>，而不是对象本身。 Object.assign(target, ...sources) target：目标对象，即接收源对象属性的对象。该对象会被修改并返回。 ...sources：一个或多个源对象，包含了要复制到目标对象的属性。可以传入多个源对象，用逗号分隔。 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> // 1.Object.assign()</font> <font style=\"color:#595959;\"> var obj = {</font> <font style=\"color:#595959;\"> name: \"jack\",</font> <font style=\"color:#595959;\"> age: 18,</font> <font style=\"color:#595959;\"> person: {</font> <font style=\"color:#595959;\"> name: \"tim\",</font> <font style=\"color:#595959;\"> age: 28,</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">//将{}和obj合并，返回一个新的obj对象</font> <font style=\"color:#FF0000;\">var objNew = Object.assign({}, obj);</font> <font style=\"color:#595959;\">objNew.name = \"tom\";//当object只有一层的时候，是深拷贝</font> <font style=\"color:#595959;\">objNew.person.name = \"Diana\";//当object只有一层的时候，是浅拷贝</font> <font style=\"color:#595959;\">console.log(obj, \"obj\");</font> <font style=\"color:#595959;\">console.log(objNew, \"objNew\");</font> <font style=\"color:#595959;\"></script></font> （3）、<font style=\"color:#4D4D4D;\">Array.prototype.concat()</font> <font style=\"color:#000000;\">数组的concat方法 用途: 合并2个或多个数组，返回一个</font><font style=\"color:#FF0000;\">浅拷贝对象</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //3、Array.prototype.concat()</font> <font style=\"color:#595959;\"> var arr2 = [1, \"hello\", { usename: \"tom\" }];</font> <font style=\"color:#595959;\">var arr3 = arr2.concat();</font> <font style=\"color:#595959;\">arr2[2].usename = \"tim\";</font> <font style=\"color:#595959;\">console.log(arr2[2].usename, \"arr2\"); //tim</font> <font style=\"color:#595959;\">console.log(arr3[2].usename, \"arr3\"); //tim</font> <font style=\"color:#595959;\"></script></font> <font style=\"color:#555666;\">(4)</font>Array.prototype.slice() slice(start, end); start为起始元素位置，end为截止元素位置， <font style=\"color:#595959;\">var arr4 = [1, \"hello\", { usename: \"tom\" }];</font> <font style=\"color:#595959;\">var arr5 = arr4.slice();</font> <font style=\"color:#595959;\">arr4[2].usename = \"diana\";</font> <font style=\"color:#595959;\">//console.log(arr4[2].usename, \"arr4\"); //diana</font> <font style=\"color:#595959;\">//console.log(arr5[2].usename, \"arr5\"); //diana</font> <font style=\"color:#FF0000;\">深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的</font><font style=\"color:#F33232;\">。</font> 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 4、实现深拷贝 （1）、Object.assign() <font style=\"color:#4D4D4D;\">当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //1、Object.assign();</font> <font style=\"color:#595959;\"> var obj = {</font> <font style=\"color:#595959;\"> //当object只有一层的时候，是深拷贝</font> <font style=\"color:#595959;\"> name: \"jack\",</font> <font style=\"color:#595959;\"> age: 18,</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">var objNew = Object.assign({}, obj);</font> <font style=\"color:#595959;\">objNew.name = \"tom\";</font> <font style=\"color:#595959;\">console.log(obj.name, \"obj\"); //jack</font> <font style=\"color:#595959;\">console.log(objNew.name, \"objNew\"); //tom</font> <font style=\"color:#595959;\"></script></font> （2）、<font style=\"color:#4D4D4D;\">JSON.parse(JSON.stringify())</font> 原理：用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝 <font style=\"color:#FF0000;\">注意：这种方法虽然可以实现数组或对象深拷贝,但不能处理函数</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> var arr1 = [</font> <font style=\"color:#595959;\"> 1,</font> <font style=\"color:#595959;\"> \"hello\",</font> <font style=\"color:#595959;\"> { usename: \"tom\" },</font> <font style=\"color:#595959;\"> function () {</font> <font style=\"color:#595959;\"> console.log(111);</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\">];</font> <font style=\"color:#595959;\">var arr2 = JSON.parse(JSON.stringify(arr1));</font> <font style=\"color:#595959;\">arr1[2].usename = \"diana\";</font> <font style=\"color:#595959;\">console.log(arr1[2].usename); //diana</font> <font style=\"color:#595959;\">console.log(arr2[2].usename); //tom</font> <font style=\"color:#595959;\">console.log(arr2[3]);//null</font> <font style=\"color:#595959;\"></script></font> （3）、<font style=\"color:#4D4D4D;\">手写递归方法</font> <font style=\"color:#FF0000;\">原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> function deepClone(oldData) {</font> <font style=\"color:#595959;\"> // 1、判断oldData的数据类型</font> <font style=\"color:#595959;\"> if (typeof oldData == \"object\" && oldData !== null) {</font> <font style=\"color:#595959;\"> // 3、再判断类型是否是数组，根据类型返回[],{}，开辟新的空间，放深拷贝数据</font> <font style=\"color:#595959;\"> var res = Array.isArray(oldData) ? [] : {};</font> <font style=\"color:#595959;\"> // 4、遍历数据，拿到属性，将属性值赋值给拷贝的数据</font> <font style=\"color:#595959;\"> for (var k in oldData) {</font> <font style=\"color:#595959;\"> // 5、判断这个k属性是否是oldData上自有的属性，原型链上的就不算了</font> <font style=\"color:#595959;\"> if (oldData.hasOwnProperty(k)) {</font> <font style=\"color:#595959;\"> // 6、对象有可能是嵌套对象，所以，需要递归再进行判断，一层层，直到拷贝了所有的数据</font> <font style=\"color:#595959;\"> res[k] = deepClone(oldData[k]);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> return res;</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> // 2、如果不是对象或数组，则返回原数据</font> <font style=\"color:#595959;\"> return oldData;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">// 测试：</font> <font style=\"color:#595959;\">let obj = {</font> <font style=\"color:#595959;\"> name: \"jack\",</font> <font style=\"color:#595959;\"> age: 18,</font> <font style=\"color:#595959;\"> hobby: [\"song\", \"run\"],</font> <font style=\"color:#595959;\"> sayHi(msg) {</font> <font style=\"color:#595959;\"> console.log(msg);</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">let newObj = deepClone(obj);</font> <font style=\"color:#595959;\">// obj.sayHi(\"hi\");</font> <font style=\"color:#595959;\">// newObj.sayHi(\"hello\");</font> <font style=\"color:#595959;\">newObj.name = \"tom\";</font> <font style=\"color:#595959;\">newObj.hobby = [\"唱歌\", \"跑步\"];</font> <font style=\"color:#595959;\">console.log(obj, \"obj\");</font> <font style=\"color:#595959;\">console.log(newObj, \"newObj\");</font> <font style=\"color:#595959;\"></script></font> （4）、通过jQuery的extend方法实现深拷贝 <font style=\"color:#595959;\">var array = [1,2,3,4];</font> <font style=\"color:#595959;\"> var newArray = $.extend(true,[],array);</font> （5）、lodash函数库实现深拷贝 lodash很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝 1、节流和防抖的目的： 都是为了<font style=\"color:#FF0000;\">限制函数的执行频次</font>，以优化函数触发频率过高导致的响应速度跟不上触发频率，防止在短时间内频繁触发同一事件而出现延迟，假死或卡顿的现象 2、节流和防抖的区别： 防抖：如果不断在delay之前重新触发，那么定时器会不断重新计时，最终会在<font style=\"color:#FF0000;\">最后一次完后才执行</font> 节流：目前有一事件A设置了定时器，那么在delay之前触发，都<font style=\"color:#FF0000;\">只会触发一次</font> 3、节流和防抖的详解 <font style=\"color:#FF0001;\">（1）、防抖 debounce</font>（设置1分钟只会执行一次，如果1分钟内又多次触发，会从再次触发开始重新计算1分钟时间，然后再执行） 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间 本质：将多次执行变为最后一次执行<font style=\"color:#FF0001;\">(重新执行)</font> 举例：<font style=\"color:#000000;\">比如我们平时在使用搜索框时，我们一输入内容就会发送对应的网络请求，如果我们后面一直有在输入内容，那么就会一直发送网络请求。正确的做法应该是在我们输入期间不发送网络请求，当我们输入完成后在发送网络请求。</font> <font style=\"color:#FF0001;\">（2）、节流 throttle（</font>设置1分钟只会执行一次，一分钟内，多次触发无效，必须等1分钟后才能触发函数） 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率 本质：将多次执行变成每隔一段时间执行<font style=\"color:#FF0001;\">（不能打断我）</font> 举例：比如我们在玩LOL游戏时，当需要回城时，我们触发回城按钮，进入到回城状态进会有一个等待的时间，如果在这个等待时间内有重复去执行回城按钮，这时回城状态并不会做出其他响应，而是等时间到了后才会完成回城。这也说明了，在我们回城的过程中，一直触发回城按钮都是不会响应的，他会按照自己的一个回城时间才做出响应。 4、代码实现简单防抖与节流 4.1、防抖 （1）、简单版（掌握） <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- 防抖函数 debounce --></font> <font style=\"color:#595959;\"> <input type=\"text\" name=\"\" id=\"\" /></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var int = document.querySelector(\"input\");</font> <font style=\"color:#595959;\">function inputChange() {</font> <font style=\"color:#595959;\"> console.log(this.value);</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">// 不加防抖函数，不断的输出</font> <font style=\"color:#595959;\">//int.addEventListener(\"keyup\", inputChange);</font> <font style=\"color:#595959;\">//加入防抖函数，1秒钟输出一次</font> <font style=\"color:#595959;\">var intVal = debounce(inputChange, 1000);</font> <font style=\"color:#595959;\">int.addEventListener(\"keyup\", intVal);</font> <font style=\"color:#595959;\">//防抖函数</font> <font style=\"color:#595959;\">function debounce(fn, delay) {</font> <font style=\"color:#595959;\"> // 1、定义一个定时器，保存上一次的定时器</font> <font style=\"color:#595959;\"> var timer = null;</font> <font style=\"color:#595959;\"> // 2、真正执行的函数</font> <font style=\"color:#595959;\"> var _debounce = function () {</font> <font style=\"color:#595959;\"> //3、 取消上一次的定时器</font> <font style=\"color:#595959;\"> if (timer) clearTimeout(timer);</font> <font style=\"color:#595959;\"> //4、 保存this</font> <font style=\"color:#595959;\"> var _this = this;</font> <font style=\"color:#595959;\"> //5、 延迟执行</font> <font style=\"color:#595959;\"> timer = setTimeout(function () {</font> <font style=\"color:#595959;\"> //6、 让fn执行时，指向input</font> <font style=\"color:#595959;\"> fn.call(_this);</font> <font style=\"color:#595959;\"> }, delay);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> return _debounce;</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\"></script></font> <font style=\"color:#595959;\"> </body></font> （2）、this和参数实现（了解） <font style=\"color:#595959;\"><input type=\"text\" name=\"\" id=\"\" /></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var int = document.querySelector(\"input\");</font> <font style=\"color:#595959;\"> // 需求：输出输入的内容</font> <font style=\"color:#595959;\"> function inputChange() {</font> <font style=\"color:#595959;\"> console.log(this.value);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 不加防抖函数，不停的搜索</font> <font style=\"color:#595959;\"> // int.addEventListener(\"keyup\", inputChange);</font> <font style=\"color:#595959;\"> // 加入防抖函数</font> <font style=\"color:#595959;\"> int.addEventListener(\"keyup\", debounce(inputChange, 1000));</font> <font style=\"color:#595959;\"> // 防抖函数二：this和参数实现</font> <font style=\"color:#595959;\"> function debounce(fn, delay) {</font> <font style=\"color:#595959;\"> //console.log(this, \"debounce\"); //这里的this指向的是window</font> <font style=\"color:#595959;\"> // 1、定义一个定时器，保存上一次的定时器</font> <font style=\"color:#595959;\"> var timer = null;</font> <font style=\"color:#595959;\"> // 2、真正执行的函数,传入参数</font> <font style=\"color:#595959;\"> return function (...ages) {</font> <font style=\"color:#595959;\"> //3、保存this,此时的this指向的是input</font> <font style=\"color:#595959;\"> var _this = this;</font> <font style=\"color:#595959;\"> // 4、判断定时器是否存在，清楚定时器</font> <font style=\"color:#595959;\"> if (timer) clearTimeout(timer);</font> <font style=\"color:#595959;\"> // 重新调用setTimerout</font> <font style=\"color:#595959;\"> timer = setTimeout(function () {</font> <font style=\"color:#595959;\"> //console.log(this);//定时器里的this指向widow</font> <font style=\"color:#595959;\"> // fn()直接执行，this指向window</font> <font style=\"color:#595959;\"> fn.apply(_this, ages);</font> <font style=\"color:#595959;\"> timer = null;</font> <font style=\"color:#595959;\"> }, delay);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"></script></font> （3）、立即执行（了解） <font style=\"color:#595959;\"><input type=\"text\" name=\"\" id=\"\" value=\"你好\" /></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var int = document.querySelector(\"input\");</font> <font style=\"color:#595959;\">// 需求：输出输入的内容</font> <font style=\"color:#595959;\">function inputChange() {</font> <font style=\"color:#595959;\"> console.log(this.value);</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">// 不加防抖函数，不停的搜索</font> <font style=\"color:#595959;\">// int.addEventListener(\"keyup\", inputChange);</font> <font style=\"color:#595959;\">// 加入防抖函数</font> <font style=\"color:#595959;\">int.addEventListener(\"keyup\", debounce(inputChange, 1000, true));</font> <font style=\"color:#595959;\">// int.addEventListener(\"keyup\", debounce(inputChange, 1000, false));</font> <font style=\"color:#595959;\">// 防抖函数三：立即执行</font> <font style=\"color:#595959;\">//创建一个防抖函数debounce</font> <font style=\"color:#595959;\">function debounce(fn, delay, immediate = false) {</font> <font style=\"color:#595959;\"> // 1.定义一个定时器, 保存上一次的定时器</font> <font style=\"color:#595959;\"> let timer = null;</font> <font style=\"color:#595959;\"> let isInvoke = false;</font> <font style=\"color:#595959;\"> // 2.真正执行的函数</font> <font style=\"color:#595959;\"> const _debounce = function (...ages) {</font> <font style=\"color:#595959;\"> // 取消上一次的定时器</font> <font style=\"color:#595959;\"> if (timer) clearTimeout(timer);</font> <font style=\"color:#595959;\"> // 判断是否需要立即执行</font> <font style=\"color:#595959;\"> if (immediate && !isInvoke) {</font> <font style=\"color:#595959;\"> fn.apply(this, ages);</font> <font style=\"color:#595959;\"> isInvoke = true;</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> // 延迟执行</font> <font style=\"color:#595959;\"> timer = setTimeout(() => {</font> <font style=\"color:#595959;\"> // 外部传入的真正要执行的函数</font> <font style=\"color:#595959;\"> fn.apply(this, ages);</font> <font style=\"color:#595959;\"> isInvoke = false;</font> <font style=\"color:#595959;\"> }, delay);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> return _debounce;</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\"></script></font> 4.2、节流 （1）、时间戳版 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- 需求：在快速点击的过程中，降低日志打印的频率，1s中执行一次 --></font> <font style=\"color:#595959;\"> <button>点我试试</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var btn = document.querySelector(\"button\");</font> <font style=\"color:#595959;\"> var fn = function () {</font> <font style=\"color:#595959;\"> console.log(\"发送请求\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> // 问题：快速点击按钮，只要点了一次，日志就打印一次</font> <font style=\"color:#595959;\"> // btn.addEventListener(\"click\", fn);</font> <font style=\"color:#595959;\"> // 添加节流函数，在2s内，多次点击，只执行一次</font> <font style=\"color:#595959;\"> btn.addEventListener(\"click\", throttle(fn, 2000));</font> <font style=\"color:#595959;\"> //参数： fn 真正执行的函数，interval 多久执行一次</font> <font style=\"color:#595959;\"> function throttle(fn, interval) {</font> <font style=\"color:#595959;\"> // 1、记录上一次的开始时间</font> <font style=\"color:#595959;\"> var lastTime = 0;</font> <font style=\"color:#595959;\"> // 2、事件触发时，真正执行的函数</font> <font style=\"color:#595959;\"> var _throttle = function () {</font> <font style=\"color:#595959;\"> // 2.1获取当前事件触发时的时间</font> <font style=\"color:#595959;\"> var nowTime = new Date().getTime();</font> <font style=\"color:#595959;\"> // 2.2使用规定好的时间间隔减去当前时间和上一次触发时间的时间间隔，得到多少时间再次触发</font> <font style=\"color:#595959;\"> var remainTime = interval - (nowTime - lastTime);</font> <font style=\"color:#595959;\"> if (remainTime <= 0) {</font> <font style=\"color:#595959;\"> // 2.3触发真正函数</font> <font style=\"color:#595959;\"> fn();</font> <font style=\"color:#595959;\"> // 2.4 保留上次触发的时间</font> <font style=\"color:#595959;\"> lastTime = nowTime;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> return _throttle;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> （2）、定时器版（掌握） <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <!-- 需求：在快速点击的过程中，降低日志打印的频率，1s中执行一次 --></font> <font style=\"color:#595959;\"> <button>点我试试</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var btn = document.querySelector(\"button\");</font> <font style=\"color:#595959;\"> var fn = function () {</font> <font style=\"color:#595959;\"> console.log(\"发送请求\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> // 问题：快速点击按钮，只要点了一次，日志就打印一次</font> <font style=\"color:#595959;\"> // btn.addEventListener(\"click\", fn);</font> <font style=\"color:#595959;\"> // 添加节流函数，在2s内，多次点击，只执行一次</font> <font style=\"color:#595959;\"> btn.addEventListener(\"click\", throttle(fn, 2000));</font> <font style=\"color:#595959;\"> //参数： fn 真正执行的函数，interval 多久执行一次</font> <font style=\"color:#595959;\"> // 定时器方式</font> <font style=\"color:#595959;\"> function throttle(fn, delay) {</font> <font style=\"color:#595959;\"> //1、设置标志，判断函数是否执行</font> <font style=\"color:#595959;\"> var sign = true;</font> <font style=\"color:#595959;\"> return function () {</font> <font style=\"color:#595959;\"> //2、 在函数开头判断标志是否为 true，不为 true 则中断函数</font> <font style=\"color:#595959;\"> if (!sign) return;</font> <font style=\"color:#595959;\"> //3、 sign 设置为 false，防止执行之前再被执行</font> <font style=\"color:#595959;\"> sign = false;</font> <font style=\"color:#595959;\"> //4、 保存this</font> <font style=\"color:#595959;\"> var _this = this;</font> <font style=\"color:#595959;\"> setTimeout(function () {</font> <font style=\"color:#595959;\"> //5、 this是当前被点击的dom元素，button</font> <font style=\"color:#595959;\"> fn.apply(_this, arguments);</font> <font style=\"color:#595959;\"> //6、 执行完事件之后，重新将这个标志设置为 true</font> <font style=\"color:#595959;\"> sign = true;</font> <font style=\"color:#595959;\"> }, delay);</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> 5、节流的应用场景 防抖 表单元素的校验，如手机号，邮箱，用户名等，部分搜索功能的模糊查询结果实现 搜索框搜素输入 文本编辑器实时保存 节流 高频事件，例如快速点击、鼠标滑动、resize事件、scroll事件 下拉加载 视频播放记录时间等 （一）、懒加载 1.什么是懒加载？ 懒加载也就是延迟加载。当访问一个页面的时候，先把img元素或是其他元素的背景图片路径替换成一张大小为1*1px图片的路径（这样就只需请求一次，俗称<font style=\"color:#FF0000;\">占位图</font>），只有当图片出现在浏览器的<font style=\"color:#FF0000;\">可视区域</font>内时，才<font style=\"color:#FF0000;\">设置</font>图片<font style=\"color:#FF0000;\">真正</font>的<font style=\"color:#FF0000;\">路径</font>，让图片显示出来。这就是图片懒加载。 2.为什么要使用懒加载？ 很多页面，内容很丰富，页面很长，图片较多。比如说各种商城页面。这些页面图片数量多，而且比较大，少说百来K，多则上兆。要是页面载入就一次性加载完毕。估计大家都会等到黄花变成黄花菜了。 3.懒加载的优点是什么？ 页面加载速度快、可以减轻服务器的压力、节约了流量,用户体验好 4.懒加载的原理是什么？ 页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片，只有通过javascript设置了图片路径，浏览器才会发送请求。 懒加载的原理就是先在页面中把所有的图片统一使用一张占位图进行占位，把<font style=\"color:#FF0000;\">真正的路径存在元素的</font>“data-url”（这个名字起个自己认识好记的就行）<font style=\"color:#FF0000;\">属性</font>里，要<font style=\"color:#FF0000;\">用</font>的<font style=\"color:#FF0000;\">时</font>候就<font style=\"color:#FF0000;\">取出</font>来，再设置； 5.懒加载的实现步骤？ 1）首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。 2)页面加载完成后，判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。 6、懒加载实现方式 html结构 1、 <font style=\"color:#FF0000;\">obj.getAttribute(\"属性名\")</font>通过元素节点的属性名称<font style=\"color:#FF0000;\">获取属性的值</font>。 2、使用data-前缀设置我们需要的自定义属性,来进行一些数据的存放, <font style=\"color:#FF0000;\">dataset </font>获取<font style=\"color:#FF0000;\">自定义属性值</font>的使用 <font style=\"color:#595959;\"><ul></font> <font style=\"color:#595959;\"> <li></font> <font style=\"color:#595959;\"> <img data-src=\"./img/img1.gif\" src=\"./img/loading.gif\" alt=\"\" /></font> <font style=\"color:#595959;\"> </li></font> <font style=\"color:#595959;\"> <li></font> <font style=\"color:#595959;\"> <img data-src=\"./img/img2.gif\" src=\"./img/loading.gif\" alt=\"\" /></font> <font style=\"color:#595959;\"> </li></font> <font style=\"color:#595959;\"> <li></font> <font style=\"color:#595959;\"> <img data-src=\"./img/img3.gif\" src=\"./img/loading.gif\" alt=\"\" /></font> <font style=\"color:#595959;\"> </li></font> <font style=\"color:#595959;\"> <li></font> <font style=\"color:#595959;\"> <img data-src=\"./img/img4.gif\" src=\"./img/loading.gif\" alt=\"\" /></font> <font style=\"color:#595959;\"> </li></font> <font style=\"color:#595959;\"> <li></font> <font style=\"color:#595959;\"> <img data-src=\"./img/img5.png\" src=\"./img/loading.gif\" alt=\"\" /></font> <font style=\"color:#595959;\"> </li></font> <font style=\"color:#595959;\"> </ul></font> 第一种 <font style=\"color:#FF0000;\">元素距顶部的高度 - 页面被卷去的高度 <= 浏览器可视区的高度</font> 来判断是否符合我们想要的条件.需要实时监听页面滚动时 图片的高度变化 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> window.onload = function () {</font> <font style=\"color:#595959;\"> var imgs = document.querySelectorAll(\"img\");</font> <font style=\"color:#595959;\"> // 初始化执行</font> <font style=\"color:#595959;\"> lazyLoad(imgs);</font> <font style=\"color:#595959;\"> // 滚动执行</font> <font style=\"color:#595959;\"> window.addEventListener(\"scroll\", function () {</font> <font style=\"color:#595959;\"> lazyLoad(imgs);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> function lazyLoad(imgs) {</font> <font style=\"color:#595959;\"> for (let i = 0; i < imgs.length; i++) {</font> <font style=\"color:#595959;\"> var imgoffsetT = imgs[i].offsetTop; // 图片的距顶部的高度</font> <font style=\"color:#595959;\"> var wheight = window.innerHeight; // 浏览器可视区的高度</font> <font style=\"color:#595959;\"> var scrollT = document.documentElement.scrollTop; // 页面被卷去的高度</font> <font style=\"color:#595959;\"> if (imgoffsetT - scrollT <= wheight) {</font> <font style=\"color:#595959;\"> // 判断图片是否将要出现</font> <font style=\"color:#595959;\"> imgs[i].src = imgs[i].dataset.src; // 出现后将自定义地址转为真实地址</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> 第二种 <font style=\"color:#FF0000;\">getBoundingClientRect()</font> ——获取元素位置，这个方法没有参数 ——<font style=\"color:#FF0000;\">用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置</font>。 ——是DOM元素到浏览器可视范围的距离（不包含文档卷起的部分）。 该函数<font style=\"color:#FF0000;\">返回</font>一个Object<font style=\"color:#FF0000;\">对象</font>，该对象有6个属性：top,lef,right,bottom,width,height； <font style=\"color:#595959;\">window.onload = function () {</font> <font style=\"color:#595959;\"> var imgs = document.querySelectorAll(\"img\");</font> <font style=\"color:#595959;\"> // 初始调动一次</font> <font style=\"color:#595959;\"> lazyLoad();</font> <font style=\"color:#595959;\"> // 监听滚动时，再调用函数</font> <font style=\"color:#595959;\"> window.addEventListener(\"scroll\", throttle(lazyLoad, 1000), false);</font> <font style=\"color:#595959;\"> //函数1:封装判定图片是否在可视区</font> <font style=\"color:#595959;\"> function isInVisibleArea(imgOne) {</font> <font style=\"color:#595959;\"> const info = imgOne.getBoundingClientRect();</font> <font style=\"color:#595959;\"> // 获取页面可视区的高度，宽度</font> <font style=\"color:#595959;\"> let windowH = window.innerHeight;</font> <font style=\"color:#595959;\"> let windowW = window.innerWidth;</font> <font style=\"color:#595959;\"> // 限定参数在可视区内</font> <font style=\"color:#595959;\"> let res = info.bottom > 0 && info.top < windowH && info.right > 0 && info.left < windowW;</font> <font style=\"color:#595959;\"> return res;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //函数2: 封装滚动时重新加载函数</font> <font style=\"color:#595959;\"> function lazyLoad() {</font> <font style=\"color:#595959;\"> for (let i = 0; i < imgs.length; i++) {</font> <font style=\"color:#595959;\"> const imgOne = imgs[i];</font> <font style=\"color:#595959;\"> // 判定是否在可视区内</font> <font style=\"color:#595959;\"> if (isInVisibleArea(imgOne)) {</font> <font style=\"color:#595959;\"> // 替换src方法一：</font> <font style=\"color:#595959;\"> // imgOne.src = imgOne.getAttribute(\"data-src\");</font> <font style=\"color:#595959;\"> // 替换src方法二：</font> <font style=\"color:#595959;\"> imgOne.src = imgOne.dataset.src;</font> <font style=\"color:#595959;\"> // imgs.splice(i,1)</font> <font style=\"color:#595959;\"> // i--;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> console.log(\"我滚了\"); //滚动就出发，要做节流操作</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> //函数3:节流函数</font> <font style=\"color:#595959;\"> function throttle(fn, time = 250) {</font> <font style=\"color:#595959;\"> let lastTime = null;</font> <font style=\"color:#595959;\"> return function (...args) {</font> <font style=\"color:#595959;\"> const now = Date.now(); //当前时间</font> <font style=\"color:#595959;\"> if (now - lastTime >= time) {</font> <font style=\"color:#595959;\"> fn(); //帮助执行函数，改变上下文</font> <font style=\"color:#595959;\"> lastTime = now;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">};</font> 第三种 <font style=\"color:#FF0000;\">IntersectionObserver(callback) </font> <font style=\"color:#FF0000;\">callback函数会触发两次，元素进入视窗（开始可见时）和元素离开视窗（开始不可见时）都会触发</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> const imgs = document.querySelectorAll(\"img\");</font> <font style=\"color:#595959;\"> var callback = function (res) {</font> <font style=\"color:#595959;\"> //res 是观察的元素数组 info 每个被观察的图片信息</font> <font style=\"color:#595959;\"> res.forEach(function (info) {</font> <font style=\"color:#595959;\"> // isIntersecting 目标是否被观察到，返回布尔值</font> <font style=\"color:#595959;\"> if (info.isIntersecting) {</font> <font style=\"color:#595959;\"> // img 就是当前的图片标签</font> <font style=\"color:#595959;\"> const img = info.target;</font> <font style=\"color:#595959;\"> img.src = img.getAttribute(\"data-src\");</font> <font style=\"color:#595959;\"> // 真实地址替换后 取消对它的观察</font> <font style=\"color:#595959;\"> obs.unobserve(img);</font> <font style=\"color:#595959;\"> // console.log(\"触发\");</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> // 实例化 IntersectionObserver</font> <font style=\"color:#595959;\"> const obs = new IntersectionObserver(callback);</font> <font style=\"color:#595959;\"> // 遍历imgs所有的图片，然后给每个图片添加观察实例</font> <font style=\"color:#595959;\"> imgs.forEach(function (img) {</font> <font style=\"color:#595959;\"> // observe : 被调用的IntersectionObserver实例。给每个图片添加观察实例</font> <font style=\"color:#595959;\"> obs.observe(img);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> （二）、预加载 1.什么是预加载 资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。预加载简单来说就是将所有<font style=\"color:#FF0000;\">所需的资源提前请求加载到本地</font>，这样后面在需要用到时就直接从缓存取资源。 2.为什么要用预加载 在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。 3、预加载实现方式 html结构 <font style=\"color:#595959;\"><!-- 需求：实现点击图片，切换下一张图片 --></font> <font style=\"color:#595959;\"> <div></font> <font style=\"color:#595959;\"> <p></p></font> <font style=\"color:#595959;\"> <img src=\"./img/img1.gif\" alt=\"\" /></font> <font style=\"color:#595959;\"> </div></font> js实现 <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> const imgs = [\"./img/img2.gif\", \"./img/img3.gif\", \"./img/img4.gif\", \"./img/img5.png\"];</font> <font style=\"color:#595959;\"> const img = document.querySelector(\"img\");</font> <font style=\"color:#595959;\"> const test = document.querySelector(\"p\");</font> <font style=\"color:#595959;\"> //实现点击切换下一张图片</font> <font style=\"color:#595959;\"> let index = 0;</font> <font style=\"color:#595959;\"> test.innerHTML = \"我是第\" + (index + 1) + \"张图片\";</font> <font style=\"color:#595959;\"> img.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> if (index < imgs.length) {</font> <font style=\"color:#595959;\"> img.src = imgs[index];</font> <font style=\"color:#595959;\"> index++;</font> <font style=\"color:#595959;\"> test.innerHTML = \"我是第\" + (index + 1) + \"张图片\";</font> <font style=\"color:#595959;\"> }else{</font> <font style=\"color:#595959;\"> alert('没有了')</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 切换图片后，同时让浏览器提前加载下载一张图片</font> <font style=\"color:#595959;\"> if (index < imgs.length) {</font> <font style=\"color:#595959;\"> preLoad(imgs[index]);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> // 调用加载函数，页面一开始就加载数组第一个元素</font> <font style=\"color:#595959;\"> preLoad(imgs[0]);</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> // 封装函数，新建一个img标签，然后增加src属性，让浏览器加载下一张图片</font> <font style=\"color:#595959;\"> function preLoad(src) {</font> <font style=\"color:#595959;\"> img.addEventListener(\"load\", () => {</font> <font style=\"color:#595959;\"> // 创建一个新的img标签</font> <font style=\"color:#595959;\"> const img = document.createElement(\"img\");</font> <font style=\"color:#595959;\"> // 给img添加src属性，为我们传进来的src</font> <font style=\"color:#595959;\"> img.src = src;</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> （一）、ajax简介及相关知识 1、原生ajax 1.1、AJAX 简介 AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。 通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：<font style=\"color:#FF0001;\">无刷新获取数据。按需请求，可以提高网站的性能</font> AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。 使用场景： 注册账号，核对输入是否符合设置要求，发送ajax请求，返回相关信息 京东、淘宝下拉加载更多的数据显示 鼠标移入，显示新的页面数据 鼠标点击，显示不同的页面切换数据 ·············· 1.2 XML 简介 XML 可扩展标记语言。 XML 被设计用来传输和存储数据。 XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签， 全都是自定义标签，用来表示一些数据。 <font style=\"color:#000000;\">比如说我有一个学生数据：</font> <font style=\"color:#000000;\">name = \"孙悟空\" ; age = 18 ; gender = \"男\" ; </font> <font style=\"color:#000000;\">用 XML 表示： </font> <font style=\"color:#000000;\"><student> </font> <font style=\"color:#000000;\"><name>孙悟空</name> </font> <font style=\"color:#000000;\"><age>18</age> </font> <font style=\"color:#000000;\"><gender>男</gender> </font> <font style=\"color:#000000;\"></student> </font> <font style=\"color:#FF0001;\">现在已经被 JSON 取代了。 </font> <font style=\"color:#000000;\">用 JSON 表示： </font> <font style=\"color:#000000;\">{\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"} </font> <font style=\"color:#000000;\">1.3 AJAX 的特点 </font> <font style=\"color:#000000;\">1.3.1 AJAX 的优点 </font> <font style=\"color:#000000;\">1) 可以</font><font style=\"color:#FF0001;\">无需刷新页面</font><font style=\"color:#000000;\">而</font><font style=\"color:#FF0001;\">与服务器</font><font style=\"color:#000000;\">端进行</font><font style=\"color:#FF0001;\">通信</font><font style=\"color:#000000;\">。 速度很快</font> <font style=\"color:#000000;\">2) 允许你</font><font style=\"color:#FF0001;\">根据</font><font style=\"color:#000000;\">用户</font><font style=\"color:#FF0001;\">事件</font><font style=\"color:#000000;\">来</font><font style=\"color:#FF0001;\">更新部分页面</font><font style=\"color:#000000;\">内容。 按需更新，鼠标移入请求数据，鼠标点击请求数据</font> <font style=\"color:#000000;\">1.3.2 AJAX 的缺点 </font> <font style=\"color:#000000;\">1) 没有浏览历史，不能回退 </font> <font style=\"color:#000000;\">2) 存在跨域问题(同源) </font> <font style=\"color:#000000;\">3) SEO 不友好</font> <font style=\"color:#000000;\">2、HTTP</font> HTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间<font style=\"color:#FF0001;\">互相通信的规则</font>。（<font style=\"color:#FF0001;\">约定</font>, 规则） 2.1、请求报文 （重点关注格式与参数） 请求行 ：请求类型 url路径部分 请求版本) POST /s?ie=utf-8 HTTP/1.1 名字: 值 请求头 Host: bdqn.com Cookie: name=bdqn Content-type: application/x-www-form-urlencoded /请求类型 User-Agent: chrome 83 请求空行 请求体 <font style=\"color:#FF0001;\">get请求，请求体为空， post请求体可以不为空</font> username=admin&password=admin 404 找不到 403 被禁止 401 未授权 500 错误 200 正确ok 2.4、网站查看 3、node.js安装 https://nodejs.org/en 安装网址 检测是否安装 在开始的位置点开，输入cmd，点击命令提示符，在窗体里，输入node -v，出现版本信息 4、express框架 ajax发送请求，需要一个服务端，所以简单学习express 打开终端： npm init --yes 初始化 npm i express 安装express npm list express 查看版本 创建express.js文件，完成基本配置 <font style=\"color:#595959;\">//1. 引入express</font> <font style=\"color:#595959;\">const express = require('express');</font> <font style=\"color:#595959;\">//2. 创建应用对象</font> <font style=\"color:#595959;\">const app = express();</font> <font style=\"color:#595959;\">//3. 创建路由规则</font> <font style=\"color:#595959;\">// request 是对请求报文的封装</font> <font style=\"color:#595959;\">// response 是对响应报文的封装</font> <font style=\"color:#595959;\">app.get('/', (request, response)=>{</font> <font style=\"color:#595959;\"> //设置响应</font> <font style=\"color:#595959;\"> response.send('HELLO EXPRESS');</font> <font style=\"color:#595959;\">});</font> <font style=\"color:#595959;\">//4. 监听端口启动服务</font> <font style=\"color:#595959;\">app.listen(8000, ()=>{</font> <font style=\"color:#595959;\"> console.log(\"服务已经启动, 8000 端口监听中....\");</font> <font style=\"color:#595959;\">});</font> 启动express 在终端输入： node 文件名 如：node express基本使用.js 在浏览器地址栏：http://127.0.0.1:8000/，可以显示响应文本 释放8000窗口，ctrl+C （4）、nodemon安装 可以帮助自动重启express后台服务器 https://www.npmjs.com/package/nodemon npm install -g nodemon 安装完毕，重启severs.js 启动命令 nodemon severs.js （二）、原生ajax实现 1、页面及服务器准备 （1）、页面准备 需求：点击按钮，发送请求，将响应体结果返回在div中 <font style=\"color:#595959;\"><button>点击发送请求</button></font> <font style=\"color:#595959;\"> <div id=\"result\"></div></font> （2）、服务器准备 新建server.js文件 <font style=\"color:#595959;\">//1. 引入express</font> <font style=\"color:#595959;\">const express = require(\"express\");</font> <font style=\"color:#595959;\">//2. 创建应用对象</font> <font style=\"color:#595959;\">const app = express();</font> <font style=\"color:#595959;\">//3. 创建路由规则</font> <font style=\"color:#595959;\">// server 请求行的url有/server，就回执行对应函数</font> <font style=\"color:#595959;\">app.get(\"/server\", (request, response) => {</font> <font style=\"color:#595959;\"> //设置响应头 设置允许跨域</font> <font style=\"color:#595959;\"> //Access-Control-Allow-Origin 响应头名字</font> <font style=\"color:#595959;\"> response.setHeader(\"Access-Control-Allow-Origin\", \"*\");</font> <font style=\"color:#595959;\"> //设置响应体</font> <font style=\"color:#595959;\"> response.send(\"你好，ajax\");</font> <font style=\"color:#595959;\">});</font> <font style=\"color:#595959;\">//4. 监听端口启动服务</font> <font style=\"color:#595959;\">app.listen(8000, () => {</font> <font style=\"color:#595959;\"> console.log(\"服务已经启动, 8000 端口监听中....\");</font> <font style=\"color:#595959;\">});</font> 2、ajax基本请求 （1）、get请求 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <button>点击发送请求</button></font> <font style=\"color:#595959;\"> <div id=\"result\"></div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //获取button元素</font> <font style=\"color:#595959;\"> const btn = document.querySelector(\"button\");</font> <font style=\"color:#595959;\"> const result = document.getElementById(\"result\");</font> <font style=\"color:#595959;\"> //绑定事件</font> <font style=\"color:#595959;\"> btn.onclick = function () {</font> <font style=\"color:#595959;\"> //1. 创建对象</font> <font style=\"color:#595959;\"> const xhr = new XMLHttpRequest();</font> <font style=\"color:#595959;\"> //2. 初始化 设置请求方法和 url 可以加参数</font> <font style=\"color:#595959;\"> xhr.open(\"GET\", \"http://127.0.0.1:8000/server?a=100&b=200&c=300\");</font> <font style=\"color:#595959;\"> //3. 发送</font> <font style=\"color:#595959;\"> xhr.send();</font> <font style=\"color:#595959;\"> //4. 事件绑定 处理服务端返回的结果</font> <font style=\"color:#595959;\"> // on 当....时候</font> <font style=\"color:#595959;\"> // readystate 是 xhr 对象中的属性, 表示状态 0 1 2 3 4</font> <font style=\"color:#595959;\"> // 0 表示初始化，1表示open()发送完毕 2 表示send()发送完毕 3 服务端返回部分结果 4 服务端返回所有的结果 </font> <font style=\"color:#595959;\"> // change 改变</font> <font style=\"color:#595959;\"> xhr.onreadystatechange = function () {</font> <font style=\"color:#595959;\"> //判断 (服务端返回了所有的结果)</font> <font style=\"color:#595959;\"> if (xhr.readyState === 4) {</font> <font style=\"color:#595959;\"> //判断响应状态码 200 404 403 401 500</font> <font style=\"color:#595959;\"> // 2xx 成功</font> <font style=\"color:#595959;\"> if (xhr.status >= 200 && xhr.status < 300) {</font> <font style=\"color:#595959;\"> //处理结果 行 头 空行 体</font> <font style=\"color:#595959;\"> //响应行 </font> <font style=\"color:#595959;\"> // console.log(xhr.status);//状态码</font> <font style=\"color:#595959;\"> // console.log(xhr.statusText);//状态字符串</font> <font style=\"color:#595959;\"> // console.log(xhr.getAllResponseHeaders());//所有响应头</font> <font style=\"color:#595959;\"> // console.log(xhr.response);//响应体</font> <font style=\"color:#595959;\"> //设置 result 的文本</font> <font style=\"color:#595959;\"> result.innerHTML = xhr.response;</font> <font style=\"color:#595959;\"> } else {</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> （2）、post请求 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <div id=\"result\"></div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //获取元素对象</font> <font style=\"color:#595959;\"> const result = document.getElementById(\"result\");</font> <font style=\"color:#595959;\"> //绑定事件</font> <font style=\"color:#595959;\"> result.addEventListener(\"mouseover\", function () {</font> <font style=\"color:#595959;\"> //1. 创建对象</font> <font style=\"color:#595959;\"> const xhr = new XMLHttpRequest();</font> <font style=\"color:#595959;\"> //2. 初始化 设置类型与 URL</font> <font style=\"color:#595959;\"> xhr.open(\"POST\", \"http://127.0.0.1:8000/server\");</font> <font style=\"color:#595959;\"> //5、 设置请求头 xhr.setRequestHeader(\"头的名字\", \"头的值\");</font> <font style=\"color:#595959;\"> // 用于做用户身份的校验</font> <font style=\"color:#595959;\"> // Content-Type 设置请求体内容类型</font> <font style=\"color:#595959;\"> // application/x-www-form-urlencoded 参数查询字符串类型，固定写法</font> <font style=\"color:#595959;\"> xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");</font> <font style=\"color:#595959;\"> //6、 自定义请求头信息，这个自定义的请求头，需要在server.js中设置所有头信息，都能接受</font> <font style=\"color:#595959;\"> xhr.setRequestHeader(\"name\", \"bdqn\");</font> <font style=\"color:#595959;\"> //3. 发送 可以传递参数，设置请求体</font> <font style=\"color:#595959;\"> xhr.send(\"a=100&b=200&c=300\");</font> <font style=\"color:#595959;\"> // xhr.send('a:100&b:200&c:300');</font> <font style=\"color:#595959;\"> // xhr.send('1233211234567');</font> <font style=\"color:#595959;\"> //4. 事件绑定</font> <font style=\"color:#595959;\"> xhr.onreadystatechange = function () {</font> <font style=\"color:#595959;\"> //判断</font> <font style=\"color:#595959;\"> if (xhr.readyState === 4) {</font> <font style=\"color:#595959;\"> if (xhr.status >= 200 && xhr.status < 300) {</font> <font style=\"color:#595959;\"> //处理服务端返回的结果</font> <font style=\"color:#595959;\"> result.innerHTML = xhr.response;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> server.js <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> //可以接收任意类型的请求</font> <font style=\"color:#595959;\"> app.all(\"/server\", (request, response) => {</font> <font style=\"color:#595959;\"> //设置响应头 设置允许跨域</font> <font style=\"color:#595959;\"> response.setHeader(\"Access-Control-Allow-Origin\", \"*\");</font> <font style=\"color:#595959;\"> //响应头 所有类型的头信息都可以接受</font> <font style=\"color:#595959;\"> response.setHeader(\"Access-Control-Allow-Headers\", \"*\");</font> <font style=\"color:#595959;\"> //设置响应体</font> <font style=\"color:#595959;\"> response.send(\"HELLO AJAX POST\");</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> （3）、JSON返回值 <font style=\"color:#595959;\"><div id=\"result\"></div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> const result = document.getElementById(\"result\");</font> <font style=\"color:#595959;\"> //绑定键盘按下事件</font> <font style=\"color:#595959;\"> window.onkeydown = function () {</font> <font style=\"color:#595959;\"> //1、发送请求</font> <font style=\"color:#595959;\"> const xhr = new XMLHttpRequest();</font> <font style=\"color:#595959;\"> //设置响应体数据的类型 响应数据自动转成json</font> <font style=\"color:#595959;\"> xhr.responseType = \"json\";</font> <font style=\"color:#595959;\"> //2、初始化</font> <font style=\"color:#595959;\"> xhr.open(\"GET\", \"http://127.0.0.1:8000/json-server\");</font> <font style=\"color:#595959;\"> //3、发送</font> <font style=\"color:#595959;\"> xhr.send();</font> <font style=\"color:#595959;\"> //4、事件绑定</font> <font style=\"color:#595959;\"> xhr.onreadystatechange = function () {</font> <font style=\"color:#595959;\"> if (xhr.readyState === 4) {</font> <font style=\"color:#595959;\"> if (xhr.status >= 200 && xhr.status < 300) {</font> <font style=\"color:#595959;\"> //这里返回的是一个字符串，需要转成对象</font> <font style=\"color:#595959;\"> // console.log(xhr.response);</font> <font style=\"color:#595959;\"> // result.innerHTML = xhr.response;</font> <font style=\"color:#595959;\"> // 1. 手动对数据转化</font> <font style=\"color:#595959;\"> // let data = JSON.parse(xhr.response);</font> <font style=\"color:#595959;\"> // console.log(data);</font> <font style=\"color:#595959;\"> // result.innerHTML = data.name;</font> <font style=\"color:#595959;\"> // 2. 自动转换</font> <font style=\"color:#595959;\"> console.log(xhr.response);</font> <font style=\"color:#595959;\"> result.innerHTML = xhr.response.name;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> </script></font> severs.js <font style=\"color:#595959;\">//JSON 响应</font> <font style=\"color:#595959;\">app.all(\"/json-server\", (request, response) => {</font> <font style=\"color:#595959;\"> //设置响应头 设置允许跨域</font> <font style=\"color:#595959;\"> response.setHeader(\"Access-Control-Allow-Origin\", \"*\");</font> <font style=\"color:#595959;\"> //响应头</font> <font style=\"color:#595959;\"> response.setHeader(\"Access-Control-Allow-Headers\", \"*\");</font> <font style=\"color:#595959;\"> //响应一个数据</font> <font style=\"color:#595959;\"> const data = {</font> <font style=\"color:#595959;\"> name: \"bdqn\",</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //对对象进行字符串转换</font> <font style=\"color:#595959;\"> let str = JSON.stringify(data);</font> <font style=\"color:#595959;\"> //设置响应体</font> <font style=\"color:#595959;\"> response.send(str);</font> <font style=\"color:#595959;\">});</font> 3、IE缓存问题处理（一般现在不需要额外处理） ie浏览器会对ajax请求的结果做一个缓存处理。产生的问题就是ajax的下一次请求，ie浏览器，就会走本地的缓存，而不是服务器返回的最新数据，这样对时效比较强的场景，ajax请求就会影响我们的结果。 <font style=\"color:#595959;\"><button>点击发送请求</button></font> <font style=\"color:#595959;\"> <div id=\"result\"></div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> const btn = document.querySelector(\"button\");</font> <font style=\"color:#595959;\"> const result = document.querySelector(\"#result\");</font> <font style=\"color:#595959;\"> btn.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> const xhr = new XMLHttpRequest();</font> <font style=\"color:#595959;\"> // 为了解决ie浏览器缓存的问题，在发送请求时，添加参数，当前时间戳</font> <font style=\"color:#595959;\"> xhr.open(\"GET\", \"http://127.0.0.1:8000/ie?t=\" + Date.now());</font> <font style=\"color:#595959;\"> xhr.send();</font> <font style=\"color:#595959;\"> xhr.onreadystatechange = function () {</font> <font style=\"color:#595959;\"> if (xhr.readyState === 4) {</font> <font style=\"color:#595959;\"> if (xhr.status >= 200 && xhr.status < 300) {</font> <font style=\"color:#595959;\"> result.innerHTML = xhr.response;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> server.js <font style=\"color:#595959;\">//针对 IE 缓存</font> <font style=\"color:#595959;\">app.get(\"/ie\", (request, response) => {</font> <font style=\"color:#595959;\"> //设置响应头 设置允许跨域</font> <font style=\"color:#595959;\"> response.setHeader(\"Access-Control-Allow-Origin\", \"*\");</font> <font style=\"color:#595959;\"> //设置响应体</font> <font style=\"color:#595959;\"> response.send(\"HELLO IE - 6\");</font> <font style=\"color:#595959;\">});</font> 4、超时与网络异常处理 <font style=\"color:#595959;\"><button>点击发送请求</button></font> <font style=\"color:#595959;\"> <div id=\"result\"></div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> const btn = document.querySelector(\"button\");</font> <font style=\"color:#595959;\">const result = document.querySelector(\"#result\");</font> <font style=\"color:#595959;\">btn.addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> const xhr = new XMLHttpRequest();</font> <font style=\"color:#595959;\"> //超时设置 2s 设置</font> <font style=\"color:#595959;\"> xhr.timeout = 2000;</font> <font style=\"color:#595959;\"> //超时回调</font> <font style=\"color:#595959;\"> xhr.ontimeout = function () {</font> <font style=\"color:#595959;\"> alert(\"网络异常, 请稍后重试!!\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //网络异常回调，断网的时候，会出现的提醒</font> <font style=\"color:#595959;\"> xhr.onerror = function () {</font> <font style=\"color:#595959;\"> alert(\"你的网络似乎出了一些问题!\");</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> xhr.open(\"GET\", \"http://127.0.0.1:8000/delay\");</font> <font style=\"color:#595959;\"> xhr.send();</font> <font style=\"color:#595959;\"> xhr.onreadystatechange = function () {</font> <font style=\"color:#595959;\"> if (xhr.readyState === 4) {</font> <font style=\"color:#595959;\"> if (xhr.status >= 200 && xhr.status < 300) {</font> <font style=\"color:#595959;\"> result.innerHTML = xhr.response;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\">});</font> <font style=\"color:#595959;\"></script></font> server.js <font style=\"color:#595959;\">//延时响应</font> <font style=\"color:#595959;\">app.all(\"/delay\", (request, response) => {</font> <font style=\"color:#595959;\"> //设置响应头 设置允许跨域</font> <font style=\"color:#595959;\"> response.setHeader(\"Access-Control-Allow-Origin\", \"*\");</font> <font style=\"color:#595959;\"> // 允许任何头类型，自带的还有自定义的</font> <font style=\"color:#595959;\"> response.setHeader(\"Access-Control-Allow-Headers\", \"*\");</font> <font style=\"color:#595959;\"> //为了测试服务器延迟响应到前台</font> <font style=\"color:#595959;\"> setTimeout(() => {</font> <font style=\"color:#595959;\"> //设置响应体</font> <font style=\"color:#595959;\"> response.send(\"延时响应\");</font> <font style=\"color:#595959;\"> }, 3000);</font> <font style=\"color:#595959;\">});</font> 5、ajax取消请求 abort() 取消请求 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <button>点击发送</button></font> <font style=\"color:#595959;\"> <button>点击取消</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //获取元素对象</font> <font style=\"color:#595959;\"> const btns = document.querySelectorAll(\"button\");</font> <font style=\"color:#595959;\">let x = null;</font> <font style=\"color:#595959;\">btns[0].onclick = function () {</font> <font style=\"color:#595959;\"> xhr = new XMLHttpRequest();</font> <font style=\"color:#595959;\"> xhr.open(\"GET\", \"http://127.0.0.1:8000/delay\");</font> <font style=\"color:#595959;\"> xhr.send();</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">// abort() 取消请求</font> <font style=\"color:#595959;\">btns[1].onclick = function () {</font> <font style=\"color:#595959;\"> xhr.abort();</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\"></script></font> <font style=\"color:#595959;\"> </body></font> 6、重复请求问题 如果用户疯狂点击请求后台数据，会导致服务器压力比较大。 处理办法：发送请求前，看之前有没有同样的请求，有的话，就把前面的请求去掉，发送一个新的请求 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <button>点击发送</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //获取元素对象</font> <font style=\"color:#595959;\"> const btns = document.querySelectorAll(\"button\");</font> <font style=\"color:#595959;\">let x = null;</font> <font style=\"color:#595959;\">//1、标识变量，是否正在发送AJAX请求</font> <font style=\"color:#595959;\">let isSending = false;</font> <font style=\"color:#595959;\">btns[0].onclick = function () {</font> <font style=\"color:#595959;\"> //判断标识变量</font> <font style=\"color:#595959;\"> if (isSending) x.abort(); // 如果正在发送, 则取消该请求, 创建一个新的请求</font> <font style=\"color:#595959;\"> x = new XMLHttpRequest();</font> <font style=\"color:#595959;\"> //2、修改标识变量的值，在发送ajax请求</font> <font style=\"color:#595959;\"> isSending = true;</font> <font style=\"color:#595959;\"> x.open(\"GET\", \"http://127.0.0.1:8000/delay\");</font> <font style=\"color:#595959;\"> x.send();</font> <font style=\"color:#595959;\"> x.onreadystatechange = function () {</font> <font style=\"color:#595959;\"> if (x.readyState === 4) {</font> <font style=\"color:#595959;\"> //3、修改标识变量，请求响应回来了，标识变量为false</font> <font style=\"color:#595959;\"> isSending = false;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\"></script></font> <font style=\"color:#595959;\"> </body></font> （三）、JQuery中发送ajax请求 sever.js <font style=\"color:#595959;\">//jQuery 服务</font> <font style=\"color:#595959;\">app.all(\"/jquery-server\", (request, response) => {</font> <font style=\"color:#595959;\"> //设置响应头 设置允许跨域</font> <font style=\"color:#595959;\"> response.setHeader(\"Access-Control-Allow-Origin\", \"*\");</font> <font style=\"color:#595959;\"> response.setHeader(\"Access-Control-Allow-Headers\", \"*\");</font> <font style=\"color:#595959;\"> // response.send('Hello jQuery AJAX');</font> <font style=\"color:#595959;\"> const data = { name: \"bdqn\" };</font> <font style=\"color:#595959;\"> response.send(JSON.stringify(data));</font> <font style=\"color:#595959;\">});</font> 1、<font style=\"color:#000000;\">get 请求 </font> <font style=\"color:#000000;\">$.get(url, [data], [callback], [type]) </font> <font style=\"color:#000000;\">url:请求的 URL 地址。 </font> <font style=\"color:#000000;\">data:请求携带的参数。 </font> <font style=\"color:#000000;\">callback:载入成功时回调函数。 </font> <font style=\"color:#000000;\">type:设置返回内容格式，xml, html, script, json, text, _default。</font> <font style=\"color:#595959;\">$('button').eq(0).click(function(){</font> <font style=\"color:#595959;\"> $.get('http://127.0.0.1:8000/jquery-server',</font> <font style=\"color:#595959;\"> {a:100, b:200}, </font> <font style=\"color:#595959;\"> function(data){</font> <font style=\"color:#595959;\"> console.log(data);</font> <font style=\"color:#595959;\"> },'json');</font> <font style=\"color:#595959;\">});</font> <font style=\"color:#000000;\">2、 post 请求 </font> <font style=\"color:#000000;\">$.post(url, [data], [callback], [type]) </font> <font style=\"color:#000000;\">url:请求的 URL 地址。 </font> <font style=\"color:#000000;\">data:请求携带的参数。 </font> <font style=\"color:#000000;\">callback:载入成功时回调函数。 </font> <font style=\"color:#000000;\">type:设置返回内容格式，xml, html, script, json, text, _default。 </font> <font style=\"color:#595959;\">$('button').eq(1).click(function(){</font> <font style=\"color:#595959;\"> $.post('http://127.0.0.1:8000/jquery-server', {a:100, b:200}, function(data){</font> <font style=\"color:#595959;\"> console.log(data);</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\">});</font> 3、通用方法ajax <font style=\"color:#595959;\">$('button').eq(2).click(function(){</font> <font style=\"color:#595959;\"> $.ajax({</font> <font style=\"color:#595959;\"> //url</font> <font style=\"color:#595959;\"> url: 'http://127.0.0.1:8000/jquery-server',</font> <font style=\"color:#595959;\"> //参数</font> <font style=\"color:#595959;\"> data: {a:100, b:200},</font> <font style=\"color:#595959;\"> //请求类型</font> <font style=\"color:#595959;\"> type: 'GET',</font> <font style=\"color:#595959;\"> //响应体结果</font> <font style=\"color:#595959;\"> dataType: 'json',</font> <font style=\"color:#595959;\"> //成功的回调</font> <font style=\"color:#595959;\"> success: function(data){</font> <font style=\"color:#595959;\"> console.log(data);</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> //超时时间</font> <font style=\"color:#595959;\"> timeout: 2000,</font> <font style=\"color:#595959;\"> //失败的回调</font> <font style=\"color:#595959;\"> error: function(){</font> <font style=\"color:#595959;\"> console.log('出错啦!!');</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> //头信息</font> <font style=\"color:#595959;\"> headers: {</font> <font style=\"color:#595959;\"> c:300,</font> <font style=\"color:#595959;\"> d:400</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\">});</font> （四）、axios发送ajax请求 axios官网：https://www.bootcdn.cn/axios/ axios线上链接：<script src=\"https://cdn.bootcdn.net/ajax/libs/axios/1.6.8/axios.js\"></script> <font style=\"color:#595959;\"><head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>axios 发送 AJAX 请求</title></font> <font style=\"color:#595959;\"> <link href=\"https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\" /></font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"><script src=\"https://cdn.bootcdn.net/ajax/libs/axios/1.6.8/axios.js\"></script></font> <font style=\"color:#595959;\"></head></font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <div class=\"container\"></font> <font style=\"color:#595959;\"> <h2 class=\"page-header\">axios发送AJAX请求</h2></font> <font style=\"color:#595959;\"> <button class=\"btn btn-primary\">GET</button></font> <font style=\"color:#595959;\"> <button class=\"btn btn-danger\">POST</button></font> <font style=\"color:#595959;\"> <button class=\"btn btn-info\">通用型方法ajax</button></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> var btns = document.querySelectorAll(\"button\");</font> <font style=\"color:#595959;\"> // 设置基本路径</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">axios.defaults.baseURL = \"http://127.0.0.1:8000\";</font> <font style=\"color:#595959;\"> // get请求</font> <font style=\"color:#595959;\"> btns[0].addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">axios</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">.get(\"/axios-server\", {</font> <font style=\"color:#FF0000;\"> //设置请求头</font> <font style=\"color:#FF0000;\"> headers: {</font> <font style=\"color:#FF0000;\"> id: \"007\",</font> <font style=\"color:#FF0000;\"> },</font> <font style=\"color:#FF0000;\"> })</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">.then(</font> <font style=\"color:#FF0000;\"> (response) => {</font> <font style=\"color:#FF0000;\"> console.log(\"服务器返回的数据：\", response.data);</font> <font style=\"color:#FF0000;\"> },</font> <font style=\"color:#FF0000;\"> (error) => {</font> <font style=\"color:#FF0000;\"> console.log(\"错误信息\", error.message);</font> <font style=\"color:#FF0000;\"> }</font> <font style=\"color:#FF0000;\"> );</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> // 新增</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">// axios.get(\"/axios-server\")</font> <font style=\"color:#FF0000;\"> // .then(function(response){</font> <font style=\"color:#FF0000;\"> // console.log(\"服务器返回的数据：\", response.data);</font> <font style=\"color:#FF0000;\"> // })</font> <font style=\"color:#FF0000;\"> // .catch(function (error){</font> <font style=\"color:#FF0000;\"> // console.log(\"错误信息\", error.message);</font> <font style=\"color:#FF0000;\"> // })</font> <font style=\"color:#595959;\"> //写法2</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">// axios.get(\"/axios-serve\")</font> <font style=\"color:#FF0000;\"> // .then(</font> <font style=\"color:#FF0000;\"> // function(response){</font> <font style=\"color:#FF0000;\"> // console.log(\"服务器返回的数据：\", response.data);</font> <font style=\"color:#FF0000;\"> // console.log(\"错误信息\", error.message);</font> <font style=\"color:#FF0000;\"> // },</font> <font style=\"color:#FF0000;\"> // function(error){</font> <font style=\"color:#FF0000;\"> // console.log(\"错误信息\", error.message);</font> <font style=\"color:#FF0000;\"> // }</font> <font style=\"color:#595959;\"> // )</font> <font style=\"color:#595959;\"> // 写法三</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">// try {</font> <font style=\"color:#FF0000;\"> // let res= await axios.get(\"/axios-server\")</font> <font style=\"color:#FF0000;\"> // console.log(res.data);</font> <font style=\"color:#FF0000;\"> // } catch (error) {</font> <font style=\"color:#FF0000;\"> // console.log(error);</font> <font style=\"color:#FF0000;\"> // }</font> <font style=\"color:#595959;\"> // post请求</font> <font style=\"color:#595959;\"> btns[1].addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">axios</font> <font style=\"color:#FF0000;\"> .post(</font> <font style=\"color:#FF0000;\"> \"/axios-server\",</font> <font style=\"color:#FF0000;\"> {</font> <font style=\"color:#FF0000;\"> username: \"admin\",</font> <font style=\"color:#FF0000;\"> password: \"123456\",</font> <font style=\"color:#FF0000;\"> },</font> <font style=\"color:#FF0000;\"> {</font> <font style=\"color:#FF0000;\"> // url</font> <font style=\"color:#FF0000;\"> params: {</font> <font style=\"color:#FF0000;\"> id: \"008\",</font> <font style=\"color:#FF0000;\"> },</font> <font style=\"color:#FF0000;\"> // 请求头参数</font> <font style=\"color:#FF0000;\"> headers: {</font> <font style=\"color:#FF0000;\"> height: \"180\",</font> <font style=\"color:#FF0000;\"> weight: 180,</font> <font style=\"color:#FF0000;\"> },</font> <font style=\"color:#FF0000;\"> }</font> <font style=\"color:#FF0000;\"> )</font> <font style=\"color:#FF0000;\"> .then((res) => {</font> <font style=\"color:#FF0000;\"> console.log(res.data);</font> <font style=\"color:#FF0000;\"> })</font> <font style=\"color:#FF0000;\"> .catch((error) => {</font> <font style=\"color:#FF0000;\"> console.log(error.message);</font> <font style=\"color:#FF0000;\"> });</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> // axios通用请求</font> <font style=\"color:#595959;\"> btns[2].addEventListener(\"click\", function () {</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">axios({</font> <font style=\"color:#FF0000;\"> // 请求方法</font> <font style=\"color:#FF0000;\"> method: \"POST\",</font> <font style=\"color:#FF0000;\"> // url</font> <font style=\"color:#FF0000;\"> url: \"/axios-server\",</font> <font style=\"color:#FF0000;\"> // url参数</font> <font style=\"color:#FF0000;\"> params: {</font> <font style=\"color:#FF0000;\"> id: \"010\",</font> <font style=\"color:#FF0000;\"> },</font> <font style=\"color:#FF0000;\"> // 头信息</font> <font style=\"color:#FF0000;\"> headers: {</font> <font style=\"color:#FF0000;\"> a: 100,</font> <font style=\"color:#FF0000;\"> b: 200,</font> <font style=\"color:#FF0000;\"> },</font> <font style=\"color:#FF0000;\"> // 请求体参数</font> <font style=\"color:#FF0000;\"> data: {</font> <font style=\"color:#FF0000;\"> username: \"admin\",</font> <font style=\"color:#FF0000;\"> password: \"12345\",</font> <font style=\"color:#FF0000;\"> },</font> <font style=\"color:#FF0000;\"> })</font> <font style=\"color:#FF0000;\"> .then((res) => {</font> <font style=\"color:#FF0000;\"> console.log(res.data);</font> <font style=\"color:#FF0000;\"> })</font> <font style=\"color:#FF0000;\"> .catch((error) => {</font> <font style=\"color:#FF0000;\"> console.log(error.message);</font> <font style=\"color:#FF0000;\"> });</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> （五）、跨域 1、<font style=\"color:#000000;\">同源策略</font> <font style=\"color:#000000;\">同源策略(Same-Origin Policy)最早由 Netscape 公司提出，是浏览器的一种安全策略。</font> <font style=\"color:#000000;\">同源：协议、域名、端口号必须完全相同。</font> <font style=\"color:#000000;\">违背同源策略就是跨域。</font> <font style=\"color:#000000;\">2、演示同源策略</font> server.js <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> const express = require(\"express\");</font> <font style=\"color:#595959;\"> const app = express();</font> <font style=\"color:#595959;\"> app.get(\"/home\", (request, response) => {</font> <font style=\"color:#595959;\"> //响应一个页面 绝对路径,当前js文件所处的目录</font> <font style=\"color:#595959;\"> response.sendFile(__dirname + \"/index.html\");</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> app.get(\"/data\", (request, response) => {</font> <font style=\"color:#595959;\"> response.send(\"用户数据\");</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> app.listen(8001, () => {</font> <font style=\"color:#595959;\"> console.log(\"服务已经启动...\");</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#000000;\">index.html 跟serve.js同级</font> <font style=\"color:#000000;\">在网址栏直接输入 </font>http://localhost:8001/home<font style=\"color:#000000;\">,不用vscode打开，否则会出现跨域问题</font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <h1>bdqn</h1></font> <font style=\"color:#595959;\"> <button>点击获取用户数据</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> const btn = document.querySelector('button');</font> <font style=\"color:#595959;\"> btn.onclick = function(){</font> <font style=\"color:#595959;\"> const x = new XMLHttpRequest();</font> <font style=\"color:#595959;\"> //这里因为是满足同源策略的, 所以 url 可以简写</font> <font style=\"color:#595959;\"> x.open(\"GET\",'/data');</font> <font style=\"color:#595959;\"> //发送</font> <font style=\"color:#595959;\"> x.send();</font> <font style=\"color:#595959;\"> //绑定事件</font> <font style=\"color:#595959;\"> x.onreadystatechange = function(){</font> <font style=\"color:#595959;\"> if(x.readyState === 4){</font> <font style=\"color:#595959;\"> if(x.status >= 200 && x.status < 300){</font> <font style=\"color:#595959;\"> console.log(x.response);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"></body></font> <font style=\"color:#000000;\">3 、如何解决跨域</font> <font style=\"color:#000000;\">（1）、 JSONP </font> <font style=\"color:#000000;\">1) JSONP 是什么 </font> <font style=\"color:#000000;\">JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持 get 请求。 </font> <font style=\"color:#000000;\">2) JSONP 怎么工作的？ </font> <font style=\"color:#000000;\">在网页有一些标签天生具有跨域能力，比如：img link iframe script。 JSONP 就是利用 script 标签的跨域能力来发送请求的。 </font> <font style=\"color:#000000;\">3）jsonp的简单原理</font> jsonp原理.html <font style=\"color:#595959;\"><head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> h1 {</font> <font style=\"color:#595959;\"> width: 300px;</font> <font style=\"color:#595959;\"> height: 100px;</font> <font style=\"color:#595959;\"> border: 1px solid red;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <h1 id=\"res\"></h1></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 提前定义好，数据处理函数，用于处理script请求回来的数据</font> <font style=\"color:#595959;\"> function handle(data) {</font> <font style=\"color:#595959;\"> const res = document.getElementById(\"res\");</font> <font style=\"color:#595959;\"> res.innerHTML = data.name;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> <!--1、 script的正常使用，引入外部资源--></font> <font style=\"color:#595959;\"> <!-- <script src=\"./js/app.js\"></script> --></font> <font style=\"color:#595959;\"> <!--2、 script跨域请求数据 --></font> <font style=\"color:#595959;\"> <script src=\"http://127.0.0.1:8000/jsonp-server\"></script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#000000;\">app.js 演示script的正常用法，引入外部资源</font> <font style=\"color:#595959;\">var data = {</font> <font style=\"color:#595959;\"> name: \"jack\",</font> <font style=\"color:#595959;\">};</font> <font style=\"color:#595959;\">//1、 自定义一个handle的函数，处理这个data数据，放入到页面中</font> <font style=\"color:#595959;\">// function handle(data) {</font> <font style=\"color:#595959;\">// const res = document.getElementById(\"res\");</font> <font style=\"color:#595959;\">// res.innerHTML = data.name;</font> <font style=\"color:#595959;\">// }</font> <font style=\"color:#595959;\">// 2、这个自定义函数，放入到html页面中，截止到这就是简单的引入</font> <font style=\"color:#595959;\">// 3、去sever.js文件中变形操作</font> <font style=\"color:#595959;\">handle(data);</font> <font style=\"color:#000000;\">server.js</font> <font style=\"color:#595959;\">//jsonp服务</font> <font style=\"color:#595959;\">app.all(\"/jsonp-server\", (request, response) => {</font> <font style=\"color:#595959;\"> // 返回字符串，这个字符串，要写js能识别的语法，js引擎要对返回内容进行解析</font> <font style=\"color:#595959;\"> // response.send('console.log(\"hello jsonp\")');</font> <font style=\"color:#595959;\"> // 返回数据处理函数</font> <font style=\"color:#595959;\"> const data = {</font> <font style=\"color:#595959;\"> name: \"北大青鸟\",</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //将数据转化为字符串</font> <font style=\"color:#595959;\"> let str = JSON.stringify(data);</font> <font style=\"color:#595959;\"> //返回结果，.end()不用设置响应头，这个handle（），在页面中要提前定义</font> <font style=\"color:#595959;\"> response.end(handle(${str}));</font> <font style=\"color:#595959;\">});</font> <font style=\"color:#000000;\">4) JSONP 的案例使用</font> 需求：用户输入用户名，失焦时，发送ajax请求，判断用户名是否存在，存在将input变成红色框，且显示用户名已存在 <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> 用户名: <input type=\"text\" id=\"username\"></font> <font style=\"color:#595959;\"> <p></p></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //获取 input 元素</font> <font style=\"color:#595959;\"> const input = document.querySelector('input');</font> <font style=\"color:#595959;\">const p = document.querySelector('p');</font> <font style=\"color:#595959;\">//声明 handle 函数</font> <font style=\"color:#595959;\">function handle(data){</font> <font style=\"color:#595959;\"> input.style.border = \"solid 1px #f00\";</font> <font style=\"color:#595959;\"> //修改 p 标签的提示文本</font> <font style=\"color:#595959;\"> p.innerHTML = data.msg;</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">//绑定事件</font> <font style=\"color:#595959;\">input.onblur = function(){</font> <font style=\"color:#595959;\"> //获取用户的输入值</font> <font style=\"color:#595959;\"> let username = this.value;</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">//向服务器端发送请求 检测用户名是否存在</font> <font style=\"color:#FF0000;\"> //1. 创建 script 标签</font> <font style=\"color:#FF0000;\"> const script = document.createElement('script');</font> <font style=\"color:#FF0000;\"> //2. 设置标签的 src 属性</font> <font style=\"color:#FF0000;\"> script.src = 'http://127.0.0.1:8000/check-username';</font> <font style=\"color:#FF0000;\"> //3. 将 script 插入到文档中，否则script不执行</font> <font style=\"color:#FF0000;\"> document.body.appendChild(script);</font> <font style=\"color:#FF0000;\">}</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> sever.js <font style=\"color:#595959;\">//用户名检测是否存在</font> <font style=\"color:#595959;\">app.all(\"/check-username\", (request, response) => {</font> <font style=\"color:#595959;\"> const data = {</font> <font style=\"color:#595959;\"> exist: 1, </font> <font style=\"color:#595959;\"> msg: \"用户名已经存在\",</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> //将数据转化为字符串</font> <font style=\"color:#595959;\"> let str = JSON.stringify(data);</font> <font style=\"color:#595959;\"> //返回结果，交给handle处理函数</font> <font style=\"color:#595959;\"> response.end(handle(${str}));</font> <font style=\"color:#595959;\">});</font> （2）、cors 1) CORS 是什么？ CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源 2) CORS 怎么工作的？ CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行。 3) CORS 的使用 sever.js <font style=\"color:#595959;\">app.all(\"/cors-server\", (request, response) => {</font> <font style=\"color:#595959;\"> //设置响应头，允许跨域</font> <font style=\"color:#595959;\"> response.setHeader(\"Access-Control-Allow-Origin\", \"*\");</font> <font style=\"color:#595959;\"> // 允许自定义响应头</font> <font style=\"color:#595959;\"> response.setHeader(\"Access-Control-Allow-Headers\", \"*\");</font> <font style=\"color:#595959;\"> //设置请求允许的方法</font> <font style=\"color:#595959;\"> response.setHeader(\"Access-Control-Allow-Method\", \"*\");</font> <font style=\"color:#595959;\"> // response.setHeader(\"Access-Control-Allow-Origin\", \"http://127.0.0.1:5500\");</font> <font style=\"color:#595959;\"> response.send(\"hello CORS\");</font> <font style=\"color:#595959;\">});</font> <font style=\"color:#595959;\"><body></font> <font style=\"color:#595959;\"> <button>发送请求</button></font> <font style=\"color:#595959;\"> <div id=\"result\"></div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> const btn = document.querySelector('button');</font> <font style=\"color:#595959;\">btn.onclick = function(){</font> <font style=\"color:#595959;\"> //1. 创建对象</font> <font style=\"color:#595959;\"> const x = new XMLHttpRequest();</font> <font style=\"color:#595959;\"> //2. 初始化设置</font> <font style=\"color:#595959;\"> x.open(\"GET\", \"http://127.0.0.1:8000/cors-server\");</font> <font style=\"color:#595959;\"> //3. 发送</font> <font style=\"color:#595959;\"> x.send();</font> <font style=\"color:#595959;\"> //4. 绑定事件</font> <font style=\"color:#595959;\"> x.onreadystatechange = function(){</font> <font style=\"color:#595959;\"> if(x.readyState === 4){</font> <font style=\"color:#595959;\"> if(x.status >= 200 && x.status < 300){</font> <font style=\"color:#595959;\"> //输出响应体</font> <font style=\"color:#595959;\"> console.log(x.response);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS vue代理服务器跨域 1、axios的基本使用 1.1、简介 说到axios我们就不得不说下Ajax。在旧浏览器页面在向服务器请求数据时，因为返回的是整个页面的数据，页面都会强制刷新一下，这对于用户来讲并不是很友好。并且我们只是需要修改页面的部分数据，但是从服务器端发送的却是整个页面的数据，十分消耗网络资源。而我们只是需要修改页面的部分数据，也希望不刷新页面，因此异步网络请求就应运而生。 Ajax(Asynchronous JavaScript and XML)： 异步网络请求。Ajax能够让页面无刷新的请求数据。 实现ajax的方式有多种，如jQuery封装的ajax，原生的XMLHttpRequest，以及axios。但各种方式都有利弊： 原生的XMLHttpRequest的配置和调用方式都很繁琐，实现异步请求十分麻烦 jQuery的ajax相对于原生的ajax是非常好用的，但是没有必要因为要用ajax异步网络请求而引用jQuery框架 Axios（ajax i/o system）： 这不是一种新技术，本质上还是对原生XMLHttpRequest的封装，可用于浏览器和nodejs的HTTP客户端，只不过它是基于Promise的，符合最新的ES规范。 axios具备以下特点： <font style=\"color:#FF0000;\">在浏览器中创建XMLHttpRequest请求</font> <font style=\"color:#FF0000;\">在node.js中发送http请求</font> <font style=\"color:#FF0000;\">支持Promise API</font> <font style=\"color:#FF0000;\">拦截请求和响应</font> <font style=\"color:#FF0000;\">转换请求和响应数据</font> <font style=\"color:#FF0000;\">取消要求</font> <font style=\"color:#FF0000;\">自动转换JSON数据</font> 1.2、安装 1.2.1、<font style=\"color:#B4B4B4;\">通过cdn引入</font> <font style=\"color:#595959;\"><script src=\"https://unpkg.com/axios/dist/axios.min.js\"> </script></font> 1.3、基本使用 1.3.1、准备服务器 模拟服务器，这里使用json-server （1）安装json-server npm install -g json-server （2）创建数据源 在空文件夹下创建JSON文件作为数据源，例如 db.json <font style=\"color:#595959;\">{</font> <font style=\"color:#595959;\"> \"list\": [</font> <font style=\"color:#595959;\"> {</font> <font style=\"color:#595959;\"> \"id\": \"1\",</font> <font style=\"color:#595959;\"> \"name\": \"唐僧\",</font> <font style=\"color:#595959;\"> \"age\": 20,</font> <font style=\"color:#595959;\"> \"address\": \"东土大唐\"</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> {</font> <font style=\"color:#595959;\"> \"id\": \"2\",</font> <font style=\"color:#595959;\"> \"name\": \"孙悟空\",</font> <font style=\"color:#595959;\"> \"age\": 500,</font> <font style=\"color:#595959;\"> \"address\": \"花果山\"</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> {</font> <font style=\"color:#595959;\"> \"id\": \"3\",</font> <font style=\"color:#595959;\"> \"name\": \"猪八戒\",</font> <font style=\"color:#595959;\"> \"age\": 330,</font> <font style=\"color:#595959;\"> \"address\": \"高老庄\"</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> {</font> <font style=\"color:#595959;\"> \"id\": \"4\",</font> <font style=\"color:#595959;\"> \"name\": \"沙悟净\",</font> <font style=\"color:#595959;\"> \"age\": 200,</font> <font style=\"color:#595959;\"> \"address\": \"流沙河\"</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> {</font> <font style=\"color:#595959;\"> \"id\": \"5\",</font> <font style=\"color:#595959;\"> \"name\": \"红孩儿\",</font> <font style=\"color:#595959;\"> \"age\": 10,</font> <font style=\"color:#595959;\"> \"address\": \"火焰山\"</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> ]</font> <font style=\"color:#595959;\">}</font> （3）启动服务器 使用以下命令启动json-server，并将JSON文件作为参数传递给服务器。这将在本地计算机的<font style=\"color:#C7254E;\">3000端口</font>上启动服务器，并将db.json文件中的数据暴露为RESTful API。 方式一、//db.json是文件名 <font style=\"color:#595959;\">json-server db.json </font> 方式二、 <font style=\"color:#595959;\">json-server --watch db.json </font> 方式三、 跟db.json同级目录，创建package.json文件，配置别名 <font style=\"color:#595959;\">{</font> <font style=\"color:#595959;\"> \"scripts\":{</font> <font style=\"color:#595959;\"> \"mock\":\"json-server --watch db.json --port 3001\"</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">}</font> 启动方式：npm run mock 1.3.2、各种请求方式 <font style=\"color:#B4B4B4;\">1.3.2.1、get请求</font> <font style=\"color:#B4B4B4;\">获取数据，请求指定的信息，返回实体对象</font> <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <script src=\"../js/axios.js\"></script></font> <font style=\"color:#595959;\"> <!-- <script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script> --></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> #warp {</font> <font style=\"color:#595959;\"> width: 400px;</font> <font style=\"color:#595959;\"> margin: 50px auto;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .showUser {</font> <font style=\"color:#595959;\"> width: 400px;</font> <font style=\"color:#595959;\"> margin: 10px auto;</font> <font style=\"color:#595959;\"> height: 260px;</font> <font style=\"color:#595959;\"> border: 1px solid red;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> li {</font> <font style=\"color:#595959;\"> line-height: 2;</font> <font style=\"color:#595959;\"> background-color: pink;</font> <font style=\"color:#595959;\"> margin: 10px;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <div id=\"warp\"></font> <font style=\"color:#595959;\"> <button onclick=\"getInfo()\">get请求</button></font> <font style=\"color:#595959;\"> <ul class=\"showUser\"></ul></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // get请求</font> <font style=\"color:#595959;\"> async function getInfo() {</font> <font style=\"color:#595959;\"> // 请求结果处理方法一：</font> <font style=\"color:#595959;\"> // axios.get(\"http://localhost:3000/list\").then(</font> <font style=\"color:#595959;\"> // (res) => {</font> <font style=\"color:#595959;\"> // // 将请求到的结果进行渲染</font> <font style=\"color:#595959;\"> // render(res.data);</font> <font style=\"color:#595959;\"> // },</font> <font style=\"color:#595959;\"> // (err) => {</font> <font style=\"color:#595959;\"> // console.log(err);</font> <font style=\"color:#595959;\"> // }</font> <font style=\"color:#595959;\"> // );</font> <font style=\"color:#595959;\"> // 请求结果处理方法二：</font> <font style=\"color:#595959;\"> // axios</font> <font style=\"color:#595959;\"> // .get(\"http://localhost:3000/list\")</font> <font style=\"color:#595959;\"> // .then((res) => {</font> <font style=\"color:#595959;\"> // // 将请求到的结果进行渲染</font> <font style=\"color:#595959;\"> // render(res.data);</font> <font style=\"color:#595959;\"> // })</font> <font style=\"color:#595959;\"> // .catch((err) => {</font> <font style=\"color:#595959;\"> // console.log(err);</font> <font style=\"color:#595959;\"> // });</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\"> // 请求结果处理方法三：推荐使用第三种</font> <font style=\"color:#FF0000;\"> try {</font> <font style=\"color:#FF0000;\"> let res = await axios.get(\"http://localhost:3000/list\");</font> <font style=\"color:#FF0000;\"> render(res.data);</font> <font style=\"color:#FF0000;\"> } catch (error) {</font> <font style=\"color:#FF0000;\"> console.log(err);</font> <font style=\"color:#FF0000;\"> }</font> <font style=\"color:#FF0000;\"> }</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">// 渲染函数</font> <font style=\"color:#FF0000;\"> function render(data) {</font> <font style=\"color:#FF0000;\"> let showUser = document.querySelector(\".showUser\");</font> <font style=\"color:#FF0000;\"> let str = \"\";</font> <font style=\"color:#FF0000;\"> data.forEach((item) => {</font> <font style=\"color:#FF0000;\"> str += <li>${item.name}<a href='#'>删除</a></li>;</font> <font style=\"color:#FF0000;\"> });</font> <font style=\"color:#FF0000;\"> showUser.innerHTML = str;</font> <font style=\"color:#595959;\"> </font><font style=\"color:#FF0000;\">}</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> 此外get请求，还可以携带参数 <font style=\"color:#595959;\">// get请求带参数方式一</font> <font style=\"color:#595959;\">// try {</font> <font style=\"color:#595959;\">// let res = await axios.get(\"http://localhost:3000/list?id=1\");</font> <font style=\"color:#595959;\">// render(res.data);</font> <font style=\"color:#595959;\">// } catch (error) {</font> <font style=\"color:#595959;\">// console.log(err);</font> <font style=\"color:#595959;\">// }</font> <font style=\"color:#595959;\">// get请求带参数方式二</font> <font style=\"color:#595959;\">try {</font> <font style=\"color:#595959;\"> let res = await axios.get(\"http://localhost:3000/list\", {</font> <font style=\"color:#595959;\"> params: {</font> <font style=\"color:#595959;\"> id: 2,</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> render(res.data);</font> <font style=\"color:#595959;\">} catch (error) {</font> <font style=\"color:#595959;\"> console.log(err);</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#B4B4B4;\">1.3.2.2、post请求：</font> <font style=\"color:#B4B4B4;\">向指定资源提交数据（例如表单提交或文件上传）</font> <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <script src=\"../js/axios.js\"></script></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> #warp {</font> <font style=\"color:#595959;\"> width: 400px;</font> <font style=\"color:#595959;\"> margin: 50px auto;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .showUser {</font> <font style=\"color:#595959;\"> width: 400px;</font> <font style=\"color:#595959;\"> margin: 10px auto;</font> <font style=\"color:#595959;\"> height: 260px;</font> <font style=\"color:#595959;\"> border: 1px solid red;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> li {</font> <font style=\"color:#595959;\"> line-height: 2;</font> <font style=\"color:#595959;\"> background-color: pink;</font> <font style=\"color:#595959;\"> margin: 10px;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <div id=\"warp\"></font> <font style=\"color:#595959;\"> <button onclick=\"postInfo()\">post请求</button></font> <font style=\"color:#595959;\"> <ul class=\"showUser\"></ul></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // post请求</font> <font style=\"color:#595959;\"> async function postInfo() {</font> <font style=\"color:#595959;\"> await axios.post(\"http://localhost:3000/list\", </font> <font style=\"color:#595959;\"> {</font> <font style=\"color:#595959;\"> name: \"蜘蛛精\",</font> <font style=\"color:#595959;\"> age: 200,</font> <font style=\"color:#595959;\"> address: \"盘丝洞\",</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> // 重新获取数据，渲染</font> <font style=\"color:#595959;\"> let res = await axios.get(\"http://localhost:3000/list\");</font> <font style=\"color:#595959;\"> render(res.data);</font> <font style=\"color:#595959;\"> // console.log(res.data);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 渲染函数</font> <font style=\"color:#595959;\"> function render(data) {</font> <font style=\"color:#595959;\"> let showUser = document.querySelector(\".showUser\");</font> <font style=\"color:#595959;\"> let str = \"\";</font> <font style=\"color:#595959;\"> data.forEach((item) => {</font> <font style=\"color:#595959;\"> str += <li>${item.name}<a href='#'>删除</a></li>;</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> showUser.innerHTML = str;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> <font style=\"color:#B4B4B4;\">1.3.2.3、put请求：</font> <font style=\"color:#B4B4B4;\">更新数据，从客户端向服务器传送的数据取代指定的文档的内容</font> <font style=\"color:#B4B4B4;\">会把更新的数据完全替代原数据，如果只修改了部分的数据，原数据其他内容都会丢失</font> <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <script src=\"../js/axios.js\"></script></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> #warp {</font> <font style=\"color:#595959;\"> width: 400px;</font> <font style=\"color:#595959;\"> margin: 50px auto;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .showUser {</font> <font style=\"color:#595959;\"> width: 400px;</font> <font style=\"color:#595959;\"> margin: 10px auto;</font> <font style=\"color:#595959;\"> height: 260px;</font> <font style=\"color:#595959;\"> border: 1px solid red;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> li {</font> <font style=\"color:#595959;\"> line-height: 2;</font> <font style=\"color:#595959;\"> background-color: pink;</font> <font style=\"color:#595959;\"> margin: 10px;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <div id=\"warp\"></font> <font style=\"color:#595959;\"> <button onclick=\"putInfo()\">put请求-修改数据</button></font> <font style=\"color:#595959;\"> <ul class=\"showUser\"></ul></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // put请求</font> <font style=\"color:#595959;\"> async function putInfo() {</font> <font style=\"color:#595959;\"> let res = await axios.put(\"http://localhost:3000/list/1\", {</font> <font style=\"color:#595959;\"> name: \"玉皇大帝\",</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> // 渲染</font> <font style=\"color:#595959;\"> getData()</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 重新获取数据，渲染</font> <font style=\"color:#595959;\"> async function getData() {</font> <font style=\"color:#595959;\"> let res = await axios.get(\"http://localhost:3000/list\");</font> <font style=\"color:#595959;\"> render(res.data);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 渲染函数</font> <font style=\"color:#595959;\"> function render(data) {</font> <font style=\"color:#595959;\"> let showUser = document.querySelector(\".showUser\");</font> <font style=\"color:#595959;\"> let str = \"\";</font> <font style=\"color:#595959;\"> data.forEach((item) => {</font> <font style=\"color:#595959;\"> str += <li>${item.name}<a href='#'>删除</a></li>;</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> showUser.innerHTML = str;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> <font style=\"color:#B4B4B4;\">1.3.2.4、patch请求：</font> <font style=\"color:#B4B4B4;\">更新数据，是对put方法的补充，用来对已知资源进行局部更新</font> <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <script src=\"../js/axios.js\"></script></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> #warp {</font> <font style=\"color:#595959;\"> width: 400px;</font> <font style=\"color:#595959;\"> margin: 50px auto;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .showUser {</font> <font style=\"color:#595959;\"> width: 400px;</font> <font style=\"color:#595959;\"> margin: 10px auto;</font> <font style=\"color:#595959;\"> height: 260px;</font> <font style=\"color:#595959;\"> border: 1px solid red;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> li {</font> <font style=\"color:#595959;\"> line-height: 2;</font> <font style=\"color:#595959;\"> background-color: pink;</font> <font style=\"color:#595959;\"> margin: 10px;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <div id=\"warp\"></font> <font style=\"color:#595959;\"> <button onclick=\"patchInfo()\">patch请求-修改数据</button></font> <font style=\"color:#595959;\"> <ul class=\"showUser\"></ul></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // patch请求</font> <font style=\"color:#595959;\"> async function patchInfo() {</font> <font style=\"color:#595959;\"> let res = await axios.patch(\"http://localhost:3000/list/2\", {</font> <font style=\"color:#595959;\"> name: \"王母娘娘\",</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> // 渲染</font> <font style=\"color:#595959;\"> getData();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 重新获取数据，渲染</font> <font style=\"color:#595959;\"> async function getData() {</font> <font style=\"color:#595959;\"> let res = await axios.get(\"http://localhost:3000/list\");</font> <font style=\"color:#595959;\"> render(res.data);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 渲染函数</font> <font style=\"color:#595959;\"> function render(data) {</font> <font style=\"color:#595959;\"> let showUser = document.querySelector(\".showUser\");</font> <font style=\"color:#595959;\"> let str = \"\";</font> <font style=\"color:#595959;\"> data.forEach((item) => {</font> <font style=\"color:#595959;\"> str += <li>${item.name}<a href='#'>删除</a></li>;</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> showUser.innerHTML = str;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> <font style=\"color:#B4B4B4;\">1.3.2.5、delete请求：</font> <font style=\"color:#B4B4B4;\">请求服务器删除指定的数据</font> <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <script src=\"../js/axios.js\"></script></font> <font style=\"color:#595959;\"> <style></font> <font style=\"color:#595959;\"> #warp {</font> <font style=\"color:#595959;\"> width: 400px;</font> <font style=\"color:#595959;\"> margin: 50px auto;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> .showUser {</font> <font style=\"color:#595959;\"> width: 400px;</font> <font style=\"color:#595959;\"> margin: 10px auto;</font> <font style=\"color:#595959;\"> height: 260px;</font> <font style=\"color:#595959;\"> border: 1px solid red;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> li {</font> <font style=\"color:#595959;\"> line-height: 2;</font> <font style=\"color:#595959;\"> background-color: pink;</font> <font style=\"color:#595959;\"> margin: 10px;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </style></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <div id=\"warp\"></font> <font style=\"color:#595959;\"> <button onclick=\"deleteInfo()\">delet请求-修改数据</button></font> <font style=\"color:#595959;\"> <ul class=\"showUser\"></ul></font> <font style=\"color:#595959;\"> </div></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // delete请求</font> <font style=\"color:#595959;\"> async function deleteInfo() {</font> <font style=\"color:#595959;\"> let res = await axios.delete(\"http://localhost:3000/list/1\");</font> <font style=\"color:#595959;\"> // 渲染</font> <font style=\"color:#595959;\"> getData();</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 重新获取数据，渲染</font> <font style=\"color:#595959;\"> async function getData() {</font> <font style=\"color:#595959;\"> let res = await axios.get(\"http://localhost:3000/list\");</font> <font style=\"color:#595959;\"> render(res.data);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> // 渲染函数</font> <font style=\"color:#595959;\"> function render(data) {</font> <font style=\"color:#595959;\"> let showUser = document.querySelector(\".showUser\");</font> <font style=\"color:#595959;\"> let str = \"\";</font> <font style=\"color:#595959;\"> data.forEach((item) => {</font> <font style=\"color:#595959;\"> str += <li>${item.name}<a href='#'>删除</a></li>`;</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> showUser.innerHTML = str;</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> 1.3.3、axios的配置 配置的优先级为：请求配置 > 实例配置 > 全局配置 1.3.3.1、全局配置 <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <script src=\"../js/axios.js\"></script></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <button id=\"btn\" onclick=\"getData()\">发送请求</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> //配置全局的超时时长</font> <font style=\"color:#595959;\"> axios.defaults.timeout = 2000;</font> <font style=\"color:#595959;\"> //配置全局的基本URL</font> <font style=\"color:#595959;\"> axios.defaults.baseURL = \"http://localhost:3000\";</font> <font style=\"color:#595959;\"> async function getData() {</font> <font style=\"color:#595959;\"> try {</font> <font style=\"color:#595959;\"> let res1 = await axios.get(\"/list\");</font> <font style=\"color:#595959;\"> let res2 = await axios.get(\"/user\");</font> <font style=\"color:#595959;\"> console.log(res1.data);</font> <font style=\"color:#595959;\"> console.log(res2.data);</font> <font style=\"color:#595959;\"> } catch (error) {</font> <font style=\"color:#595959;\"> console.log(error);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> 1.3.3.2、实例配置 在一个项目中，我们会有很多不同的请求，如果都用axios去请求，很容易造成冲突，所以我们可以去创建axios的实例，通过不同的实例去请求，配置 <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <script src=\"../js/axios.js\"></script></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <button id=\"btn\" onclick=\"getData()\">发送请求</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> async function getData() {</font> <font style=\"color:#595959;\"> // 创建实例1，创建同时配置</font> <font style=\"color:#595959;\"> let instance = axios.create({</font> <font style=\"color:#595959;\"> baseURL: \"http://localhost:3000\",</font> <font style=\"color:#595959;\"> timeout: 2000,</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> let res = await instance.get(\"/list\");</font> <font style=\"color:#595959;\"> console.log(res.data);</font> <font style=\"color:#595959;\"> // 创建实例2，现创建，再配置</font> <font style=\"color:#595959;\"> let instance2 = axios.create();</font> <font style=\"color:#595959;\"> instance2.defaults.timeout = 2;</font> <font style=\"color:#595959;\"> instance2.defaults.baseURL = \"http://localhost:3000\";</font> <font style=\"color:#595959;\"> let res2 = await instance.get(\"/user\");</font> <font style=\"color:#595959;\"> console.log(res2.data);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> axios实例常用配置： baseURL 请求的域名，基本地址，类型：String timeout 请求超时时长，单位ms，类型：Number url 请求路径，类型：String method 请求方法，类型：String headers 设置请求头，类型：Object params 请求参数，将参数拼接在URL上，类型：Object data 请求参数，将参数放到请求体中，类型：Object 1.3.3.3、请求配置 <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <script src=\"../js/axios.js\"></script></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <button id=\"btn\" onclick=\"getData()\">发送请求</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> async function getData() {</font> <font style=\"color:#595959;\"> let res = await axios.get(\"http://localhost:3000/list\", {</font> <font style=\"color:#595959;\"> timeout: 2000,</font> <font style=\"color:#595959;\"> });</font> <font style=\"color:#595959;\"> console.log(res.data);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> 1.3.4、axios的拦截器 axios给我们提供了两大类拦截器 请求方向的拦截（成功请求，失败请求） 响应方向的拦截（成功的，失败的） 拦截器的作用，用于我们在网络请求的时候，在发起请求或者响应时对操作进行处理 例如：发送请求时，可以添加网页加载的动画，或认证token，强制用户先登录再请求数据 响应的时候，可以结束网页加载的动画，或者对响应的数据进行处理 1.3.4.1、请求拦截器 <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <script src=\"../js/axios.js\"></script></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <button id=\"btn\" onclick=\"getData()\">发送请求</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 请求拦截器</font> <font style=\"color:#595959;\"> async function getData() {</font> <font style=\"color:#595959;\"> axios.interceptors.request.use(</font> <font style=\"color:#595959;\"> (config) => {</font> <font style=\"color:#595959;\"> // 发生请求前的一系列的处理</font> <font style=\"color:#595959;\"> console.log(\"开启加载动画\");</font> <font style=\"color:#595959;\"> console.log(\"认证是否有token，如果没有，要去登录\");</font> <font style=\"color:#595959;\"> return config; //拦截后的放行</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> (err) => {</font> <font style=\"color:#595959;\"> // 请求错误处理</font> <font style=\"color:#595959;\"> return Promise.reject(err);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> );</font> <font style=\"color:#595959;\"> let res = await axios.get(\"http://localhost:3000/list\");</font> <font style=\"color:#595959;\"> console.log(res.data);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> 1.3.4.2、响应拦截器 <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <script src=\"../js/axios.js\"></script></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <button id=\"btn\" onclick=\"getData()\">发送请求</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 响应拦截器</font> <font style=\"color:#595959;\"> async function getData() {</font> <font style=\"color:#595959;\"> axios.interceptors.response.use(</font> <font style=\"color:#595959;\"> (config) => {</font> <font style=\"color:#595959;\"> // 数据回来前的一系列的处理</font> <font style=\"color:#595959;\"> console.log(\"关闭加载动画\");</font> <font style=\"color:#595959;\"> console.log(\"对数据进行一些数据\");</font> <font style=\"color:#595959;\"> return config.data; //拦截后的放行</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> (err) => {</font> <font style=\"color:#595959;\"> // 响应错误处理</font> <font style=\"color:#595959;\"> return Promise.reject(err);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> );</font> <font style=\"color:#595959;\"> let res = await axios.get(\"http://localhost:3000/list\");</font> <font style=\"color:#595959;\"> console.log(res.data);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> 1.3.4.3、取消拦截 <font style=\"color:#595959;\"><!DOCTYPE html></font> <font style=\"color:#595959;\"><html lang=\"en\"></font> <font style=\"color:#595959;\"> <head></font> <font style=\"color:#595959;\"> <meta charset=\"UTF-8\" /></font> <font style=\"color:#595959;\"> <title>Document</title></font> <font style=\"color:#595959;\"> <script src=\"../js/axios.js\"></script></font> <font style=\"color:#595959;\"> </head></font> <font style=\"color:#595959;\"> <body></font> <font style=\"color:#595959;\"> <button id=\"btn\" onclick=\"getData()\">发送请求</button></font> <font style=\"color:#595959;\"> <script></font> <font style=\"color:#595959;\"> // 请求拦截器</font> <font style=\"color:#595959;\"> async function getData() {</font> <font style=\"color:#595959;\"> let instance = axios.create();</font> <font style=\"color:#595959;\"> instance.interceptors.request.use(</font> <font style=\"color:#595959;\"> (config) => {</font> <font style=\"color:#595959;\"> // 发生请求前的一系列的处理</font> <font style=\"color:#595959;\"> console.log(\"开启加载动画\");</font> <font style=\"color:#595959;\"> console.log(\"认证是否有token，如果没有，要去登录\");</font> <font style=\"color:#595959;\"> return config; //拦截后的放行</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> (err) => {</font> <font style=\"color:#595959;\"> // 请求错误处理</font> <font style=\"color:#595959;\"> return Promise.reject(err);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> );</font> <font style=\"color:#595959;\"> // 取消拦截</font> <font style=\"color:#595959;\"> axios.interceptors.request.eject(instance);</font> <font style=\"color:#595959;\"> let res = await axios.get(\"http://localhost:3000/list\");</font> <font style=\"color:#595959;\"> console.log(res.data);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </script></font> <font style=\"color:#595959;\"> </body></font> <font style=\"color:#595959;\"></html></font> 2、Vue中axios的使用 2.1、基本使用 2.1.1<font style=\"color:#B4B4B4;\">、npm安装</font> 终端安装： <font style=\"color:#595959;\"> npm install axios</font> 2.1.2、在Vue原型上配置$axios 在vue项目的main.js文件中引入axios <font style=\"color:#595959;\">// 导入axios</font> <font style=\"color:#595959;\">import axios from 'axios'</font> <font style=\"color:#595959;\">// 将axios放到Vue原型上，这样vm，vc身上就都有axios了</font> <font style=\"color:#595959;\">Vue.prototype.$axios=axios</font> 2.1.3、在组件中使用： <font style=\"color:#595959;\"><button @click=\"getDate\">点击发送请求</button></font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\">export default {</font> <font style=\"color:#595959;\"> name: 'App',</font> <font style=\"color:#595959;\"> methods: {</font> <font style=\"color:#595959;\"> async getDate() {</font> <font style=\"color:#595959;\"> let res = await this.$axios.get('http://localhost:3000/list')</font> <font style=\"color:#595959;\"> console.log(res.data);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\"></script></font> 2.2、一次封装 如果是多个组件都需要发送请求，而且每次请求前，我们都要进行一些验证处理等，可以进行简单封装 2.2.1、封装<font style=\"color:#FE2C24;\">request.js</font> <font style=\"color:#4D4D4D;\">src/utils创建</font><font style=\"color:#FE2C24;\">request.js</font> <font style=\"color:#595959;\">/ 封装axios用于发送请求 /</font> <font style=\"color:#595959;\">import axios from \"axios\";</font> <font style=\"color:#595959;\">/*</font> <font style=\"color:#595959;\">(1)request 相当于 Axios 的实例对象</font> <font style=\"color:#595959;\">(2)为什么要有request,而不是直接用axios</font> <font style=\"color:#595959;\"> * 项目开发中，有可能会有两个基地址</font> <font style=\"color:#595959;\"> * 不同的接口配置不同（有的要token,有的不要token）</font> <font style=\"color:#595959;\">*/</font> <font style=\"color:#595959;\">const request = axios.create({</font> <font style=\"color:#595959;\"> baseURL: \"http://localhost:3000\", // 设置基地址</font> <font style=\"color:#595959;\"> timeout: 2000, // 请求超时：当2s没有响应就会结束请求</font> <font style=\"color:#595959;\">});</font> <font style=\"color:#595959;\">// 添加请求拦截器，一下内容是axios的拦截器，可以不用写</font> <font style=\"color:#595959;\">request.interceptors.request.use(</font> <font style=\"color:#595959;\"> function (config) {</font> <font style=\"color:#595959;\"> // 发请求前做的一些处理，数据转化，配置请求头，设置token,设置loading等，根据需求去添加</font> <font style=\"color:#595959;\"> // 例如1</font> <font style=\"color:#595959;\"> config.data = JSON.stringify(config.data); // 数据转化,也可以使用qs转换</font> <font style=\"color:#595959;\"> // 例如2</font> <font style=\"color:#595959;\"> config.headers = {</font> <font style=\"color:#595959;\"> \"Content-Type\": \"application/x-www-form-urlencoded\", // 配置请求头</font> <font style=\"color:#595959;\"> };</font> <font style=\"color:#595959;\"> // 例如3</font> <font style=\"color:#595959;\"> //注意使用token的时候需要引入cookie方法或者用本地localStorage等方法，推荐js-cookie</font> <font style=\"color:#595959;\"> const token = getCookie(\"名称\"); // 这里取token之前，你肯定需要先拿到token,存一下</font> <font style=\"color:#595959;\"> if (token) {</font> <font style=\"color:#595959;\"> config.params = { token: token }; // 如果要求携带在参数中</font> <font style=\"color:#595959;\"> config.headers.token = token; // 如果要求携带在请求头中</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> </font> <font style=\"color:#595959;\"> return config; //拦截后的放行</font> <font style=\"color:#595959;\"> }, </font> <font style=\"color:#595959;\"> function (error) {</font> <font style=\"color:#595959;\"> // 对请求错误做些什么</font> <font style=\"color:#595959;\"> return Promise.reject(error);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">);</font> <font style=\"color:#595959;\">// 添加响应拦截器</font> <font style=\"color:#595959;\">request.interceptors.response.use(</font> <font style=\"color:#595959;\"> function (response) {</font> <font style=\"color:#595959;\"> // 对响应数据做点什么</font> <font style=\"color:#595959;\"> console.log('关闭请求数据动画');</font> <font style=\"color:#595959;\"> console.log('对数据进行处理');</font> <font style=\"color:#595959;\"> return response.data; //只要响应对象中的数据</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> function (error) {</font> <font style=\"color:#595959;\"> // 对响应错误做点什么</font> <font style=\"color:#595959;\"> return Promise.reject(error);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">);</font> <font style=\"color:#595959;\">export default request;</font> <font style=\"color:#FE2C24;\">第一次封装，引入了基地址与拦截器</font> <font style=\"color:#FE2C24;\">2.2.2、组件中使用</font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\"> import request from '../utils/request'</font> <font style=\"color:#595959;\"> export default {</font> <font style=\"color:#595959;\"> name: 'ShowList',</font> <font style=\"color:#595959;\"> methods: {</font> <font style=\"color:#595959;\"> async getList() {</font> <font style=\"color:#595959;\"> // 基本路径已经配置过</font> <font style=\"color:#595959;\"> let res = await request.get('/list')</font> <font style=\"color:#595959;\"> //这里的res也是响应拦截器里处理之后的结果</font> <font style=\"color:#595959;\"> console.log(res);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"></script></font> <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\">import request from '@/utils/request';</font> <font style=\"color:#595959;\">export default {</font> <font style=\"color:#595959;\"> name: 'ShowUser',</font> <font style=\"color:#595959;\"> methods: {</font> <font style=\"color:#595959;\"> async getUser() {</font> <font style=\"color:#595959;\"> let res = await request.get('/user')</font> <font style=\"color:#595959;\"> console.log(res);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\"></script></font> 2.3、二次封装 项目当中会有很多的页面，如果每个页面中都会多次请求，将我们的请求都写在对应的页面中，比较难以维护，所以可以将请求再次进行封装，类似如下效果： src/apis/showList.js <font style=\"color:#595959;\">// 导入一次封装的request</font> <font style=\"color:#595959;\">import request from \"@/utils/request\";</font> <font style=\"color:#595959;\">// 请求list数据</font> <font style=\"color:#595959;\">export function getListInfo1() {</font> <font style=\"color:#595959;\"> return request.get(\"/list\");</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\">// 请求user数据</font> <font style=\"color:#595959;\">export function getUserInfo1() {</font> <font style=\"color:#595959;\"> return request.get(\"/user\");</font> <font style=\"color:#595959;\">}</font> showList.vue <font style=\"color:#595959;\"><script></font> <font style=\"color:#595959;\">import { getListInfo1, getUserInfo1 } from '../apis/showList'</font> <font style=\"color:#595959;\">export default {</font> <font style=\"color:#595959;\"> name: 'ShowList',</font> <font style=\"color:#595959;\"> methods: {</font> <font style=\"color:#595959;\"> async getList1() { </font> <font style=\"color:#595959;\"> // 调用请求函数</font> <font style=\"color:#595959;\"> let res = await getListInfo1()</font> <font style=\"color:#595959;\"> console.log(res);</font> <font style=\"color:#595959;\"> },</font> <font style=\"color:#595959;\"> async getUser1() {</font> <font style=\"color:#595959;\"> let res = await getUserInfo1()</font> <font style=\"color:#595959;\"> console.log(res);</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\"> }</font> <font style=\"color:#595959;\">}</font> <font style=\"color:#595959;\"></script></font>"
    },
    {
      "title": "第1章 JavaScript 是什么",
      "path": "JS/第1章 JavaScript 是什么.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "在1995年5月，当时的Netscape公司面临一个重要的商业挑战。Web浏览器虽然能够显示静态的HTML页面，但缺乏动态交互能力。为了在激烈的浏览器大战中获得优势，Netscape决定为他们的浏览器添加一门脚本语言。\r\n\r\nBrendan Eich，一位年轻的程序员，接到了一个看似不可能的任务：在10天内设计并实现一门全新的编程语言。这门语言需要：\r\n- 语法简单，易于学习\r\n- 能够操作网页内",
      "content": "第1章 JavaScript 是什么 1.1 JavaScript 的诞生与历史背景 JavaScript 的起源故事 在1995年5月，当时的Netscape公司面临一个重要的商业挑战。Web浏览器虽然能够显示静态的HTML页面，但缺乏动态交互能力。为了在激烈的浏览器大战中获得优势，Netscape决定为他们的浏览器添加一门脚本语言。 Brendan Eich，一位年轻的程序员，接到了一个看似不可能的任务：在10天内设计并实现一门全新的编程语言。这门语言需要： 语法简单，易于学习 能够操作网页内容 与Java有一定的相似性（当时Java非常流行） 命名的变迁 这门语言的命名经历了有趣的变化： LiveScript（1995年9月）- 最初的名称 JavaScript（1995年12月）- 为了蹭Java的热度而改名 ECMAScript（1997年）- 标准化后的正式名称 重要提醒：尽管名字相似，JavaScript和Java是完全不同的两门语言！ 关键历史节点 | 年份 | 重要事件 | |------|---------| | 1995 | JavaScript 诞生于 Netscape | | 1996 | Microsoft 推出 JScript（IE浏览器） | | 1997 | ECMAScript 1.0 标准发布 | | 1999 | ECMAScript 3.0，奠定现代JS基础 | | 2005 | Ajax技术兴起，JavaScript重获关注 | | 2009 | Node.js发布，JavaScript进军后端 | | 2015 | ES6/ES2015发布，JavaScript现代化 | 1.2 浏览器与 JS 的关系 浏览器是JavaScript的第一个家 JavaScript最初是为浏览器而生的。理解这种关系对于掌握JavaScript至关重要。 浏览器提供的运行环境 浏览器为JavaScript提供了： JavaScript引擎 - 负责解析和执行JS代码 Web APIs - 提供操作网页的能力 安全沙箱 - 保护用户系统安全 调试工具 - 开发者工具帮助调试 主流浏览器的JavaScript引擎 | 浏览器 | JavaScript引擎 | 特点 | |--------|---------------|------| | Chrome | V8 | 高性能，Node.js也使用 | | Firefox | SpiderMonkey | Mozilla开发，历史悠久 | | Safari | JavaScriptCore | Apple开发，移动端优化 | | Edge | Chakra/V8 | 现已改用V8引擎 | 浏览器兼容性问题 不同浏览器对JavaScript的支持程度不同，这是前端开发的一大挑战： 1.3 ECMAScript、DOM、BOM 的关系 JavaScript的三个组成部分 JavaScript并不是一个单一的技术，而是由三个核心部分组成： ECMAScript - 语言核心 ECMAScript定义了JavaScript的语法规范，包括： 变量和数据类型 操作符和表达式 函数和对象 控制流程语句 DOM - 文档对象模型 DOM（Document Object Model）提供了操作网页内容的能力： DOM的层级结构： BOM - 浏览器对象模型 BOM（Browser Object Model）提供了与浏览器交互的能力： 三者的关系图 1.4 JavaScript 在现代开发中的地位 从\"玩具语言\"到\"全栈语言\" JavaScript经历了戏剧性的地位转变： 早期阶段（1995-2005） 定位：网页装饰语言 用途：简单的表单验证、弹窗效果 认知：被认为是\"不够严肃\"的玩具语言 崛起阶段（2005-2015） 转折点：Ajax技术兴起 应用：富交互的Web应用 框架：jQuery、Prototype等简化开发 全盛阶段（2015至今） 定位：全栈开发语言 生态：完整的工具链和框架体系 应用场景：几乎覆盖所有软件开发领域 JavaScript的应用领域 前端Web开发 🌐 后端服务开发 🖥️ 移动应用开发 📱 桌面应用开发 🖥️ 其他新兴领域 物联网（IoT）：Johnny-Five框架 机器学习：TensorFlow.js 游戏开发：Three.js、Phaser 区块链：Web3.js、Truffle 现代JavaScript生态系统 1.5 JavaScript 的发展趋势 技术发展趋势 类型安全的重视 现代化语法持续演进 性能优化技术 行业应用趋势 全栈JavaScript普及 同构应用：前后端共享代码 微前端：大型应用的模块化方案 Serverless：函数即服务的兴起 AI和机器学习集成 Web标准的推动 WebAssembly：高性能计算 Progressive Web Apps：原生应用体验 Web Components：标准化组件系统 学习JavaScript的最佳路径 总结 JavaScript已经从一个简单的脚本语言发展成为现代软件开发的核心技术。它的特点是： 易学易用：语法灵活，入门门槛低 生态丰富：庞大的开源社区和工具链 应用广泛：覆盖前端、后端、移动端等多个领域 持续发展：标准化进程活跃，新特性不断涌现 无论你是刚开始学习编程的新手，还是希望扩展技能栈的资深开发者，JavaScript都是一个值得深入学习的优秀选择。 --- 本章总结 第1章全面介绍了JavaScript语言的本质和发展历程： JavaScript的诞生与历史背景： 1995年Brendan Eich在网景公司10天内创造 从解决网页交互问题到成为通用编程语言 标准化过程和ECMAScript规范的建立 浏览器大战对JavaScript发展的影响 浏览器与JS的关系： JavaScript作为浏览器的内置脚本语言 不同浏览器JavaScript引擎的发展 Web标准的推进和跨浏览器兼容性 现代浏览器对ES6+特性的支持 ECMAScript、DOM、BOM的关系： ECMAScript定义语言核心语法和API DOM提供文档操作接口 BOM提供浏览器对象模型 三者结合构成完整的JavaScript运行环境 JavaScript在现代开发中的地位： 从前端脚本到全栈开发语言的转变 Node.js推动JavaScript进入服务端领域 丰富的生态系统和工具链支持 在移动端、桌面端应用开发中的应用 JavaScript的发展趋势： 类型安全（TypeScript）的普及 WebAssembly的补充作用 AI和机器学习在前端的应用 Web标准的持续演进 关键要点： JavaScript已从简单脚本语言发展为现代软件开发的核心技术 掌握JavaScript就掌握了Web开发的基础 生态系统的丰富性使其适用于多种应用场景 持续学习新特性和最佳实践是保持竞争力的关键 下一章预告 第2章将深入学习JavaScript的运行机制，包括浏览器如何执行JavaScript、V8引擎的解析流程、以及从代码输入到页面渲染的完整生命周期。"
    },
    {
      "title": "第2章 JavaScript 的运行机制",
      "path": "JS/第2章 JavaScript 的运行机制.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "当我们在网页中运行JavaScript时，浏览器为我们提供了一个复杂而精密的执行环境。理解这个环境的工作原理，对于写出高效的JavaScript代码至关重要。\r\n\r\n\r\n\r\n现代浏览器采用多进程架构来提高稳定性和安全性：\r\n\r\n\r\n\r\n\r\n\r\nJavaScript主要在渲染进程中执行，与页面渲染共享同一个线程：\r\n\r\n\r\n\r\n\r\n\r\n浏览器处理JavaScript的执行时机有多种情况：\r\n\r\n\r\n",
      "content": "第2章 JavaScript 的运行机制 2.1 浏览器如何执行 JavaScript 浏览器的JavaScript执行环境 当我们在网页中运行JavaScript时，浏览器为我们提供了一个复杂而精密的执行环境。理解这个环境的工作原理，对于写出高效的JavaScript代码至关重要。 浏览器的多进程架构 现代浏览器采用多进程架构来提高稳定性和安全性： JavaScript在渲染进程中的执行 JavaScript主要在渲染进程中执行，与页面渲染共享同一个线程： 脚本加载与执行时机 浏览器处理JavaScript的执行时机有多种情况： 同步脚本执行 异步脚本执行 动态脚本注入 执行上下文的创建 每当JavaScript代码执行时，浏览器都会创建执行上下文： 执行上下文堆栈示例： 2.2 V8 引擎解析与执行流程 V8引擎简介 V8是Google开发的高性能JavaScript引擎，被Chrome浏览器和Node.js使用。它采用即时编译(JIT)技术，将JavaScript直接编译为机器码执行。 V8的执行流程 第一阶段：源码解析 (Parsing) V8首先将源码转换为抽象语法树(AST)： 第二阶段：字节码生成 V8将AST转换为字节码(Bytecode)，这是一种中间表示： 第三阶段：解释执行与优化编译 V8的优化策略 内联缓存 (Inline Caching) 隐藏类 (Hidden Classes) 垃圾回收优化 V8使用分代垃圾回收： 新生代：短期对象，使用Scavenge算法 老生代：长期对象，使用Mark-Sweep算法 2.3 JavaScript 是单线程的原因 历史设计决策 JavaScript被设计为单线程语言的原因： 简化DOM操作：避免多线程同时修改DOM产生的竞态条件 降低复杂性：单线程模型更容易理解和调试 快速实现：Brendan Eich只有10天时间设计语言 单线程的工作机制 事件循环 (Event Loop) 虽然JavaScript是单线程的，但通过事件循环机制实现异步执行： 事件循环流程图： Web Workers：突破单线程限制 2.4 从输入到渲染：代码执行生命周期 完整的页面加载流程 当用户访问一个包含JavaScript的网页时，浏览器执行以下步骤： 网络请求阶段 HTML解析阶段 DOM构建与脚本执行 关键渲染路径 (Critical Rendering Path) 渲染阻塞与优化 脚本阻塞问题 代码分割与懒加载 2.5 JavaScript 的应用边界 浏览器环境的限制 安全沙箱限制 内存与性能限制 JavaScript能做什么 前端交互 数据处理与可视化 网络通信 JavaScript做不到什么 直接系统访问 高精度计算限制 现代JavaScript的能力扩展 Progressive Web Apps (PWA) WebAssembly集成 总结 JavaScript的运行机制虽然基于单线程模型，但通过事件循环、异步编程和现代Web API的扩展，已经能够处理复杂的应用场景。理解这些机制有助于： 编写高性能代码：避免阻塞主线程的操作 合理使用异步：掌握Promise、async/await的执行时机 优化用户体验：通过代码分割和懒加载提升页面性能 扩展应用边界：利用Web Workers、WebAssembly等技术突破限制 --- 本章总结 第2章深入解析了JavaScript的运行机制和执行环境： 浏览器如何执行JavaScript： 多进程架构中JavaScript在渲染进程的执行 主线程的职责和JavaScript引擎的作用 与其他线程（网络、存储、合成）的协作 浏览器沙箱机制对JavaScript的安全限制 V8引擎解析与执行流程： 词法分析和语法分析的解析阶段 抽象语法树（AST）的构建过程 解释器Ignition和编译器TurboFan 即时编译（JIT）和代码优化机制 JavaScript单线程的原因： 避免DOM操作的竞态条件 简化编程模型和内存管理 通过事件循环实现并发处理 单线程模型的优势和限制 从输入到渲染的代码执行生命周期： HTML解析和JavaScript资源发现 脚本下载、解析、执行的时机控制 关键渲染路径和性能优化要点 页面交互就绪的完整流程 JavaScript的应用边界： Web Workers突破单线程限制 WebAssembly提供高性能计算能力 现代Web API扩展JavaScript能力 渐进式Web应用（PWA）的技术支撑 关键要点： JavaScript的单线程+事件循环模型是其核心执行机制 V8引擎的优化策略直接影响代码执行性能 理解执行时机有助于编写高性能的异步代码 现代Web技术为JavaScript提供了更广阔的应用空间 下一章预告 第3章将学习编写JavaScript的方式与加载机制，包括script标签的多种用法、async与defer的差异、以及前端性能优化策略。"
    },
    {
      "title": "第3章 编写 JavaScript 的方式与加载机制",
      "path": "JS/第3章 编写 JavaScript 的方式与加载机制.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "在网页中编写JavaScript代码有三种主要方式，每种方式都有其适用场景和特点：\r\n\r\n| 方式 | 定义位置 | 适用场景 | 优缺点 |\r\n|------|---------|----------|--------|\r\n| 内联脚本 | HTML元素的事件属性中 | 简单的事件响应 | 简单但不易维护 |\r\n| 内部脚本 | HTML文档的<script>标签内 | 页面特定的逻辑 | 便于",
      "content": "第3章 编写 JavaScript 的方式与加载机制 3.1 内联脚本、内部脚本、外部脚本 三种脚本编写方式概览 在网页中编写JavaScript代码有三种主要方式，每种方式都有其适用场景和特点： | 方式 | 定义位置 | 适用场景 | 优缺点 | |------|---------|----------|--------| | 内联脚本 | HTML元素的事件属性中 | 简单的事件响应 | 简单但不易维护 | | 内部脚本 | HTML文档的<script>标签内 | 页面特定的逻辑 | 便于调试但增加文档大小 | | 外部脚本 | 独立的.js文件中 | 可复用的功能模块 | 可缓存、易维护但需额外请求 | 内联脚本 (Inline Scripts) 内联脚本直接写在HTML元素的事件属性中，是最简单但也最不推荐的方式： 内联脚本的问题： 内部脚本 (Internal Scripts) 内部脚本写在HTML文档的<script>标签内： 内部脚本的适用场景： 页面特定的配置和初始化代码 需要访问页面内联数据的脚本 原型开发和调试阶段 外部脚本 (External Scripts) 外部脚本存储在独立的.js文件中，通过src属性引用： 最佳实践与选择标准 选择决策树 最佳实践规则 优先使用外部脚本 合理组织文件结构 使用模块化开发 遵循关注点分离原则 --- 3.2 script 标签与执行顺序 script 标签的基本语法 <script>标签是在HTML中嵌入JavaScript的标准方式，具有多个重要属性： 常用属性详解 | 属性 | 说明 | 示例 | |------|------|------| | src | 外部脚本文件路径 | src=\"js/main.js\" | | type | 脚本MIME类型 | type=\"text/javascript\" (默认) | | async | 异步加载和执行 | async | | defer | 延迟到DOM解析完成后执行 | defer | | crossorigin | 跨域资源共享 | crossorigin=\"anonymous\" | | integrity | 子资源完整性校验 | integrity=\"sha384-xxx\" | 脚本执行顺序规则 默认执行顺序（同步加载） 浏览器按照<script>标签在文档中出现的顺序执行： 执行阻塞行为 同步脚本会阻塞HTML解析： 依赖管理与执行时机 脚本依赖问题 依赖检测与错误处理 DOM就绪状态处理 模块化依赖管理 现代JavaScript使用ES6模块来管理依赖： --- 3.3 async 与 defer 差异 同步加载的问题 传统的同步脚本加载会阻塞HTML解析，影响页面性能： 同步加载的问题： 阻塞渲染：脚本下载和执行期间，页面显示空白 串行加载：脚本必须按顺序下载，无法并行 用户体验差：首屏渲染时间长 async 属性详解 async属性让脚本异步加载，下载完成后立即执行： async执行时序图 async适用场景 defer 属性详解 defer属性让脚本延迟到HTML解析完成后按顺序执行： defer执行时序图 defer使用示例 async vs defer 对比 详细对比表 | 特性 | 同步 | async | defer | |------|------|-------|-------| | 下载时机 | 立即下载，阻塞解析 | 并行下载，不阻塞 | 并行下载，不阻塞 | | 执行时机 | 下载完立即执行 | 下载完立即执行 | DOM解析完后执行 | | 执行顺序 | 严格按标签顺序 | 不保证顺序 | 严格按标签顺序 | | DOM访问 | 取决于标签位置 | 可能DOM未完成 | DOM一定完成 | | 适用场景 | 关键依赖脚本 | 独立功能脚本 | 需要DOM的脚本 | 实际应用决策 性能测试对比 选择建议 --- 3.4 阻塞与性能优化 渲染阻塞的原因 JavaScript执行会阻塞DOM构建和页面渲染，影响用户体验： 主要阻塞原因 同步脚本下载：阻塞HTML解析 脚本执行时间：长时间计算阻塞渲染 DOM操作频繁：引起多次重绘重排 资源加载顺序：关键资源加载过晚 性能优化策略 优化脚本加载顺序 使用Web Workers处理耗时计算 优化DOM操作 代码分割与懒加载 动态导入实现代码分割 资源预加载策略 --- 3.5 浏览器缓存与 JS 加载策略 浏览器缓存机制 浏览器缓存是提升JavaScript加载性能的关键技术： HTTP缓存头设置 Service Worker缓存策略 版本控制与缓存失效 文件指纹策略 动态资源加载器 现代加载策略 HTTP/2推送和预加载 --- --- 本章总结 第3章深入探讨了JavaScript代码的编写方式和加载机制： 内联脚本、内部脚本、外部脚本： 三种脚本编写方式的语法和特点 各种方式的适用场景和性能考量 安全性和维护性的权衡选择 现代开发中的最佳实践建议 script标签与执行顺序： 同步脚本的阻塞执行特性 DOM解析和脚本执行的时序关系 脚本依赖管理和加载策略 执行顺序对页面性能的影响 async与defer差异： async异步下载但立即执行的特性 defer延迟执行到DOM解析完成 两种属性的适用场景和性能对比 模块脚本（type=\"module\"）的加载行为 阻塞与性能优化： 关键渲染路径和阻塞资源识别 代码分割和懒加载的实现策略 Web Workers处理计算密集型任务 现代性能监控和优化技术 浏览器缓存与JS加载策略： HTTP缓存头的配置和控制 Service Worker的离线缓存能力 版本控制和缓存更新策略 CDN和资源优化的最佳实践 关键要点： 正确的加载策略是前端性能优化的基础 async和defer属性能显著改善页面加载体验 代码分割和缓存策略需要在性能和维护性间平衡 现代Web技术提供了更多性能优化可能性 下一章预告 第4章将进入语法基础篇，学习变量与常量，包括var、let、const的根本差异、作用域机制、变量提升与暂时性死区等核心概念。"
    },
    {
      "title": "第4章 变量与常量",
      "path": "JS/第4章 变量与常量.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "变量是编程语言的基础概念，JavaScript提供了三种声明变量的方式：var、let和const。理解它们的差异和适用场景，是掌握JavaScript的重要一步。\r\n\r\n\r\n\r\n\r\n\r\nJavaScript提供了三种变量声明关键字，每种都有其特定的行为和适用场景：\r\n\r\n| 关键字 | 引入版本 | 作用域 | 可重复声明 | 可重新赋值 | 变量提升 | 暂时性死区 |\r\n|--------|",
      "content": "第二篇 语法基础——构建语言根基 第4章 变量与常量 变量是编程语言的基础概念，JavaScript提供了三种声明变量的方式：var、let和const。理解它们的差异和适用场景，是掌握JavaScript的重要一步。 4.1 var、let、const 的根本差异 变量声明方式概览 JavaScript提供了三种变量声明关键字，每种都有其特定的行为和适用场景： | 关键字 | 引入版本 | 作用域 | 可重复声明 | 可重新赋值 | 变量提升 | 暂时性死区 | |--------|----------|--------|------------|------------|----------|------------| | var | ES3 | 函数作用域 | ✅ 是 | ✅ 是 | ✅ 是 | ❌ 否 | | let | ES6 | 块级作用域 | ❌ 否 | ✅ 是 | 🔶 有但不可访问 | ✅ 是 | | const | ES6 | 块级作用域 | ❌ 否 | ❌ 否 | 🔶 有但不可访问 | ✅ 是 | var：传统的变量声明 var是JavaScript最早的变量声明方式，具有以下特点： 函数作用域 允许重复声明 变量提升（Hoisting） 循环中的问题 let：块级作用域变量 let在ES6中引入，解决了var的诸多问题： 块级作用域 不允许重复声明 解决循环问题 const：不可变引用常量 const用于声明常量，具有let的所有特性，但有额外限制： 必须在声明时初始化 不可重新赋值 对象和数组的可变性 创建真正不可变的对象 三者对比总结 实际应用场景对比 选择建议决策树 性能考虑 --- 4.2 作用域：全局、函数、块级 作用域的概念 作用域（Scope）决定了变量和函数的可访问性。JavaScript中有三种主要的作用域： 全局作用域 全局作用域是最外层的作用域，在全局作用域中声明的变量可以在代码的任何地方访问： 浏览器环境中的全局作用域 意外的全局变量 全局命名空间污染问题 函数作用域 每个函数都创建自己的作用域，函数内部声明的变量只在函数内部可访问： 基本函数作用域 参数作用域 立即执行函数表达式（IIFE） 块级作用域 ES6引入的let和const支持块级作用域，由{}包围的区域形成一个块： 基本块级作用域 循环中的块级作用域 Switch语句的块级作用域陷阱 作用域链 JavaScript引擎通过作用域链来查找变量，从当前作用域开始，向外层作用域查找： 作用域链机制 作用域链与闭包 作用域性能优化 javascript // 代码编写时的样子 console.log(hoistedVar); // 输出: undefined var hoistedVar = 'I am hoisted'; // JavaScript引擎实际执行时的理解 var hoistedVar; // 声明被提升 console.log(hoistedVar); // undefined hoistedVar = 'I am hoisted'; // 赋值留在原位置 javascript / var提升示例 */ function varHoistingExample() { console.log('变量a:', a); // 输出: undefined (而不是报错) if (true) { var a = 'Hello'; console.log('块内变量a:', a); // 输出: Hello } console.log('块外变量a:', a); // 输出: Hello // 实际上等同于： // var a; // console.log('变量a:', a); // if (true) { // a = 'Hello'; // console.log('块内变量a:', a); // } // console.log('块外变量a:', a); } varHoistingExample(); javascript / 暂时性死区示例 */ function temporalDeadZoneExample() { console.log('进入函数作用域'); // 这里是TDZ开始 // console.log(letVar); // ReferenceError: Cannot access 'letVar' before initialization // console.log(constVar); // ReferenceError: Cannot access 'constVar' before initialization let letVar = 'I am let'; // TDZ结束 const constVar = 'I am const'; // TDZ结束 console.log(letVar); // 输出: I am let console.log(constVar); // 输出: I am const } temporalDeadZoneExample(); / 复杂的TDZ场景 */ function complexTDZ() { let x = 1; function innerFunction() { // 内部的x声明创建了TDZ，屏蔽了外部的x console.log(x); // ReferenceError: Cannot access 'x' before initialization let x = 2; } innerFunction(); } // complexTDZ(); // 取消注释会报错 javascript / 函数提升对比 */ console.log('=== 函数声明提升 ==='); console.log(declaredFunction()); // 输出: I am a declared function function declaredFunction() { return 'I am a declared function'; } console.log('=== 函数表达式不提升 ==='); // console.log(expressionFunction()); // TypeError: expressionFunction is not a function var expressionFunction = function() { return 'I am a function expression'; }; console.log(expressionFunction()); // 输出: I am a function expression / 箭头函数也不会提升 */ // console.log(arrowFunction()); // ReferenceError: Cannot access 'arrowFunction' before initialization const arrowFunction = () => { return 'I am an arrow function'; }; console.log(arrowFunction()); // 输出: I am an arrow function javascript // ✅ 推荐的声明优先级 const CONFIG = { api: '/api/v1' }; // 优先使用const let counter = 0; // 需要重新赋值时使用let // var legacy; // 避免使用var（除非维护老代码） / 实际应用示例 */ function bestPracticeExample() { // 常量配置 const MAX_RETRY = 3; const API_ENDPOINTS = { users: '/users', posts: '/posts' }; // 可变变量 let currentRetry = 0; let isLoading = false; // 函数内的局部常量 const processData = (data) => { const timestamp = Date.now(); return { ...data, timestamp }; }; return { MAX_RETRY, currentRetry, processData }; } javascript // ✅ 利用块级作用域组织代码 function processItems(items) { const results = []; // 处理有效项目 { const validItems = items.filter(item => item && item.id); const processedItems = validItems.map(item => ({ id: item.id, name: item.name || 'Unknown', processed: true })); results.push(...processedItems); } // 处理无效项目 { const invalidItems = items.filter(item => !item || !item.id); const errorItems = invalidItems.map((item, index) => ({ error: 'Invalid item', index, original: item })); results.push(...errorItems); } return results; } javascript // ✅ 好的命名约定 const USER_ROLES = ['admin', 'user', 'guest']; // 常量使用大写 const maxFileSize = 10 1024 1024; // 驼峰命名 const isAuthenticated = false; // 布尔值使用is/has前缀 const userList = []; // 数组使用复数或List后缀 const userMap = new Map(); // Map使用Map后缀 // ❌ 避免的命名方式 const data = {}; // 太模糊 const temp = 'value'; // 临时变量名不明确 const a = 10; // 单字母变量名 const UsErNaMe = 'John'; // 不一致的命名风格 / 函数和方法命名 */ const UserService = { // 动词开头，表达行为 createUser(userData) { / ... / }, deleteUser(userId) { / ... / }, // 获取数据使用get前缀 getUserById(id) { / ... / }, getUserList() { / ... / }, // 验证功能使用validate/check前缀 validateUserData(data) { / ... / }, checkUserPermission(userId, permission) { / ... / }, // 布尔返回值使用is/has/can前缀 isUserActive(userId) { / ... / }, hasPermission(userId, permission) { / ... / }, canUserAccess(userId, resource) { / ... / } }; javascript / 私有变量和方法（约定使用下划线前缀） */ class DataProcessor { constructor() { this._cache = new Map(); // 私有属性 this._maxCacheSize = 100; // 私有常量 } // 公共方法 processData(data) { return this._validateAndProcess(data); } // 私有方法 _validateAndProcess(data) { if (this._isValidData(data)) { return this._processValidData(data); } throw new Error('Invalid data'); } _isValidData(data) { / ... / } _processValidData(data) { / ... / } } / 事件处理函数命名 */ const EventHandlers = { // handle + 事件名 handleButtonClick(event) { / ... / }, handleInputChange(event) { / ... / }, handleFormSubmit(event) { / ... / }, // on + 事件名（回调函数） onUserLogin(userData) { / ... / }, onDataLoaded(data) { / ... / }, onError(error) { / ... / } }; javascript / 推荐的变量声明组织方式 */ function wellOrganizedFunction(params) { // 1. 常量配置（顶部） const DEFAULT_TIMEOUT = 5000; const VALID_STATUSES = ['active', 'pending', 'inactive']; // 2. 解构参数 const { userId, options = {} } = params; const { timeout = DEFAULT_TIMEOUT, retries = 3 } = options; // 3. 初始化变量 let currentRetry = 0; let lastError = null; let result = null; // 4. 复杂对象构造 const requestConfig = { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': Bearer ${getAuthToken()} }, timeout }; // 5. 函数逻辑 while (currentRetry < retries) { try { result = performRequest(requestConfig); break; } catch (error) { lastError = error; currentRetry++; } } return result || { error: lastError }; } javascript // module-config.js - 配置模块 export const APP_CONFIG = { API_BASE_URL: process.env.API_URL || 'http://localhost:3000', DEFAULT_TIMEOUT: 5000, MAX_RETRIES: 3 }; export const UI_CONSTANTS = { BREAKPOINTS: { mobile: '768px', tablet: '1024px', desktop: '1200px' }, COLORS: { primary: '#007bff', secondary: '#6c757d', success: '#28a745' } }; // user-service.js - 服务模块 import { APP_CONFIG } from './module-config.js'; // 模块级私有变量 let authToken = null; let requestCache = new Map(); // 公开的服务接口 export const UserService = { async login(credentials) { const response = await fetch(${APP_CONFIG.API_BASE_URL}/auth/login, { method: 'POST', body: JSON.stringify(credentials) }); if (response.ok) { authToken = response.headers.get('Authorization'); } return response; } }; javascript // ❌ 经典陷阱：循环中的var function createButtonHandlers_Bad() { const buttons = document.querySelectorAll('.btn'); for (var i = 0; i < buttons.length; i++) { buttons[i].onclick = function() { console.log('点击了按钮', i); // 总是输出最后一个i的值 }; } } // ✅ 解决方案1：使用let function createButtonHandlers_Good1() { const buttons = document.querySelectorAll('.btn'); for (let i = 0; i < buttons.length; i++) { buttons[i].onclick = function() { console.log('点击了按钮', i); // 正确输出对应的i值 }; } } // ✅ 解决方案2：使用forEach function createButtonHandlers_Good2() { const buttons = document.querySelectorAll('.btn'); buttons.forEach((button, index) => { button.onclick = () => { console.log('点击了按钮', index); }; }); } javascript // ❌ 意外创建全局变量 function processData_Bad() { data = []; // 忘记声明，创建了全局变量 for (item of items) { // 忘记声明，item成为全局变量 data.push(processItem(item)); } return data; } // ✅ 正确的变量声明 function processData_Good() { 'use strict'; // 使用严格模式防止意外全局变量 const data = []; for (const item of items) { data.push(processItem(item)); } return data; } javascript // ❌ 容易混淆的变量提升 function confusingHoisting_Bad() { console.log(message); // undefined，令人困惑 if (false) { var message = 'This will never execute'; } console.log(message); // 仍然是undefined } // ✅ 清晰的变量声明 function clearDeclaration_Good() { let message; if (someCondition()) { message = 'Condition is true'; } else { message = 'Condition is false'; } console.log(message); // 逻辑清晰 } javascript // ❌ 对const的误解 const users = []; users = []; // TypeError: Assignment to constant variable const config = { api: '/api/v1' }; config = {}; // TypeError: Assignment to constant variable // ✅ 正确使用const const users = []; users.push({ id: 1, name: 'Alice' }); // ✅ 可以修改数组内容 const config = { api: '/api/v1' }; config.timeout = 5000; // ✅ 可以修改对象属性 // 如需真正不可变，使用Object.freeze() const immutableConfig = Object.freeze({ api: '/api/v1', version: '1.0.0' }); ``` --- --- 本章总结 第4章详细介绍了JavaScript变量与常量的声明和使用： var、let、const的根本差异： var的函数作用域和变量提升特性 let的块级作用域和暂时性死区机制 const的常量特性和初始化要求 三种声明方式的适用场景对比 作用域：全局、函数、块级： 全局作用域的变量访问和污染问题 函数作用域的封装性和局部变量 ES6块级作用域的引入和应用价值 作用域链的查找机制和性能考量 变量提升与暂时性死区（TDZ）： var声明的提升行为和undefined初始化 函数声明的完整提升特性 let/const的TDZ和ReferenceError 提升机制对代码执行的影响 最佳实践与代码风格： 现代JavaScript的声明优先级原则 有意义的变量命名约定 作用域控制和代码组织策略 避免常见陷阱的编程技巧 关键要点： 优先使用const，需要重新赋值时使用let，避免使用var 块级作用域提供了更好的代码组织和错误预防能力 理解变量提升和TDZ有助于避免常见的JavaScript陷阱 良好的变量命名和作用域管理是高质量代码的基础 下一章预告 第5章将学习JavaScript的数据类型与类型系统，包括七种基本类型、引用类型、栈与堆的存储机制、以及类型判断与转换的方法。"
    },
    {
      "title": "第5章 数据类型与类型系统",
      "path": "JS/第5章 数据类型与类型系统.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "数据类型是编程语言的基础概念，JavaScript作为动态类型语言，具有灵活而复杂的类型系统。理解数据类型及其转换机制，是掌握JavaScript的关键。\r\n\r\n\r\n\r\n\r\n\r\nJavaScript有7种基本数据类型（原始类型），它们都是不可变的，存储在栈内存中：\r\n\r\n| 类型 | 引入版本 | 描述 | 默认值 | 特殊值 |\r\n|------|----------|------|------",
      "content": "第5章 数据类型与类型系统 数据类型是编程语言的基础概念，JavaScript作为动态类型语言，具有灵活而复杂的类型系统。理解数据类型及其转换机制，是掌握JavaScript的关键。 5.1 基本类型（七种） 基本类型概览 JavaScript有7种基本数据类型（原始类型），它们都是不可变的，存储在栈内存中： | 类型 | 引入版本 | 描述 | 默认值 | 特殊值 | |------|----------|------|--------|--------| | Number | ES1 | 数值类型 | 0 | NaN, Infinity | | String | ES1 | 字符串类型 | \"\" | 无 | | Boolean | ES1 | 布尔类型 | false | 无 | | Null | ES1 | 空值类型 | null | 无 | | Undefined | ES1 | 未定义类型 | undefined | 无 | | Symbol | ES6 | 符号类型 | 无默认值 | 无 | | BigInt | ES2020 | 大整数类型 | 0n | 无 | Number（数值类型） JavaScript中所有数值都使用64位浮点数表示（IEEE 754标准）： 数值表示方式 特殊数值 Number对象方法 String（字符串类型） 字符串是不可变的Unicode字符序列： 字符串创建方式 字符串方法 Boolean（布尔类型） 布尔类型只有两个值：true和false： Null（空值类型） null表示有意的空值或不存在的对象： Undefined（未定义类型） undefined表示变量已声明但未赋值，或不存在的对象属性： Symbol（符号类型） Symbol是ES6引入的新基本类型，表示唯一的标识符： BigInt（大整数类型） BigInt是ES2020引入的新类型，用于表示任意精度的整数： --- 5.2 引用类型 引用类型的特点 引用类型（对象类型）存储在堆内存中，变量存储的是对象的引用地址： 引用类型与基本类型的区别 | 特性 | 基本类型 | 引用类型 | |------|----------|----------| | 存储位置 | 栈内存 | 堆内存 | | 存储内容 | 值本身 | 引用地址 | | 可变性 | 不可变 | 可变 | | 比较方式 | 值比较 | 引用比较 | | 复制行为 | 值复制 | 引用复制 | Object（对象类型） 对象是键值对的集合，是JavaScript中最重要的数据类型： 对象创建方式 对象属性操作 Array（数组类型） 数组是特殊的对象，用于存储有序的数据集合： 数组创建和基本操作 Function（函数类型） 函数是JavaScript中的一等公民，也是对象类型： Date（日期类型） Date对象用于处理日期和时间： RegExp（正则表达式类型） 正则表达式用于模式匹配和文本处理： --- 5.3 栈与堆 内存分配模式 JavaScript使用两种内存区域存储数据：栈（Stack）和堆（Heap），了解它们的区别有助于理解数据类型的行为： 基本类型的栈存储 基本类型直接存储在栈内存中，具有以下特点： 引用类型的堆存储 引用类型存储在堆内存中，栈中只存储引用地址： 内存管理与垃圾回收 JavaScript自动管理内存，但了解垃圾回收机制有助于编写高效代码： --- 5.4 类型判断：typeof、instanceof typeof 操作符 typeof 是JavaScript中最基本的类型判断操作符，用于判断变量的数据类型： typeof 的基本用法 typeof 的应用场景 instanceof 操作符 instanceof 用于检测对象是否为特定构造函数的实例： instanceof 的基本原理 instanceof 的陷阱和限制 其他类型判断方法 除了 typeof 和 instanceof，还有其他更精确的类型判断方法： 准确的类型判断工具函数 基于以上方法，我们可以创建一套完整的类型判断工具： --- 5.5 类型转换（隐式与显式） 隐式类型转换 JavaScript会在特定情况下自动执行类型转换，这被称为隐式类型转换或强制类型转换： 字符串转换 数值转换 布尔转换 显式类型转换 显式类型转换是程序员主动执行的类型转换，更可控和可预测： 转换规则与机制 JavaScript类型转换遵循特定的规则和算法： 常见转换陷阱 了解常见的类型转换陷阱有助于避免Bug： --- 5.6 JSON 的本质与应用 JSON 数据格式 JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，基于JavaScript对象语法但独立于编程语言： JSON 序列化与反序列化 JavaScript提供了内置的JSON对象来处理JSON数据： JSON 与 JavaScript 对象的差异 尽管JSON基于JavaScript对象语法，但两者存在重要差异： 实际应用场景 JSON在实际开发中有广泛的应用： --- 本章总结 第5章深入探讨了JavaScript的数据类型与类型系统： 基本类型（七种）：详细介绍了Number、String、Boolean、Null、Undefined、Symbol、BigInt的特性和使用方法 引用类型：深入讲解了Object、Array、Function、Date、RegExp等引用类型的创建和操作 栈与堆：解释了内存分配模式、深浅拷贝机制，以及内存管理和垃圾回收 类型判断：掌握typeof、instanceof等判断方法的原理、局限性和最佳实践 类型转换：理解隐式转换规则、掌握显式转换方法，避免常见转换陷阱 JSON应用：了解JSON格式规范、序列化反序列化机制，以及在实际开发中的应用 理解数据类型是JavaScript编程的基础，掌握类型系统有助于编写更可靠、更高效的代码。 下一章预告 第6章将探讨JavaScript的运算符与表达式，包括算术运算符、比较运算符、逻辑运算符、位运算符等的使用方法和运算优先级。 --- 本章总结 下一章预告"
    },
    {
      "title": "第6章 运算符、表达式与逻辑",
      "path": "JS/第6章 运算符、表达式与逻辑.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "运算符是JavaScript编程的基础工具，用于执行各种操作和逻辑判断。掌握运算符的使用方法、优先级规则以及现代JavaScript的新特性，能够让你编写更简洁高效的代码。\r\n\r\n\r\n\r\n\r\n\r\n算术运算符用于执行数学运算，包括基本的加减乘除和其他数学操作：\r\n\r\n\r\n\r\n\r\n\r\n比较运算符用于比较两个值，返回布尔结果：\r\n\r\n\r\n\r\n\r\n\r\n逻辑运算符用于逻辑运算，通常与布尔值配合使用：\r\n\r\n",
      "content": "第6章 运算符、表达式与逻辑 运算符是JavaScript编程的基础工具，用于执行各种操作和逻辑判断。掌握运算符的使用方法、优先级规则以及现代JavaScript的新特性，能够让你编写更简洁高效的代码。 6.1 算术、比较、逻辑运算符 算术运算符 算术运算符用于执行数学运算，包括基本的加减乘除和其他数学操作： 比较运算符 比较运算符用于比较两个值，返回布尔结果： 逻辑运算符 逻辑运算符用于逻辑运算，通常与布尔值配合使用： --- 6.2 短路逻辑 短路逻辑是JavaScript中逻辑运算符的重要特性，当第一个操作数就能确定整个表达式的结果时，JavaScript会停止求值后续操作数。 逻辑与（&&）的短路特性 逻辑与操作符从左到右求值，当遇到第一个假值时立即返回该值，否则返回最后一个值： 逻辑或（||）的短路特性 逻辑或操作符从左到右求值，当遇到第一个真值时立即返回该值，否则返回最后一个值： 短路逻辑的实际应用 短路逻辑在实际编程中有许多实用的应用场景： --- 6.3 可选链（?.）与空值合并（??） ES2020引入的可选链和空值合并操作符为JavaScript提供了更安全、更简洁的属性访问和默认值设置方式。 可选链操作符（?.） 可选链操作符允许安全地访问深层嵌套的对象属性，而不必验证每个引用： 空值合并操作符（??） 空值合并操作符只有在左侧为null或undefined时才返回右侧值： 现代JavaScript的安全访问模式 结合可选链和空值合并，可以创建更安全、更简洁的代码模式： --- 6.4 == vs === 理解==和===的区别是JavaScript编程的重要基础，选择正确的比较操作符可以避免许多隐藏的错误。 等值比较（==） 等值比较会进行类型转换，试图将两个值转换为可比较的类型： 严格相等比较（===） 严格相等比较不进行类型转换，只有类型和值都相同才返回true： 比较运算的最佳实践 基于==和===的特性，这里是一些最佳实践建议： --- 6.5 优先级规则 运算符优先级决定了表达式的求值顺序，理解优先级规则有助于编写正确且可读的代码。 运算符优先级表 JavaScript运算符的优先级从高到低排列： 结合性规则 当运算符具有相同优先级时，结合性决定求值顺序： 复杂表达式的求值顺序 理解复杂表达式的求值顺序有助于调试和优化代码： 括号的使用建议 合理使用括号可以提高代码的可读性和正确性： --- 本章总结 第6章深入探讨了JavaScript的运算符、表达式与逻辑： 算术、比较、逻辑运算符：掌握了各类运算符的基本用法、特殊情况和实用工具函数 短路逻辑：理解了&&和||的短路特性，学会利用短路进行性能优化和条件执行 可选链与空值合并：掌握了现代JavaScript的安全访问模式，避免了深层属性访问的错误 == vs ===：深入理解了两种比较方式的区别，学会了选择合适的比较操作符 优先级规则：掌握了运算符优先级和结合性，学会了使用括号提高代码可读性 理解运算符和表达式是编写高质量JavaScript代码的重要基础，正确使用这些概念能够让代码更安全、更高效、更易维护。 下一章预告 第7章将探讨JavaScript的流程控制，包括条件语句、循环语句、跳转语句等的使用方法和最佳实践。"
    },
    {
      "title": "第7章 流程控制",
      "path": "JS/第7章 流程控制.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "流程控制是编程的核心概念，决定了代码的执行路径和逻辑结构。JavaScript提供了丰富的流程控制语句，包括条件判断、循环执行、分支选择等，掌握这些语句是编写复杂逻辑的基础。\r\n\r\n\r\n\r\n条件语句是程序中最基本的控制结构，允许根据不同的条件执行不同的代码分支。\r\n\r\n\r\n\r\n最简单的条件语句只包含一个if分支，当条件为真时执行相应代码：\r\n\r\n\r\n\r\n\r\n\r\nif/else提供了二元选择，当条件",
      "content": "第7章 流程控制 流程控制是编程的核心概念，决定了代码的执行路径和逻辑结构。JavaScript提供了丰富的流程控制语句，包括条件判断、循环执行、分支选择等，掌握这些语句是编写复杂逻辑的基础。 7.1 条件语句：if / else 条件语句是程序中最基本的控制结构，允许根据不同的条件执行不同的代码分支。 基本if语句 最简单的条件语句只包含一个if分支，当条件为真时执行相应代码： if / else 结构 if/else提供了二元选择，当条件不满足时执行替代逻辑： 嵌套条件与多重判断 复杂的业务逻辑往往需要嵌套的条件判断： 条件语句的最佳实践 编写清晰、可维护的条件语句需要遵循一些最佳实践： --- 7.2 多分支：switch switch语句提供了一种更简洁的方式来处理多个条件分支，特别适用于基于单个变量值的多路选择。 switch语句的基本结构 switch语句通过匹配表达式的值与case标签来选择执行路径： case语句与break break语句控制switch的执行流程，防止代码\"落through\"到下一个case： default子句 default子句为switch提供兜底处理，当所有case都不匹配时执行： switch的高级应用 switch语句的一些高级用法和最佳实践： --- 7.3 循环语句：for、while、do-while 循环语句允许重复执行代码块，是处理数组、对象和重复任务的核心工具。 for循环 for循环是最常用的循环结构，适合已知循环次数的情况： while循环 while循环适用于条件未知何时满足的情况： do-while循环 do-while循环至少执行一次代码块，适用于需要先执行后判断的场景： 循环的性能优化 掌握循环性能优化技巧可以显著提升代码执行效率： --- 7.4 for...in、for...of ES6引入了两种特殊的循环语句，分别用于遍历对象属性和可迭代对象。 for...in 遍历对象属性 for...in循环用于遍历对象的可枚举属性： for...of 遍历可迭代对象 for...of循环用于遍历可迭代对象（如数组、字符串、Map、Set等）的值： 两种循环的差异与选择 理解for...in和for...of的区别，有助于在不同场景中选择合适的遍历方式： --- 7.5 break 与 continue break和continue语句用于控制循环的执行流程，提供了更精细的循环控制能力。 break语句 break语句用于立即退出当前循环： continue语句 continue语句用于跳过当前迭代，继续执行下一次迭代： 标签语句与多层循环控制 标签语句允许在多层嵌套循环中精确控制break和continue的作用范围： --- 7.6 常见流程控制场景 流程控制在实际开发中有许多典型的应用模式，掌握这些场景能够写出更高效、更可维护的代码。 数据处理流程 数据处理是最常见的流程控制应用场景： 用户交互逻辑 用户交互场景需要复杂的条件判断和状态管理： 错误处理与异常流程 健壮的错误处理是高质量代码的重要特征： --- 本章总结 第7章全面探讨了JavaScript的流程控制机制： 条件语句(if/else): 掌握了基本条件判断、嵌套优化、早期返回模式和重构技巧 多分支(switch): 学会了switch语句的各种用法、fall-through特性和与if/else的性能对比 循环语句: 深入理解了for、while、do-while的特点和性能优化策略 现代循环: 掌握了for...in和for...of的差异、适用场景和迭代器协议 循环控制: 学会了break、continue和标签语句的精确控制技巧 实际应用: 探讨了数据处理、用户交互和错误处理等常见流程控制场景 流程控制是编程的基础，正确运用这些控制结构能让代码逻辑更清晰、执行更高效、维护更容易。 下一章预告 第8章将深入探讨JavaScript的函数基础，包括函数声明方式、箭头函数、参数处理、返回值机制和闭包概念，为深入理解JavaScript的函数式编程特性打下坚实基础。"
    },
    {
      "title": "第8章 函数基础",
      "path": "JS/第8章 函数基础.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "函数是JavaScript的核心概念，是第一类对象（First-class Object），可以作为值传递、存储在变量中、作为参数传递给其他函数，或作为返回值。理解函数是掌握JavaScript高级特性的关键。\r\n\r\n\r\n\r\nJavaScript提供了多种声明函数的方式，每种方式都有其特点和适用场景。理解这些差异对于编写高质量的代码至关重要。\r\n\r\n\r\n\r\n函数声明是最传统的定义函数的方式，具有提",
      "content": "第8章 函数基础 函数是JavaScript的核心概念，是第一类对象（First-class Object），可以作为值传递、存储在变量中、作为参数传递给其他函数，或作为返回值。理解函数是掌握JavaScript高级特性的关键。 8.1 函数声明方式 JavaScript提供了多种声明函数的方式，每种方式都有其特点和适用场景。理解这些差异对于编写高质量的代码至关重要。 函数声明（Function Declaration） 函数声明是最传统的定义函数的方式，具有提升（hoisting）特性： 函数表达式（Function Expression） 函数表达式将函数赋值给变量，不具有提升特性： 箭头函数（Arrow Function） ES6引入的箭头函数提供了更简洁的语法： 函数构造器（Function Constructor） Function构造器允许动态创建函数，但很少使用： 方法定义（Method Definition） ES6引入了简化的方法定义语法： --- 8.2 箭头函数与 this 箭头函数的this绑定机制与传统函数完全不同，这是JavaScript中最重要的概念之一。 箭头函数的语法特点 箭头函数提供了简洁的语法，但有特定的使用规则： this绑定机制 箭头函数最重要的特性是它没有自己的this，而是继承外围作用域的this： 箭头函数的局限性 理解箭头函数的限制有助于正确选择使用场景： 实际应用场景 了解箭头函数的最佳使用场景： --- 8.3 参数、默认参数、剩余参数 JavaScript函数提供了灵活的参数处理机制，ES6进一步增强了参数的功能。 基本参数处理 函数参数的基础概念和处理方式： 默认参数（Default Parameters） ES6引入的默认参数功能，简化了参数处理： 剩余参数（Rest Parameters） 剩余参数允许函数接收任意数量的参数： 参数解构 参数解构提供了更灵活的参数处理方式： --- 8.4 返回值与执行流程 函数的返回值和执行流程是理解JavaScript运行机制的关键。 函数返回值 JavaScript函数可以返回各种类型的值，包括基本类型、对象、函数等： 执行上下文 每个函数调用都会创建一个新的执行上下文： 调用栈 调用栈管理函数的执行顺序和嵌套关系： 递归函数 递归是函数调用自身的编程技术： --- 8.5 闭包（Closure）基础 闭包是JavaScript最重要的概念之一，理解闭包对掌握高级编程技巧至关重要。 闭包的概念 闭包是指函数能够访问其外部作用域变量的特性： 闭包的形成条件 闭包的形成需要满足特定条件： 闭包的实际应用 闭包在实际开发中有许多重要应用： 闭包的注意事项 使用闭包时需要注意内存和性能问题： --- 本章总结 第8章全面介绍了JavaScript函数的基础知识： 函数声明方式: 掌握了函数声明、函数表达式、箭头函数、构造器和方法定义等多种方式 箭头函数与this: 深入理解了箭头函数的语法特点、this绑定机制、局限性和最佳实践 参数处理: 学会了基本参数、默认参数、剩余参数和参数解构等现代参数处理技术 返回值与执行流程: 理解了函数返回值、执行上下文、调用栈和递归等执行机制 闭包基础: 掌握了闭包的概念、形成条件、实际应用和注意事项 函数是JavaScript的核心，掌握这些基础概念为后续学习高级函数特性、面向对象编程和函数式编程奠定了坚实基础。 下一章预告 第9章将深入探讨JavaScript的对象与引用，包括对象的创建方式、属性访问与配置、引用模型的共享特性，以及浅拷贝与深拷贝等重要概念，为理解JavaScript的对象系统做好准备。"
    },
    {
      "title": "第9章 对象与引用",
      "path": "JS/第9章 对象与引用.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "对象是JavaScript的核心数据结构，几乎所有的JavaScript程序都涉及对象的创建、操作和管理。理解对象的引用模型对于编写正确和高效的代码至关重要。\r\n\r\n\r\n\r\nJavaScript提供了多种创建对象的方式，每种方式都有其特点和适用场景。\r\n\r\n\r\n\r\n对象字面量是创建对象最简单直观的方式：\r\n\r\n\r\n\r\n\r\n\r\n使用Object构造函数创建对象：\r\n\r\n\r\n\r\n\r\n\r\n自定义构造函数",
      "content": "第9章 对象与引用 对象是JavaScript的核心数据结构，几乎所有的JavaScript程序都涉及对象的创建、操作和管理。理解对象的引用模型对于编写正确和高效的代码至关重要。 9.1 创建对象的多种方式 JavaScript提供了多种创建对象的方式，每种方式都有其特点和适用场景。 对象字面量 对象字面量是创建对象最简单直观的方式： Object构造函数 使用Object构造函数创建对象： 构造函数模式 自定义构造函数是创建特定类型对象的传统方式： 工厂模式 工厂模式用于封装对象创建过程： Object.create() Object.create()方法提供了基于原型创建对象的方式： 类（ES6） ES6引入的class语法提供了更清晰的面向对象编程方式： --- 9.2 属性访问与配置 JavaScript对象的属性访问和配置机制非常灵活，提供了多种方式来操作对象属性。 属性访问方式 对象属性有两种基本访问方式： 属性描述符 属性描述符定义了属性的特性： getter和setter Getter和Setter提供了属性访问的控制机制： 属性的枚举性 控制属性在枚举操作中的可见性： --- 9.3 引用模型与共享特性 JavaScript中的引用模型是理解对象行为的关键，它决定了变量如何存储和传递数据。 引用类型vs值类型 JavaScript有两种数据类型的存储方式： 引用传递 理解引用传递对于正确处理对象至关重要： 对象共享 多个变量可以共享同一个对象： 引用比较 对象比较的是引用，而不是内容： --- 9.4 浅拷贝与深拷贝 理解和正确实现对象拷贝是JavaScript编程中的重要技能。 浅拷贝的实现 浅拷贝只复制对象的第一层属性： 深拷贝的实现 深拷贝递归复制所有层级的属性： 拷贝的注意事项 使用拷贝时需要注意的问题： 实际应用场景 了解何时使用浅拷贝或深拷贝： --- 本章总结 第9章深入探讨了JavaScript对象与引用的核心概念： 创建对象的多种方式： 对象字面量：最简单直观的创建方式 构造函数模式：创建特定类型的对象实例 工厂模式：封装对象创建过程 Object.create()：基于原型创建对象 ES6类：提供更清晰的面向对象语法 属性访问与配置： 点记法和方括号记法的使用场景 属性描述符控制属性特性 getter/setter实现属性访问控制 属性枚举性管理和遍历方法 引用模型与共享特性： 值类型vs引用类型的本质区别 引用传递机制和内存模型 对象共享的优势与陷阱 引用比较和深度比较实现 浅拷贝与深拷贝： 多种浅拷贝实现方式及其限制 深拷贝的递归实现和特殊情况处理 性能考虑和不可变数据模式 实际应用中的拷贝策略选择 通过本章学习，你应该能够： 灵活运用各种对象创建方式 精确控制对象属性的行为 理解引用机制避免意外修改 正确实现对象拷贝满足不同需求 关键要点： 对象是引用类型，赋值传递的是引用而非值 浅拷贝只复制第一层，深层属性仍是引用 深拷贝需要考虑循环引用、特殊对象等情况 不可变数据模式有助于状态管理和调试 下一章预告 第10章将深入探讨原型与原型链，包括prototype的本质、原型链查找机制、构造函数的工作原理、ES6 class语法，以及继承与封装的实现方式。这些知识是理解JavaScript面向对象编程的关键。"
    },
    {
      "title": "第10章 原型与原型链",
      "path": "JS/第10章 原型与原型链.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "原型与原型链是JavaScript面向对象编程的核心机制。理解原型链不仅有助于掌握JavaScript的继承体系，更是深入理解JavaScript运行机制的关键。\r\n\r\n\r\n\r\nJavaScript中的每个函数都有一个prototype属性，这是原型继承的基础。\r\n\r\n\r\n\r\n每个函数都有一个prototype属性，它指向一个对象：\r\n\r\n\r\n\r\n\r\n\r\n理解原型对象的内部结构：\r\n\r\n\r\n\r\n-",
      "content": "第10章 原型与原型链 原型与原型链是JavaScript面向对象编程的核心机制。理解原型链不仅有助于掌握JavaScript的继承体系，更是深入理解JavaScript运行机制的关键。 10.1 prototype 的本质 JavaScript中的每个函数都有一个prototype属性，这是原型继承的基础。 函数的prototype属性 每个函数都有一个prototype属性，它指向一个对象： 原型对象的结构 理解原型对象的内部结构： --- 10.2 原型链查找机制 原型链是JavaScript实现继承的核心机制，理解属性查找过程对掌握JavaScript至关重要。 属性查找过程 JavaScript引擎按照特定顺序查找属性： 方法继承 方法继承是原型链的重要应用： 原型链的尽头 理解原型链如何终止： --- 10.3 构造函数 构造函数是JavaScript中创建对象和实现继承的传统方式。 构造函数与new操作符 理解new操作符的工作机制： 实例属性vs原型属性 理解实例属性和原型属性的区别： 构造函数的问题与优化 传统构造函数的问题和现代解决方案： --- 10.4 class 与 ES6 面向对象 ES6的class语法提供了更清晰的面向对象编程方式。 class语法糖 class本质上是构造函数的语法糖： 实例方法与静态方法 class中的方法分类和使用场景： getter/setter 属性访问器的高级用法： 私有属性 JavaScript中的私有属性实现： --- 10.5 super、继承、封装 JavaScript继承机制的完整实现。 原型继承 传统的原型继承模式： class继承 ES6 class的继承机制： --- 本章总结 第10章深入探讨了JavaScript原型与原型链的核心机制： prototype的本质： 函数的prototype属性与实例的__proto__关系 原型对象的默认结构和动态修改 原型污染的风险和防范 原型链查找机制： 属性查找的完整过程和性能影响 方法继承和属性遮蔽现象 Object.prototype作为原型链终点 构造函数： new操作符的工作机制 实例属性vs原型属性的区别 构造函数的问题与现代优化方案 ES6 class： class作为构造函数的语法糖 实例方法、静态方法和访问器 私有属性的实现方式 继承与封装： 原型继承的传统模式 class继承和super的使用 多种封装模式的对比 关键要点： 原型链是JavaScript继承的基础机制 属性查找沿着原型链进行，理解查找顺序很重要 class语法提供了更清晰的面向对象编程方式 私有属性有多种实现方案，ES2022的#语法最为标准 下一章预告 第11章将学习数组与高阶方法，包括数组的本质、常用数组方法、迭代器模式、map/filter/reduce等高阶方法，以及实际项目中的数组处理模式。"
    },
    {
      "title": "第11章 数组与高阶方法",
      "path": "JS/第11章 数组与高阶方法.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "数组是JavaScript中最重要的数据结构之一，也是函数式编程的核心载体。本章将深入探讨数组的本质、常用方法、迭代器模式，以及map、filter、reduce等高阶方法的实际应用。\r\n\r\n\r\n\r\n理解数组的内部结构和特性是掌握数组操作的基础。\r\n\r\n\r\n\r\nJavaScript数组是一种特殊的对象：\r\n\r\n\r\n\r\n\r\n\r\n掌握各种数组创建方法：\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\nJavaSc",
      "content": "第11章 数组与高阶方法 数组是JavaScript中最重要的数据结构之一，也是函数式编程的核心载体。本章将深入探讨数组的本质、常用方法、迭代器模式，以及map、filter、reduce等高阶方法的实际应用。 11.1 数组的本质 理解数组的内部结构和特性是掌握数组操作的基础。 数组的内部结构 JavaScript数组是一种特殊的对象： 数组创建方式 掌握各种数组创建方法： --- 11.2 常用数组方法 JavaScript提供了丰富的数组方法来处理各种操作需求。 基础操作方法 数组的增删改查基础操作： 查找和检测方法 数组中元素的查找和检测： 排序方法 数组排序和重新排列： --- 11.3 数组迭代器 数组遍历从传统循环到现代迭代器的演进。 传统遍历方式 经典的数组遍历方法： 现代迭代器 ES6迭代器协议和Iterator接口： --- 11.4 map / filter / reduce 函数式编程的核心高阶方法。 map方法深度解析 数据映射和转换： filter方法应用 数据过滤和筛选： reduce的强大功能 数据聚合和累积操作： 组合使用模式 高阶方法的链式组合： --- 11.5 在实际项目中的数组处理模式 实际开发中的数组处理最佳实践。 数据转换模式 常见的数据处理场景： --- 本章总结 第11章全面探讨了JavaScript数组与高阶方法的核心知识： 数组的本质： 数组作为特殊对象的内部结构 长度属性的动态性和特殊行为 多种创建方式和稀疏数组处理 常用数组方法： 增删改查的基础操作方法 查找和检测的多种技巧 排序和重新排列的高级应用 数组迭代器： 从传统循环到现代迭代器的演进 Iterator协议和可迭代对象 性能优化和最佳实践 高阶方法： map方法的数据映射和转换 filter方法的筛选和去重 reduce方法的聚合和累积操作 方法链式组合的强大威力 实际项目应用： API数据标准化处理 表格数据的智能转换 嵌套数据的扁平化技巧 关键要点： 数组是JavaScript中最重要的数据结构 高阶方法是函数式编程的核心工具 合理的方法组合能简化复杂的数据处理 性能优化要在可读性和效率间找到平衡 下一章预告 第12章将学习DOM基础，包括DOM树结构、元素获取与操作、属性和样式修改、节点关系遍历，以及DOM性能优化技巧。这将开启我们与浏览器交互的重要篇章。"
    },
    {
      "title": "第12章 DOM基础",
      "path": "JS/第12章 DOM基础.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "DOM（Document Object Model，文档对象模型）是JavaScript操作网页的核心接口。它将HTML文档表示为节点树，让我们能够动态地操作网页内容、结构和样式。本章将全面掌握DOM操作的基础知识。\r\n\r\n\r\n\r\n理解DOM的树形结构是操作网页元素的前提。\r\n\r\n\r\n\r\nDOM中的不同节点类型及其特征：\r\n\r\n\r\n\r\n\r\n\r\n深入理解HTML文档的DOM表示：\r\n\r\n\r\n\r\n--",
      "content": "第12章 DOM基础 DOM（Document Object Model，文档对象模型）是JavaScript操作网页的核心接口。它将HTML文档表示为节点树，让我们能够动态地操作网页内容、结构和样式。本章将全面掌握DOM操作的基础知识。 12.1 DOM树结构 理解DOM的树形结构是操作网页元素的前提。 DOM节点类型 DOM中的不同节点类型及其特征： 文档结构分析 深入理解HTML文档的DOM表示： --- 12.2 获取、创建、删除元素 DOM元素的基础操作是网页动态交互的基础。 元素获取方法 掌握各种元素选择和获取技巧： 元素创建技巧 多种元素创建和构建方式： 12.3 修改属性、样式、文本 操作元素的内容和外观是DOM操作的核心功能。 属性操作 元素属性的获取和设置方法： 样式控制 CSS样式的动态操作： 文本内容管理 操作元素的文本内容： --- 12.4 节点关系与遍历 理解和操作DOM节点之间的关系。 节点关系属性 DOM节点的层级关系： 遍历算法 高效的DOM树遍历方法： --- 12.5 DOM性能优化 提升DOM操作的性能和效率。 性能瓶颈分析 识别和避免常见的性能问题： --- 本章总结 第12章深入探讨了DOM基础操作的核心知识： DOM树结构： 12种DOM节点类型及其特征 文档对象模型的层次结构 HTML5语义化元素的正确使用 文档生命周期和状态管理 元素操作基础： 多种元素获取方法对比 现代CSS选择器的灵活运用 元素创建的最佳实践 性能优化的批量操作技巧 属性和样式控制： 标准属性操作和特殊属性处理 数据属性和表单属性的管理 内联样式的动态操作 CSS类的灵活控制和批量操作 关键要点： DOM是JavaScript操作网页的核心接口 选择合适的元素获取方法能提升性能 DocumentFragment是批量操作的性能利器 理解节点类型有助于准确的DOM操作 属性和property有微妙差异需要注意 classList API提供了强大的类操作功能 下一章预告 第13章将学习事件与交互系统，包括事件监听机制、事件冒泡与捕获、事件委托模式、以及各种用户交互事件的处理，构建真正的动态网页交互功能。"
    },
    {
      "title": "第13章 事件与交互系统",
      "path": "JS/第13章 事件与交互系统.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "事件是Web交互的核心机制，让网页能够响应用户的操作和系统状态变化。本章将深入学习JavaScript事件系统，从基础的事件监听到复杂的事件管理模式，构建真正动态的用户界面。\r\n\r\n\r\n\r\n现代JavaScript事件处理的标准方法。\r\n\r\n\r\n\r\n掌握addEventListener的核心用法：\r\n\r\n\r\n\r\n\r\n\r\n了解各种DOM事件类型：\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\nJavaScri",
      "content": "第13章 事件与交互系统 事件是Web交互的核心机制，让网页能够响应用户的操作和系统状态变化。本章将深入学习JavaScript事件系统，从基础的事件监听到复杂的事件管理模式，构建真正动态的用户界面。 13.1 事件监听（addEventListener） 现代JavaScript事件处理的标准方法。 基础事件监听 掌握addEventListener的核心用法： 事件类型分类 了解各种DOM事件类型： --- 13.2 冒泡与捕获 JavaScript事件流的三个阶段：捕获阶段、目标阶段、冒泡阶段。 事件流机制 理解事件在DOM树中的传播过程： --- 13.3 阻止默认与阻止传播 控制事件的默认行为和传播过程。 事件控制方法 掌握preventDefault和stopPropagation的使用： --- 13.4 事件委托 利用事件冒泡实现高效的事件管理模式。 委托模式原理 事件委托的核心概念和实现： --- 13.5 鼠标、键盘、表单事件 处理各种用户输入事件。 鼠标事件处理 鼠标交互的完整处理： 键盘事件管理 键盘输入的处理和管理： --- 13.6 TodoList 事件管理实战 通过完整的TodoList项目展示事件管理的最佳实践。 项目架构设计 构建一个功能完整的TodoList应用： --- 本章总结 第13章深入探讨了JavaScript事件与交互系统的核心知识： 事件监听机制： addEventListener的标准用法和选项 事件管理和EventManager类 各种事件类型的分类和处理 事件流机制： 捕获、目标、冒泡三个阶段 事件路径追踪和阶段检测 实际应用中的事件流控制 事件控制： preventDefault阻止默认行为 stopPropagation控制事件传播 条件性事件控制和最佳实践 事件委托： 利用事件冒泡实现高效管理 delegate工具函数的实现 性能优化的实际效果 用户交互事件： 鼠标事件的完整处理 键盘事件和快捷键系统 拖拽功能的实现 实战应用： TodoList完整项目 事件管理的最佳实践 本地存储集成 关键要点： 现代事件处理以addEventListener为标准 理解事件流有助于复杂交互设计 事件委托能显著提升性能 合理的事件控制能提升用户体验 实际项目中需要统一的事件管理策略 下一章预告 第14章将学习BOM（浏览器对象模型），包括window对象、定时器、location和history对象、本地存储（localStorage/sessionStorage/cookie）以及浏览器能力检测等内容。 捕获、目标、冒泡三个阶段 事件路径追踪和阶段检测 实际应用中的事件流控制 事件控制： preventDefault阻止默认行为 stopPropagation控制事件传播 条件性事件控制和最佳实践 关键要点： 现代事件处理以addEventListener为标准 理解事件流有助于复杂交互设计 合理的事件控制能提升用户体验 事件管理类能简化复杂应用的事件处理 下一章预告 第14章将学习BOM（浏览器对象模型），包括window对象、定时器、location和history对象、本地存储（localStorage/sessionStorage/cookie）以及浏览器能力检测等内容。"
    },
    {
      "title": "第14章 BOM：浏览器对象模型",
      "path": "JS/第14章 BOM：浏览器对象模型.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "BOM（Browser Object Model，浏览器对象模型）提供了与浏览器窗口交互的接口，包括窗口控制、定时器、位置信息、历史记录、本地存储等功能。本章将深入学习BOM的各个组件及其在实际开发中的应用。\r\n\r\n\r\n\r\nwindow对象是BOM的核心，代表浏览器窗口，也是JavaScript的全局对象。\r\n\r\n\r\n\r\nwindow对象作为全局对象的特殊性：\r\n\r\n\r\n\r\n\r\n\r\nwindow对",
      "content": "第14章 BOM：浏览器对象模型 BOM（Browser Object Model，浏览器对象模型）提供了与浏览器窗口交互的接口，包括窗口控制、定时器、位置信息、历史记录、本地存储等功能。本章将深入学习BOM的各个组件及其在实际开发中的应用。 14.1 window对象 window对象是BOM的核心，代表浏览器窗口，也是JavaScript的全局对象。 全局对象特性 window对象作为全局对象的特殊性： 窗口事件处理 window对象的重要事件： --- 14.2 定时器 JavaScript提供了多种定时器机制，用于延迟执行和周期性执行代码。 基础定时器 setTimeout和setInterval的使用： --- 14.3 location、history 浏览器的位置信息和历史记录管理。 location对象 URL信息的获取和操作： --- 14.4 localStorage / sessionStorage / cookie Web存储机制的完整应用。 本地存储机制 --- 14.5 浏览器能力检测 现代浏览器特性检测和兼容性处理。 特性检测 --- 本章总结 第14章深入探讨了BOM浏览器对象模型的核心知识： window对象： 全局对象特性和作用域管理 窗口属性、方法和事件处理 网络状态和响应式处理 定时器机制： setTimeout和setInterval的使用 TimerManager定时器管理类 高精度定时器和动画帧 位置和历史： location对象的URL操作 history对象的导航管理 存储机制： localStorage和sessionStorage StorageManager存储管理类 数据过期和清理机制 能力检测： 现代浏览器特性检测 兼容性处理和降级方案 关键要点： BOM提供了与浏览器环境交互的完整接口 定时器管理对性能和资源控制至关重要 本地存储需要考虑容量限制和过期机制 特性检测比用户代理检测更可靠 下一章预告 第15章将学习异步编程基础，包括同步与异步的差异、回调函数、任务队列与事件循环、宏任务与微任务等现代JavaScript异步编程的核心概念。"
    },
    {
      "title": "第15章 异步编程基础",
      "path": "JS/第15章 异步编程基础.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "异步编程是现代JavaScript的核心特性，它让我们能够处理网络请求、定时器、用户交互等耗时操作而不阻塞主线程。本章将从基础概念开始，深入理解异步编程的原理和机制。\r\n\r\n\r\n\r\n理解同步与异步执行模式的本质区别。\r\n\r\n\r\n\r\n同步和异步的基本概念：\r\n\r\n\r\n\r\n\r\n\r\nJavaScript中常见的异步操作：\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n回调函数是最基础的异步编程模式。\r\n\r\n\r\n\r",
      "content": "第15章 异步编程基础 异步编程是现代JavaScript的核心特性，它让我们能够处理网络请求、定时器、用户交互等耗时操作而不阻塞主线程。本章将从基础概念开始，深入理解异步编程的原理和机制。 15.1 同步与异步的差异 理解同步与异步执行模式的本质区别。 执行模式对比 同步和异步的基本概念： 异步的应用场景 JavaScript中常见的异步操作： --- 15.2 回调函数 回调函数是最基础的异步编程模式。 回调模式基础 回调函数的定义和使用： --- 15.3 任务队列与事件循环 JavaScript的事件循环是异步编程的核心机制。 事件循环机制 理解JavaScript单线程的事件循环： --- 15.4 宏任务与微任务 深入理解JavaScript中不同类型任务的执行优先级。 任务分类和优先级 --- 本章总结 第15章深入探讨了JavaScript异步编程的基础知识： 同步与异步差异： 执行模式的本质区别 异步编程的应用场景 网络请求、UI交互、文件操作的异步处理 回调函数机制： 基础回调模式和错误处理 回调地狱问题及其解决方案 回调优化技巧和管理工具 事件循环原理： JavaScript单线程的事件循环机制 调用栈、任务队列的工作原理 任务调度和执行顺序 宏任务与微任务： 任务类型的分类和识别 执行优先级和顺序规则 实际应用中的优化技巧 关键要点： JavaScript是单线程的，通过事件循环实现异步 微任务优先级高于宏任务 理解事件循环有助于编写高性能的异步代码 回调函数是异步编程的基础，但存在嵌套和错误处理问题 下一章预告 第16章将学习Promise，这是解决回调地狱问题的现代方案，包括Promise状态管理、链式调用、错误处理，以及Promise.all、race、any等静态方法的使用。"
    },
    {
      "title": "第16章 Promise",
      "path": "JS/第16章 Promise.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "Promise是ES6引入的异步编程解决方案，它以更优雅的方式处理异步操作，解决了回调地狱问题。Promise代表一个异步操作的最终完成（或失败）及其结果值。\r\n\r\n\r\n\r\n理解Promise的三种状态和状态转换机制。\r\n\r\n\r\n\r\nPromise的核心状态管理：\r\n\r\n\r\n\r\n\r\n\r\n不同的Promise创建模式：\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\nPromise的核心方法和链式调用。\r\n\r\n",
      "content": "第16章 Promise Promise是ES6引入的异步编程解决方案，它以更优雅的方式处理异步操作，解决了回调地狱问题。Promise代表一个异步操作的最终完成（或失败）及其结果值。 16.1 Promise状态 理解Promise的三种状态和状态转换机制。 Promise基础概念 Promise的核心状态管理： Promise创建方式 不同的Promise创建模式： --- 16.2 then / catch / finally Promise的核心方法和链式调用。 then方法详解 --- 16.3 Promise链 理解Promise链式调用的机制和最佳实践。 链式调用机制 --- 16.4 Promise.all / race / any Promise并发控制的静态方法。 并发控制方法 --- 本章总结 第16章深入探讨了Promise异步编程的核心知识： Promise状态： 三种状态的转换机制 状态监听和检测工具 多种Promise创建方式 核心方法： then链式调用和值传递 catch错误处理和恢复 finally资源清理操作 Promise链： 链式调用的执行机制 条件分支和复杂流程控制 并行串行混合模式 并发控制： Promise.all全部完成模式 Promise.race竞速完成模式 Promise.any任一成功模式 关键要点： Promise解决了回调地狱问题 理解状态转换对调试很重要 链式调用让异步代码更清晰 合理选择并发控制方法提升性能 下一章预告 第17章将学习async/await，这是基于Promise的更现代的异步语法，让异步代码看起来像同步代码，包括async函数原理、await暂停机制、错误处理和流程优化。"
    },
    {
      "title": "第17章 async await",
      "path": "JS/第17章 async await.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "async/await是ES2017引入的异步编程语法糖，基于Promise构建，让异步代码看起来像同步代码，极大提升了异步编程的可读性和可维护性。\r\n\r\n\r\n\r\n理解async函数的本质和工作机制。\r\n\r\n\r\n\r\nasync函数本质上是Generator函数的语法糖：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n深入理解await关键字的工作原理。\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r",
      "content": "第17章 async / await async/await是ES2017引入的异步编程语法糖，基于Promise构建，让异步代码看起来像同步代码，极大提升了异步编程的可读性和可维护性。 17.1 async函数原理 理解async函数的本质和工作机制。 async函数基础 async函数本质上是Generator函数的语法糖： async函数与Promise对比 --- 17.2 await的暂停机制 深入理解await关键字的工作原理。 await执行机制 --- 17.3 try/catch异步错误处理 理解async/await中的错误处理机制。 异步错误捕获 --- 17.4 异步流程写法优化 掌握async/await的性能优化和高级用法。 并发执行优化 --- 本章总结 第17章深入探讨了async/await异步编程语法： async函数原理： async函数本质是Generator的语法糖 执行机制和Promise的区别 各种async函数变体形式 await暂停机制： await的暂停和恢复过程 多个await的串行执行特性 执行顺序的深度理解 异步错误处理： try/catch在异步中的应用 多层错误处理策略 选择性错误处理模式 流程优化： 并行vs串行执行的性能对比 循环中的异步处理最佳实践 并发数量控制技巧 关键要点： async/await让异步代码更像同步代码 理解暂停机制对性能优化很重要 合理选择并行和串行执行模式 循环中的异步处理需要特别注意 下一章预告 第18章将学习网络请求与跨域，包括HTTP基础、Fetch API、Axios库使用、CORS原理和常用跨域解决方案，这是现代Web应用的核心技术。"
    },
    {
      "title": "第18章 网络请求与跨域",
      "path": "JS/第18章 网络请求与跨域.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "网络请求是现代Web应用的核心功能，本章将深入探讨HTTP协议基础、现代Fetch API、流行的Axios库、跨域问题的CORS原理以及常用的跨域解决方案。\r\n\r\n\r\n\r\n理解HTTP协议的核心概念和工作原理。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n现代浏览器的标准网络请求API。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n流行的JavaScript HT",
      "content": "第18章 网络请求与跨域 网络请求是现代Web应用的核心功能，本章将深入探讨HTTP协议基础、现代Fetch API、流行的Axios库、跨域问题的CORS原理以及常用的跨域解决方案。 18.1 HTTP基础 理解HTTP协议的核心概念和工作原理。 HTTP协议概述 HTTP请求响应流程 --- 18.2 Fetch API 现代浏览器的标准网络请求API。 Fetch基础用法 高级配置和错误处理 --- 18.3 Axios 流行的JavaScript HTTP客户端库。 Axios核心功能 --- 18.4 CORS原理 跨域资源共享机制详解。 同源策略和跨域问题 --- 18.5 前端常用跨域方案 解决跨域问题的实用方法。 开发和生产环境方案 --- 本章总结 第18章全面探讨了网络请求与跨域的核心技术： HTTP基础： HTTP方法、状态码、请求头的完整理解 请求响应流程和缓存机制 RESTful API设计原则 Fetch API： 现代浏览器标准网络请求API 高级配置、错误处理和响应类型 超时控制和请求取消机制 Axios库： 流行的HTTP客户端库特性 请求配置和响应处理 拦截器和实例管理 CORS原理： 同源策略的工作机制 简单请求vs复杂请求 预检请求的完整流程 跨域解决方案： 开发环境代理配置 JSONP传统跨域方案 生产环境CORS配置 关键要点： HTTP是Web通信的基础协议 Fetch是现代JavaScript网络请求的标准 CORS是解决跨域问题的现代方案 开发和生产环境需要不同的跨域策略 下一章预告 第19章将开始ES6+现代JavaScript的学习，包括let/const声明、解构赋值、展开语法、模板字符串等核心语法，这些是现代JavaScript开发的基础。"
    },
    {
      "title": "第19章 ES6核心语法",
      "path": "JS/第19章 ES6核心语法.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "ES6（ECMAScript 2015）是JavaScript发展史上的重要里程碑，引入了众多现代语法特性。本章将深入学习let/const声明、解构赋值、展开语法、模板字符串等核心语法。\r\n\r\n\r\n\r\nES6引入的块级作用域声明方式。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\nES6的强大语法特性，简化数据提取操作。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n",
      "content": "第19章 ES6核心语法 ES6（ECMAScript 2015）是JavaScript发展史上的重要里程碑，引入了众多现代语法特性。本章将深入学习let/const声明、解构赋值、展开语法、模板字符串等核心语法。 19.1 let / const ES6引入的块级作用域声明方式。 块级作用域和变量提升 最佳实践和使用场景 --- 19.2 解构赋值 ES6的强大语法特性，简化数据提取操作。 数组解构 对象解构 --- 19.3 展开语法 扩展运算符的强大功能。 数组展开 对象展开 --- 19.4 模板字符串 现代字符串处理方式。 基础用法和插值 标签模板函数 --- 19.5 数组与对象增强语法 ES6对数组和对象的语法增强。 简写语法 新增方法 --- 本章总结 第19章全面介绍了ES6核心语法特性： let/const声明： 块级作用域和暂时性死区 循环中的作用域问题解决 常量声明和最佳实践 解构赋值： 数组解构的各种模式 对象解构和嵌套处理 函数参数解构应用 展开语法： 数组展开操作和应用 对象展开和属性合并 函数参数展开和剩余参数 模板字符串： 基础插值和多行字符串 HTML/CSS模板生成 标签模板函数的强大功能 增强语法： 对象属性和方法简写 计算属性名和动态对象 ES6新增的实用方法 关键要点： ES6语法让JavaScript代码更简洁优雅 解构和展开语法大大简化了数据操作 模板字符串提供了强大的字符串处理能力 新增方法丰富了数组、对象、字符串的操作 下一章预告 第20章将学习ES6新数据结构，包括Map、Set、WeakMap、WeakSet等新的集合类型，以及它们在实际开发中的典型应用场景。"
    },
    {
      "title": "第20章 新数据结构",
      "path": "JS/第20章 新数据结构.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "> ES6+ 为 JavaScript 引入了许多新的数据结构，包括 Map、Set、WeakMap 和 WeakSet。这些数据结构为我们提供了更强大、更灵活的数据组织方式，解决了传统对象和数组在某些场景下的局限性。\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\nMap 是一种键值对的集合，类似于对象，但有以下重要区别：\r\n\r\n- 键的类型：Map 的键可以是任意类型（对象、基本类型），而对象的键只能是字",
      "content": "第20章 新数据结构 ES6+ 为 JavaScript 引入了许多新的数据结构，包括 Map、Set、WeakMap 和 WeakSet。这些数据结构为我们提供了更强大、更灵活的数据组织方式，解决了传统对象和数组在某些场景下的局限性。 --- 20.1 Map 20.1.1 什么是 Map Map 是一种键值对的集合，类似于对象，但有以下重要区别： 键的类型：Map 的键可以是任意类型（对象、基本类型），而对象的键只能是字符串或 Symbol 大小：Map 有 size 属性，可以直接获取元素个数 迭代：Map 是可迭代的，可以直接用 for...of 循环 性能：在频繁增删键值对的场景下，Map 性能更好 20.1.2 Map 的常用方法 20.1.3 Map 的迭代方法 20.1.4 Map 与对象的转换 --- 20.2 Set 20.2.1 什么是 Set Set 是一个值的集合，其中每个值只能出现一次。Set 主要用于： 去重：自动去除重复值 成员检测：快速判断某个值是否存在 集合运算：交集、并集、差集等操作 20.2.2 Set 的常用方法 20.2.3 Set 的迭代 20.2.4 Set 的实用操作 --- 20.3 WeakMap 与 WeakSet 20.3.1 WeakMap WeakMap 与 Map 类似，但有重要区别： 键只能是对象：不能使用基本类型作为键 弱引用：不会阻止垃圾回收 不可遍历：没有 size 属性，不能迭代 用途：主要用于存储对象的私有数据 20.3.2 WeakMap 的应用场景 20.3.3 WeakSet WeakSet 与 Set 类似，但有以下特点： 只能存储对象：不能存储基本类型值 弱引用：不会阻止垃圾回收 不可遍历：没有 size 属性，不能迭代 20.3.4 WeakSet 的应用场景 --- 20.4 典型使用场景 20.4.1 数据去重与集合运算 20.4.2 缓存与记忆化 20.4.3 状态管理与追踪 20.4.4 性能对比与选择建议 20.4.5 选择指南 | 数据结构 | 适用场景 | 优势 | 注意事项 | |----------|----------|------|----------| | Map | 频繁增删键值对<br>需要非字符串键<br>需要保持插入顺序 | 任意类型键<br>更好的迭代性能<br>size 属性 | 内存占用略高 | | Set | 数据去重<br>成员检测<br>集合运算 | 自动去重<br>快速查找<br>集合操作 | 只存储值 | | WeakMap | 私有数据存储<br>DOM 关联数据<br>避免内存泄漏 | 弱引用<br>垃圾回收友好 | 不可遍历<br>键只能是对象 | | WeakSet | 对象标记<br>循环引用检测<br>临时对象集合 | 弱引用<br>自动清理 | 不可遍历<br>只能存储对象 | --- 本章总结 第20章全面介绍了ES6+新增的数据结构及其应用： Map数据结构： 支持任意类型键的键值对集合 提供size属性和完整的迭代支持 与对象转换和性能优势分析 在缓存和记忆化场景中的应用 Set数据结构： 自动去重的值集合 快速成员检测和集合运算 数组去重和复杂数据处理 交集、并集、差集等集合操作 WeakMap与WeakSet： 弱引用特性避免内存泄漏 私有数据存储和对象关联 DOM节点数据管理 循环引用检测和状态追踪 典型应用场景： 数据去重和集合运算优化 LRU缓存和函数记忆化实现 组件状态管理和事件系统 性能对比和选择策略 关键要点： 新数据结构提供了更强大灵活的数据组织方式 Map和Set在特定场景下性能优于传统Object和Array WeakMap/WeakSet的弱引用特性有助于内存管理 根据具体需求选择最适合的数据结构至关重要 下一章预告 第21章将学习Class与模块，包括ES6类语法、继承机制、静态方法、私有属性，以及工厂模式与构造模式的现代实现方式。"
    },
    {
      "title": "第21章 Class与模块",
      "path": "JS/第21章 Class与模块.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "> ES6 引入的 class 语法为 JavaScript 提供了更清晰的面向对象编程方式。虽然本质上仍是基于原型的继承，但 class 语法让代码更加直观和易于理解。\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r",
      "content": "第21章 Class与模块 ES6 引入的 class 语法为 JavaScript 提供了更清晰的面向对象编程方式。虽然本质上仍是基于原型的继承，但 class 语法让代码更加直观和易于理解。 --- 21.1 class 语法 21.1.1 基本 class 语法 21.1.2 class 与构造函数的对比 21.1.3 class 表达式 --- 21.2 继承 extends 21.2.1 基本继承 21.2.2 super 关键字详解 21.2.3 多层继承 --- 21.3 静态方法 21.3.1 静态方法基础 21.3.2 静态方法在继承中的行为 21.3.3 实用静态方法模式 --- 21.4 私有属性 21.4.1 私有字段（Private Fields） 21.4.2 私有方法 21.4.3 私有访问器 --- 21.5 工厂模式与构造模式 21.5.1 工厂模式实现 21.5.2 抽象工厂模式 21.5.3 构造者模式 21.5.4 单例模式 --- 本章总结 第21章深入介绍了ES6 Class语法和现代面向对象编程模式： Class语法基础： 类定义和构造函数的现代语法 getter/setter访问器的使用 class表达式和立即执行类 与传统构造函数的对比分析 继承extends机制： 基础继承和super关键字详解 父类方法调用和重写技巧 多层继承的实现和注意事项 继承链中的方法查找机制 静态方法和属性： 静态方法的定义和继承行为 工厂模式中静态方法的应用 静态属性和类级别的工具函数 this在静态方法中的指向 私有属性系统： ES2022私有字段语法(#) 私有方法和访问器的实现 真正的封装性和数据保护 私有属性在类设计中的最佳实践 设计模式应用： 工厂模式和抽象工厂的现代实现 构造者模式的链式调用设计 单例模式的私有字段实现 设计模式在实际开发中的应用场景 关键要点： Class语法提供了更清晰的面向对象编程方式 继承机制解决了代码复用和扩展问题 私有字段实现了真正的数据封装 设计模式帮助解决复杂的架构设计问题 下一章预告 第22章将学习模块化体系，包括CommonJS、ES Modules的深入解析，import/export规则详解，以及大型项目的模块组织策略。"
    },
    {
      "title": "第22章 模块化体系",
      "path": "JS/第22章 模块化体系.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "> 模块化是现代JavaScript开发的基础，它帮助我们组织代码、管理依赖关系、实现代码复用。从CommonJS到ES Modules，JavaScript模块化经历了重要的演进过程。\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r",
      "content": "第22章 模块化体系 模块化是现代JavaScript开发的基础，它帮助我们组织代码、管理依赖关系、实现代码复用。从CommonJS到ES Modules，JavaScript模块化经历了重要的演进过程。 --- 22.1 模块化需求背景 22.1.1 为什么需要模块化 22.1.2 模块化发展历程 --- 22.2 CommonJS 22.2.1 CommonJS 基础 22.2.2 CommonJS 特点 22.2.3 CommonJS 高级用法 --- 22.3 ES Modules 22.3.1 ES Modules 基础 22.3.2 导入导出的多种方式 22.3.3 ES Modules 特性 --- 22.4 import/export 规则 22.4.1 导入规则 22.4.2 导出规则 22.4.3 动态导入 --- 22.5 模块组织与工程结构 22.5.1 项目结构设计 22.5.2 模块导出策略 22.5.3 模块依赖管理 22.5.4 模块化最佳实践 --- 本章总结 第22章全面解析了JavaScript模块化体系的发展历程和核心概念： 模块化发展背景： 早期JavaScript全局污染和依赖管理问题 从IIFE到命名空间再到标准模块系统的演进 模块化在解决代码组织和维护方面的重要作用 现代前端工程化的基础需求分析 CommonJS模块系统： require/exports的基本语法和使用规则 同步加载机制和缓存特性详解 循环依赖处理和模块封装器原理 Node.js环境下的模块最佳实践 ES Modules标准： import/export的现代语法体系 编译时依赖分析和tree-shaking优化 值绑定vs值拷贝的关键差异 顶层await和动态导入的高级特性 导入导出规则： 静态导入和动态导入的使用场景 默认导出、命名导出和重导出模式 路径解析规则和文件扩展名处理 条件加载和懒加载的实现策略 工程化组织实践： 大型项目的模块结构设计原则 桶文件和统一导出的管理模式 依赖注入和配置管理的模块化方案 循环依赖避免和错误处理机制 关键要点： ES Modules是现代JavaScript的标准模块系统 合理的模块组织是大型项目可维护性的关键 动态导入支持代码分割和按需加载优化 模块化设计需要遵循单一职责和接口分离原则 下一章预告 第23章将深入JavaScript执行机制，学习执行上下文与作用域链的工作原理，理解变量查找和闭包形成的内部机制。"
    },
    {
      "title": "第23章 执行上下文与作用域链",
      "path": "JS/第23章 执行上下文与作用域链.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "> 理解执行上下文与作用域链是掌握JavaScript运行机制的关键。这些概念解释了变量查找、函数调用、闭包原理等核心问题。\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "content": "第23章 执行上下文与作用域链 理解执行上下文与作用域链是掌握JavaScript运行机制的关键。这些概念解释了变量查找、函数调用、闭包原理等核心问题。 --- 23.1 执行上下文创建 23.1.1 什么是执行上下文 23.1.2 执行上下文的组成 23.1.3 执行上下文的生命周期 --- 23.2 变量环境与词法环境 23.2.1 变量环境（Variable Environment） 23.2.2 词法环境（Lexical Environment） 23.2.3 暂时性死区（TDZ） --- 23.3 作用域链查找 23.3.1 作用域链的形成 23.3.2 静态作用域与动态查找 23.3.3 作用域链与性能 --- 23.4 闭包的内部机制 23.4.1 闭包的形成原理 23.4.2 闭包的内存管理 23.4.3 闭包的高级应用 --- 本章总结 第23章深入解析了JavaScript执行机制的核心概念： 执行上下文创建： 全局执行上下文和函数执行上下文的区别 创建阶段和执行阶段的详细过程 执行栈的工作机制和调用顺序 上下文切换和内存管理机制 变量环境与词法环境： 变量环境中var声明和函数声明的提升行为 词法环境中let/const的暂时性死区机制 两种环境的创建时机和存储内容 环境记录的查找和绑定过程 作用域链查找： 词法作用域的静态确定原理 作用域链的构建和遍历算法 变量查找的完整路径和性能影响 作用域嵌套和变量遮蔽现象 闭包内部机制： 闭包形成的必要条件和识别方法 外部变量引用的保持机制 闭包在内存中的存储结构 常见的闭包陷阱和解决方案 关键要点： 执行上下文是JavaScript代码执行的基础环境 作用域链决定了变量访问的查找路径 闭包是词法作用域和函数对象结合的产物 理解这些机制有助于避免常见错误和性能问题 下一章预告 第24章将全面解析this绑定机制，包括五种绑定方式、箭头函数的特殊性、以及bind/call/apply的本质原理。"
    },
    {
      "title": "第24章 this全解析",
      "path": "JS/第24章 this全解析.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "> this是JavaScript中最容易产生困惑的概念之一。理解this的绑定规则对于掌握面向对象编程和函数调用机制至关重要。\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r",
      "content": "第24章 this全解析 this是JavaScript中最容易产生困惑的概念之一。理解this的绑定规则对于掌握面向对象编程和函数调用机制至关重要。 --- 24.1 this的五种绑定方式 24.1.1 默认绑定 24.1.2 隐式绑定 24.1.3 显式绑定 24.1.4 new绑定 24.1.5 箭头函数绑定 --- 24.2 全局与函数调用场景 24.2.1 不同环境中的全局this 24.2.2 函数调用模式详解 --- 24.3 箭头函数的this 24.3.1 箭头函数this的特殊性 --- 24.4 bind/call/apply的本质 24.4.1 call和apply的实现原理 24.4.2 bind的实现原理 --- 24.5 常见this陷阱 24.5.1 回调函数中的this丢失 24.5.2 事件处理器中的this --- 本章总结 第24章全面解析了JavaScript中this绑定的复杂机制： this的五种绑定方式： 默认绑定规则和严格模式下的区别 隐式绑定和隐式丢失的常见场景 显式绑定（call/apply/bind）的使用技巧 new绑定的构造函数调用机制 箭头函数的词法绑定特性 全局与函数调用场景： 全局作用域中this的指向规律 函数直接调用vs方法调用的区别 严格模式对this绑定的影响 不同环境（浏览器vs Node.js）下的差异 箭头函数的this特性： 词法作用域继承的工作原理 与普通函数this绑定的根本区别 在对象方法和构造函数中的使用注意事项 事件处理和回调函数中的应用场景 bind/call/apply的本质： 三种方法的参数传递和调用方式 手动实现这些方法的核心算法 性能考虑和使用场景选择 柯里化和部分应用函数的实现 常见this陷阱： 回调函数中的this丢失问题 事件处理器的this指向错误 解构赋值和方法提取的陷阱 定时器和异步操作中的this问题 关键要点： this的值在函数调用时确定，不是在定义时确定 箭头函数的this是词法绑定，无法通过调用方式改变 理解绑定优先级有助于准确判断this指向 合理使用bind方法可以解决大部分this相关问题 下一章预告 第25章将深入学习深拷贝与浅拷贝，包括各种复制方法的实现原理、性能对比、以及手写深拷贝函数的完整实现。"
    },
    {
      "title": "第25章 深拷贝与浅拷贝",
      "path": "JS/第25章 深拷贝与浅拷贝.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "> 理解对象复制机制是JavaScript编程的重要技能。深拷贝与浅拷贝的区别影响着数据安全性和程序的正确性。\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n本章总结\r\n\r\n第25章深入探讨了J",
      "content": "第25章 深拷贝与浅拷贝 理解对象复制机制是JavaScript编程的重要技能。深拷贝与浅拷贝的区别影响着数据安全性和程序的正确性。 --- 25.1 引用复制 25.1.1 基本类型与引用类型的复制 --- 25.2 常用浅拷贝方式 25.2.1 对象的浅拷贝 25.2.2 数组的浅拷贝 --- 25.3 深拷贝解决方案 25.3.1 JSON方法深拷贝 25.3.2 递归深拷贝实现 25.3.3 完整的深拷贝实现 --- 25.4 手写深拷贝函数 25.4.1 逐步构建深拷贝函数 25.4.2 性能优化版本 25.4.3 工具库级别的实现 --- 本章总结 第25章深入探讨了JavaScript中对象复制的核心概念和实现方法： 引用复制机制： 基本类型的值复制特性 引用类型的引用复制行为 赋值操作中的内存指向关系 引用共享带来的数据安全问题 浅拷贝方法详解： Object.assign()的使用和局限性 展开运算符的便捷语法 Array.slice()和Array.concat()的数组拷贝 各种浅拷贝方法的性能对比 深拷贝解决方案： JSON.stringify/parse的快速方法 递归实现的完整深拷贝算法 lodash.cloneDeep等第三方库的优势 structuredClone API的现代解决方案 手写深拷贝实现： 基础递归算法的构建思路 循环引用检测和处理机制 特殊对象类型的识别和克隆 性能优化和边界情况处理 关键要点： 理解浅拷贝和深拷贝的本质区别是掌握对象操作的基础 JSON方法简单但有局限性，不能处理函数、undefined等特殊值 手写深拷贝需要考虑循环引用和各种数据类型 实际开发中应根据数据复杂度选择合适的拷贝方法 下一章预告 第26章将进入工程化篇章，学习Webpack入门知识，包括核心概念、配置文件、loader和plugin机制、以及打包优化策略。"
    },
    {
      "title": "第26章 Webpack入门",
      "path": "JS/第26章 Webpack入门.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "> Webpack是现代前端开发的核心构建工具，它将各种资源打包成浏览器可以理解的静态文件。\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r",
      "content": "第26章 Webpack入门 Webpack是现代前端开发的核心构建工具，它将各种资源打包成浏览器可以理解的静态文件。 --- 26.1 Webpack的定位 26.1.1 什么是Webpack 26.1.2 核心概念 --- 26.2 核心概念详解 26.2.1 Entry和Output配置 26.2.2 Loader详解 26.2.3 Plugin系统 --- 26.3 开发环境与生产环境 26.3.1 开发环境配置 26.3.2 生产环境配置 26.3.3 配置合并 --- 26.4 常用Loader解析 26.4.1 样式Loader 26.4.2 JavaScript Loader --- 26.5 打包优化与Tree-Shaking 26.5.1 代码分割 26.5.2 Tree Shaking 26.5.3 性能优化 --- 本章总结 第26章介绍了Webpack现代前端构建工具的核心概念： Webpack的定位： 解决模块化、资源处理和代码优化问题 从传统多文件加载到单bundle的转变 现代前端工程化的基础设施 与其他构建工具的对比和优势 四大核心概念： Entry入口文件的配置和多入口处理 Output输出配置和文件命名规则 Loader资源转换和处理链 Plugin功能扩展和生命周期钩子 开发环境与生产环境： 开发环境的热更新和调试优化 生产环境的压缩和性能优化 webpack-dev-server的配置和使用 source-map的不同类型选择 常用Loader解析： babel-loader的JavaScript转译 css-loader和style-loader的样式处理 file-loader和url-loader的资源处理 各种Loader的配置选项和最佳实践 打包优化与Tree-Shaking： 代码分割和懒加载的实现方式 Tree Shaking死代码消除原理 bundle分析和性能优化策略 缓存策略和长期缓存配置 关键要点： Webpack是现代前端工程化的核心工具 掌握四大核心概念是使用Webpack的基础 区分开发环境和生产环境的不同优化策略 合理使用Loader和Plugin可以大幅提升开发效率 下一章预告 第27章将学习Vite新时代构建工具，了解基于ESM的开发服务器、HMR热更新机制、以及与Webpack的对比优势。"
    },
    {
      "title": "第27章 Vite：新时代构建工具",
      "path": "JS/第27章 Vite：新时代构建工具.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "> Vite是基于ES modules的新一代前端构建工具，提供极速的开发服务器和优化的生产构建。\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n本章总结\r\n\r\n",
      "content": "第27章 Vite：新时代构建工具 Vite是基于ES modules的新一代前端构建工具，提供极速的开发服务器和优化的生产构建。 --- 27.1 为什么选择Vite 27.1.1 传统构建工具的问题 27.1.2 Vite的优势 --- 27.2 开发服务器与HMR 27.2.1 开发服务器配置 27.2.2 热模块替换(HMR) 27.2.3 依赖预构建 --- 27.3 Vite配置文件 27.3.1 基础配置结构 27.3.2 条件配置 27.3.3 插件配置 --- 27.4 构建与部署流程 27.4.1 构建优化 27.4.2 静态资源处理 27.4.3 部署配置 --- 本章总结 第27章深入介绍了Vite新时代构建工具的核心特性： Vite的优势： 基于原生ES模块的极速冷启动 毫秒级的HMR热更新体验 开箱即用的合理默认配置 针对现代开发环境的优化设计 开发服务器与HMR： ES模块的即时加载机制 依赖预构建和缓存策略 热模块替换的实现原理 开发服务器的配置和优化 Vite配置文件： vite.config.js的基础配置 插件系统的使用和扩展 路径别名和环境变量配置 开发和生产环境的差异处理 构建与部署流程： 生产环境的Rollup打包 静态资源的处理和优化 构建产物的分析和优化 不同部署平台的配置策略 关键要点： Vite利用现代浏览器的ES模块支持实现极速开发体验 HMR热更新机制大幅提升开发效率 插件系统提供了强大的扩展能力 生产构建基于Rollup保证了优化效果 下一章预告 第28章将学习NPM与包管理，包括package.json完整解析、scripts编写规范、版本管理semver，以及发布npm包的完整流程。"
    },
    {
      "title": "第28章 NPM与包管理",
      "path": "JS/第28章 NPM与包管理.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "> NPM是Node.js的包管理器，也是现代前端开发的基础设施。理解NPM和包管理对于前端工程化至关重要。\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nbash\r\n",
      "content": "第28章 NPM与包管理 NPM是Node.js的包管理器，也是现代前端开发的基础设施。理解NPM和包管理对于前端工程化至关重要。 --- 28.1 package.json全字段说明 28.1.1 基本信息字段 28.1.2 入口和模块字段 28.1.3 依赖管理字段 28.1.4 脚本和配置字段 --- 28.2 scripts编写规范 28.2.1 生命周期脚本 28.2.2 跨平台脚本 28.2.3 复杂脚本组合 --- 28.3 版本号semver 28.3.1 语义化版本规范 28.3.2 依赖版本策略 --- 28.4 发布npm包流程 28.4.1 包开发准备 28.4.2 构建配置 28.4.3 测试和文档 bash npm install @username/my-package javascript import { helper1 } from '@username/my-package'; const result = helper1(1, 2); console.log(result); // 3 28.4.4 发布流程 --- 本章总结 第28章全面介绍了NPM包管理系统的核心知识： package.json全字段解析： 项目元数据和基础信息配置 依赖管理和版本控制字段 入口文件和导出配置详解 生命周期钩子和脚本配置 scripts编写规范： 内置生命周期脚本的使用 自定义脚本的命名和组合 跨平台兼容性的处理方案 复杂工作流的脚本编排技巧 版本号semver规范： 主版本、次版本、修订版的含义 依赖版本范围的表示方法 版本锁定和灵活更新策略 破坏性变更的处理原则 发布npm包流程： 包开发的完整生命周期 测试、文档和质量控制要求 npm发布的权限和配置管理 版本发布和维护的最佳实践 关键要点： NPM是JavaScript生态系统的包管理基础设施 package.json是项目配置和依赖管理的中心 合理的版本管理策略对项目稳定性至关重要 发布高质量的npm包需要完善的开发流程 下一章预告 第29章将进入Node.js基础学习，包括Node.js组成架构、CommonJS模块深入、fs/path/http核心模块，以及异步IO机制的工作原理。"
    },
    {
      "title": "第29章 Node.js基础",
      "path": "JS/第29章 Node.js基础.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "> Node.js让JavaScript运行在服务器端，为前端开发者提供了全栈开发的可能性。\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n本章总结\r\n\r\n第29章介绍了Node.js服务端Ja",
      "content": "第29章 Node.js基础 Node.js让JavaScript运行在服务器端，为前端开发者提供了全栈开发的可能性。 --- 29.1 Node.js的组成 29.1.1 Node.js架构 29.1.2 模块系统 --- 29.2 CommonJS深入 29.2.1 模块包装器 29.2.2 循环依赖处理 --- 29.3 fs/path/http模块 29.3.1 文件系统模块 29.3.2 路径模块 29.3.3 HTTP模块 --- 29.4 异步IO机制 29.4.1 事件循环 29.4.2 异步编程模式 --- 本章总结 第29章介绍了Node.js服务端JavaScript运行环境的基础知识： Node.js的组成： V8 JavaScript引擎的高性能执行 libuv提供的异步I/O支持 丰富的内置模块生态系统 跨平台的运行时环境特性 CommonJS模块深入： require/exports的加载机制 模块缓存和循环依赖处理 全局对象和模块作用域 ES模块与CommonJS的互操作 核心模块详解： fs文件系统的同步和异步操作 path路径处理的跨平台兼容性 http模块的服务器和客户端功能 各模块的实际应用场景和最佳实践 异步IO机制： 事件循环的工作原理和执行顺序 非阻塞I/O的性能优势 事件驱动编程模型 异步操作的错误处理策略 关键要点： Node.js将JavaScript扩展到服务端开发领域 事件循环和非阻塞I/O是Node.js高性能的核心 模块系统提供了良好的代码组织和复用机制 丰富的内置模块覆盖了大部分服务端开发需求 下一章预告 第30章将学习使用Express开发后端应用，包括路由系统、中间件机制、模拟Mock API构建，以及前后端联调的实用技巧。"
    },
    {
      "title": "第30章 使用Express开发后端",
      "path": "JS/第30章 使用Express开发后端.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "> Express是Node.js最流行的Web应用框架，提供了构建Web服务器和API的强大工具。\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r",
      "content": "第30章 使用Express开发后端 Express是Node.js最流行的Web应用框架，提供了构建Web服务器和API的强大工具。 --- 30.1 Express基础 30.1.1 快速开始 30.1.2 应用程序结构 --- 30.2 路由系统 30.2.1 基本路由 30.2.2 路由中间件 --- 30.3 中间件机制 30.3.1 内置中间件 30.3.2 第三方中间件 30.3.3 自定义中间件 --- 30.4 模拟构建Mock API 30.4.1 Mock数据管理 30.4.2 Mock中间件 --- 30.5 前后端联调技巧 30.5.1 开发环境配置 30.5.2 API文档和测试 30.5.3 调试和监控 --- --- 本章总结 第30章介绍了Express框架在Node.js Web开发中的应用： Express基础： 轻量级Web应用框架的设计理念 简洁而强大的API接口 快速搭建HTTP服务器的能力 与Node.js原生http模块的关系 路由系统： RESTful API的路由设计原则 动态路由参数和查询参数处理 路由中间件的使用和组合 路由模块化和项目组织结构 中间件机制： 中间件的执行顺序和数据流 内置中间件和第三方中间件使用 自定义中间件的编写技巧 错误处理中间件的特殊机制 模拟Mock API构建： 前后端分离开发的协作模式 快速构建测试数据接口 CORS跨域问题的解决方案 API文档和接口规范制定 前后端联调技巧： 开发环境的代理配置 接口调试和数据验证方法 错误处理和日志记录策略 部署和生产环境配置 关键要点： Express是Node.js生态中最受欢迎的Web框架 中间件系统提供了灵活的请求处理管道 良好的项目结构是大型应用的基础 Mock API能够显著提升前后端协作效率 教程总结 至此，我们完成了JavaScript从基础到高级、从前端到后端的完整学习旅程。这套教程涵盖了现代JavaScript开发的核心知识点，为成为全栈JavaScript开发者奠定了坚实的基础。 继续学习的方向包括：TypeScript类型系统、React/Vue等前端框架、数据库操作、微服务架构等更高级的主题。"
    },
    {
      "title": "JavaScript 目录",
      "path": "JS/JavaScript 目录.md",
      "category": "JS",
      "tags": [],
      "date": null,
      "description": "+ 1.1 JavaScript 的诞生与历史背景  \n+ 1.2 浏览器与 JS 的关系  \n+ 1.3 ECMAScript、DOM、BOM 的关系  \n+ 1.4 JavaScript 在现代开发中的地位  \n+ 1.5 JavaScript 的发展趋势\n\n\n+ 2.1 浏览器如何执行 JavaScript  \n+ 2.2 V8 引擎解析与执行流程  \n+ 2.3 JavaScript 是单",
      "content": "第一篇 JavaScript 世界观——理解一门语言的核心定位 第1章 JavaScript 是什么 1.1 JavaScript 的诞生与历史背景 1.2 浏览器与 JS 的关系 1.3 ECMAScript、DOM、BOM 的关系 1.4 JavaScript 在现代开发中的地位 1.5 JavaScript 的发展趋势 第2章 JavaScript 的运行机制 2.1 浏览器如何执行 JavaScript 2.2 V8 引擎解析与执行流程 2.3 JavaScript 是单线程的原因 2.4 从输入到渲染：代码执行生命周期 2.5 JavaScript 的应用边界 第3章 编写 JavaScript 的方式与加载机制 3.1 内联脚本、内部脚本、外部脚本 3.2 script 标签与执行顺序 3.3 async 与 defer 差异 3.4 阻塞与性能优化 3.5 浏览器缓存与 JS 加载策略 --- 第二篇 语法基础——构建语言根基 第4章 变量与常量 4.1 var、let、const 的根本差异 4.2 作用域：全局、函数、块级 4.3 变量提升与暂时性死区（TDZ） 4.4 最佳实践与代码风格 第5章 数据类型与类型系统 5.1 基本类型（七种） 5.2 引用类型 5.3 栈与堆 5.4 类型判断：typeof、instanceof 5.5 类型转换（隐式与显式） 5.6 JSON 的本质与应用 第6章 运算符、表达式与逻辑 6.1 算术、比较、逻辑运算符 6.2 短路逻辑 6.3 可选链（?.）与空值合并（??） 6.4 == vs === 6.5 优先级规则 第7章 流程控制 7.1 条件语句：if / else 7.2 多分支：switch 7.3 循环语句：for、while、do-while 7.4 for...in、for...of 7.5 break 与 continue 7.6 常见流程控制场景 --- 第三篇 函数与对象——深入理解 JavaScript 灵魂 第8章 函数基础 8.1 函数声明方式 8.2 箭头函数与 this 8.3 参数、默认参数、剩余参数 8.4 返回值与执行流程 8.5 闭包（Closure）基础 第9章 对象与引用 9.1 创建对象的多种方式 9.2 属性访问与配置 9.3 引用模型与共享特性 9.4 浅拷贝与深拷贝 第10章 原型与原型链 10.1 prototype 的本质 10.2 原型链查找机制 10.3 构造函数 10.4 class 与 ES6 面向对象 10.5 super、继承、封装 第11章 数组与高阶方法 11.1 数组的本质 11.2 常用数组方法 11.3 数组迭代器 11.4 map / filter / reduce 11.5 在实际项目中的数组处理模式 --- 第四篇 操作浏览器——打造真实的网页交互能力 第12章 DOM 基础 12.1 DOM 树结构 12.2 获取、创建、删除元素 12.3 修改属性、样式、文本 12.4 节点关系与遍历 12.5 DOM 性能优化 第13章 事件与交互系统 13.1 事件监听（addEventListener） 13.2 冒泡与捕获 13.3 阻止默认与阻止传播 13.4 事件委托 13.5 鼠标、键盘、表单事件 13.6 TodoList 事件管理实战 第14章 BOM：浏览器对象模型 14.1 window 对象 14.2 定时器 14.3 location、history 14.4 localStorage / sessionStorage / cookie 14.5 浏览器能力检测 --- 第五篇 异步与网络请求——现代 JS 核心 第15章 异步编程基础 15.1 同步与异步的差异 15.2 回调函数 15.3 任务队列与事件循环 15.4 宏任务与微任务 第16章 Promise 16.1 Promise 状态 16.2 then / catch / finally 16.3 Promise 链 16.4 Promise.all / race / any 16.5 异步封装实战 第17章 async / await 17.1 async 函数原理 17.2 await 的暂停机制 17.3 try/catch 异步错误处理 17.4 异步流程写法优化 第18章 网络请求与跨域 18.1 HTTP 基础 18.2 Fetch API 18.3 Axios 18.4 CORS 原理 18.5 前端常用跨域方案 --- 第六篇 ES6+ 现代 JavaScript 第19章 ES6 核心语法 19.1 let / const 19.2 解构赋值 19.3 展开语法 19.4 模板字符串 19.5 数组与对象增强语法 第20章 新数据结构 20.1 Map 20.2 Set 20.3 WeakMap / WeakSet 20.4 典型使用场景 第21章 Class 与模块 21.1 class 语法 21.2 继承 extends 21.3 静态方法 21.4 私有属性 21.5 工厂模式与构造模式 第22章 模块化体系 22.1 模块化需求背景 22.2 CommonJS 22.3 ES Modules 22.4 import/export 规则 22.5 模块组织与工程结构 --- 第七篇 JavaScript 深入机制 第23章 执行上下文与作用域链 23.1 执行上下文创建 23.2 变量环境与词法环境 23.3 作用域链查找 23.4 闭包的内部机制 第24章 this 全解析 24.1 this 的五种绑定方式 24.2 全局与函数调用场景 24.3 箭头函数的 this 24.4 bind / call / apply 的本质 24.5 常见 this 陷阱 第25章 深拷贝与浅拷贝 25.1 引用复制 25.2 常用浅拷贝方式 25.3 深拷贝解决方案 25.4 手写深拷贝函数 --- 第八篇 工程化与现代前端开发 第26章 Webpack 入门 26.1 Webpack 的定位 26.2 核心概念：entry / output / loader / plugin 26.3 开发环境与生产环境 26.4 常用 loader 解析 26.5 打包优化与 Tree-Shaking 第27章 Vite：新时代构建工具 27.1 为什么选择 Vite 27.2 开发服务器与 HMR 27.3 Vite 配置文件 27.4 构建与部署流程 第28章 NPM 与包管理 28.1 package.json 全字段说明 28.2 scripts 编写规范 28.3 版本号 semver 28.4 发布 npm 包流程 --- 第九篇 Node.js（选读） 第29章 Node.js 基础 29.1 Node.js 的组成 29.2 CommonJS 深入 29.3 fs / path / http 模块 29.4 异步 IO 机制 第30章 使用 Express 开发后端 30.1 Express 基础 30.2 路由系统 30.3 中间件机制 30.4 模拟构建 Mock API 30.5 前后端联调技巧 --- 附录 附录 A：JavaScript 常用 API 速查表 A.1 基础数据类型 API String 字符串方法 Array 数组方法 Object 对象方法 A.2 DOM 操作 API 元素获取 元素创建和修改 属性和样式操作 A.3 事件处理 API 事件监听 常用事件类型 A.4 异步编程 API Promise 方法 Async/Await 语法 定时器 API A.5 现代 Web API Fetch API 本地存储 API --- 附录 B：现代前端工具链导航 B.1 开发环境工具 代码编辑器 | 工具 | 特点 | 推荐插件 | |------|------|----------| | VS Code | 免费、插件丰富、性能好 | ES7+ React/Redux/React-Native, Prettier, ESLint, GitLens | | WebStorm | 功能完整、智能提示强 | 内置大部分功能，开箱即用 | | Sublime Text | 轻量、快速启动 | Package Control, Emmet, SublimeLinter | 包管理器 版本控制 B.2 构建工具生态 模块打包器 | 工具 | 适用场景 | 优势 | 学习曲线 | |------|----------|------|----------| | Webpack | 复杂项目、生产环境 | 功能强大、插件丰富 | 陡峭 | | Vite | 现代开发、快速原型 | 启动快速、HMR优秀 | 平缓 | | Rollup | 库开发、组件打包 | 输出简洁、Tree-shaking | 中等 | | Parcel | 简单项目、零配置 | 开箱即用、自动优化 | 平缓 | 任务运行器 B.3 代码质量工具 代码检查工具 代码格式化 B.4 测试工具链 单元测试框架 | 框架 | 特点 | 配置复杂度 | |------|------|------------| | Jest | Facebook出品，功能完整 | 低 | | Vitest | 基于Vite，速度快 | 低 | | Mocha | 灵活性高，需要额外配置 | 中 | | Jasmine | 行为驱动开发 | 中 | E2E测试工具 B.5 性能监控工具 开发时性能分析 运行时性能监控 B.6 部署和CI/CD 自动化部署平台 | 平台 | 特点 | 适用场景 | |------|------|----------| | Vercel | 零配置、自动部署 | 静态站点、Next.js | | Netlify | 功能丰富、边缘计算 | JAMstack应用 | | GitHub Pages | 免费、简单 | 文档站点、个人项目 | | AWS S3 | 可扩展、配置灵活 | 企业级应用 | GitHub Actions 工作流 --- 附录 C：JavaScript 面试与进阶路线图 C.1 面试知识点分级 初级开发者 (Junior) 基础语法 (必须掌握) 变量声明：var、let、const 的区别 数据类型：基本类型vs引用类型，类型判断 函数：声明方式、参数传递、作用域 对象：创建、属性访问、方法调用 数组：常用方法、遍历方式 条件判断：if/else、switch、三元运算符 循环：for、while、for...in、for...of DOM操作 (必须掌握) 中级开发者 (Mid-level) 进阶概念 (重点掌握) 闭包：概念理解、实际应用、内存管理 原型链：prototype、__proto__、继承机制 this绑定：四种绑定规则、箭头函数特性 异步编程：callback、Promise、async/await 模块化：CommonJS、ES Modules、打包原理 错误处理：try/catch、Promise错误处理 常见面试题 高级开发者 (Senior) 深入机制 (精通要求) 事件循环：宏任务、微任务、执行顺序 内存管理：垃圾回收、内存泄漏防范 性能优化：代码分割、懒加载、缓存策略 设计模式：观察者、发布订阅、单例等 工程化：构建工具、代码规范、CI/CD 架构能力题目 C.2 技能进阶路线图 阶段一：JavaScript基础 (0-6个月) 阶段二：核心概念深入 (6-12个月) 阶段三：框架和生态 (1-2年) 阶段四：全栈和架构 (2-3年) C.3 实战项目推荐 入门级项目 计算器应用 技能点：基础语法、事件处理、DOM操作 时间：1-2周 Todo List 技能点：数组操作、本地存储、事件委托 时间：2-3周 简单游戏（如贪吃蛇） 技能点：Canvas API、定时器、游戏逻辑 时间：3-4周 进阶级项目 天气应用 技能点：API调用、Promise、响应式设计 时间：1个月 博客系统 技能点：路由、状态管理、组件设计 时间：2-3个月 电商网站 技能点：复杂交互、购物车逻辑、支付集成 时间：3-6个月 高级项目 代码编辑器 技能点：复杂算法、性能优化、插件系统 时间：6个月以上 实时协作平台 技能点：WebSocket、实时同步、冲突解决 时间：6个月以上 C.4 学习资源推荐 官方文档 MDN Web Docs - 最权威的Web技术文档 ECMAScript规范 - JavaScript语言标准 Node.js官方文档 - 服务端JavaScript 在线学习平台 freeCodeCamp - 免费编程学习 JavaScript.info - 现代JavaScript教程 Eloquent JavaScript - 经典JavaScript书籍 代码练习平台 LeetCode - 算法练习 Codewars - 编程挑战 HackerRank - 技能认证 技术博客和社区 Dev.to - 开发者社区 Stack Overflow - 编程问答 GitHub - 开源项目和代码托管 C.5 职业发展建议 技术成长路径 核心竞争力建设 技术深度：深入理解JavaScript原理和机制 技术广度：掌握前端生态和相关技术栈 工程能力：具备大型项目开发和维护经验 学习能力：保持对新技术的敏感度和学习热情 沟通协作：具备良好的团队协作和技术分享能力 持续学习建议 关注技术发展趋势，及时学习新特性 参与开源项目，提升代码质量和协作能力 定期总结和分享技术经验 建立个人技术品牌，撰写技术博客 参加技术会议和社区活动，扩展技术网络 --- 总结 这套JavaScript教程涵盖了从基础到高级的完整知识体系，附录部分为学习者提供了实用的API速查表、工具链导航和职业发展指导。无论你是JavaScript初学者还是希望系统梳理知识的开发者，都能在这里找到适合的学习路径和参考资料。 继续学习，持续进步，在JavaScript的世界中创造更多可能！🚀"
    },
    {
      "title": "uv-ui框架请求使用指南",
      "path": "uvui/uv-ui框架请求使用指南.md",
      "category": "uvui",
      "tags": [],
      "date": null,
      "description": "> 适合小白快速上手的uv-ui请求教程，让你轻松处理前后端数据交互 🚀\r\n\r\n\r\n\r\n\r\n确保你已经安装了uv-ui框架。如果还没安装，请先到插件市场下载。\r\n\r\n\r\n\r\n\r\n在项目根目录创建 /util/request/index.js：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n在项目根目录创建 /common/api.js：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "content": "UV-UI框架 HTTP请求使用指南 适合小白快速上手的uv-ui请求教程，让你轻松处理前后端数据交互 🚀 一、快速开始 1.1 前置条件 确保你已经安装了uv-ui框架。如果还没安装，请先到插件市场下载。 1.2 基础配置（3步搞定） 第1步：创建请求配置文件 在项目根目录创建 /util/request/index.js： 第2步：在main.js中引入 第3步：创建API管理文件 在项目根目录创建 /common/api.js： 二、基础用法（最常用） 2.1 GET请求 2.2 POST请求 三、进阶用法 3.1 文件上传 3.2 文件下载 3.3 自定义参数（custom用法） 3.4 请求取消 四、完整拦截器示例 五、实战示例 5.1 登录流程 5.2 列表分页加载 六、常见问题 Q1: 如何处理不同环境的API地址？ Q2: 如何统一处理错误？ Q3: GET和POST请求参数位置不同？ GET请求：所有配置都在第二个参数 POST请求：第二个参数是数据，第三个参数才是配置 七、小技巧 请求防抖：搜索框输入时，使用防抖避免频繁请求 缓存策略：对不常变化的数据进行本地缓存 错误重试：网络错误时可以自动重试1-2次 请求合并：同时需要多个接口数据时，使用Promise.all --- 💡 温馨提示：以上就是uv-ui框架请求的核心用法，掌握这些足够应对90%的场景。遇到问题多看官方文档，多动手实践！ 📚 官方文档：https://www.uvui.cn/js/http.html"
    }
  ],
  "lastUpdated": "2025-12-08T13:34:22.388Z"
}