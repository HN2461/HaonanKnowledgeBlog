# 第20章 新数据结构

> ES6+ 为 JavaScript 引入了许多新的数据结构，包括 Map、Set、WeakMap 和 WeakSet。这些数据结构为我们提供了更强大、更灵活的数据组织方式，解决了传统对象和数组在某些场景下的局限性。

---

## 20.1 Map

### 20.1.1 什么是 Map

Map 是一种键值对的集合，类似于对象，但有以下重要区别：

- **键的类型**：Map 的键可以是任意类型（对象、基本类型），而对象的键只能是字符串或 Symbol
- **大小**：Map 有 size 属性，可以直接获取元素个数
- **迭代**：Map 是可迭代的，可以直接用 for...of 循环
- **性能**：在频繁增删键值对的场景下，Map 性能更好

```javascript
/**
 * Map 基本使用
 */
const myMap = new Map();

// 设置键值对
myMap.set('name', '张三');
myMap.set(1, 'number key');
myMap.set(true, 'boolean key');

// 对象作为键
const objKey = { id: 1 };
myMap.set(objKey, 'object key');

console.log(myMap.size); // 4
```

### 20.1.2 Map 的常用方法

```javascript
/**
 * Map 的核心 API
 */
const userMap = new Map();

// 设置值
userMap.set('id', 1001);
userMap.set('name', '李四');
userMap.set('age', 25);

// 获取值
console.log(userMap.get('name')); // '李四'
console.log(userMap.get('email')); // undefined

// 检查键是否存在
console.log(userMap.has('age')); // true
console.log(userMap.has('phone')); // false

// 删除键值对
userMap.delete('age');
console.log(userMap.has('age')); // false

// 清空所有键值对
userMap.clear();
console.log(userMap.size); // 0
```

### 20.1.3 Map 的迭代方法

```javascript
/**
 * Map 迭代演示
 */
const scoreMap = new Map([
    ['语文', 85],
    ['数学', 92],
    ['英语', 88]
]);

// 迭代键值对
for (const [subject, score] of scoreMap) {
    console.log(`${subject}: ${score}分`);
}

// 迭代键
for (const subject of scoreMap.keys()) {
    console.log('科目:', subject);
}

// 迭代值
for (const score of scoreMap.values()) {
    console.log('分数:', score);
}

// forEach 方法
scoreMap.forEach((score, subject) => {
    console.log(`${subject}考了${score}分`);
});
```

### 20.1.4 Map 与对象的转换

```javascript
/**
 * Map 和对象之间的转换
 */

// 对象转 Map
const obj = { a: 1, b: 2, c: 3 };
const mapFromObj = new Map(Object.entries(obj));
console.log(mapFromObj); // Map(3) {'a' => 1, 'b' => 2, 'c' => 3}

// Map 转对象（键必须是字符串）
const objFromMap = Object.fromEntries(mapFromObj);
console.log(objFromMap); // { a: 1, b: 2, c: 3 }

// 复杂键的 Map 转对象
const complexMap = new Map([
    ['string', 1],
    [2, 'number key'],
    [true, 'boolean key']
]);

// 只有字符串键可以转换为对象属性
const partialObj = {};
for (const [key, value] of complexMap) {
    if (typeof key === 'string') {
        partialObj[key] = value;
    }
}
```

---

## 20.2 Set

### 20.2.1 什么是 Set

Set 是一个值的集合，其中每个值只能出现一次。Set 主要用于：

- **去重**：自动去除重复值
- **成员检测**：快速判断某个值是否存在
- **集合运算**：交集、并集、差集等操作

```javascript
/**
 * Set 基本使用
 */
const mySet = new Set();

// 添加值
mySet.add(1);
mySet.add(2);
mySet.add(2); // 重复值会被忽略
mySet.add('hello');

console.log(mySet.size); // 3
console.log(mySet); // Set(3) {1, 2, 'hello'}

// 从数组创建 Set（自动去重）
const numbers = [1, 2, 2, 3, 3, 4, 5];
const uniqueNumbers = new Set(numbers);
console.log(uniqueNumbers); // Set(5) {1, 2, 3, 4, 5}
```

### 20.2.2 Set 的常用方法

```javascript
/**
 * Set 的核心 API
 */
const skillSet = new Set(['JavaScript', 'HTML', 'CSS']);

// 添加值
skillSet.add('Vue.js');
skillSet.add('React');

// 检查值是否存在
console.log(skillSet.has('JavaScript')); // true
console.log(skillSet.has('Python')); // false

// 删除值
skillSet.delete('CSS');
console.log(skillSet.has('CSS')); // false

// 清空所有值
const tempSet = new Set([1, 2, 3]);
tempSet.clear();
console.log(tempSet.size); // 0
```

### 20.2.3 Set 的迭代

```javascript
/**
 * Set 迭代方法
 */
const colorSet = new Set(['red', 'green', 'blue']);

// for...of 迭代
for (const color of colorSet) {
    console.log('颜色:', color);
}

// forEach 方法
colorSet.forEach(color => {
    console.log('Color:', color);
});

// 迭代器方法
for (const color of colorSet.values()) {
    console.log(color);
}

// keys() 和 values() 在 Set 中是相同的
console.log(colorSet.keys() === colorSet.values()); // false（不同对象）
// 但内容相同
console.log([...colorSet.keys()]); // ['red', 'green', 'blue']
console.log([...colorSet.values()]); // ['red', 'green', 'blue']
```

### 20.2.4 Set 的实用操作

```javascript
/**
 * Set 在实际开发中的应用
 */

// 数组去重
function uniqueArray(arr) {
    return [...new Set(arr)];
}

const numbers = [1, 2, 2, 3, 4, 4, 5];
console.log(uniqueArray(numbers)); // [1, 2, 3, 4, 5]

// 字符串去重
function uniqueChars(str) {
    return [...new Set(str)].join('');
}

console.log(uniqueChars('hello')); // 'helo'

// 集合运算
function intersection(setA, setB) {
    return new Set([...setA].filter(x => setB.has(x)));
}

function union(setA, setB) {
    return new Set([...setA, ...setB]);
}

function difference(setA, setB) {
    return new Set([...setA].filter(x => !setB.has(x)));
}

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([3, 4, 5, 6]);

console.log('交集:', intersection(setA, setB)); // Set {3, 4}
console.log('并集:', union(setA, setB)); // Set {1, 2, 3, 4, 5, 6}
console.log('差集:', difference(setA, setB)); // Set {1, 2}
```

---

## 20.3 WeakMap 与 WeakSet

### 20.3.1 WeakMap

WeakMap 与 Map 类似，但有重要区别：

- **键只能是对象**：不能使用基本类型作为键
- **弱引用**：不会阻止垃圾回收
- **不可遍历**：没有 size 属性，不能迭代
- **用途**：主要用于存储对象的私有数据

```javascript
/**
 * WeakMap 基本使用
 */
const wm = new WeakMap();

const obj1 = { id: 1 };
const obj2 = { id: 2 };

// 设置键值对（键必须是对象）
wm.set(obj1, 'data for obj1');
wm.set(obj2, 'data for obj2');

// 获取值
console.log(wm.get(obj1)); // 'data for obj1'

// 检查键是否存在
console.log(wm.has(obj1)); // true

// 删除键值对
wm.delete(obj1);
console.log(wm.has(obj1)); // false

// 错误用法：不能使用基本类型作为键
// wm.set('string', 'value'); // TypeError
```

### 20.3.2 WeakMap 的应用场景

```javascript
/**
 * WeakMap 实际应用：存储私有数据
 */
const privateData = new WeakMap();

class Person {
    constructor(name, age) {
        // 使用 WeakMap 存储私有数据
        privateData.set(this, { name, age });
    }
    
    getName() {
        return privateData.get(this).name;
    }
    
    getAge() {
        return privateData.get(this).age;
    }
    
    setAge(newAge) {
        const data = privateData.get(this);
        data.age = newAge;
    }
}

const person = new Person('张三', 25);
console.log(person.getName()); // '张三'
console.log(person.getAge()); // 25

// 无法直接访问私有数据
console.log(person.name); // undefined

/**
 * WeakMap 应用：DOM 节点关联数据
 */
const elementData = new WeakMap();

function attachData(element, data) {
    elementData.set(element, data);
}

function getData(element) {
    return elementData.get(element);
}

// 当 DOM 元素被删除时，关联的数据也会被垃圾回收
const button = document.createElement('button');
attachData(button, { clickCount: 0, created: Date.now() });
```

### 20.3.3 WeakSet

WeakSet 与 Set 类似，但有以下特点：

- **只能存储对象**：不能存储基本类型值
- **弱引用**：不会阻止垃圾回收
- **不可遍历**：没有 size 属性，不能迭代

```javascript
/**
 * WeakSet 基本使用
 */
const ws = new WeakSet();

const obj1 = { name: 'object1' };
const obj2 = { name: 'object2' };

// 添加对象
ws.add(obj1);
ws.add(obj2);

// 检查对象是否存在
console.log(ws.has(obj1)); // true
console.log(ws.has(obj2)); // true

// 删除对象
ws.delete(obj1);
console.log(ws.has(obj1)); // false

// 错误用法：不能添加基本类型
// ws.add('string'); // TypeError
```

### 20.3.4 WeakSet 的应用场景

```javascript
/**
 * WeakSet 应用：跟踪对象状态
 */
const processedObjects = new WeakSet();

function processObject(obj) {
    if (processedObjects.has(obj)) {
        console.log('对象已经处理过了');
        return;
    }
    
    // 处理对象的逻辑
    console.log('处理对象:', obj);
    
    // 标记为已处理
    processedObjects.add(obj);
}

const data1 = { id: 1, name: 'item1' };
const data2 = { id: 2, name: 'item2' };

processObject(data1); // 处理对象: {id: 1, name: 'item1'}
processObject(data1); // 对象已经处理过了
processObject(data2); // 处理对象: {id: 2, name: 'item2'}

/**
 * WeakSet 应用：防止循环引用
 */
const visitedNodes = new WeakSet();

function traverse(node) {
    if (visitedNodes.has(node)) {
        console.log('检测到循环引用，停止遍历');
        return;
    }
    
    visitedNodes.add(node);
    console.log('访问节点:', node.value);
    
    // 遍历子节点
    if (node.children) {
        node.children.forEach(child => traverse(child));
    }
}
```

---

## 20.4 典型使用场景

### 20.4.1 数据去重与集合运算

```javascript
/**
 * 复杂数据结构去重
 */

// 对象数组去重（基于特定属性）
function uniqueByProperty(arr, prop) {
    const seen = new Set();
    return arr.filter(item => {
        const value = item[prop];
        if (seen.has(value)) {
            return false;
        }
        seen.add(value);
        return true;
    });
}

const users = [
    { id: 1, name: '张三' },
    { id: 2, name: '李四' },
    { id: 1, name: '张三（重复）' },
    { id: 3, name: '王五' }
];

const uniqueUsers = uniqueByProperty(users, 'id');
console.log(uniqueUsers);
// [{ id: 1, name: '张三' }, { id: 2, name: '李四' }, { id: 3, name: '王五' }]

// 多条件去重
function uniqueByMultipleProps(arr, ...props) {
    const seen = new Set();
    return arr.filter(item => {
        const key = props.map(prop => item[prop]).join('|');
        if (seen.has(key)) {
            return false;
        }
        seen.add(key);
        return true;
    });
}
```

### 20.4.2 缓存与记忆化

```javascript
/**
 * 使用 Map 实现函数记忆化
 */
function memoize(fn) {
    const cache = new Map();
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            console.log('从缓存获取结果');
            return cache.get(key);
        }
        
        console.log('计算新结果');
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    };
}

// 斐波那契数列（带缓存）
const fibonacci = memoize(function(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
});

console.log(fibonacci(10)); // 计算新结果...
console.log(fibonacci(10)); // 从缓存获取结果

/**
 * LRU 缓存实现
 */
class LRUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.cache = new Map();
    }
    
    get(key) {
        if (this.cache.has(key)) {
            // 重新插入以更新顺序（LRU）
            const value = this.cache.get(key);
            this.cache.delete(key);
            this.cache.set(key, value);
            return value;
        }
        return -1;
    }
    
    put(key, value) {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        } else if (this.cache.size >= this.capacity) {
            // 删除最久未使用的项（第一个）
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        this.cache.set(key, value);
    }
}
```

### 20.4.3 状态管理与追踪

```javascript
/**
 * 组件状态追踪
 */
const componentStates = new WeakMap();

class Component {
    constructor(name) {
        this.name = name;
        componentStates.set(this, {
            mounted: false,
            updated: 0,
            props: new Map()
        });
    }
    
    mount() {
        const state = componentStates.get(this);
        state.mounted = true;
        console.log(`${this.name} 组件已挂载`);
    }
    
    update() {
        const state = componentStates.get(this);
        state.updated++;
        console.log(`${this.name} 组件已更新 ${state.updated} 次`);
    }
    
    setProp(key, value) {
        const state = componentStates.get(this);
        state.props.set(key, value);
    }
    
    getProp(key) {
        const state = componentStates.get(this);
        return state.props.get(key);
    }
}

/**
 * 事件订阅管理
 */
class EventManager {
    constructor() {
        this.listeners = new Map();
    }
    
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, new Set());
        }
        this.listeners.get(event).add(callback);
    }
    
    off(event, callback) {
        if (this.listeners.has(event)) {
            this.listeners.get(event).delete(callback);
        }
    }
    
    emit(event, data) {
        if (this.listeners.has(event)) {
            this.listeners.get(event).forEach(callback => {
                callback(data);
            });
        }
    }
}
```

### 20.4.4 性能对比与选择建议

```javascript
/**
 * 不同数据结构的性能对比
 */
function performanceTest() {
    const size = 100000;
    
    // 测试 Map vs Object
    console.time('Map 插入');
    const map = new Map();
    for (let i = 0; i < size; i++) {
        map.set(`key${i}`, i);
    }
    console.timeEnd('Map 插入');
    
    console.time('Object 插入');
    const obj = {};
    for (let i = 0; i < size; i++) {
        obj[`key${i}`] = i;
    }
    console.timeEnd('Object 插入');
    
    // 测试查找性能
    console.time('Map 查找');
    for (let i = 0; i < 1000; i++) {
        map.get(`key${Math.floor(Math.random() * size)}`);
    }
    console.timeEnd('Map 查找');
    
    console.time('Object 查找');
    for (let i = 0; i < 1000; i++) {
        obj[`key${Math.floor(Math.random() * size)}`];
    }
    console.timeEnd('Object 查找');
}

// performanceTest();
```

### 20.4.5 选择指南

| 数据结构 | 适用场景 | 优势 | 注意事项 |
|----------|----------|------|----------|
| **Map** | 频繁增删键值对<br>需要非字符串键<br>需要保持插入顺序 | 任意类型键<br>更好的迭代性能<br>size 属性 | 内存占用略高 |
| **Set** | 数据去重<br>成员检测<br>集合运算 | 自动去重<br>快速查找<br>集合操作 | 只存储值 |
| **WeakMap** | 私有数据存储<br>DOM 关联数据<br>避免内存泄漏 | 弱引用<br>垃圾回收友好 | 不可遍历<br>键只能是对象 |
| **WeakSet** | 对象标记<br>循环引用检测<br>临时对象集合 | 弱引用<br>自动清理 | 不可遍历<br>只能存储对象 |

```javascript
/**
 * 选择建议示例
 */

// ✅ 使用 Map：需要复杂键类型
const userCache = new Map();
const userObj = { id: 123 };
userCache.set(userObj, { name: '张三', lastActive: Date.now() });

// ✅ 使用 Set：数据去重
const uniqueIds = new Set([1, 2, 2, 3, 4, 4, 5]);

// ✅ 使用 WeakMap：私有数据
const privateProps = new WeakMap();
class User {
    constructor(name) {
        privateProps.set(this, { name, secret: Math.random() });
    }
}

// ✅ 使用普通 Object：简单的键值存储
const config = {
    apiUrl: 'https://api.example.com',
    timeout: 5000
};
```

---

## 本章小结

新数据结构为 JavaScript 提供了更强大的数据组织能力：

### 核心要点

1. **Map**：键值对集合，支持任意类型键，适用于复杂的键值关系
2. **Set**：值的集合，自动去重，适用于唯一值存储和集合运算
3. **WeakMap**：弱引用的键值对，适用于私有数据和避免内存泄漏
4. **WeakSet**：弱引用的值集合，适用于对象标记和临时集合

### 实用技巧

- 使用 Map 替代对象来获得更好的性能和灵活性
- 利用 Set 进行数据去重和集合运算
- 使用 WeakMap/WeakSet 避免内存泄漏
- 根据具体需求选择合适的数据结构

### 下一步

掌握了新数据结构后，我们将学习 ES6 的 Class 语法和模块化体系，这将帮助我们构建更加结构化和可维护的代码。
