# 第15章　异步编程基础

异步编程是现代JavaScript的核心特性，它让我们能够处理网络请求、定时器、用户交互等耗时操作而不阻塞主线程。本章将从基础概念开始，深入理解异步编程的原理和机制。

## 15.1 同步与异步的差异

理解同步与异步执行模式的本质区别。

### 执行模式对比

同步和异步的基本概念：

```javascript
/**
 * 同步与异步执行示例
 */
const SyncAsyncExamples = {
    /**
     * 同步执行演示
     */
    synchronousExecution() {
        console.log('=== 同步执行演示 ===');
        
        function syncTask1() {
            console.log('同步任务1开始');
            // 模拟耗时操作（阻塞）
            const start = Date.now();
            while (Date.now() - start < 1000) {
                // 忙等待1秒
            }
            console.log('同步任务1完成');
            return '任务1结果';
        }
        
        function syncTask2() {
            console.log('同步任务2开始');
            console.log('同步任务2完成');
            return '任务2结果';
        }
        
        console.log('开始执行同步代码');
        const result1 = syncTask1(); // 阻塞1秒
        console.log('任务1结果:', result1);
        
        const result2 = syncTask2(); // 立即执行
        console.log('任务2结果:', result2);
        
        console.log('同步代码执行完毕');
        console.log('总特点: 按顺序执行，前一个任务未完成时会阻塞后续任务');
    },
    
    /**
     * 异步执行演示
     */
    asynchronousExecution() {
        console.log('=== 异步执行演示 ===');
        
        function asyncTask1(callback) {
            console.log('异步任务1开始');
            setTimeout(() => {
                console.log('异步任务1完成');
                callback('任务1结果');
            }, 1000);
        }
        
        function asyncTask2(callback) {
            console.log('异步任务2开始');
            setTimeout(() => {
                console.log('异步任务2完成');
                callback('任务2结果');
            }, 500);
        }
        
        console.log('开始执行异步代码');
        
        asyncTask1((result1) => {
            console.log('任务1结果:', result1);
        });
        
        asyncTask2((result2) => {
            console.log('任务2结果:', result2);
        });
        
        console.log('异步代码发起完毕');
        console.log('总特点: 非阻塞执行，任务可以并行进行');
        
        // 注意：这里会先打印，因为异步任务还在执行中
        setTimeout(() => {
            console.log('所有异步任务应该已完成');
        }, 1200);
    },
    
    /**
     * 混合执行模式
     */
    mixedExecution() {
        console.log('=== 混合执行模式 ===');
        
        console.log('1. 同步开始');
        
        setTimeout(() => {
            console.log('4. 异步任务1（1秒后）');
        }, 1000);
        
        console.log('2. 同步中间');
        
        setTimeout(() => {
            console.log('3. 异步任务2（0秒后，下一个事件循环）');
        }, 0);
        
        console.log('5. 同步结束');
        
        // 执行顺序：1 -> 2 -> 5 -> 3 -> 4
        // 说明：同步代码总是优先执行，即使setTimeout延迟为0
    }
};

SyncAsyncExamples.synchronousExecution();
setTimeout(() => SyncAsyncExamples.asynchronousExecution(), 2000);
setTimeout(() => SyncAsyncExamples.mixedExecution(), 4000);
```

### 异步的应用场景

JavaScript中常见的异步操作：

```javascript
/**
 * 异步应用场景示例
 */
const AsyncScenariosExamples = {
    /**
     * 网络请求异步
     */
    networkRequests() {
        console.log('=== 网络请求异步 ===');
        
        // 模拟fetch请求
        function mockFetch(url, delay = 1000) {
            console.log(`发起请求: ${url}`);
            
            return new Promise((resolve) => {
                setTimeout(() => {
                    const mockData = {
                        url,
                        data: { id: Math.floor(Math.random() * 1000), name: 'Mock Data' },
                        timestamp: Date.now()
                    };
                    console.log(`请求完成: ${url}`);
                    resolve(mockData);
                }, delay);
            });
        }
        
        // 串行请求（等待前一个完成）
        async function serialRequests() {
            console.log('串行请求开始:');
            
            const result1 = await mockFetch('/api/user');
            console.log('用户数据:', result1.data);
            
            const result2 = await mockFetch('/api/posts');
            console.log('帖子数据:', result2.data);
            
            console.log('串行请求完成');
        }
        
        // 并行请求（同时发起）
        async function parallelRequests() {
            console.log('并行请求开始:');
            
            const [userResult, postsResult] = await Promise.all([
                mockFetch('/api/user'),
                mockFetch('/api/posts')
            ]);
            
            console.log('用户数据:', userResult.data);
            console.log('帖子数据:', postsResult.data);
            console.log('并行请求完成');
        }
        
        // 演示执行
        setTimeout(() => {
            serialRequests();
        }, 1000);
        
        setTimeout(() => {
            parallelRequests();
        }, 4000);
    },
    
    /**
     * 用户界面异步
     */
    userInterfaceAsync() {
        console.log('=== 用户界面异步 ===');
        
        if (typeof document === 'undefined') {
            console.log('需要浏览器环境运行');
            return;
        }
        
        // 创建演示界面
        const container = document.createElement('div');
        container.innerHTML = `
            <div style="padding: 20px; border: 1px solid #ccc; margin: 10px;">
                <h3>异步UI示例</h3>
                <button id="asyncBtn">点击触发异步操作</button>
                <div id="progress" style="margin: 10px 0;"></div>
                <div id="result"></div>
            </div>
        `;
        
        document.body.appendChild(container);
        
        const button = container.querySelector('#asyncBtn');
        const progress = container.querySelector('#progress');
        const result = container.querySelector('#result');
        
        button.addEventListener('click', async () => {
            button.disabled = true;
            progress.textContent = '处理中...';
            
            try {
                // 模拟长时间运行的任务
                await new Promise(resolve => {
                    let count = 0;
                    const interval = setInterval(() => {
                        count += 10;
                        progress.textContent = `进度: ${count}%`;
                        
                        if (count >= 100) {
                            clearInterval(interval);
                            resolve();
                        }
                    }, 100);
                });
                
                result.textContent = '操作完成！';
                result.style.color = 'green';
            } catch (error) {
                result.textContent = '操作失败: ' + error.message;
                result.style.color = 'red';
            } finally {
                button.disabled = false;
                progress.textContent = '';
            }
        });
        
        // 5秒后自动移除
        setTimeout(() => {
            if (document.body.contains(container)) {
                document.body.removeChild(container);
            }
        }, 30000);
    },
    
    /**
     * 文件操作异步
     */
    fileOperationsAsync() {
        console.log('=== 文件操作异步 ===');
        
        if (typeof document === 'undefined') {
            console.log('需要浏览器环境运行');
            return;
        }
        
        // 异步读取文件
        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = (event) => {
                    resolve(event.target.result);
                };
                
                reader.onerror = (event) => {
                    reject(new Error('文件读取失败'));
                };
                
                reader.readAsText(file);
            });
        }
        
        // 创建文件选择界面
        const fileContainer = document.createElement('div');
        fileContainer.innerHTML = `
            <div style="padding: 15px; border: 1px solid #ddd; margin: 10px;">
                <h4>文件异步读取示例</h4>
                <input type="file" accept=".txt,.js,.json" id="fileInput">
                <div id="fileResult" style="margin-top: 10px; font-family: monospace; white-space: pre-wrap;"></div>
            </div>
        `;
        
        document.body.appendChild(fileContainer);
        
        const fileInput = fileContainer.querySelector('#fileInput');
        const fileResult = fileContainer.querySelector('#fileResult');
        
        fileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            fileResult.textContent = '读取中...';
            
            try {
                const content = await readFileAsync(file);
                fileResult.textContent = `文件名: ${file.name}\n大小: ${file.size} bytes\n内容预览:\n${content.substring(0, 500)}${content.length > 500 ? '...' : ''}`;
            } catch (error) {
                fileResult.textContent = '读取失败: ' + error.message;
                fileResult.style.color = 'red';
            }
        });
        
        // 5秒后自动移除
        setTimeout(() => {
            if (document.body.contains(fileContainer)) {
                document.body.removeChild(fileContainer);
            }
        }, 30000);
    }
};

AsyncScenariosExamples.networkRequests();
AsyncScenariosExamples.userInterfaceAsync();
AsyncScenariosExamples.fileOperationsAsync();
```

---

## 15.2 回调函数

回调函数是最基础的异步编程模式。

### 回调模式基础

回调函数的定义和使用：

```javascript
/**
 * 回调函数示例
 */
const CallbackExamples = {
    /**
     * 基础回调模式
     */
    basicCallbacks() {
        console.log('=== 基础回调模式 ===');
        
        // 简单的回调函数
        function processData(data, callback) {
            console.log('开始处理数据:', data);
            
            setTimeout(() => {
                const result = data.toUpperCase();
                console.log('数据处理完成');
                callback(null, result); // 第一个参数是错误，第二个是结果
            }, 1000);
        }
        
        // 使用回调
        processData('hello world', (error, result) => {
            if (error) {
                console.error('处理失败:', error);
            } else {
                console.log('处理结果:', result);
            }
        });
        
        // 多个回调的情况
        function fetchUserData(userId, onSuccess, onError) {
            console.log('获取用户数据:', userId);
            
            setTimeout(() => {
                if (userId > 0) {
                    onSuccess({
                        id: userId,
                        name: `User${userId}`,
                        email: `user${userId}@example.com`
                    });
                } else {
                    onError(new Error('无效的用户ID'));
                }
            }, 800);
        }
        
        // 成功情况
        fetchUserData(123, 
            (userData) => {
                console.log('用户数据获取成功:', userData);
            },
            (error) => {
                console.error('用户数据获取失败:', error.message);
            }
        );
        
        // 错误情况
        fetchUserData(-1,
            (userData) => {
                console.log('用户数据获取成功:', userData);
            },
            (error) => {
                console.error('用户数据获取失败:', error.message);
            }
        );
    },
    
    /**
     * 回调地狱问题
     */
    callbackHell() {
        console.log('=== 回调地狱问题 ===');
        
        // 模拟异步操作
        function asyncOperation(data, callback) {
            setTimeout(() => {
                callback(null, data * 2);
            }, 300);
        }
        
        // 回调地狱示例
        console.log('回调地狱示例:');
        asyncOperation(1, (err1, result1) => {
            if (err1) {
                console.error('操作1失败:', err1);
                return;
            }
            console.log('操作1结果:', result1);
            
            asyncOperation(result1, (err2, result2) => {
                if (err2) {
                    console.error('操作2失败:', err2);
                    return;
                }
                console.log('操作2结果:', result2);
                
                asyncOperation(result2, (err3, result3) => {
                    if (err3) {
                        console.error('操作3失败:', err3);
                        return;
                    }
                    console.log('操作3结果:', result3);
                    
                    asyncOperation(result3, (err4, result4) => {
                        if (err4) {
                            console.error('操作4失败:', err4);
                            return;
                        }
                        console.log('最终结果:', result4);
                        console.log('回调地狱：代码呈现金字塔形状，难以阅读和维护');
                    });
                });
            });
        });
    },
    
    /**
     * 回调优化技巧
     */
    callbackOptimization() {
        console.log('=== 回调优化技巧 ===');
        
        // 1. 命名函数代替匿名函数
        function handleUserData(error, userData) {
            if (error) {
                console.error('获取用户数据失败:', error.message);
                return;
            }
            
            console.log('用户数据:', userData);
            fetchUserPosts(userData.id, handleUserPosts);
        }
        
        function handleUserPosts(error, posts) {
            if (error) {
                console.error('获取用户帖子失败:', error.message);
                return;
            }
            
            console.log('用户帖子:', posts);
            fetchPostComments(posts[0].id, handlePostComments);
        }
        
        function handlePostComments(error, comments) {
            if (error) {
                console.error('获取帖子评论失败:', error.message);
                return;
            }
            
            console.log('帖子评论:', comments);
            console.log('优化后的回调：结构更清晰，易于调试');
        }
        
        // 模拟API函数
        function fetchUserData(userId, callback) {
            setTimeout(() => {
                callback(null, { id: userId, name: `User${userId}` });
            }, 200);
        }
        
        function fetchUserPosts(userId, callback) {
            setTimeout(() => {
                callback(null, [{ id: 1, title: 'Post 1', userId }]);
            }, 200);
        }
        
        function fetchPostComments(postId, callback) {
            setTimeout(() => {
                callback(null, [{ id: 1, text: 'Comment 1', postId }]);
            }, 200);
        }
        
        // 使用优化后的回调
        fetchUserData(123, handleUserData);
        
        // 2. 错误优先的回调约定 (Error-first callback)
        function standardCallback(error, result) {
            if (error) {
                // 处理错误
                console.error('错误处理:', error);
                return;
            }
            
            // 处理成功结果
            console.log('成功处理:', result);
        }
        
        // 3. 回调管理工具
        class CallbackManager {
            constructor() {
                this.callbacks = new Map();
            }
            
            register(id, callback) {
                this.callbacks.set(id, callback);
            }
            
            execute(id, ...args) {
                const callback = this.callbacks.get(id);
                if (callback) {
                    callback(...args);
                }
            }
            
            remove(id) {
                this.callbacks.delete(id);
            }
        }
        
        const callbackManager = new CallbackManager();
        
        callbackManager.register('success', (data) => {
            console.log('管理器成功回调:', data);
        });
        
        callbackManager.register('error', (error) => {
            console.error('管理器错误回调:', error);
        });
        
        // 延迟执行回调
        setTimeout(() => {
            callbackManager.execute('success', { message: '操作完成' });
        }, 1000);
    }
};

CallbackExamples.basicCallbacks();
setTimeout(() => CallbackExamples.callbackHell(), 3000);
setTimeout(() => CallbackExamples.callbackOptimization(), 6000);
```

---

## 15.3 任务队列与事件循环

JavaScript的事件循环是异步编程的核心机制。

### 事件循环机制

理解JavaScript单线程的事件循环：

```javascript
/**
 * 事件循环机制示例
 */
const EventLoopExamples = {
    /**
     * 基础事件循环演示
     */
    basicEventLoop() {
        console.log('=== 基础事件循环演示 ===');
        
        console.log('1. 同步代码开始');
        
        setTimeout(() => {
            console.log('4. setTimeout 回调（异步）');
        }, 0);
        
        Promise.resolve().then(() => {
            console.log('3. Promise.then 回调（异步）');
        });
        
        console.log('2. 同步代码结束');
        
        // 执行顺序：1 -> 2 -> 3 -> 4
        // 说明：同步代码优先，Promise.then优先于setTimeout
        
        setTimeout(() => {
            console.log('事件循环演示完成');
            console.log('执行顺序体现了事件循环的工作机制');
        }, 100);
    },
    
    /**
     * 调用栈演示
     */
    callStackDemo() {
        console.log('=== 调用栈演示 ===');
        
        function first() {
            console.log('进入 first 函数');
            second();
            console.log('first 函数结束');
        }
        
        function second() {
            console.log('进入 second 函数');
            third();
            console.log('second 函数结束');
        }
        
        function third() {
            console.log('进入 third 函数');
            console.log('third 函数结束');
        }
        
        console.log('调用栈演示开始');
        first();
        console.log('调用栈演示结束');
        
        // 调用栈：后进先出(LIFO)
        // main() -> first() -> second() -> third()
        // third() -> second() -> first() -> main()
    },
    
    /**
     * 任务队列可视化
     */
    taskQueueVisualization() {
        console.log('=== 任务队列可视化 ===');
        
        // 模拟任务队列管理器
        class TaskQueueSimulator {
            constructor() {
                this.callStack = [];
                this.taskQueue = [];
                this.microtaskQueue = [];
                this.isRunning = false;
            }
            
            // 执行同步函数
            executeSync(fn, name) {
                this.callStack.push(name);
                console.log(`[调用栈] 压入: ${name}`);
                
                const result = fn();
                
                this.callStack.pop();
                console.log(`[调用栈] 弹出: ${name}`);
                
                return result;
            }
            
            // 添加宏任务
            addMacroTask(fn, name) {
                this.taskQueue.push({ fn, name });
                console.log(`[宏任务队列] 添加: ${name}`);
            }
            
            // 添加微任务
            addMicrotask(fn, name) {
                this.microtaskQueue.push({ fn, name });
                console.log(`[微任务队列] 添加: ${name}`);
            }
            
            // 处理微任务队列
            processMicrotasks() {
                while (this.microtaskQueue.length > 0) {
                    const task = this.microtaskQueue.shift();
                    console.log(`[执行微任务] ${task.name}`);
                    task.fn();
                }
            }
            
            // 事件循环主逻辑
            eventLoop() {
                console.log('=== 事件循环开始 ===');
                
                // 1. 执行所有微任务
                this.processMicrotasks();
                
                // 2. 执行一个宏任务
                if (this.taskQueue.length > 0) {
                    const task = this.taskQueue.shift();
                    console.log(`[执行宏任务] ${task.name}`);
                    task.fn();
                    
                    // 3. 再次执行所有微任务
                    this.processMicrotasks();
                    
                    // 4. 继续下一轮循环
                    if (this.taskQueue.length > 0 || this.microtaskQueue.length > 0) {
                        setTimeout(() => this.eventLoop(), 0);
                    } else {
                        console.log('=== 事件循环结束 ===');
                    }
                }
            }
            
            // 获取当前状态
            getStatus() {
                return {
                    callStack: [...this.callStack],
                    taskQueue: this.taskQueue.map(t => t.name),
                    microtaskQueue: this.microtaskQueue.map(t => t.name)
                };
            }
        }
        
        const simulator = new TaskQueueSimulator();
        
        // 模拟一些异步操作
        simulator.executeSync(() => {
            console.log('同步任务1执行');
        }, 'sync1');
        
        simulator.addMacroTask(() => {
            console.log('宏任务1执行');
            simulator.addMicrotask(() => {
                console.log('宏任务1中的微任务');
            }, 'micro-in-macro1');
        }, 'macro1');
        
        simulator.addMicrotask(() => {
            console.log('微任务1执行');
        }, 'micro1');
        
        simulator.addMacroTask(() => {
            console.log('宏任务2执行');
        }, 'macro2');
        
        simulator.addMicrotask(() => {
            console.log('微任务2执行');
        }, 'micro2');
        
        console.log('当前队列状态:', simulator.getStatus());
        
        // 启动事件循环
        setTimeout(() => {
            simulator.eventLoop();
        }, 100);
    }
};

EventLoopExamples.basicEventLoop();
setTimeout(() => EventLoopExamples.callStackDemo(), 1000);
setTimeout(() => EventLoopExamples.taskQueueVisualization(), 2000);
```

---

## 15.4 宏任务与微任务

深入理解JavaScript中不同类型任务的执行优先级。

### 任务分类和优先级

```javascript
/**
 * 宏任务与微任务示例
 */
const MacroMicroTaskExamples = {
    /**
     * 任务类型识别
     */
    taskTypeIdentification() {
        console.log('=== 任务类型识别 ===');
        
        // 宏任务 (Macro Tasks)
        console.log('宏任务类型:');
        console.log('- setTimeout/setInterval');
        console.log('- setImmediate (Node.js)');
        console.log('- requestAnimationFrame');
        console.log('- I/O操作');
        console.log('- UI渲染');
        console.log('- postMessage');
        
        // 微任务 (Micro Tasks)  
        console.log('\n微任务类型:');
        console.log('- Promise.then/catch/finally');
        console.log('- queueMicrotask()');
        console.log('- MutationObserver');
        console.log('- process.nextTick (Node.js)');
        
        console.log('\n执行优先级: 微任务 > 宏任务');
    },
    
    /**
     * 执行顺序详解
     */
    executionOrderDetails() {
        console.log('=== 执行顺序详解 ===');
        
        console.log('开始执行');
        
        // 宏任务1
        setTimeout(() => {
            console.log('宏任务1: setTimeout 0ms');
        }, 0);
        
        // 宏任务2  
        setTimeout(() => {
            console.log('宏任务2: setTimeout 0ms');
        }, 0);
        
        // 微任务1
        Promise.resolve().then(() => {
            console.log('微任务1: Promise.then');
        });
        
        // 微任务2
        Promise.resolve().then(() => {
            console.log('微任务2: Promise.then');
        });
        
        // 现代微任务API
        if (typeof queueMicrotask !== 'undefined') {
            queueMicrotask(() => {
                console.log('微任务3: queueMicrotask');
            });
        }
        
        console.log('同步代码结束');
        
        // 预期执行顺序：
        // 1. 开始执行
        // 2. 同步代码结束  
        // 3. 微任务1: Promise.then
        // 4. 微任务2: Promise.then
        // 5. 微任务3: queueMicrotask
        // 6. 宏任务1: setTimeout 0ms
        // 7. 宏任务2: setTimeout 0ms
    },
    
    /**
     * 复杂执行场景
     */
    complexExecutionScenario() {
        console.log('=== 复杂执行场景 ===');
        
        console.log('1. 脚本开始');
        
        setTimeout(() => {
            console.log('2. 宏任务1开始');
            
            Promise.resolve().then(() => {
                console.log('3. 宏任务1中的微任务1');
            });
            
            setTimeout(() => {
                console.log('4. 宏任务1中的宏任务');
            }, 0);
            
            Promise.resolve().then(() => {
                console.log('5. 宏任务1中的微任务2');
            });
            
            console.log('6. 宏任务1结束');
        }, 0);
        
        Promise.resolve().then(() => {
            console.log('7. 脚本中的微任务1');
            
            Promise.resolve().then(() => {
                console.log('8. 微任务中的微任务');
            });
        });
        
        setTimeout(() => {
            console.log('9. 宏任务2');
        }, 0);
        
        Promise.resolve().then(() => {
            console.log('10. 脚本中的微任务2');
        });
        
        console.log('11. 脚本结束');
        
        // 分析执行顺序的关键：
        // - 每个宏任务执行完毕后，必须清空所有微任务队列
        // - 微任务可以产生新的微任务，会在同一轮事件循环中执行
        
        setTimeout(() => {
            console.log('=== 执行顺序分析 ===');
            console.log('第一轮事件循环:');
            console.log('  同步: 1, 11');
            console.log('  微任务: 7, 8, 10');
            console.log('第二轮事件循环:');  
            console.log('  宏任务: 2, 6');
            console.log('  微任务: 3, 5');
            console.log('第三轮事件循环:');
            console.log('  宏任务: 9');
            console.log('第四轮事件循环:');
            console.log('  宏任务: 4');
        }, 1000);
    },
    
    /**
     * 实际应用场景
     */
    practicalApplications() {
        console.log('=== 实际应用场景 ===');
        
        // 1. 批量DOM更新优化
        function batchDOMUpdates() {
            console.log('批量DOM更新示例:');
            
            if (typeof document === 'undefined') {
                console.log('需要浏览器环境');
                return;
            }
            
            const div = document.createElement('div');
            div.textContent = '初始内容';
            document.body.appendChild(div);
            
            // 使用微任务批量更新
            Promise.resolve().then(() => {
                div.textContent = '更新1';
                div.style.color = 'red';
                console.log('微任务中更新DOM');
            });
            
            Promise.resolve().then(() => {
                div.style.fontSize = '20px';
                console.log('另一个微任务更新样式');
            });
            
            // 宏任务中的更新会在下一轮
            setTimeout(() => {
                div.textContent = '宏任务更新';
                console.log('宏任务中更新DOM');
            }, 0);
            
            // 清理
            setTimeout(() => {
                if (document.body.contains(div)) {
                    document.body.removeChild(div);
                }
            }, 2000);
        }
        
        // 2. 状态同步管理
        class StateManager {
            constructor() {
                this.state = {};
                this.listeners = [];
                this.updateScheduled = false;
            }
            
            setState(updates) {
                Object.assign(this.state, updates);
                this.scheduleUpdate();
            }
            
            scheduleUpdate() {
                if (!this.updateScheduled) {
                    this.updateScheduled = true;
                    // 使用微任务确保同步更新
                    Promise.resolve().then(() => {
                        this.notifyListeners();
                        this.updateScheduled = false;
                    });
                }
            }
            
            notifyListeners() {
                this.listeners.forEach(listener => {
                    listener(this.state);
                });
            }
            
            subscribe(listener) {
                this.listeners.push(listener);
            }
        }
        
        const stateManager = new StateManager();
        
        stateManager.subscribe((state) => {
            console.log('状态更新:', state);
        });
        
        // 多次快速更新只会触发一次通知
        stateManager.setState({ count: 1 });
        stateManager.setState({ count: 2 });
        stateManager.setState({ count: 3 });
        
        batchDOMUpdates();
        
        // 3. 异步错误处理
        function asyncErrorHandling() {
            console.log('异步错误处理示例:');
            
            // 微任务中的错误
            Promise.resolve().then(() => {
                throw new Error('微任务中的错误');
            }).catch(error => {
                console.log('捕获微任务错误:', error.message);
            });
            
            // 宏任务中的错误
            setTimeout(() => {
                try {
                    throw new Error('宏任务中的错误');
                } catch (error) {
                    console.log('捕获宏任务错误:', error.message);
                }
            }, 0);
        }
        
        asyncErrorHandling();
    }
};

MacroMicroTaskExamples.taskTypeIdentification();
setTimeout(() => MacroMicroTaskExamples.executionOrderDetails(), 500);
setTimeout(() => MacroMicroTaskExamples.complexExecutionScenario(), 1000);
setTimeout(() => MacroMicroTaskExamples.practicalApplications(), 2000);
```

---

**本章总结**

第15章深入探讨了JavaScript异步编程的基础知识：

1. **同步与异步差异**：
   - 执行模式的本质区别
   - 异步编程的应用场景
   - 网络请求、UI交互、文件操作的异步处理

2. **回调函数机制**：
   - 基础回调模式和错误处理
   - 回调地狱问题及其解决方案
   - 回调优化技巧和管理工具

3. **事件循环原理**：
   - JavaScript单线程的事件循环机制
   - 调用栈、任务队列的工作原理
   - 任务调度和执行顺序

4. **宏任务与微任务**：
   - 任务类型的分类和识别
   - 执行优先级和顺序规则
   - 实际应用中的优化技巧

**关键要点**：
- JavaScript是单线程的，通过事件循环实现异步
- 微任务优先级高于宏任务
- 理解事件循环有助于编写高性能的异步代码
- 回调函数是异步编程的基础，但存在嵌套和错误处理问题

**下一章预告**

第16章将学习Promise，这是解决回调地狱问题的现代方案，包括Promise状态管理、链式调用、错误处理，以及Promise.all、race、any等静态方法的使用。
