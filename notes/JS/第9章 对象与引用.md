# 第9章　对象与引用

对象是JavaScript的核心数据结构，几乎所有的JavaScript程序都涉及对象的创建、操作和管理。理解对象的引用模型对于编写正确和高效的代码至关重要。

## 9.1 创建对象的多种方式

JavaScript提供了多种创建对象的方式，每种方式都有其特点和适用场景。

### 对象字面量

对象字面量是创建对象最简单直观的方式：

```javascript
/**
 * 对象字面量创建方式
 */
const ObjectLiteralExamples = {
    /**
     * 基本对象字面量
     */
    basicObjectLiteral() {
        console.log('=== 基本对象字面量 ===');
        
        // 最简单的对象
        const emptyObject = {};
        console.log('空对象:', emptyObject);
        
        // 带属性的对象
        const person = {
            name: 'Alice',
            age: 25,
            city: 'Beijing'
        };
        console.log('基本对象:', person);
        
        // 对象中包含方法
        const calculator = {
            value: 0,
            add: function(n) {
                this.value += n;
                return this;
            },
            multiply: function(n) {
                this.value *= n;
                return this;
            },
            getValue: function() {
                return this.value;
            }
        };
        
        const result = calculator.add(5).multiply(3).getValue();
        console.log('计算器结果:', result); // 15
        
        // ES6简化方法定义
        const modernCalc = {
            value: 0,
            add(n) {
                this.value += n;
                return this;
            },
            multiply(n) {
                this.value *= n;
                return this;
            },
            getValue() {
                return this.value;
            }
        };
        
        console.log('现代语法计算:', modernCalc.add(10).multiply(2).getValue());
    },
    
    /**
     * 动态属性名
     */
    dynamicProperties() {
        console.log('=== 动态属性名 ===');
        
        // 计算属性名
        const prefix = 'user';
        const suffix = 'Info';
        
        const obj1 = {
            [prefix + suffix]: 'User Information',
            [`${prefix}Name`]: 'Alice',
            [Symbol('id')]: 123
        };
        
        console.log('动态属性对象:', obj1);
        console.log('访问动态属性:', obj1.userInfo);
        
        // 使用表达式作为属性名
        let counter = 0;
        
        const obj2 = {
            [`prop${++counter}`]: 'first',
            [`prop${++counter}`]: 'second',
            [`prop${++counter}`]: 'third'
        };
        
        console.log('表达式属性名:', obj2);
        
        // 使用函数返回值作为属性名
        function getPropertyName(type) {
            return `${type}_${Date.now()}`;
        }
        
        const obj3 = {
            [getPropertyName('data')]: 'value1',
            [getPropertyName('cache')]: 'value2'
        };
        
        console.log('函数生成的属性名:', Object.keys(obj3));
    },
    
    /**
     * 嵌套对象和数组
     */
    nestedStructures() {
        console.log('=== 嵌套对象和数组 ===');
        
        const complexObject = {
            id: 1,
            name: 'Product',
            details: {
                description: 'A product',
                specifications: {
                    weight: '100g',
                    dimensions: {
                        width: 10,
                        height: 20,
                        depth: 5
                    }
                }
            },
            tags: ['new', 'featured', 'sale'],
            reviews: [
                { user: 'Alice', rating: 5, comment: 'Great!' },
                { user: 'Bob', rating: 4, comment: 'Good' }
            ],
            getFullDescription() {
                return `${this.name}: ${this.details.description}`;
            }
        };
        
        console.log('复杂对象:', complexObject);
        console.log('访问嵌套属性:', complexObject.details.specifications.dimensions.width);
        console.log('数组元素:', complexObject.reviews[0].user);
        console.log('方法调用:', complexObject.getFullDescription());
        
        // 对象展开操作符
        const baseConfig = {
            theme: 'dark',
            language: 'zh-CN'
        };
        
        const userConfig = {
            ...baseConfig,
            username: 'user123',
            language: 'en-US' // 覆盖baseConfig中的language
        };
        
        console.log('合并后的配置:', userConfig);
    }
};

ObjectLiteralExamples.basicObjectLiteral();
ObjectLiteralExamples.dynamicProperties();
ObjectLiteralExamples.nestedStructures();
```

### Object构造函数

使用Object构造函数创建对象：

```javascript
/**
 * Object构造函数示例
 */
const ObjectConstructorExamples = {
    /**
     * 基本Object构造函数
     */
    basicConstructor() {
        console.log('=== Object构造函数 ===');
        
        // 使用new Object()
        const obj1 = new Object();
        obj1.name = 'Alice';
        obj1.age = 25;
        console.log('new Object()创建:', obj1);
        
        // 不使用new（效果相同）
        const obj2 = Object();
        obj2.name = 'Bob';
        obj2.age = 30;
        console.log('Object()创建:', obj2);
        
        // 传入原始类型会进行包装
        const strObj = new Object('Hello');
        const numObj = new Object(42);
        const boolObj = new Object(true);
        
        console.log('字符串包装对象:', strObj);
        console.log('数字包装对象:', numObj);
        console.log('布尔包装对象:', boolObj);
        
        // 传入对象直接返回
        const existingObj = { key: 'value' };
        const sameObj = new Object(existingObj);
        console.log('传入对象是否相同:', existingObj === sameObj); // true
    }
};

ObjectConstructorExamples.basicConstructor();
```

### 构造函数模式

自定义构造函数是创建特定类型对象的传统方式：

```javascript
/**
 * 构造函数模式示例
 */
const ConstructorPatternExamples = {
    /**
     * 基本构造函数
     */
    basicConstructor() {
        console.log('=== 基本构造函数 ===');
        
        // 构造函数定义
        function Person(name, age) {
            // 实例属性
            this.name = name;
            this.age = age;
            this.createdAt = new Date();
            
            // 实例方法（不推荐，每个实例都会创建）
            this.greet = function() {
                return `Hello, I'm ${this.name}`;
            };
        }
        
        // 原型方法（推荐，所有实例共享）
        Person.prototype.introduce = function() {
            return `My name is ${this.name}, I'm ${this.age} years old`;
        };
        
        Person.prototype.birthday = function() {
            this.age++;
            console.log(`Happy birthday ${this.name}! Now ${this.age} years old`);
        };
        
        // 创建实例
        const alice = new Person('Alice', 25);
        const bob = new Person('Bob', 30);
        
        console.log('Alice:', alice);
        console.log('Bob:', bob);
        
        console.log('Alice greet:', alice.greet());
        console.log('Bob introduce:', bob.introduce());
        
        alice.birthday();
        
        // 检查原型链
        console.log('Alice instanceof Person:', alice instanceof Person);
        console.log('构造函数:', alice.constructor === Person);
        
        // 方法比较
        console.log('greet方法相同?:', alice.greet === bob.greet); // false
        console.log('introduce方法相同?:', alice.introduce === bob.introduce); // true
    },
    
    /**
     * 构造函数继承
     */
    constructorInheritance() {
        console.log('=== 构造函数继承 ===');
        
        // 父类构造函数
        function Animal(name) {
            this.name = name;
            this.type = 'animal';
        }
        
        Animal.prototype.speak = function() {
            return `${this.name} makes a sound`;
        };
        
        // 子类构造函数
        function Dog(name, breed) {
            // 调用父类构造函数
            Animal.call(this, name);
            this.breed = breed;
            this.type = 'dog';
        }
        
        // 设置原型链
        Dog.prototype = Object.create(Animal.prototype);
        Dog.prototype.constructor = Dog;
        
        // 添加子类特有方法
        Dog.prototype.bark = function() {
            return `${this.name} barks: Woof!`;
        };
        
        // 重写父类方法
        Dog.prototype.speak = function() {
            return `${this.name} the ${this.breed} barks loudly`;
        };
        
        const myDog = new Dog('Buddy', 'Golden Retriever');
        
        console.log('Dog实例:', myDog);
        console.log('Dog speak:', myDog.speak());
        console.log('Dog bark:', myDog.bark());
        console.log('instanceof检查:', myDog instanceof Dog, myDog instanceof Animal);
    },
    
    /**
     * 构造函数的问题和优化
     */
    constructorOptimization() {
        console.log('=== 构造函数优化 ===');
        
        // 问题：忘记使用new
        function User(name) {
            // 严格模式下会报错
            'use strict';
            
            // 防御性检查
            if (!(this instanceof User)) {
                return new User(name);
            }
            
            this.name = name;
        }
        
        const user1 = new User('Alice');
        const user2 = User('Bob'); // 忘记new也能正常工作
        
        console.log('user1:', user1);
        console.log('user2:', user2);
        
        // 组合使用构造函数和原型模式
        function Product(name, price) {
            // 实例属性
            this.name = name;
            this.price = price;
            this.quantity = 0;
            
            // 只在第一次创建实例时定义原型方法
            if (typeof this.updateQuantity !== 'function') {
                Product.prototype.updateQuantity = function(qty) {
                    this.quantity = qty;
                };
                
                Product.prototype.getTotalValue = function() {
                    return this.price * this.quantity;
                };
            }
        }
        
        const product1 = new Product('Laptop', 999);
        product1.updateQuantity(5);
        console.log('Product total value:', product1.getTotalValue());
    }
};

ConstructorPatternExamples.basicConstructor();
ConstructorPatternExamples.constructorInheritance();
ConstructorPatternExamples.constructorOptimization();
```

### 工厂模式

工厂模式用于封装对象创建过程：

```javascript
/**
 * 工厂模式示例
 */
const FactoryPatternExamples = {
    /**
     * 简单工厂
     */
    simpleFactory() {
        console.log('=== 简单工厂模式 ===');
        
        // 工厂函数
        function createPerson(name, age, occupation) {
            return {
                name: name,
                age: age,
                occupation: occupation,
                introduce: function() {
                    return `I'm ${this.name}, ${this.age} years old, work as ${this.occupation}`;
                }
            };
        }
        
        const person1 = createPerson('Alice', 25, 'Developer');
        const person2 = createPerson('Bob', 30, 'Designer');
        
        console.log('Person1:', person1.introduce());
        console.log('Person2:', person2.introduce());
        
        // 无法识别对象类型
        console.log('instanceof Object:', person1 instanceof Object); // true
        console.log('constructor:', person1.constructor); // Object
    },
    
    /**
     * 复杂工厂
     */
    complexFactory() {
        console.log('=== 复杂工厂模式 ===');
        
        // 不同类型的产品
        function createVehicle(type, config) {
            let vehicle;
            
            switch(type) {
                case 'car':
                    vehicle = {
                        type: 'car',
                        wheels: 4,
                        doors: config.doors || 4,
                        brand: config.brand,
                        drive: function() {
                            return `Driving the ${this.brand} car`;
                        }
                    };
                    break;
                    
                case 'motorcycle':
                    vehicle = {
                        type: 'motorcycle',
                        wheels: 2,
                        brand: config.brand,
                        engineCC: config.engineCC || 500,
                        ride: function() {
                            return `Riding the ${this.brand} motorcycle`;
                        }
                    };
                    break;
                    
                case 'bicycle':
                    vehicle = {
                        type: 'bicycle',
                        wheels: 2,
                        gears: config.gears || 1,
                        pedal: function() {
                            return `Pedaling the bicycle with ${this.gears} gears`;
                        }
                    };
                    break;
                    
                default:
                    throw new Error(`Unknown vehicle type: ${type}`);
            }
            
            // 添加通用方法
            vehicle.getInfo = function() {
                return `This is a ${this.type} with ${this.wheels} wheels`;
            };
            
            return vehicle;
        }
        
        const car = createVehicle('car', { brand: 'Toyota', doors: 2 });
        const motorcycle = createVehicle('motorcycle', { brand: 'Harley', engineCC: 1200 });
        const bicycle = createVehicle('bicycle', { gears: 21 });
        
        console.log('Car:', car.drive());
        console.log('Motorcycle:', motorcycle.ride());
        console.log('Bicycle:', bicycle.pedal());
        
        console.log('Car info:', car.getInfo());
        console.log('Motorcycle info:', motorcycle.getInfo());
    },
    
    /**
     * 抽象工厂
     */
    abstractFactory() {
        console.log('=== 抽象工厂模式 ===');
        
        // UI组件工厂
        class UIFactory {
            static createComponent(type, props) {
                switch(type) {
                    case 'button':
                        return this.createButton(props);
                    case 'input':
                        return this.createInput(props);
                    case 'select':
                        return this.createSelect(props);
                    default:
                        throw new Error(`Unknown component type: ${type}`);
                }
            }
            
            static createButton(props) {
                return {
                    type: 'button',
                    text: props.text || 'Click me',
                    onClick: props.onClick || function() { console.log('Button clicked'); },
                    style: props.style || 'primary',
                    render: function() {
                        return `<button class="${this.style}">${this.text}</button>`;
                    }
                };
            }
            
            static createInput(props) {
                return {
                    type: 'input',
                    placeholder: props.placeholder || '',
                    value: props.value || '',
                    onChange: props.onChange || function(val) { this.value = val; },
                    render: function() {
                        return `<input placeholder="${this.placeholder}" value="${this.value}" />`;
                    }
                };
            }
            
            static createSelect(props) {
                return {
                    type: 'select',
                    options: props.options || [],
                    selected: props.selected || null,
                    onChange: props.onChange || function(val) { this.selected = val; },
                    render: function() {
                        const optionsHtml = this.options.map(opt => 
                            `<option value="${opt.value}">${opt.label}</option>`
                        ).join('');
                        return `<select>${optionsHtml}</select>`;
                    }
                };
            }
        }
        
        // 使用工厂创建组件
        const button = UIFactory.createComponent('button', {
            text: 'Submit',
            style: 'success'
        });
        
        const input = UIFactory.createComponent('input', {
            placeholder: 'Enter your name',
            value: ''
        });
        
        const select = UIFactory.createComponent('select', {
            options: [
                { value: 'js', label: 'JavaScript' },
                { value: 'py', label: 'Python' },
                { value: 'java', label: 'Java' }
            ]
        });
        
        console.log('Button render:', button.render());
        console.log('Input render:', input.render());
        console.log('Select render:', select.render());
    }
};

FactoryPatternExamples.simpleFactory();
FactoryPatternExamples.complexFactory();
FactoryPatternExamples.abstractFactory();
```

### Object.create()

Object.create()方法提供了基于原型创建对象的方式：

```javascript
/**
 * Object.create()示例
 */
const ObjectCreateExamples = {
    /**
     * 基本Object.create用法
     */
    basicObjectCreate() {
        console.log('=== Object.create基本用法 ===');
        
        // 创建一个原型对象
        const personProto = {
            greet: function() {
                return `Hello, I'm ${this.name}`;
            },
            introduce: function() {
                return `My name is ${this.name}, I'm ${this.age} years old`;
            }
        };
        
        // 基于原型创建新对象
        const alice = Object.create(personProto);
        alice.name = 'Alice';
        alice.age = 25;
        
        const bob = Object.create(personProto);
        bob.name = 'Bob';
        bob.age = 30;
        
        console.log('Alice greet:', alice.greet());
        console.log('Bob introduce:', bob.introduce());
        
        // 检查原型链
        console.log('Alice原型:', Object.getPrototypeOf(alice) === personProto);
        console.log('方法在原型上:', alice.hasOwnProperty('greet')); // false
        console.log('属性在实例上:', alice.hasOwnProperty('name')); // true
        
        // 创建没有原型的对象
        const nullProtoObj = Object.create(null);
        nullProtoObj.key = 'value';
        console.log('无原型对象:', nullProtoObj);
        console.log('toString方法:', nullProtoObj.toString); // undefined
    },
    
    /**
     * 使用属性描述符
     */
    withPropertyDescriptors() {
        console.log('=== 带属性描述符的Object.create ===');
        
        const proto = {
            type: 'base'
        };
        
        // 第二个参数定义属性描述符
        const obj = Object.create(proto, {
            // 数据属性
            name: {
                value: 'CustomObject',
                writable: true,
                enumerable: true,
                configurable: true
            },
            
            // 只读属性
            id: {
                value: Math.random().toString(36).substr(2, 9),
                writable: false,
                enumerable: true,
                configurable: false
            },
            
            // 不可枚举属性
            secretKey: {
                value: 'hidden',
                writable: true,
                enumerable: false,
                configurable: true
            },
            
            // 访问器属性
            fullInfo: {
                get: function() {
                    return `${this.name} (${this.id})`;
                },
                set: function(value) {
                    console.log(`尝试设置fullInfo为: ${value}`);
                },
                enumerable: true,
                configurable: true
            }
        });
        
        console.log('创建的对象:', obj);
        console.log('name属性:', obj.name);
        console.log('id属性（只读）:', obj.id);
        
        // 尝试修改只读属性
        obj.id = 'new-id';
        console.log('修改后的id:', obj.id); // 不会改变
        
        // 枚举属性
        console.log('可枚举属性:', Object.keys(obj));
        console.log('包含不可枚举:', Object.getOwnPropertyNames(obj));
        
        // 访问器属性
        console.log('fullInfo:', obj.fullInfo);
        obj.fullInfo = 'test'; // 触发setter
    },
    
    /**
     * 原型继承模式
     */
    prototypeInheritance() {
        console.log('=== 原型继承模式 ===');
        
        // 基础对象
        const vehicle = {
            type: 'vehicle',
            wheels: 0,
            start: function() {
                return `${this.type} is starting`;
            },
            stop: function() {
                return `${this.type} is stopping`;
            }
        };
        
        // 创建car原型，继承自vehicle
        const carProto = Object.create(vehicle, {
            type: { value: 'car', writable: true },
            wheels: { value: 4, writable: true },
            drive: {
                value: function() {
                    return `Driving the ${this.brand || 'car'}`;
                }
            }
        });
        
        // 创建具体的car实例
        const myCar = Object.create(carProto);
        myCar.brand = 'Toyota';
        myCar.model = 'Camry';
        
        console.log('Car type:', myCar.type);
        console.log('Car wheels:', myCar.wheels);
        console.log('Car start:', myCar.start());
        console.log('Car drive:', myCar.drive());
        
        // 检查原型链
        console.log('原型链检查:');
        console.log('myCar -> carProto:', Object.getPrototypeOf(myCar) === carProto);
        console.log('carProto -> vehicle:', Object.getPrototypeOf(carProto) === vehicle);
        
        // 创建另一种车型
        const electricCarProto = Object.create(carProto, {
            type: { value: 'electric car' },
            charge: {
                value: function() {
                    return `Charging the ${this.brand || 'electric car'}`;
                }
            }
        });
        
        const myTesla = Object.create(electricCarProto);
        myTesla.brand = 'Tesla';
        myTesla.batteryCapacity = '100kWh';
        
        console.log('Tesla type:', myTesla.type);
        console.log('Tesla charge:', myTesla.charge());
        console.log('Tesla drive:', myTesla.drive());
        console.log('Tesla start:', myTesla.start());
    }
};

ObjectCreateExamples.basicObjectCreate();
ObjectCreateExamples.withPropertyDescriptors();
ObjectCreateExamples.prototypeInheritance();
```

### 类（ES6）

ES6引入的class语法提供了更清晰的面向对象编程方式：

```javascript
/**
 * ES6类示例
 */
const ClassExamples = {
    /**
     * 基本类定义
     */
    basicClass() {
        console.log('=== ES6基本类 ===');
        
        class Person {
            // 构造函数
            constructor(name, age) {
                this.name = name;
                this.age = age;
                this.createdAt = new Date();
            }
            
            // 实例方法
            greet() {
                return `Hello, I'm ${this.name}`;
            }
            
            introduce() {
                return `My name is ${this.name}, I'm ${this.age} years old`;
            }
            
            birthday() {
                this.age++;
                return `Happy birthday! Now ${this.age} years old`;
            }
            
            // getter
            get info() {
                return `${this.name} (${this.age})`;
            }
            
            // setter
            set info(value) {
                const [name, age] = value.split(',');
                this.name = name.trim();
                this.age = parseInt(age);
            }
            
            // 静态方法
            static createAnonymous() {
                return new Person('Anonymous', 0);
            }
            
            // 静态属性
            static species = 'Homo sapiens';
        }
        
        const alice = new Person('Alice', 25);
        const bob = new Person('Bob', 30);
        
        console.log('Alice:', alice);
        console.log('Alice greet:', alice.greet());
        console.log('Bob introduce:', bob.introduce());
        
        // 使用getter和setter
        console.log('Alice info:', alice.info);
        alice.info = 'Alice Smith, 26';
        console.log('Updated Alice:', alice.info);
        
        // 静态方法和属性
        const anonymous = Person.createAnonymous();
        console.log('Anonymous person:', anonymous.introduce());
        console.log('Species:', Person.species);
        
        // 检查实例
        console.log('instanceof检查:', alice instanceof Person);
        console.log('constructor:', alice.constructor === Person);
    },
    
    /**
     * 类继承
     */
    classInheritance() {
        console.log('=== 类继承 ===');
        
        // 基类
        class Animal {
            constructor(name) {
                this.name = name;
                this.type = 'animal';
            }
            
            speak() {
                return `${this.name} makes a sound`;
            }
            
            move() {
                return `${this.name} is moving`;
            }
        }
        
        // 派生类
        class Dog extends Animal {
            constructor(name, breed) {
                super(name); // 调用父类构造函数
                this.breed = breed;
                this.type = 'dog';
            }
            
            // 重写父类方法
            speak() {
                return `${this.name} barks: Woof!`;
            }
            
            // 调用父类方法
            moveAndSpeak() {
                return `${super.move()} and ${this.speak()}`;
            }
            
            // 新方法
            wagTail() {
                return `${this.name} is wagging tail`;
            }
            
            // getter
            get description() {
                return `${this.name} is a ${this.breed}`;
            }
        }
        
        // 再次派生
        class Puppy extends Dog {
            constructor(name, breed, age) {
                super(name, breed);
                this.age = age;
                this.type = 'puppy';
            }
            
            speak() {
                return `${this.name} says: Yip yip!`;
            }
            
            play() {
                return `${this.name} the ${this.age} month old puppy is playing`;
            }
        }
        
        const animal = new Animal('Generic');
        const dog = new Dog('Buddy', 'Golden Retriever');
        const puppy = new Puppy('Max', 'Labrador', 3);
        
        console.log('Animal speak:', animal.speak());
        console.log('Dog speak:', dog.speak());
        console.log('Dog moveAndSpeak:', dog.moveAndSpeak());
        console.log('Dog description:', dog.description);
        
        console.log('Puppy speak:', puppy.speak());
        console.log('Puppy play:', puppy.play());
        
        // instanceof检查
        console.log('Puppy instanceof Puppy:', puppy instanceof Puppy);
        console.log('Puppy instanceof Dog:', puppy instanceof Dog);
        console.log('Puppy instanceof Animal:', puppy instanceof Animal);
    },
    
    /**
     * 私有属性和方法
     */
    privateMembers() {
        console.log('=== 私有属性和方法 ===');
        
        class BankAccount {
            // 私有属性（ES2022）
            #balance = 0;
            #accountNumber;
            
            // 公共属性
            owner;
            
            constructor(owner, initialBalance = 0) {
                this.owner = owner;
                this.#balance = initialBalance;
                this.#accountNumber = this.#generateAccountNumber();
            }
            
            // 私有方法
            #generateAccountNumber() {
                return 'ACC' + Math.random().toString(36).substr(2, 9).toUpperCase();
            }
            
            #validateAmount(amount) {
                if (amount <= 0) {
                    throw new Error('Amount must be positive');
                }
                return true;
            }
            
            // 公共方法访问私有属性
            deposit(amount) {
                if (this.#validateAmount(amount)) {
                    this.#balance += amount;
                    console.log(`Deposited ${amount}. New balance: ${this.#balance}`);
                }
            }
            
            withdraw(amount) {
                if (this.#validateAmount(amount)) {
                    if (amount > this.#balance) {
                        throw new Error('Insufficient funds');
                    }
                    this.#balance -= amount;
                    console.log(`Withdrew ${amount}. New balance: ${this.#balance}`);
                }
            }
            
            get balance() {
                return this.#balance;
            }
            
            get accountInfo() {
                return {
                    owner: this.owner,
                    accountNumber: this.#accountNumber,
                    balance: this.#balance
                };
            }
        }
        
        const account = new BankAccount('Alice', 1000);
        
        console.log('Account info:', account.accountInfo);
        account.deposit(500);
        account.withdraw(200);
        console.log('Current balance:', account.balance);
        
        // 尝试访问私有属性（会报错）
        try {
            console.log(account.#balance);
        } catch (error) {
            console.log('无法访问私有属性:', error.message);
        }
    }
};

ClassExamples.basicClass();
ClassExamples.classInheritance();
ClassExamples.privateMembers();
```

---

## 9.2 属性访问与配置

JavaScript对象的属性访问和配置机制非常灵活，提供了多种方式来操作对象属性。

### 属性访问方式

对象属性有两种基本访问方式：

```javascript
/**
 * 属性访问方式示例
 */
const PropertyAccessExamples = {
    /**
     * 点记法vs方括号记法
     */
    accessMethods() {
        console.log('=== 属性访问方式 ===');
        
        const obj = {
            name: 'Alice',
            age: 25,
            'email-address': 'alice@example.com',
            '123': 'numeric key',
            'has space': 'value with space key'
        };
        
        // 点记法（Dot notation）
        console.log('点记法访问name:', obj.name);
        console.log('点记法访问age:', obj.age);
        
        // 方括号记法（Bracket notation）
        console.log('方括号访问name:', obj['name']);
        console.log('方括号访问age:', obj['age']);
        
        // 只能用方括号访问的情况
        console.log('特殊字符键:', obj['email-address']);
        console.log('数字键:', obj['123']);
        console.log('空格键:', obj['has space']);
        
        // 动态属性访问
        const propertyName = 'name';
        console.log('动态属性访问:', obj[propertyName]);
        
        // 计算属性名
        const prefix = 'user';
        const dynamicObj = {
            [`${prefix}Name`]: 'Bob',
            [`${prefix}Age`]: 30
        };
        
        console.log('计算属性:', dynamicObj.userName, dynamicObj.userAge);
    },
    
    /**
     * 嵌套属性访问
     */
    nestedAccess() {
        console.log('=== 嵌套属性访问 ===');
        
        const company = {
            name: 'Tech Corp',
            address: {
                street: '123 Main St',
                city: 'Beijing',
                country: 'China',
                coordinates: {
                    lat: 39.9042,
                    lng: 116.4074
                }
            },
            employees: [
                { id: 1, name: 'Alice', department: 'Engineering' },
                { id: 2, name: 'Bob', department: 'Marketing' }
            ]
        };
        
        // 深层访问
        console.log('公司名称:', company.name);
        console.log('城市:', company.address.city);
        console.log('经度:', company.address.coordinates.lng);
        console.log('第一个员工:', company.employees[0].name);
        
        // 混合访问方式
        const key = 'address';
        console.log('混合访问:', company[key]['city']);
        
        // 安全访问（可选链）
        console.log('安全访问:', company.address?.coordinates?.lat);
        console.log('不存在的属性:', company.contact?.phone ?? '未设置');
    },
    
    /**
     * 属性的添加、修改和删除
     */
    propertyOperations() {
        console.log('=== 属性操作 ===');
        
        const person = {
            name: 'Alice'
        };
        
        // 添加属性
        person.age = 25;
        person['email'] = 'alice@example.com';
        Object.assign(person, { phone: '123-456-7890' });
        
        console.log('添加属性后:', person);
        
        // 修改属性
        person.age = 26;
        person['email'] = 'alice.new@example.com';
        
        console.log('修改属性后:', person);
        
        // 删除属性
        delete person.phone;
        console.log('删除phone后:', person);
        
        // 检查属性存在
        console.log('has name?:', 'name' in person);
        console.log('has phone?:', 'phone' in person);
        console.log('hasOwnProperty name?:', person.hasOwnProperty('name'));
        console.log('hasOwn name?:', Object.hasOwn(person, 'name')); // ES2022
        
        // undefined vs 不存在
        person.nickname = undefined;
        console.log('nickname in person?:', 'nickname' in person); // true
        console.log('nickname value:', person.nickname); // undefined
        console.log('nonexistent value:', person.nonexistent); // undefined
    }
};

PropertyAccessExamples.accessMethods();
PropertyAccessExamples.nestedAccess();
PropertyAccessExamples.propertyOperations();
```

### 属性描述符

属性描述符定义了属性的特性：

```javascript
/**
 * 属性描述符示例
 */
const PropertyDescriptorExamples = {
    /**
     * 基本属性描述符
     */
    basicDescriptors() {
        console.log('=== 基本属性描述符 ===');
        
        const obj = {};
        
        // 定义数据属性
        Object.defineProperty(obj, 'name', {
            value: 'Alice',
            writable: true,      // 可写
            enumerable: true,    // 可枚举
            configurable: true   // 可配置
        });
        
        // 定义只读属性
        Object.defineProperty(obj, 'id', {
            value: 'ID123',
            writable: false,     // 不可写
            enumerable: true,
            configurable: false  // 不可配置
        });
        
        // 定义不可枚举属性
        Object.defineProperty(obj, 'secretKey', {
            value: 'hidden',
            writable: true,
            enumerable: false,   // 不可枚举
            configurable: true
        });
        
        console.log('对象:', obj);
        console.log('所有键:', Object.keys(obj)); // 不包含secretKey
        console.log('包含不可枚举:', Object.getOwnPropertyNames(obj));
        
        // 尝试修改只读属性
        obj.id = 'NEW_ID';
        console.log('修改只读属性后:', obj.id); // 仍然是 'ID123'
        
        // 获取属性描述符
        const nameDescriptor = Object.getOwnPropertyDescriptor(obj, 'name');
        console.log('name描述符:', nameDescriptor);
    },
    
    /**
     * 访问器属性
     */
    accessorProperties() {
        console.log('=== 访问器属性 ===');
        
        const person = {
            firstName: 'Alice',
            lastName: 'Smith'
        };
        
        // 定义访问器属性
        Object.defineProperty(person, 'fullName', {
            get() {
                return `${this.firstName} ${this.lastName}`;
            },
            set(value) {
                const parts = value.split(' ');
                this.firstName = parts[0] || '';
                this.lastName = parts[1] || '';
            },
            enumerable: true,
            configurable: true
        });
        
        console.log('Full name:', person.fullName);
        
        person.fullName = 'Bob Johnson';
        console.log('After setting:', person.firstName, person.lastName);
        console.log('New full name:', person.fullName);
        
        // 只有getter的只读属性
        Object.defineProperty(person, 'age', {
            value: 25,
            writable: false,
            enumerable: true
        });
        
        Object.defineProperty(person, 'birthYear', {
            get() {
                return new Date().getFullYear() - this.age;
            },
            enumerable: true
        });
        
        console.log('Birth year:', person.birthYear);
    },
    
    /**
     * 批量定义属性
     */
    defineMultipleProperties() {
        console.log('=== 批量定义属性 ===');
        
        const product = {};
        
        // 使用defineProperties批量定义
        Object.defineProperties(product, {
            id: {
                value: 'PRD001',
                writable: false,
                enumerable: true,
                configurable: false
            },
            name: {
                value: 'Laptop',
                writable: true,
                enumerable: true,
                configurable: true
            },
            _price: {
                value: 999,
                writable: true,
                enumerable: false,
                configurable: true
            },
            price: {
                get() {
                    return this._price;
                },
                set(value) {
                    if (value < 0) {
                        throw new Error('价格不能为负');
                    }
                    this._price = value;
                },
                enumerable: true,
                configurable: true
            },
            discount: {
                value: 0.1,
                writable: true,
                enumerable: true,
                configurable: true
            },
            finalPrice: {
                get() {
                    return this.price * (1 - this.discount);
                },
                enumerable: true,
                configurable: true
            }
        });
        
        console.log('产品对象:', product);
        console.log('原价:', product.price);
        console.log('折后价:', product.finalPrice);
        
        product.price = 899;
        product.discount = 0.2;
        console.log('调整后折后价:', product.finalPrice);
        
        // 获取所有属性描述符
        const allDescriptors = Object.getOwnPropertyDescriptors(product);
        console.log('所有描述符:', allDescriptors);
    },
    
    /**
     * 属性保护
     */
    propertyProtection() {
        console.log('=== 属性保护 ===');
        
        const config = {
            apiUrl: 'https://api.example.com',
            apiKey: 'secret123',
            timeout: 5000
        };
        
        // 冻结对象（完全不可变）
        const frozenConfig = Object.freeze({...config});
        frozenConfig.apiUrl = 'new url'; // 无效
        frozenConfig.newProp = 'value'; // 无效
        console.log('冻结后的对象:', frozenConfig);
        console.log('是否冻结:', Object.isFrozen(frozenConfig));
        
        // 密封对象（不可添加/删除属性，但可修改现有属性）
        const sealedConfig = Object.seal({...config});
        sealedConfig.timeout = 10000; // 有效
        sealedConfig.newProp = 'value'; // 无效
        delete sealedConfig.apiKey; // 无效
        console.log('密封后的对象:', sealedConfig);
        console.log('是否密封:', Object.isSealed(sealedConfig));
        
        // 阻止扩展（不可添加新属性）
        const nonExtensible = {...config};
        Object.preventExtensions(nonExtensible);
        nonExtensible.timeout = 8000; // 有效
        nonExtensible.newProp = 'value'; // 无效
        delete nonExtensible.apiKey; // 有效
        console.log('不可扩展对象:', nonExtensible);
        console.log('是否可扩展:', Object.isExtensible(nonExtensible));
    }
};

PropertyDescriptorExamples.basicDescriptors();
PropertyDescriptorExamples.accessorProperties();
PropertyDescriptorExamples.defineMultipleProperties();
PropertyDescriptorExamples.propertyProtection();
```

### getter和setter

Getter和Setter提供了属性访问的控制机制：

```javascript
/**
 * Getter和Setter示例
 */
const GetterSetterExamples = {
    /**
     * 基本getter和setter
     */
    basicGetterSetter() {
        console.log('=== 基本Getter和Setter ===');
        
        class Temperature {
            constructor(celsius = 0) {
                this._celsius = celsius;
            }
            
            // Celsius getter/setter
            get celsius() {
                return this._celsius;
            }
            
            set celsius(value) {
                if (value < -273.15) {
                    throw new Error('温度不能低于绝对零度');
                }
                this._celsius = value;
            }
            
            // Fahrenheit getter/setter
            get fahrenheit() {
                return this._celsius * 9/5 + 32;
            }
            
            set fahrenheit(value) {
                this.celsius = (value - 32) * 5/9;
            }
            
            // Kelvin getter/setter
            get kelvin() {
                return this._celsius + 273.15;
            }
            
            set kelvin(value) {
                this.celsius = value - 273.15;
            }
        }
        
        const temp = new Temperature(25);
        console.log('摄氏度:', temp.celsius);
        console.log('华氏度:', temp.fahrenheit);
        console.log('开尔文:', temp.kelvin);
        
        temp.fahrenheit = 86;
        console.log('设置华氏86度后:');
        console.log('摄氏度:', temp.celsius);
        console.log('开尔文:', temp.kelvin);
    },
    
    /**
     * 验证和计算属性
     */
    validationAndComputation() {
        console.log('=== 验证和计算属性 ===');
        
        class Rectangle {
            constructor(width = 0, height = 0) {
                this._width = width;
                this._height = height;
            }
            
            // 带验证的setter
            get width() {
                return this._width;
            }
            
            set width(value) {
                if (value <= 0) {
                    throw new Error('宽度必须大于0');
                }
                this._width = value;
            }
            
            get height() {
                return this._height;
            }
            
            set height(value) {
                if (value <= 0) {
                    throw new Error('高度必须大于0');
                }
                this._height = value;
            }
            
            // 只读计算属性
            get area() {
                return this._width * this._height;
            }
            
            get perimeter() {
                return 2 * (this._width + this._height);
            }
            
            get diagonal() {
                return Math.sqrt(this._width ** 2 + this._height ** 2);
            }
            
            get aspectRatio() {
                return this._width / this._height;
            }
            
            // 便利方法
            scale(factor) {
                this.width *= factor;
                this.height *= factor;
                return this;
            }
        }
        
        const rect = new Rectangle(10, 5);
        console.log('矩形尺寸:', rect.width, 'x', rect.height);
        console.log('面积:', rect.area);
        console.log('周长:', rect.perimeter);
        console.log('对角线:', rect.diagonal);
        console.log('宽高比:', rect.aspectRatio);
        
        rect.scale(2);
        console.log('放大2倍后面积:', rect.area);
    },
    
    /**
     * 懒加载和缓存
     */
    lazyLoadingAndCaching() {
        console.log('=== 懒加载和缓存 ===');
        
        class DataProcessor {
            constructor(data) {
                this._rawData = data;
                this._cache = {};
            }
            
            get rawData() {
                console.log('访问原始数据');
                return this._rawData;
            }
            
            // 懒加载属性
            get processedData() {
                if (!this._cache.processedData) {
                    console.log('处理数据（第一次）...');
                    this._cache.processedData = this._rawData.map(item => ({
                        ...item,
                        processed: true,
                        timestamp: Date.now()
                    }));
                }
                console.log('返回已处理数据');
                return this._cache.processedData;
            }
            
            // 带缓存的计算属性
            get statistics() {
                if (!this._cache.statistics) {
                    console.log('计算统计信息...');
                    const numbers = this._rawData.filter(item => typeof item === 'number');
                    this._cache.statistics = {
                        count: numbers.length,
                        sum: numbers.reduce((a, b) => a + b, 0),
                        avg: numbers.reduce((a, b) => a + b, 0) / numbers.length,
                        min: Math.min(...numbers),
                        max: Math.max(...numbers)
                    };
                }
                return this._cache.statistics;
            }
            
            // 清除缓存
            clearCache() {
                this._cache = {};
                console.log('缓存已清除');
            }
            
            // 更新原始数据
            set rawData(newData) {
                this._rawData = newData;
                this.clearCache(); // 数据更新时清除缓存
            }
        }
        
        const processor = new DataProcessor([1, 2, 3, 4, 5]);
        
        console.log('第一次访问processedData:');
        const processed1 = processor.processedData;
        
        console.log('第二次访问processedData:');
        const processed2 = processor.processedData;
        
        console.log('统计信息:', processor.statistics);
        
        processor.rawData = [10, 20, 30];
        console.log('更新数据后的统计:', processor.statistics);
    }
};

GetterSetterExamples.basicGetterSetter();
GetterSetterExamples.validationAndComputation();
GetterSetterExamples.lazyLoadingAndCaching();
```

### 属性的枚举性

控制属性在枚举操作中的可见性：

```javascript
/**
 * 属性枚举性示例
 */
const PropertyEnumerationExamples = {
    /**
     * 枚举方法对比
     */
    enumerationMethods() {
        console.log('=== 属性枚举方法 ===');
        
        // 创建原型链
        const parent = {
            parentProp: 'parent'
        };
        
        const obj = Object.create(parent);
        
        // 添加自有属性
        obj.ownProp1 = 'own1';
        obj.ownProp2 = 'own2';
        
        // 添加不可枚举属性
        Object.defineProperty(obj, 'nonEnum', {
            value: 'hidden',
            enumerable: false
        });
        
        // 添加Symbol属性
        const sym = Symbol('symbol');
        obj[sym] = 'symbol value';
        
        console.log('对象:', obj);
        
        // for...in（包括继承的可枚举属性）
        console.log('for...in循环:');
        for (let key in obj) {
            console.log(`  ${key}: ${obj[key]}`);
        }
        
        // Object.keys（仅自有可枚举属性）
        console.log('Object.keys:', Object.keys(obj));
        
        // Object.getOwnPropertyNames（自有属性，包括不可枚举）
        console.log('getOwnPropertyNames:', Object.getOwnPropertyNames(obj));
        
        // Object.getOwnPropertySymbols（Symbol属性）
        console.log('getOwnPropertySymbols:', Object.getOwnPropertySymbols(obj));
        
        // Reflect.ownKeys（所有自有属性）
        console.log('Reflect.ownKeys:', Reflect.ownKeys(obj));
        
        // Object.entries（自有可枚举属性的键值对）
        console.log('Object.entries:', Object.entries(obj));
        
        // Object.values（自有可枚举属性的值）
        console.log('Object.values:', Object.values(obj));
    },
    
    /**
     * 属性遍历顺序
     */
    propertyOrder() {
        console.log('=== 属性遍历顺序 ===');
        
        const obj = {};
        
        // 添加不同类型的键
        obj[2] = 'two';
        obj['1'] = 'one';
        obj.b = 'b';
        obj['3'] = 'three';
        obj.a = 'a';
        obj[Symbol('sym1')] = 'symbol1';
        obj['10'] = 'ten';
        obj.c = 'c';
        obj[Symbol('sym2')] = 'symbol2';
        
        console.log('对象内容:', obj);
        
        // 遍历顺序：
        // 1. 数字键按升序
        // 2. 字符串键按添加顺序
        // 3. Symbol键按添加顺序
        
        console.log('Object.keys顺序:', Object.keys(obj));
        console.log('Reflect.ownKeys顺序:', Reflect.ownKeys(obj));
        
        // 保持插入顺序的Map
        const map = new Map();
        map.set(2, 'two');
        map.set('1', 'one');
        map.set('b', 'b');
        map.set('3', 'three');
        map.set('a', 'a');
        
        console.log('Map保持插入顺序:');
        for (let [key, value] of map) {
            console.log(`  ${key}: ${value}`);
        }
    },
    
    /**
     * 实用枚举技巧
     */
    practicalEnumeration() {
        console.log('=== 实用枚举技巧 ===');
        
        // 过滤特定属性
        const user = {
            id: 1,
            name: 'Alice',
            email: 'alice@example.com',
            password: 'secret123',
            _internal: 'internal data',
            createdAt: new Date()
        };
        
        // 定义敏感属性为不可枚举
        Object.defineProperty(user, 'password', {
            value: user.password,
            enumerable: false
        });
        
        Object.defineProperty(user, '_internal', {
            value: user._internal,
            enumerable: false
        });
        
        // 安全序列化（自动排除不可枚举属性）
        console.log('JSON序列化:', JSON.stringify(user));
        
        // 浅拷贝（只拷贝可枚举属性）
        const publicUser = {...user};
        console.log('公开用户数据:', publicUser);
        
        // 属性白名单
        function pickProperties(obj, keys) {
            const result = {};
            for (const key of keys) {
                if (key in obj) {
                    result[key] = obj[key];
                }
            }
            return result;
        }
        
        const allowedProps = pickProperties(user, ['id', 'name', 'email']);
        console.log('白名单属性:', allowedProps);
        
        // 属性黑名单
        function omitProperties(obj, keys) {
            const result = {};
            for (const key in obj) {
                if (!keys.includes(key) && obj.hasOwnProperty(key)) {
                    result[key] = obj[key];
                }
            }
            return result;
        }
        
        const filteredUser = omitProperties(user, ['password', '_internal']);
        console.log('排除黑名单:', filteredUser);
        
        // 深度枚举
        function deepEnumerate(obj, visited = new Set()) {
            if (visited.has(obj)) return [];
            visited.add(obj);
            
            const props = [];
            
            for (const key in obj) {
                props.push(key);
                
                const value = obj[key];
                if (typeof value === 'object' && value !== null) {
                    const nestedProps = deepEnumerate(value, visited);
                    props.push(...nestedProps.map(p => `${key}.${p}`));
                }
            }
            
            return props;
        }
        
        const nested = {
            level1: {
                level2: {
                    level3: 'deep value'
                },
                another: 'value'
            },
            simple: 'value'
        };
        
        console.log('深度枚举:', deepEnumerate(nested));
    }
};

PropertyEnumerationExamples.enumerationMethods();
PropertyEnumerationExamples.propertyOrder();
PropertyEnumerationExamples.practicalEnumeration();
```

---

## 9.3 引用模型与共享特性

JavaScript中的引用模型是理解对象行为的关键，它决定了变量如何存储和传递数据。

### 引用类型vs值类型

JavaScript有两种数据类型的存储方式：

```javascript
/**
 * 值类型vs引用类型示例
 */
const ValueVsReferenceExamples = {
    /**
     * 基本类型（值类型）
     */
    primitiveTypes() {
        console.log('=== 基本类型（值类型） ===');
        
        // 基本类型：number, string, boolean, null, undefined, symbol, bigint
        let a = 10;
        let b = a; // 复制值
        b = 20;
        
        console.log('a =', a); // 10（不受影响）
        console.log('b =', b); // 20
        
        // 字符串也是值类型
        let str1 = 'Hello';
        let str2 = str1;
        str2 = 'World';
        
        console.log('str1:', str1); // 'Hello'
        console.log('str2:', str2); // 'World'
        
        // 函数参数传递值类型
        function changeValue(x) {
            x = 100;
            console.log('函数内部x:', x);
        }
        
        let num = 5;
        changeValue(num);
        console.log('函数外部num:', num); // 5（未改变）
    },
    
    /**
     * 引用类型
     */
    referenceTypes() {
        console.log('=== 引用类型 ===');
        
        // 对象是引用类型
        let obj1 = { name: 'Alice' };
        let obj2 = obj1; // 复制引用
        obj2.name = 'Bob';
        
        console.log('obj1:', obj1); // { name: 'Bob' }
        console.log('obj2:', obj2); // { name: 'Bob' }
        console.log('obj1 === obj2:', obj1 === obj2); // true
        
        // 数组也是引用类型
        let arr1 = [1, 2, 3];
        let arr2 = arr1;
        arr2.push(4);
        
        console.log('arr1:', arr1); // [1, 2, 3, 4]
        console.log('arr2:', arr2); // [1, 2, 3, 4]
        
        // 函数参数传递引用类型
        function changeObject(obj) {
            obj.modified = true;
            obj.timestamp = Date.now();
        }
        
        let myObj = { data: 'original' };
        changeObject(myObj);
        console.log('修改后的对象:', myObj); // 包含modified和timestamp
        
        // 重新赋值引用
        function reassignObject(obj) {
            obj = { newData: 'new' }; // 只改变局部变量的引用
            console.log('函数内部obj:', obj);
        }
        
        let testObj = { data: 'test' };
        reassignObject(testObj);
        console.log('函数外部testObj:', testObj); // { data: 'test' }（未改变）
    },
    
    /**
     * 内存模型演示
     */
    memoryModel() {
        console.log('=== 内存模型 ===');
        
        // 栈内存（值类型）
        let x = 10;
        let y = x;
        console.log('栈内存示例:');
        console.log('x指向值10, y复制了值10');
        console.log('x和y在栈上有各自独立的存储空间');
        
        // 堆内存（引用类型）
        let person1 = { 
            name: 'Alice',
            address: { city: 'Beijing' }
        };
        let person2 = person1;
        
        console.log('\n堆内存示例:');
        console.log('person1和person2都指向同一个堆内存地址');
        
        person2.name = 'Bob';
        person2.address.city = 'Shanghai';
        
        console.log('person1:', person1);
        console.log('person2:', person2);
        console.log('修改person2影响person1，因为指向同一对象');
        
        // 创建新对象
        person2 = { name: 'Charlie' };
        console.log('\n重新赋值后:');
        console.log('person1:', person1); // 仍然是Bob
        console.log('person2:', person2); // Charlie
        console.log('person2现在指向新的对象');
    }
};

ValueVsReferenceExamples.primitiveTypes();
ValueVsReferenceExamples.referenceTypes();
ValueVsReferenceExamples.memoryModel();
```

### 引用传递

理解引用传递对于正确处理对象至关重要：

```javascript
/**
 * 引用传递示例
 */
const ReferencePassingExamples = {
    /**
     * 函数参数传递
     */
    parameterPassing() {
        console.log('=== 参数传递机制 ===');
        
        // 对象作为参数
        function modifyObject(obj, name) {
            obj.modified = true;
            obj.name = name;
            return obj;
        }
        
        const original = { name: 'Original', value: 1 };
        const returned = modifyObject(original, 'Modified');
        
        console.log('原始对象:', original);
        console.log('返回对象:', returned);
        console.log('是同一个对象?:', original === returned); // true
        
        // 数组作为参数
        function processArray(arr) {
            arr.push('added');
            arr[0] = 'modified';
            return arr;
        }
        
        const numbers = [1, 2, 3];
        const result = processArray(numbers);
        
        console.log('原数组:', numbers);
        console.log('结果:', result);
        console.log('是同一个数组?:', numbers === result); // true
        
        // 防止修改原对象
        function safeModify(obj) {
            const copy = {...obj}; // 浅拷贝
            copy.modified = true;
            return copy;
        }
        
        const safeOriginal = { name: 'Safe', value: 2 };
        const safeResult = safeModify(safeOriginal);
        
        console.log('安全原始对象:', safeOriginal);
        console.log('安全结果:', safeResult);
        console.log('是同一个对象?:', safeOriginal === safeResult); // false
    },
    
    /**
     * 返回值引用
     */
    returnReferences() {
        console.log('=== 返回值引用 ===');
        
        // 返回同一个对象
        const sharedObject = { count: 0 };
        
        function getSharedObject() {
            sharedObject.count++;
            return sharedObject;
        }
        
        const ref1 = getSharedObject();
        const ref2 = getSharedObject();
        const ref3 = getSharedObject();
        
        console.log('ref1:', ref1);
        console.log('ref2:', ref2);
        console.log('ref3:', ref3);
        console.log('都是同一个对象:', ref1 === ref2 && ref2 === ref3);
        
        // 每次返回新对象
        function createNewObject() {
            return { 
                id: Math.random(),
                timestamp: Date.now()
            };
        }
        
        const new1 = createNewObject();
        const new2 = createNewObject();
        
        console.log('new1:', new1);
        console.log('new2:', new2);
        console.log('是不同对象:', new1 !== new2);
        
        // 闭包中的对象引用
        function createCounter() {
            const state = { count: 0 };
            
            return {
                increment() {
                    state.count++;
                    return state;
                },
                decrement() {
                    state.count--;
                    return state;
                },
                getState() {
                    return state; // 返回内部对象的引用
                }
            };
        }
        
        const counter = createCounter();
        const state1 = counter.increment();
        const state2 = counter.increment();
        const state3 = counter.getState();
        
        console.log('闭包状态引用:');
        console.log('state1:', state1);
        console.log('state2:', state2);
        console.log('state3:', state3);
        console.log('都指向同一状态:', state1 === state2 && state2 === state3);
    },
    
    /**
     * 解构赋值中的引用
     */
    destructuringReferences() {
        console.log('=== 解构赋值中的引用 ===');
        
        const original = {
            name: 'Alice',
            scores: [90, 85, 88],
            info: {
                age: 25,
                city: 'Beijing'
            }
        };
        
        // 解构赋值
        const { name, scores, info } = original;
        
        // 基本类型是值复制
        let newName = name;
        newName = 'Bob';
        console.log('原始name:', original.name); // 'Alice'
        console.log('新name:', newName); // 'Bob'
        
        // 引用类型仍然是引用
        scores.push(92);
        info.city = 'Shanghai';
        
        console.log('修改后的原始对象:', original);
        console.log('scores是同一个数组:', scores === original.scores);
        console.log('info是同一个对象:', info === original.info);
        
        // 数组解构
        const [first, ...rest] = original.scores;
        console.log('first:', first); // 值复制
        console.log('rest:', rest); // 新数组，但元素如果是对象仍是引用
        console.log('rest是新数组:', rest !== original.scores);
    }
};

ReferencePassingExamples.parameterPassing();
ReferencePassingExamples.returnReferences();
ReferencePassingExamples.destructuringReferences();
```

### 对象共享

多个变量可以共享同一个对象：

```javascript
/**
 * 对象共享示例
 */
const ObjectSharingExamples = {
    /**
     * 共享状态
     */
    sharedState() {
        console.log('=== 共享状态 ===');
        
        // 多个变量共享同一对象
        const sharedConfig = {
            apiUrl: 'https://api.example.com',
            timeout: 5000,
            retries: 3
        };
        
        const service1 = {
            name: 'UserService',
            config: sharedConfig
        };
        
        const service2 = {
            name: 'ProductService',
            config: sharedConfig
        };
        
        // 修改共享配置
        service1.config.timeout = 10000;
        
        console.log('Service1 config:', service1.config);
        console.log('Service2 config:', service2.config);
        console.log('配置是共享的:', service1.config === service2.config);
        
        // 独立配置
        const service3 = {
            name: 'OrderService',
            config: {...sharedConfig} // 创建副本
        };
        
        service3.config.timeout = 15000;
        
        console.log('Service3 config:', service3.config);
        console.log('Service1 config:', service1.config);
        console.log('配置是独立的:', service3.config !== service1.config);
    },
    
    /**
     * 原型共享
     */
    prototypeSharing() {
        console.log('=== 原型共享 ===');
        
        function Person(name) {
            this.name = name;
            this.ownData = []; // 实例自有数据
        }
        
        // 原型上的共享数据（不推荐）
        Person.prototype.sharedData = [];
        
        Person.prototype.addToOwn = function(item) {
            this.ownData.push(item);
        };
        
        Person.prototype.addToShared = function(item) {
            this.sharedData.push(item);
        };
        
        const alice = new Person('Alice');
        const bob = new Person('Bob');
        
        alice.addToOwn('Alice item');
        alice.addToShared('Shared item 1');
        
        bob.addToOwn('Bob item');
        bob.addToShared('Shared item 2');
        
        console.log('Alice自有数据:', alice.ownData);
        console.log('Bob自有数据:', bob.ownData);
        
        console.log('Alice共享数据:', alice.sharedData);
        console.log('Bob共享数据:', bob.sharedData);
        console.log('共享数据是同一个:', alice.sharedData === bob.sharedData);
    },
    
    /**
     * 避免意外共享
     */
    avoidUnintendedSharing() {
        console.log('=== 避免意外共享 ===');
        
        // ❌ 错误示例：意外共享
        class BadComponent {
            constructor() {
                // 错误：在原型上定义了可变对象
            }
        }
        
        BadComponent.prototype.state = { count: 0 };
        
        const bad1 = new BadComponent();
        const bad2 = new BadComponent();
        
        bad1.state.count++;
        console.log('Bad1 count:', bad1.state.count);
        console.log('Bad2 count:', bad2.state.count); // 也是1！
        
        // ✅ 正确示例：每个实例独立状态
        class GoodComponent {
            constructor() {
                // 正确：在构造函数中创建实例自有的状态
                this.state = { count: 0 };
            }
            
            increment() {
                this.state.count++;
            }
        }
        
        const good1 = new GoodComponent();
        const good2 = new GoodComponent();
        
        good1.increment();
        console.log('Good1 count:', good1.state.count);
        console.log('Good2 count:', good2.state.count); // 仍然是0
        
        // 工厂函数确保独立
        function createComponent() {
            return {
                state: { count: 0 },
                increment() {
                    this.state.count++;
                }
            };
        }
        
        const comp1 = createComponent();
        const comp2 = createComponent();
        
        comp1.increment();
        console.log('Comp1 count:', comp1.state.count);
        console.log('Comp2 count:', comp2.state.count);
        console.log('状态是独立的:', comp1.state !== comp2.state);
    }
};

ObjectSharingExamples.sharedState();
ObjectSharingExamples.prototypeSharing();
ObjectSharingExamples.avoidUnintendedSharing();
```

### 引用比较

对象比较的是引用，而不是内容：

```javascript
/**
 * 引用比较示例
 */
const ReferenceComparisonExamples = {
    /**
     * 相等性比较
     */
    equalityComparison() {
        console.log('=== 引用相等性比较 ===');
        
        // 相同内容的不同对象
        const obj1 = { name: 'Alice', age: 25 };
        const obj2 = { name: 'Alice', age: 25 };
        const obj3 = obj1;
        
        console.log('obj1 == obj2:', obj1 == obj2); // false
        console.log('obj1 === obj2:', obj1 === obj2); // false
        console.log('obj1 === obj3:', obj1 === obj3); // true
        
        // 数组比较
        const arr1 = [1, 2, 3];
        const arr2 = [1, 2, 3];
        const arr3 = arr1;
        
        console.log('arr1 === arr2:', arr1 === arr2); // false
        console.log('arr1 === arr3:', arr1 === arr3); // true
        
        // 空对象和数组
        console.log('{} === {}:', {} === {}); // false
        console.log('[] === []:', [] === []); // false
        
        // null和undefined
        console.log('null === null:', null === null); // true
        console.log('undefined === undefined:', undefined === undefined); // true
    },
    
    /**
     * 深度比较实现
     */
    deepComparison() {
        console.log('=== 深度比较 ===');
        
        // 深度比较函数
        function deepEqual(obj1, obj2) {
            // 相同引用
            if (obj1 === obj2) return true;
            
            // null或undefined
            if (obj1 == null || obj2 == null) return false;
            
            // 类型不同
            if (typeof obj1 !== typeof obj2) return false;
            
            // 基本类型
            if (typeof obj1 !== 'object') return obj1 === obj2;
            
            // 数组长度检查
            if (Array.isArray(obj1) && Array.isArray(obj2)) {
                if (obj1.length !== obj2.length) return false;
            }
            
            // 对象键数量检查
            const keys1 = Object.keys(obj1);
            const keys2 = Object.keys(obj2);
            if (keys1.length !== keys2.length) return false;
            
            // 递归比较每个属性
            for (let key of keys1) {
                if (!keys2.includes(key)) return false;
                if (!deepEqual(obj1[key], obj2[key])) return false;
            }
            
            return true;
        }
        
        const objA = { 
            name: 'Alice',
            scores: [90, 85],
            info: { age: 25, city: 'Beijing' }
        };
        
        const objB = { 
            name: 'Alice',
            scores: [90, 85],
            info: { age: 25, city: 'Beijing' }
        };
        
        const objC = { 
            name: 'Alice',
            scores: [90, 85],
            info: { age: 25, city: 'Shanghai' }
        };
        
        console.log('objA深度等于objB:', deepEqual(objA, objB)); // true
        console.log('objA深度等于objC:', deepEqual(objC, objB)); // false
        
        // JSON.stringify比较（简单但有限制）
        function jsonEqual(obj1, obj2) {
            try {
                return JSON.stringify(obj1) === JSON.stringify(obj2);
            } catch {
                return false;
            }
        }
        
        console.log('JSON比较objA和objB:', jsonEqual(objA, objB));
        
        // 注意：JSON.stringify有顺序依赖
        const obj4 = { a: 1, b: 2 };
        const obj5 = { b: 2, a: 1 };
        console.log('不同顺序的对象JSON比较:', jsonEqual(obj4, obj5)); // 可能false
    },
    
    /**
     * 查找和去重
     */
    findingAndDeduplication() {
        console.log('=== 查找和去重 ===');
        
        const person1 = { id: 1, name: 'Alice' };
        const person2 = { id: 2, name: 'Bob' };
        const person3 = person1; // 同一引用
        
        const people = [person1, person2, person3, person1];
        
        // 使用Set去重（基于引用）
        const uniquePeople = [...new Set(people)];
        console.log('Set去重结果:', uniquePeople);
        console.log('去重后数量:', uniquePeople.length); // 2
        
        // 基于属性值去重
        function deduplicateById(array) {
            const seen = new Map();
            return array.filter(item => {
                if (!seen.has(item.id)) {
                    seen.set(item.id, true);
                    return true;
                }
                return false;
            });
        }
        
        const morePeople = [
            { id: 1, name: 'Alice' },
            { id: 2, name: 'Bob' },
            { id: 1, name: 'Alice' }, // 重复id
            { id: 3, name: 'Charlie' }
        ];
        
        const uniqueById = deduplicateById(morePeople);
        console.log('按ID去重结果:', uniqueById);
        
        // 查找对象
        function findObjectByRef(array, target) {
            return array.indexOf(target);
        }
        
        function findObjectByProperty(array, key, value) {
            return array.find(item => item[key] === value);
        }
        
        console.log('按引用查找person1:', findObjectByRef(people, person1));
        console.log('按属性查找Bob:', findObjectByProperty(morePeople, 'name', 'Bob'));
    }
};

ReferenceComparisonExamples.equalityComparison();
ReferenceComparisonExamples.deepComparison();
ReferenceComparisonExamples.findingAndDeduplication();
```

---

## 9.4 浅拷贝与深拷贝

理解和正确实现对象拷贝是JavaScript编程中的重要技能。

### 浅拷贝的实现

浅拷贝只复制对象的第一层属性：

```javascript
/**
 * 浅拷贝实现示例
 */
const ShallowCopyExamples = {
    /**
     * 多种浅拷贝方法
     */
    shallowCopyMethods() {
        console.log('=== 浅拷贝方法 ===');
        
        const original = {
            name: 'Alice',
            age: 25,
            scores: [90, 85, 88],
            address: {
                city: 'Beijing',
                street: '123 Main St'
            }
        };
        
        // 方法1：展开操作符（最常用）
        const copy1 = {...original};
        copy1.name = 'Bob';
        copy1.scores.push(95); // 影响原对象
        
        console.log('展开操作符拷贝:');
        console.log('原对象:', original);
        console.log('拷贝:', copy1);
        
        // 方法2：Object.assign()
        const copy2 = Object.assign({}, original);
        copy2.age = 30;
        copy2.address.city = 'Shanghai'; // 影响原对象
        
        console.log('\nObject.assign拷贝:');
        console.log('原对象address:', original.address);
        console.log('拷贝address:', copy2.address);
        
        // 方法3：数组的浅拷贝
        const arr = [1, 2, { a: 3 }, [4, 5]];
        const arrCopy1 = [...arr];
        const arrCopy2 = arr.slice();
        const arrCopy3 = Array.from(arr);
        const arrCopy4 = arr.concat();
        
        arrCopy1[2].a = 99; // 影响所有数组
        
        console.log('\n数组浅拷贝:');
        console.log('原数组:', arr);
        console.log('展开操作符:', arrCopy1);
        console.log('slice:', arrCopy2);
        console.log('Array.from:', arrCopy3);
        
        // 方法4：手动浅拷贝
        function shallowCopy(obj) {
            if (obj === null || typeof obj !== 'object') {
                return obj;
            }
            
            if (obj instanceof Array) {
                return [...obj];
            }
            
            if (obj instanceof Date) {
                return new Date(obj);
            }
            
            if (obj instanceof RegExp) {
                return new RegExp(obj);
            }
            
            const copy = {};
            for (let key in obj) {
                if (obj.hasOwnProperty(key)) {
                    copy[key] = obj[key];
                }
            }
            
            return copy;
        }
        
        const manualCopy = shallowCopy(original);
        console.log('\n手动浅拷贝:', manualCopy);
    },
    
    /**
     * 浅拷贝的限制
     */
    shallowCopyLimitations() {
        console.log('=== 浅拷贝限制 ===');
        
        const user = {
            name: 'Alice',
            profile: {
                age: 25,
                hobbies: ['reading', 'coding'],
                address: {
                    city: 'Beijing'
                }
            }
        };
        
        const shallowCopy = {...user};
        
        // 修改第一层属性 - 不影响原对象
        shallowCopy.name = 'Bob';
        console.log('原对象name:', user.name);
        console.log('拷贝name:', shallowCopy.name);
        
        // 修改嵌套对象 - 影响原对象
        shallowCopy.profile.age = 30;
        shallowCopy.profile.hobbies.push('swimming');
        shallowCopy.profile.address.city = 'Shanghai';
        
        console.log('\n修改嵌套属性后:');
        console.log('原对象profile:', user.profile);
        console.log('拷贝profile:', shallowCopy.profile);
        console.log('profile是同一个对象:', user.profile === shallowCopy.profile);
        
        // 特殊对象的浅拷贝问题
        const special = {
            date: new Date(),
            regex: /test/gi,
            func: function() { return 'hello'; },
            symbol: Symbol('test'),
            map: new Map([[1, 'one']]),
            set: new Set([1, 2, 3])
        };
        
        const specialCopy = {...special};
        
        console.log('\n特殊对象浅拷贝:');
        console.log('Date是同一个:', special.date === specialCopy.date);
        console.log('RegExp是同一个:', special.regex === specialCopy.regex);
        console.log('Function是同一个:', special.func === specialCopy.func);
        console.log('Map是同一个:', special.map === specialCopy.map);
        console.log('Set是同一个:', special.set === specialCopy.set);
    }
};

ShallowCopyExamples.shallowCopyMethods();
ShallowCopyExamples.shallowCopyLimitations();
```

### 深拷贝的实现

深拷贝递归复制所有层级的属性：

```javascript
/**
 * 深拷贝实现示例
 */
const DeepCopyExamples = {
    /**
     * 基本深拷贝实现
     */
    basicDeepCopy() {
        console.log('=== 基本深拷贝 ===');
        
        // 简单的深拷贝函数
        function deepCopy(obj, visited = new WeakMap()) {
            // 处理null和基本类型
            if (obj === null || typeof obj !== 'object') {
                return obj;
            }
            
            // 处理循环引用
            if (visited.has(obj)) {
                return visited.get(obj);
            }
            
            // 处理Date
            if (obj instanceof Date) {
                return new Date(obj.getTime());
            }
            
            // 处理RegExp
            if (obj instanceof RegExp) {
                return new RegExp(obj.source, obj.flags);
            }
            
            // 处理Array
            if (obj instanceof Array) {
                const copy = [];
                visited.set(obj, copy);
                obj.forEach((item, index) => {
                    copy[index] = deepCopy(item, visited);
                });
                return copy;
            }
            
            // 处理Object
            const copy = {};
            visited.set(obj, copy);
            
            for (let key in obj) {
                if (obj.hasOwnProperty(key)) {
                    copy[key] = deepCopy(obj[key], visited);
                }
            }
            
            return copy;
        }
        
        const original = {
            name: 'Alice',
            age: 25,
            birthday: new Date('1998-01-01'),
            pattern: /test/gi,
            scores: [90, 85, 88],
            address: {
                city: 'Beijing',
                coordinates: {
                    lat: 39.9042,
                    lng: 116.4074
                }
            }
        };
        
        const deep = deepCopy(original);
        
        // 修改深拷贝
        deep.name = 'Bob';
        deep.scores.push(95);
        deep.address.city = 'Shanghai';
        deep.address.coordinates.lat = 31.2304;
        
        console.log('原对象:', original);
        console.log('深拷贝:', deep);
        console.log('address不是同一个:', original.address !== deep.address);
        console.log('scores不是同一个:', original.scores !== deep.scores);
    },
    
    /**
     * JSON方法深拷贝
     */
    jsonDeepCopy() {
        console.log('=== JSON深拷贝 ===');
        
        // JSON.stringify + JSON.parse（有限制）
        function jsonDeepCopy(obj) {
            return JSON.parse(JSON.stringify(obj));
        }
        
        const original = {
            string: 'text',
            number: 42,
            boolean: true,
            null: null,
            array: [1, 2, 3],
            object: { nested: 'value' },
            
            // 这些会丢失或转换
            undefined: undefined,
            function: function() { return 'hello'; },
            symbol: Symbol('test'),
            date: new Date(),
            regex: /test/gi,
            infinity: Infinity,
            nan: NaN
        };
        
        const jsonCopy = jsonDeepCopy(original);
        
        console.log('原对象:', original);
        console.log('JSON拷贝:', jsonCopy);
        
        console.log('\nJSON拷贝的问题:');
        console.log('undefined丢失:', 'undefined' in jsonCopy);
        console.log('function丢失:', 'function' in jsonCopy);
        console.log('symbol丢失:', 'symbol' in jsonCopy);
        console.log('Date变字符串:', typeof jsonCopy.date);
        console.log('RegExp变空对象:', jsonCopy.regex);
        console.log('Infinity变null:', jsonCopy.infinity);
        console.log('NaN变null:', jsonCopy.nan);
    },
    
    /**
     * 高级深拷贝实现
     */
    advancedDeepCopy() {
        console.log('=== 高级深拷贝 ===');
        
        // 完整的深拷贝实现
        function completeDeepCopy(obj, visited = new WeakMap()) {
            // 基本类型
            if (obj === null || typeof obj !== 'object') {
                return obj;
            }
            
            // 处理循环引用
            if (visited.has(obj)) {
                return visited.get(obj);
            }
            
            let copy;
            
            // 特殊对象类型
            if (obj instanceof Date) {
                copy = new Date(obj.getTime());
            } else if (obj instanceof RegExp) {
                copy = new RegExp(obj.source, obj.flags);
            } else if (obj instanceof Map) {
                copy = new Map();
                visited.set(obj, copy);
                obj.forEach((value, key) => {
                    copy.set(
                        completeDeepCopy(key, visited),
                        completeDeepCopy(value, visited)
                    );
                });
                return copy;
            } else if (obj instanceof Set) {
                copy = new Set();
                visited.set(obj, copy);
                obj.forEach(value => {
                    copy.add(completeDeepCopy(value, visited));
                });
                return copy;
            } else if (obj instanceof ArrayBuffer) {
                copy = obj.slice(0);
            } else if (ArrayBuffer.isView(obj)) {
                copy = new obj.constructor(obj.buffer.slice(0));
            } else if (obj instanceof Array) {
                copy = [];
            } else {
                // 普通对象，保持原型链
                copy = Object.create(Object.getPrototypeOf(obj));
            }
            
            visited.set(obj, copy);
            
            // 拷贝所有属性（包括不可枚举的）
            const descriptors = Object.getOwnPropertyDescriptors(obj);
            
            for (let key in descriptors) {
                const descriptor = descriptors[key];
                
                if (descriptor.value !== undefined) {
                    descriptor.value = completeDeepCopy(descriptor.value, visited);
                }
                
                Object.defineProperty(copy, key, descriptor);
            }
            
            // 拷贝Symbol属性
            const symbols = Object.getOwnPropertySymbols(obj);
            for (let sym of symbols) {
                const descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                if (descriptor.value !== undefined) {
                    descriptor.value = completeDeepCopy(descriptor.value, visited);
                }
                Object.defineProperty(copy, sym, descriptor);
            }
            
            return copy;
        }
        
        // 测试复杂对象
        const sym = Symbol('test');
        const complex = {
            map: new Map([['key1', 'value1'], ['key2', { nested: true }]]),
            set: new Set([1, 2, { item: 3 }]),
            [sym]: 'symbol value',
            circular: null,
            buffer: new ArrayBuffer(8),
            typedArray: new Uint8Array([1, 2, 3])
        };
        
        // 添加循环引用
        complex.circular = complex;
        
        const completeCopy = completeDeepCopy(complex);
        
        console.log('原对象:', complex);
        console.log('完整拷贝:', completeCopy);
        console.log('Map不是同一个:', complex.map !== completeCopy.map);
        console.log('Set不是同一个:', complex.set !== completeCopy.set);
        console.log('循环引用处理正确:', completeCopy.circular === completeCopy);
    }
};

DeepCopyExamples.basicDeepCopy();
DeepCopyExamples.jsonDeepCopy();
DeepCopyExamples.advancedDeepCopy();
```

### 拷贝的注意事项

使用拷贝时需要注意的问题：

```javascript
/**
 * 拷贝注意事项示例
 */
const CopyingCaveatsExamples = {
    /**
     * 性能考虑
     */
    performanceConsiderations() {
        console.log('=== 拷贝性能考虑 ===');
        
        // 大对象深拷贝性能测试
        function createLargeObject(depth, breadth) {
            if (depth === 0) {
                return Math.random();
            }
            
            const obj = {};
            for (let i = 0; i < breadth; i++) {
                obj[`prop${i}`] = createLargeObject(depth - 1, breadth);
            }
            return obj;
        }
        
        const largeObj = createLargeObject(4, 10);
        
        console.time('JSON深拷贝');
        const jsonCopy = JSON.parse(JSON.stringify(largeObj));
        console.timeEnd('JSON深拷贝');
        
        console.time('手动深拷贝');
        function simpleDeepCopy(obj) {
            if (obj === null || typeof obj !== 'object') return obj;
            if (obj instanceof Date) return new Date(obj);
            if (obj instanceof Array) return obj.map(item => simpleDeepCopy(item));
            
            const cloned = {};
            for (let key in obj) {
                cloned[key] = simpleDeepCopy(obj[key]);
            }
            return cloned;
        }
        const manualCopy = simpleDeepCopy(largeObj);
        console.timeEnd('手动深拷贝');
        
        console.time('浅拷贝');
        const shallowCopy = {...largeObj};
        console.timeEnd('浅拷贝');
        
        console.log('性能差异明显，选择合适的拷贝方式很重要');
    },
    
    /**
     * 特殊情况处理
     */
    specialCases() {
        console.log('=== 特殊情况处理 ===');
        
        // 函数属性
        const objWithFunc = {
            name: 'Test',
            method: function() { return this.name; },
            arrow: () => 'arrow function'
        };
        
        const copy = {...objWithFunc};
        console.log('函数是引用拷贝:', copy.method === objWithFunc.method);
        console.log('函数执行结果:', copy.method());
        
        // 原型链
        function CustomClass(value) {
            this.value = value;
        }
        CustomClass.prototype.getValue = function() {
            return this.value;
        };
        
        const instance = new CustomClass(42);
        const simpleCopy = {...instance};
        const jsonCopy = JSON.parse(JSON.stringify(instance));
        
        console.log('\n原型方法:');
        console.log('原实例有getValue:', 'getValue' in instance);
        console.log('展开拷贝有getValue:', 'getValue' in simpleCopy);
        console.log('JSON拷贝有getValue:', 'getValue' in jsonCopy);
        
        // getter/setter
        const objWithAccessors = {
            _value: 0,
            get value() {
                console.log('Getting value');
                return this._value;
            },
            set value(val) {
                console.log('Setting value');
                this._value = val;
            }
        };
        
        const accessorCopy = {...objWithAccessors};
        console.log('\nGetter/Setter:');
        console.log('拷贝的value:', accessorCopy.value); // 不会触发getter
        console.log('拷贝有getter?:', Object.getOwnPropertyDescriptor(accessorCopy, 'value'));
    },
    
    /**
     * 不可变数据模式
     */
    immutability() {
        console.log('=== 不可变数据模式 ===');
        
        // 状态更新模式
        const state = {
            user: {
                name: 'Alice',
                age: 25,
                preferences: {
                    theme: 'dark',
                    language: 'en'
                }
            },
            posts: [
                { id: 1, title: 'Post 1', likes: 10 },
                { id: 2, title: 'Post 2', likes: 5 }
            ]
        };
        
        // 不可变更新用户名
        const newState1 = {
            ...state,
            user: {
                ...state.user,
                name: 'Bob'
            }
        };
        
        console.log('原state.user.name:', state.user.name);
        console.log('新state.user.name:', newState1.user.name);
        
        // 不可变更新嵌套属性
        const newState2 = {
            ...state,
            user: {
                ...state.user,
                preferences: {
                    ...state.user.preferences,
                    theme: 'light'
                }
            }
        };
        
        console.log('原theme:', state.user.preferences.theme);
        console.log('新theme:', newState2.user.preferences.theme);
        
        // 不可变数组更新
        const newState3 = {
            ...state,
            posts: state.posts.map(post =>
                post.id === 1
                    ? { ...post, likes: post.likes + 1 }
                    : post
            )
        };
        
        console.log('原帖子likes:', state.posts[0].likes);
        console.log('新帖子likes:', newState3.posts[0].likes);
        
        // 使用库（如Immer）的概念
        function produce(base, recipe) {
            const copy = JSON.parse(JSON.stringify(base)); // 简化版
            recipe(copy);
            return copy;
        }
        
        const newState4 = produce(state, draft => {
            draft.user.age = 26;
            draft.posts.push({ id: 3, title: 'Post 3', likes: 0 });
        });
        
        console.log('\n使用produce模式:');
        console.log('原state posts数量:', state.posts.length);
        console.log('新state posts数量:', newState4.posts.length);
    }
};

CopyingCaveatsExamples.performanceConsiderations();
CopyingCaveatsExamples.specialCases();
CopyingCaveatsExamples.immutability();
```

### 实际应用场景

了解何时使用浅拷贝或深拷贝：

```javascript
/**
 * 实际应用场景示例
 */
const PracticalApplicationExamples = {
    /**
     * 表单数据处理
     */
    formDataHandling() {
        console.log('=== 表单数据处理 ===');
        
        class FormManager {
            constructor(initialData) {
                this.originalData = this.deepCopy(initialData);
                this.currentData = this.deepCopy(initialData);
                this.history = [this.deepCopy(initialData)];
                this.historyIndex = 0;
            }
            
            deepCopy(obj) {
                return JSON.parse(JSON.stringify(obj));
            }
            
            updateField(path, value) {
                const keys = path.split('.');
                let current = this.currentData;
                
                for (let i = 0; i < keys.length - 1; i++) {
                    current = current[keys[i]];
                }
                
                current[keys[keys.length - 1]] = value;
                this.saveToHistory();
            }
            
            saveToHistory() {
                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(this.deepCopy(this.currentData));
                this.historyIndex++;
            }
            
            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.currentData = this.deepCopy(this.history[this.historyIndex]);
                }
            }
            
            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.currentData = this.deepCopy(this.history[this.historyIndex]);
                }
            }
            
            reset() {
                this.currentData = this.deepCopy(this.originalData);
                this.saveToHistory();
            }
            
            isDirty() {
                return JSON.stringify(this.currentData) !== 
                       JSON.stringify(this.originalData);
            }
        }
        
        const formData = {
            user: {
                name: 'Alice',
                email: 'alice@example.com'
            },
            preferences: {
                newsletter: true,
                theme: 'dark'
            }
        };
        
        const form = new FormManager(formData);
        
        console.log('初始数据:', form.currentData);
        
        form.updateField('user.name', 'Bob');
        console.log('更新后:', form.currentData);
        console.log('是否修改:', form.isDirty());
        
        form.updateField('preferences.theme', 'light');
        console.log('再次更新:', form.currentData);
        
        form.undo();
        console.log('撤销一次:', form.currentData);
        
        form.redo();
        console.log('重做:', form.currentData);
        
        form.reset();
        console.log('重置:', form.currentData);
    },
    
    /**
     * 状态管理
     */
    stateManagement() {
        console.log('=== 状态管理 ===');
        
        class Store {
            constructor(initialState) {
                this.state = initialState;
                this.listeners = [];
                this.middlewares = [];
            }
            
            subscribe(listener) {
                this.listeners.push(listener);
                return () => {
                    this.listeners = this.listeners.filter(l => l !== listener);
                };
            }
            
            use(middleware) {
                this.middlewares.push(middleware);
            }
            
            dispatch(action) {
                // 中间件处理
                let finalAction = action;
                for (const middleware of this.middlewares) {
                    finalAction = middleware(this.state, finalAction);
                }
                
                // 创建新状态（不可变更新）
                const newState = this.reducer(this.state, finalAction);
                
                if (newState !== this.state) {
                    const oldState = this.state;
                    this.state = newState;
                    
                    // 通知监听器
                    this.listeners.forEach(listener => {
                        listener(newState, oldState, finalAction);
                    });
                }
            }
            
            reducer(state, action) {
                switch (action.type) {
                    case 'UPDATE_USER':
                        return {
                            ...state,
                            user: {
                                ...state.user,
                                ...action.payload
                            }
                        };
                    
                    case 'ADD_ITEM':
                        return {
                            ...state,
                            items: [...state.items, action.payload]
                        };
                    
                    case 'REMOVE_ITEM':
                        return {
                            ...state,
                            items: state.items.filter(item => 
                                item.id !== action.payload
                            )
                        };
                    
                    default:
                        return state;
                }
            }
            
            getState() {
                // 返回状态的深拷贝，防止外部直接修改
                return JSON.parse(JSON.stringify(this.state));
            }
        }
        
        // 使用示例
        const store = new Store({
            user: { name: 'Alice', role: 'admin' },
            items: [
                { id: 1, name: 'Item 1' },
                { id: 2, name: 'Item 2' }
            ]
        });
        
        // 日志中间件
        store.use((state, action) => {
            console.log('Action:', action.type);
            return action;
        });
        
        // 订阅变化
        const unsubscribe = store.subscribe((newState, oldState, action) => {
            console.log('状态变化:', action.type);
            console.log('新状态:', newState);
        });
        
        // 分发动作
        store.dispatch({
            type: 'UPDATE_USER',
            payload: { name: 'Bob' }
        });
        
        store.dispatch({
            type: 'ADD_ITEM',
            payload: { id: 3, name: 'Item 3' }
        });
        
        console.log('最终状态:', store.getState());
    }
};

PracticalApplicationExamples.formDataHandling();
PracticalApplicationExamples.stateManagement();
```

---

**本章总结**

第9章深入探讨了JavaScript对象与引用的核心概念：

1. **创建对象的多种方式**：
   - 对象字面量：最简单直观的创建方式
   - 构造函数模式：创建特定类型的对象实例
   - 工厂模式：封装对象创建过程
   - Object.create()：基于原型创建对象
   - ES6类：提供更清晰的面向对象语法

2. **属性访问与配置**：
   - 点记法和方括号记法的使用场景
   - 属性描述符控制属性特性
   - getter/setter实现属性访问控制
   - 属性枚举性管理和遍历方法

3. **引用模型与共享特性**：
   - 值类型vs引用类型的本质区别
   - 引用传递机制和内存模型
   - 对象共享的优势与陷阱
   - 引用比较和深度比较实现

4. **浅拷贝与深拷贝**：
   - 多种浅拷贝实现方式及其限制
   - 深拷贝的递归实现和特殊情况处理
   - 性能考虑和不可变数据模式
   - 实际应用中的拷贝策略选择

通过本章学习，你应该能够：
- 灵活运用各种对象创建方式
- 精确控制对象属性的行为
- 理解引用机制避免意外修改
- 正确实现对象拷贝满足不同需求

**关键要点**：
- 对象是引用类型，赋值传递的是引用而非值
- 浅拷贝只复制第一层，深层属性仍是引用
- 深拷贝需要考虑循环引用、特殊对象等情况
- 不可变数据模式有助于状态管理和调试

**下一章预告**

第10章将深入探讨原型与原型链，包括prototype的本质、原型链查找机制、构造函数的工作原理、ES6 class语法，以及继承与封装的实现方式。这些知识是理解JavaScript面向对象编程的关键。
