# 第7章　流程控制

流程控制是编程的核心概念，决定了代码的执行路径和逻辑结构。JavaScript提供了丰富的流程控制语句，包括条件判断、循环执行、分支选择等，掌握这些语句是编写复杂逻辑的基础。

## 7.1 条件语句：if / else

条件语句是程序中最基本的控制结构，允许根据不同的条件执行不同的代码分支。

### 基本if语句

最简单的条件语句只包含一个if分支，当条件为真时执行相应代码：

```javascript
/**
 * 基本if语句示例
 */
const BasicIfStatements = {
    /**
     * 简单条件判断
     */
    simpleConditions() {
        console.log('=== 基本if语句 ===');
        
        const age = 18;
        const score = 85;
        const isLoggedIn = true;
        
        // 基本if语句
        if (age >= 18) {
            console.log('已成年，可以投票');
        }
        
        if (score >= 60) {
            console.log('考试通过');
        }
        
        if (isLoggedIn) {
            console.log('欢迎回来！');
        }
        
        // 条件表达式的类型
        console.log('不同类型的条件表达式:');
        
        // 数值比较
        const temperature = 25;
        if (temperature > 30) {
            console.log('天气很热');
        }
        
        // 字符串比较
        const username = 'admin';
        if (username === 'admin') {
            console.log('管理员权限');
        }
        
        // 布尔值直接判断
        const hasPermission = true;
        if (hasPermission) {
            console.log('有操作权限');
        }
        
        // 存在性检查
        const data = { name: 'Alice' };
        if (data.name) {
            console.log('用户名存在:', data.name);
        }
    },
    
    /**
     * 复杂条件表达式
     */
    complexConditions() {
        console.log('=== 复杂条件表达式 ===');
        
        const user = {
            age: 25,
            role: 'user',
            isActive: true,
            lastLogin: new Date('2023-12-01')
        };
        
        // 逻辑与条件
        if (user.age >= 18 && user.isActive) {
            console.log('成年且活跃用户');
        }
        
        // 逻辑或条件
        if (user.role === 'admin' || user.role === 'moderator') {
            console.log('具有管理权限');
        }
        
        // 复合逻辑条件
        if ((user.age >= 18 && user.isActive) && 
            (user.role === 'admin' || user.role === 'moderator')) {
            console.log('具有完整管理权限的成年用户');
        }
        
        // 使用函数作为条件
        function isRecentLogin(lastLogin) {
            const oneWeekAgo = new Date();
            oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
            return lastLogin > oneWeekAgo;
        }
        
        if (isRecentLogin(user.lastLogin)) {
            console.log('最近有登录记录');
        }
        
        // 数组和对象的条件检查
        const permissions = ['read', 'write'];
        if (permissions.length > 0 && permissions.includes('write')) {
            console.log('具有写入权限');
        }
    },
    
    /**
     * 条件语句的性能考虑
     */
    performanceConsiderations() {
        console.log('=== 性能优化考虑 ===');
        
        const config = {
            enableCache: true,
            debugMode: false,
            apiTimeout: 5000
        };
        
        // ✅ 好的做法：先检查简单条件
        if (config.enableCache && expensiveOperation()) {
            console.log('使用缓存结果');
        }
        
        // ❌ 避免：先执行昂贵操作
        // if (expensiveOperation() && config.enableCache) {
        //     console.log('这样会先执行昂贵操作');
        // }
        
        function expensiveOperation() {
            console.log('执行昂贵操作...');
            return true;
        }
        
        // 使用短路求值优化
        const userPreferences = null;
        if (userPreferences && userPreferences.theme === 'dark') {
            console.log('深色主题模式');
        }
        
        // 避免重复计算
        const currentTime = Date.now();
        if (currentTime > config.apiTimeout) {
            console.log('API调用超时');
        }
        
        // 而不是
        // if (Date.now() > config.apiTimeout) { // 每次都计算时间
        //     console.log('API调用超时');
        // }
    }
};

BasicIfStatements.simpleConditions();
BasicIfStatements.complexConditions();
BasicIfStatements.performanceConsiderations();
```

### if / else 结构

if/else提供了二元选择，当条件不满足时执行替代逻辑：

```javascript
/**
 * if/else语句结构
 */
const IfElseStatements = {
    /**
     * 基本if/else结构
     */
    basicIfElse() {
        console.log('=== 基本if/else结构 ===');
        
        const score = 75;
        
        // 简单的二元选择
        if (score >= 60) {
            console.log('考试通过');
        } else {
            console.log('考试未通过');
        }
        
        const weather = 'rainy';
        
        if (weather === 'sunny') {
            console.log('今天天气不错，适合外出');
        } else {
            console.log('天气不太好，建议在室内活动');
        }
        
        // 使用else处理边界情况
        const userInput = '';
        
        if (userInput.trim().length > 0) {
            console.log('输入内容:', userInput);
        } else {
            console.log('请输入有效内容');
        }
    },
    
    /**
     * else if 链式判断
     */
    elseIfChain() {
        console.log('=== else if 链式判断 ===');
        
        function getGrade(score) {
            if (score >= 90) {
                return 'A';
            } else if (score >= 80) {
                return 'B';
            } else if (score >= 70) {
                return 'C';
            } else if (score >= 60) {
                return 'D';
            } else {
                return 'F';
            }
        }
        
        console.log('成绩等级:');
        console.log('95分:', getGrade(95));
        console.log('82分:', getGrade(82));
        console.log('55分:', getGrade(55));
        
        // 复杂的多条件判断
        function getUserAccessLevel(user) {
            if (!user) {
                return 'guest';
            } else if (user.role === 'admin') {
                return 'full_access';
            } else if (user.role === 'moderator' && user.isActive) {
                return 'moderate_access';
            } else if (user.isActive && user.emailVerified) {
                return 'user_access';
            } else if (user.isActive) {
                return 'limited_access';
            } else {
                return 'no_access';
            }
        }
        
        const users = [
            { role: 'admin', isActive: true, emailVerified: true },
            { role: 'user', isActive: true, emailVerified: false },
            { role: 'user', isActive: false, emailVerified: true },
            null
        ];
        
        console.log('用户访问级别:');
        users.forEach((user, index) => {
            console.log(`用户${index + 1}:`, getUserAccessLevel(user));
        });
    },
    
    /**
     * 三元运算符作为简化形式
     */
    ternaryOperator() {
        console.log('=== 三元运算符 ===');
        
        const age = 20;
        
        // 简单条件的三元运算符
        const status = age >= 18 ? 'adult' : 'minor';
        console.log('状态:', status);
        
        const score = 85;
        const result = score >= 60 ? 'pass' : 'fail';
        console.log('考试结果:', result);
        
        // 嵌套三元运算符（谨慎使用）
        const grade = score >= 90 ? 'A' : 
                     score >= 80 ? 'B' : 
                     score >= 70 ? 'C' : 'F';
        console.log('成绩等级:', grade);
        
        // 三元运算符在函数中的应用
        function formatPrice(price, currency = 'USD') {
            return currency === 'USD' ? `$${price}` : 
                   currency === 'EUR' ? `€${price}` : 
                   `${price} ${currency}`;
        }
        
        console.log('价格格式化:');
        console.log(formatPrice(100, 'USD'));
        console.log(formatPrice(100, 'EUR'));
        console.log(formatPrice(100, 'CNY'));
        
        // 三元运算符的限制和替代
        const userRole = 'admin';
        
        // ❌ 复杂逻辑不适合三元运算符
        // const message = userRole === 'admin' ? 
        //     (someComplexCondition() ? 'Admin with special access' : 'Regular admin') :
        //     (anotherComplexCondition() ? 'Special user' : 'Regular user');
        
        // ✅ 使用函数替代复杂三元运算符
        function getUserMessage(role) {
            if (role === 'admin') {
                return 'Administrator access granted';
            } else if (role === 'user') {
                return 'User access granted';
            } else {
                return 'Guest access';
            }
        }
        
        console.log('用户消息:', getUserMessage(userRole));
    }
};

IfElseStatements.basicIfElse();
IfElseStatements.elseIfChain();
IfElseStatements.ternaryOperator();
```

### 嵌套条件与多重判断

复杂的业务逻辑往往需要嵌套的条件判断：

```javascript
/**
 * 嵌套条件与多重判断
 */
const NestedConditions = {
    /**
     * 基本嵌套结构
     */
    basicNesting() {
        console.log('=== 基本嵌套结构 ===');
        
        const user = {
            isLoggedIn: true,
            profile: {
                isComplete: true,
                age: 25
            },
            subscription: {
                type: 'premium',
                isActive: true
            }
        };
        
        // 基本嵌套
        if (user.isLoggedIn) {
            console.log('用户已登录');
            
            if (user.profile.isComplete) {
                console.log('用户资料完整');
                
                if (user.profile.age >= 18) {
                    console.log('用户已成年');
                    
                    if (user.subscription.isActive) {
                        console.log('订阅状态正常');
                        
                        if (user.subscription.type === 'premium') {
                            console.log('高级用户，享受全部功能');
                        } else {
                            console.log('普通用户，享受基础功能');
                        }
                    } else {
                        console.log('订阅已过期');
                    }
                } else {
                    console.log('未成年用户，功能受限');
                }
            } else {
                console.log('请完善用户资料');
            }
        } else {
            console.log('请先登录');
        }
    },
    
    /**
     * 优化嵌套：早期返回模式
     */
    earlyReturn() {
        console.log('=== 早期返回优化 ===');
        
        /**
         * 检查用户权限（嵌套版本）
         * @param {Object} user - 用户对象
         * @returns {string} 权限检查结果
         */
        function checkPermissionNested(user) {
            if (user) {
                if (user.isActive) {
                    if (user.emailVerified) {
                        if (user.role) {
                            if (user.role === 'admin') {
                                return 'Full admin access';
                            } else if (user.role === 'moderator') {
                                return 'Moderator access';
                            } else {
                                return 'User access';
                            }
                        } else {
                            return 'No role assigned';
                        }
                    } else {
                        return 'Email not verified';
                    }
                } else {
                    return 'Account inactive';
                }
            } else {
                return 'User not found';
            }
        }
        
        /**
         * 检查用户权限（早期返回版本）
         * @param {Object} user - 用户对象
         * @returns {string} 权限检查结果
         */
        function checkPermissionOptimized(user) {
            // 早期返回，减少嵌套
            if (!user) return 'User not found';
            if (!user.isActive) return 'Account inactive';
            if (!user.emailVerified) return 'Email not verified';
            if (!user.role) return 'No role assigned';
            
            // 主要逻辑更清晰
            if (user.role === 'admin') return 'Full admin access';
            if (user.role === 'moderator') return 'Moderator access';
            return 'User access';
        }
        
        const testUsers = [
            { isActive: true, emailVerified: true, role: 'admin' },
            { isActive: true, emailVerified: false, role: 'user' },
            { isActive: false, emailVerified: true, role: 'user' },
            null
        ];
        
        console.log('嵌套版本结果:');
        testUsers.forEach((user, index) => {
            console.log(`用户${index + 1}:`, checkPermissionNested(user));
        });
        
        console.log('优化版本结果:');
        testUsers.forEach((user, index) => {
            console.log(`用户${index + 1}:`, checkPermissionOptimized(user));
        });
    },
    
    /**
     * 复杂条件的分解
     */
    conditionDecomposition() {
        console.log('=== 复杂条件分解 ===');
        
        const order = {
            items: [
                { price: 100, quantity: 2 },
                { price: 50, quantity: 1 }
            ],
            user: {
                membershipLevel: 'gold',
                region: 'US'
            },
            shippingMethod: 'express',
            paymentMethod: 'creditcard'
        };
        
        /**
         * 计算订单处理费用（复杂版本）
         */
        function calculateProcessingFeeComplex(order) {
            if (order.items && order.items.length > 0 && order.user && 
                (order.user.membershipLevel === 'gold' || order.user.membershipLevel === 'platinum') &&
                order.user.region === 'US' && order.shippingMethod === 'express' &&
                order.paymentMethod === 'creditcard' && 
                order.items.reduce((sum, item) => sum + item.price * item.quantity, 0) > 200) {
                return 0; // 免处理费
            } else if (order.items && order.items.length > 0 && order.user &&
                       order.user.membershipLevel === 'silver' && order.user.region === 'US') {
                return 5; // 银会员处理费
            } else {
                return 10; // 标准处理费
            }
        }
        
        /**
         * 计算订单处理费用（分解版本）
         */
        function calculateProcessingFeeOptimized(order) {
            // 分解复杂条件为有意义的变量
            const hasItems = order.items && order.items.length > 0;
            const isValidUser = order.user && order.user.region;
            const isPremiumMember = order.user?.membershipLevel === 'gold' || 
                                  order.user?.membershipLevel === 'platinum';
            const isSilverMember = order.user?.membershipLevel === 'silver';
            const isUSRegion = order.user?.region === 'US';
            const isExpressShipping = order.shippingMethod === 'express';
            const isCreditCardPayment = order.paymentMethod === 'creditcard';
            
            const totalAmount = hasItems ? 
                order.items.reduce((sum, item) => sum + item.price * item.quantity, 0) : 0;
            const isLargeOrder = totalAmount > 200;
            
            // 清晰的条件判断
            const qualifiesForFreeProcessing = 
                hasItems && isValidUser && isPremiumMember && 
                isUSRegion && isExpressShipping && 
                isCreditCardPayment && isLargeOrder;
            
            if (qualifiesForFreeProcessing) {
                return 0;
            }
            
            const qualifiesForDiscountedProcessing = 
                hasItems && isValidUser && isSilverMember && isUSRegion;
            
            if (qualifiesForDiscountedProcessing) {
                return 5;
            }
            
            return 10;
        }
        
        console.log('复杂版本处理费:', calculateProcessingFeeComplex(order));
        console.log('优化版本处理费:', calculateProcessingFeeOptimized(order));
    }
};

NestedConditions.basicNesting();
NestedConditions.earlyReturn();
NestedConditions.conditionDecomposition();
```

### 条件语句的最佳实践

编写清晰、可维护的条件语句需要遵循一些最佳实践：

```javascript
/**
 * 条件语句最佳实践
 */
const ConditionalBestPractices = {
    /**
     * 可读性优化
     */
    readabilityOptimization() {
        console.log('=== 可读性优化 ===');
        
        const user = {
            age: 25,
            role: 'admin',
            permissions: ['read', 'write', 'delete'],
            lastLoginTime: new Date('2023-12-01'),
            accountStatus: 'active'
        };
        
        // ❌ 避免：难以理解的条件
        if (user.age >= 18 && (user.role === 'admin' || user.role === 'moderator') && 
            user.permissions.includes('write') && user.accountStatus === 'active' &&
            Date.now() - user.lastLoginTime.getTime() < 7 * 24 * 60 * 60 * 1000) {
            console.log('用户可以执行写操作');
        }
        
        // ✅ 推荐：使用描述性变量名
        const isAdult = user.age >= 18;
        const hasAdminRole = user.role === 'admin' || user.role === 'moderator';
        const hasWritePermission = user.permissions.includes('write');
        const isActiveAccount = user.accountStatus === 'active';
        const isRecentLogin = Date.now() - user.lastLoginTime.getTime() < 7 * 24 * 60 * 60 * 1000;
        
        const canPerformWriteOperation = 
            isAdult && hasAdminRole && hasWritePermission && 
            isActiveAccount && isRecentLogin;
        
        if (canPerformWriteOperation) {
            console.log('用户可以执行写操作（优化版本）');
        }
        
        // 使用函数封装复杂判断
        function canUserWrite(user) {
            const isEligibleUser = user.age >= 18 && user.accountStatus === 'active';
            const hasRequiredRole = ['admin', 'moderator'].includes(user.role);
            const hasPermission = user.permissions.includes('write');
            const hasRecentActivity = isRecentLogin(user.lastLoginTime);
            
            return isEligibleUser && hasRequiredRole && hasPermission && hasRecentActivity;
        }
        
        function isRecentLogin(lastLoginTime) {
            const oneWeekInMs = 7 * 24 * 60 * 60 * 1000;
            return Date.now() - lastLoginTime.getTime() < oneWeekInMs;
        }
        
        if (canUserWrite(user)) {
            console.log('用户可以执行写操作（函数封装版本）');
        }
    },
    
    /**
     * 错误处理模式
     */
    errorHandlingPatterns() {
        console.log('=== 错误处理模式 ===');
        
        /**
         * 安全的数据访问
         * @param {Object} data - 数据对象
         */
        function processUserData(data) {
            // 防御性编程
            if (!data) {
                console.log('错误: 数据为空');
                return;
            }
            
            if (!data.user) {
                console.log('错误: 用户信息缺失');
                return;
            }
            
            if (typeof data.user.name !== 'string' || data.user.name.trim() === '') {
                console.log('错误: 用户名无效');
                return;
            }
            
            if (!Array.isArray(data.user.roles) || data.user.roles.length === 0) {
                console.log('警告: 用户角色为空');
            }
            
            // 主要处理逻辑
            console.log('处理用户:', data.user.name);
            console.log('角色:', data.user.roles?.join(', ') || '无');
        }
        
        // 测试不同的数据情况
        const testData = [
            { user: { name: 'Alice', roles: ['admin'] } },
            { user: { name: '', roles: [] } },
            { user: { roles: ['user'] } },
            {},
            null
        ];
        
        testData.forEach((data, index) => {
            console.log(`测试数据 ${index + 1}:`);
            processUserData(data);
        });
    },
    
    /**
     * 性能优化技巧
     */
    performanceOptimization() {
        console.log('=== 性能优化技巧 ===');
        
        const users = [
            { id: 1, active: true, role: 'admin', score: 95 },
            { id: 2, active: false, role: 'user', score: 75 },
            { id: 3, active: true, role: 'user', score: 85 },
            // ... 假设有很多用户
        ];
        
        // ❌ 低效：重复计算
        function findEligibleUsersInefficient(users) {
            const result = [];
            for (let user of users) {
                if (user.active && 
                    (user.role === 'admin' || user.role === 'moderator') &&
                    calculateUserScore(user) > 80) { // 每次都计算
                    result.push(user);
                }
            }
            return result;
        }
        
        // ✅ 高效：缓存计算结果，优化条件顺序
        function findEligibleUsersOptimized(users) {
            const result = [];
            for (let user of users) {
                // 先检查最简单的条件
                if (!user.active) continue;
                
                // 再检查角色（相对简单）
                if (user.role !== 'admin' && user.role !== 'moderator') continue;
                
                // 最后进行昂贵的计算
                const score = calculateUserScore(user);
                if (score > 80) {
                    result.push({ ...user, computedScore: score });
                }
            }
            return result;
        }
        
        function calculateUserScore(user) {
            // 模拟昂贵的计算
            console.log(`计算用户 ${user.id} 的分数`);
            return user.score + (user.role === 'admin' ? 10 : 0);
        }
        
        console.log('低效版本:');
        const inefficientResult = findEligibleUsersInefficient(users);
        console.log('结果数量:', inefficientResult.length);
        
        console.log('高效版本:');
        const optimizedResult = findEligibleUsersOptimized(users);
        console.log('结果数量:', optimizedResult.length);
    },
    
    /**
     * 条件语句的重构技巧
     */
    refactoringTechniques() {
        console.log('=== 重构技巧 ===');
        
        // 使用策略模式替代大量if/else
        const discountStrategies = {
            'regular': (price) => price,
            'member': (price) => price * 0.9,
            'vip': (price) => price * 0.8,
            'premium': (price) => price * 0.7
        };
        
        function calculatePrice(basePrice, customerType) {
            const strategy = discountStrategies[customerType] || discountStrategies.regular;
            return strategy(basePrice);
        }
        
        console.log('价格计算（策略模式）:');
        console.log('普通客户:', calculatePrice(100, 'regular'));
        console.log('会员:', calculatePrice(100, 'member'));
        console.log('VIP:', calculatePrice(100, 'vip'));
        
        // 使用查找表替代复杂条件
        const statusMessages = {
            'pending': '待处理',
            'processing': '处理中',
            'completed': '已完成',
            'failed': '处理失败',
            'cancelled': '已取消'
        };
        
        function getStatusMessage(status) {
            return statusMessages[status] || '未知状态';
        }
        
        console.log('状态消息（查找表）:');
        ['pending', 'completed', 'unknown'].forEach(status => {
            console.log(`${status}:`, getStatusMessage(status));
        });
        
        // 使用多态替代类型检查
        class Shape {
            calculateArea() {
                throw new Error('子类必须实现此方法');
            }
        }
        
        class Rectangle extends Shape {
            constructor(width, height) {
                super();
                this.width = width;
                this.height = height;
            }
            
            calculateArea() {
                return this.width * this.height;
            }
        }
        
        class Circle extends Shape {
            constructor(radius) {
                super();
                this.radius = radius;
            }
            
            calculateArea() {
                return Math.PI * this.radius * this.radius;
            }
        }
        
        const shapes = [
            new Rectangle(5, 10),
            new Circle(3)
        ];
        
        console.log('形状面积计算（多态）:');
        shapes.forEach((shape, index) => {
            console.log(`形状${index + 1}面积:`, shape.calculateArea().toFixed(2));
        });
    }
};

ConditionalBestPractices.readabilityOptimization();
ConditionalBestPractices.errorHandlingPatterns();
ConditionalBestPractices.performanceOptimization();
ConditionalBestPractices.refactoringTechniques();
```

---

## 7.2 多分支：switch

switch语句提供了一种更简洁的方式来处理多个条件分支，特别适用于基于单个变量值的多路选择。

### switch语句的基本结构

switch语句通过匹配表达式的值与case标签来选择执行路径：

```javascript
/**
 * switch语句基本结构演示
 */
const BasicSwitchStatements = {
    /**
     * 基本语法结构
     */
    basicSyntax() {
        console.log('=== switch基本语法 ===');
        
        function getWeekdayName(dayNumber) {
            let dayName;
            
            switch (dayNumber) {
                case 1:
                    dayName = '星期一';
                    break;
                case 2:
                    dayName = '星期二';
                    break;
                case 3:
                    dayName = '星期三';
                    break;
                case 4:
                    dayName = '星期四';
                    break;
                case 5:
                    dayName = '星期五';
                    break;
                case 6:
                    dayName = '星期六';
                    break;
                case 7:
                    dayName = '星期日';
                    break;
                default:
                    dayName = '无效的天数';
                    break;
            }
            
            return dayName;
        }
        
        console.log('星期名称:');
        [1, 3, 7, 8].forEach(day => {
            console.log(`${day}:`, getWeekdayName(day));
        });
        
        // 与if/else的对比
        function getWeekdayNameIfElse(dayNumber) {
            if (dayNumber === 1) return '星期一';
            else if (dayNumber === 2) return '星期二';
            else if (dayNumber === 3) return '星期三';
            else if (dayNumber === 4) return '星期四';
            else if (dayNumber === 5) return '星期五';
            else if (dayNumber === 6) return '星期六';
            else if (dayNumber === 7) return '星期日';
            else return '无效的天数';
        }
        
        console.log('if/else版本结果:', getWeekdayNameIfElse(3));
    },
    
    /**
     * 不同数据类型的匹配
     */
    dataTypeMatching() {
        console.log('=== 数据类型匹配 ===');
        
        // 字符串匹配
        function handleUserAction(action) {
            switch (action) {
                case 'login':
                    return '用户登录';
                case 'logout':
                    return '用户登出';
                case 'register':
                    return '用户注册';
                case 'reset-password':
                    return '密码重置';
                default:
                    return '未知操作';
            }
        }
        
        console.log('字符串匹配:');
        ['login', 'logout', 'unknown'].forEach(action => {
            console.log(`${action}:`, handleUserAction(action));
        });
        
        // 数值匹配
        function getHttpStatusMessage(status) {
            switch (status) {
                case 200:
                    return '请求成功';
                case 201:
                    return '资源创建成功';
                case 400:
                    return '请求错误';
                case 401:
                    return '未授权';
                case 404:
                    return '资源未找到';
                case 500:
                    return '服务器错误';
                default:
                    return '未知状态码';
            }
        }
        
        console.log('数值匹配:');
        [200, 404, 500, 999].forEach(status => {
            console.log(`${status}:`, getHttpStatusMessage(status));
        });
        
        // 布尔值匹配（较少使用）
        function getBooleanMessage(value) {
            switch (value) {
                case true:
                    return '真值';
                case false:
                    return '假值';
                default:
                    return '非布尔值';
            }
        }
        
        console.log('布尔值匹配:');
        [true, false, null, 0].forEach(value => {
            console.log(`${value}:`, getBooleanMessage(value));
        });
    }
};

BasicSwitchStatements.basicSyntax();
BasicSwitchStatements.dataTypeMatching();
```

### case语句与break

break语句控制switch的执行流程，防止代码"落through"到下一个case：

```javascript
/**
 * case语句与break的使用
 */
const CaseAndBreakStatements = {
    /**
     * break的重要性
     */
    breakImportance() {
        console.log('=== break语句的重要性 ===');
        
        // ❌ 没有break的问题演示
        function getSeasonWithoutBreak(month) {
            let season;
            
            switch (month) {
                case 12:
                case 1:
                case 2:
                    season = '冬季';
                    // 缺少break
                case 3:
                case 4:
                case 5:
                    season = '春季';
                    // 缺少break
                case 6:
                case 7:
                case 8:
                    season = '夏季';
                    // 缺少break
                case 9:
                case 10:
                case 11:
                    season = '秋季';
                    // 缺少break
                default:
                    season = '未知季节';
            }
            
            return season;
        }
        
        // ✅ 正确使用break
        function getSeasonWithBreak(month) {
            let season;
            
            switch (month) {
                case 12:
                case 1:
                case 2:
                    season = '冬季';
                    break;
                case 3:
                case 4:
                case 5:
                    season = '春季';
                    break;
                case 6:
                case 7:
                case 8:
                    season = '夏季';
                    break;
                case 9:
                case 10:
                case 11:
                    season = '秋季';
                    break;
                default:
                    season = '未知季节';
                    break;
            }
            
            return season;
        }
        
        console.log('没有break的结果:');
        [1, 6, 9].forEach(month => {
            console.log(`${month}月:`, getSeasonWithoutBreak(month));
        });
        
        console.log('有break的结果:');
        [1, 6, 9].forEach(month => {
            console.log(`${month}月:`, getSeasonWithBreak(month));
        });
    },
    
    /**
     * 故意的fall-through（落空）
     */
    intentionalFallThrough() {
        console.log('=== 故意的fall-through ===');
        
        // 多个case共享相同逻辑
        function isWeekend(dayOfWeek) {
            switch (dayOfWeek) {
                case 'Saturday':
                case 'Sunday':
                    return true;
                case 'Monday':
                case 'Tuesday':
                case 'Wednesday':
                case 'Thursday':
                case 'Friday':
                    return false;
                default:
                    return null;
            }
        }
        
        console.log('周末判断:');
        ['Saturday', 'Monday', 'Sunday'].forEach(day => {
            console.log(`${day}:`, isWeekend(day) ? '周末' : '工作日');
        });
        
        // 累积处理逻辑
        function processPermissions(userRole) {
            let permissions = [];
            
            switch (userRole) {
                case 'superadmin':
                    permissions.push('system_manage');
                    // fall through
                case 'admin':
                    permissions.push('user_manage');
                    // fall through
                case 'moderator':
                    permissions.push('content_moderate');
                    // fall through
                case 'user':
                    permissions.push('read', 'write');
                    break;
                case 'guest':
                    permissions.push('read');
                    break;
                default:
                    permissions = [];
            }
            
            return permissions;
        }
        
        console.log('权限分配:');
        ['guest', 'user', 'admin', 'superadmin'].forEach(role => {
            console.log(`${role}:`, processPermissions(role));
        });
        
        // 渐进式日志级别
        function shouldLog(currentLevel, messageLevel) {
            const levels = {
                'error': 1,
                'warn': 2,
                'info': 3,
                'debug': 4
            };
            
            const current = levels[currentLevel];
            const message = levels[messageLevel];
            
            switch (current) {
                case 4: // debug级别，记录所有
                    if (message === 4) return true;
                    // fall through
                case 3: // info级别
                    if (message === 3) return true;
                    // fall through
                case 2: // warn级别
                    if (message === 2) return true;
                    // fall through
                case 1: // error级别，只记录错误
                    if (message === 1) return true;
                    break;
                default:
                    return false;
            }
            
            return false;
        }
        
        console.log('日志级别过滤:');
        const levels = ['error', 'warn', 'info', 'debug'];
        levels.forEach(currentLevel => {
            const filtered = levels.filter(msgLevel => 
                shouldLog(currentLevel, msgLevel)
            );
            console.log(`${currentLevel}级别记录:`, filtered);
        });
    },
    
    /**
     * 替代break的return
     */
    returnAlternative() {
        console.log('=== 使用return替代break ===');
        
        // 在函数中使用return直接退出
        function getGradeDescription(grade) {
            switch (grade) {
                case 'A':
                    return '优秀 - 90分以上';
                case 'B':
                    return '良好 - 80-89分';
                case 'C':
                    return '及格 - 70-79分';
                case 'D':
                    return '不及格 - 60-69分';
                case 'F':
                    return '失败 - 60分以下';
                default:
                    return '无效成绩';
            }
            // 这里不需要break，因为return已经退出函数
        }
        
        console.log('成绩描述:');
        ['A', 'C', 'F', 'X'].forEach(grade => {
            console.log(`${grade}:`, getGradeDescription(grade));
        });
        
        // 复杂逻辑中的return使用
        function calculateShippingCost(method, weight, distance) {
            switch (method) {
                case 'standard':
                    if (weight <= 1) return 5;
                    if (weight <= 5) return 8;
                    return 8 + (weight - 5) * 2;
                    
                case 'express':
                    const baseCost = weight <= 1 ? 15 : 15 + (weight - 1) * 5;
                    return distance > 100 ? baseCost * 1.5 : baseCost;
                    
                case 'overnight':
                    return Math.max(25, weight * 10 + distance * 0.1);
                    
                default:
                    throw new Error('不支持的配送方式');
            }
        }
        
        console.log('配送费计算:');
        const shippingTests = [
            ['standard', 2, 50],
            ['express', 1, 150],
            ['overnight', 3, 200]
        ];
        
        shippingTests.forEach(([method, weight, distance]) => {
            const cost = calculateShippingCost(method, weight, distance);
            console.log(`${method} ${weight}kg ${distance}km: $${cost}`);
        });
    }
};

CaseAndBreakStatements.breakImportance();
CaseAndBreakStatements.intentionalFallThrough();
CaseAndBreakStatements.returnAlternative();
```

### default子句

default子句为switch提供兜底处理，当所有case都不匹配时执行：

```javascript
/**
 * default子句的使用
 */
const DefaultClauseUsage = {
    /**
     * 基本default用法
     */
    basicDefault() {
        console.log('=== 基本default用法 ===');
        
        function getAnimalSound(animal) {
            switch (animal) {
                case 'dog':
                    return '汪汪';
                case 'cat':
                    return '喵喵';
                case 'pig':
                    return '哼哼';
                case 'cow':
                    return '哞哞';
                default:
                    return '未知动物声音';
            }
        }
        
        console.log('动物声音:');
        ['dog', 'cat', 'elephant', 'unknown'].forEach(animal => {
            console.log(`${animal}:`, getAnimalSound(animal));
        });
    },
    
    /**
     * default的位置
     */
    defaultPosition() {
        console.log('=== default位置测试 ===');
        
        // default不一定在最后
        function processValue(value) {
            switch (value) {
                case 1:
                    return 'One';
                default:
                    return 'Default value';
                case 2:
                    return 'Two';
                case 3:
                    return 'Three';
            }
        }
        
        console.log('default位置测试:');
        [1, 2, 3, 4].forEach(value => {
            console.log(`${value}:`, processValue(value));
        });
        
        // 推荐：default放在最后
        function processValueRecommended(value) {
            switch (value) {
                case 1:
                    return 'One';
                case 2:
                    return 'Two';
                case 3:
                    return 'Three';
                default:
                    return 'Default value';
            }
        }
        
        console.log('推荐的default位置:');
        [1, 2, 3, 4].forEach(value => {
            console.log(`${value}:`, processValueRecommended(value));
        });
    },
    
    /**
     * 错误处理中的default
     */
    errorHandling() {
        console.log('=== 错误处理 ===');
        
        function validateUserRole(role) {
            switch (role) {
                case 'admin':
                case 'moderator':
                case 'user':
                case 'guest':
                    return true;
                default:
                    throw new Error(`无效的用户角色: ${role}`);
            }
        }
        
        console.log('角色验证:');
        ['admin', 'user', 'invalid'].forEach(role => {
            try {
                const isValid = validateUserRole(role);
                console.log(`${role}: 有效`);
            } catch (error) {
                console.log(`${role}: ${error.message}`);
            }
        });
        
        // 安全的默认行为
        function getPermissionLevel(role) {
            switch (role) {
                case 'admin':
                    return 10;
                case 'moderator':
                    return 5;
                case 'user':
                    return 3;
                case 'guest':
                    return 1;
                default:
                    console.warn(`未知角色 ${role}，使用最低权限`);
                    return 0; // 安全的默认值
            }
        }
        
        console.log('权限级别:');
        ['admin', 'user', 'unknown'].forEach(role => {
            console.log(`${role}:`, getPermissionLevel(role));
        });
    }
};

DefaultClauseUsage.basicDefault();
DefaultClauseUsage.defaultPosition();
DefaultClauseUsage.errorHandling();
```

### switch的高级应用

switch语句的一些高级用法和最佳实践：

```javascript
/**
 * switch的高级应用
 */
const AdvancedSwitchUsage = {
    /**
     * 表达式作为case值
     */
    expressionCases() {
        console.log('=== 表达式case值 ===');
        
        const MODES = {
            DEVELOPMENT: 'dev',
            TESTING: 'test',
            PRODUCTION: 'prod'
        };
        
        function configureApp(mode) {
            switch (mode) {
                case MODES.DEVELOPMENT:
                    return { 
                        debug: true, 
                        logging: 'verbose',
                        apiUrl: 'http://localhost:3000'
                    };
                case MODES.TESTING:
                    return { 
                        debug: true, 
                        logging: 'minimal',
                        apiUrl: 'http://test.example.com'
                    };
                case MODES.PRODUCTION:
                    return { 
                        debug: false, 
                        logging: 'error',
                        apiUrl: 'https://api.example.com'
                    };
                default:
                    throw new Error(`未知模式: ${mode}`);
            }
        }
        
        console.log('应用配置:');
        Object.values(MODES).forEach(mode => {
            const config = configureApp(mode);
            console.log(`${mode}:`, config);
        });
    },
    
    /**
     * switch与函数结合
     */
    switchWithFunctions() {
        console.log('=== switch与函数结合 ===');
        
        // 策略模式的实现
        const calculationStrategies = {
            add: (a, b) => a + b,
            subtract: (a, b) => a - b,
            multiply: (a, b) => a * b,
            divide: (a, b) => b !== 0 ? a / b : NaN
        };
        
        function calculate(operation, a, b) {
            switch (operation) {
                case 'add':
                case 'plus':
                case '+':
                    return calculationStrategies.add(a, b);
                case 'subtract':
                case 'minus':
                case '-':
                    return calculationStrategies.subtract(a, b);
                case 'multiply':
                case 'times':
                case '*':
                    return calculationStrategies.multiply(a, b);
                case 'divide':
                case '/':
                    return calculationStrategies.divide(a, b);
                default:
                    throw new Error(`不支持的运算: ${operation}`);
            }
        }
        
        console.log('计算器测试:');
        const tests = [
            ['add', 10, 5],
            ['+', 10, 5],
            ['multiply', 4, 3],
            ['divide', 15, 3],
            ['unknown', 1, 1]
        ];
        
        tests.forEach(([op, a, b]) => {
            try {
                const result = calculate(op, a, b);
                console.log(`${a} ${op} ${b} = ${result}`);
            } catch (error) {
                console.log(`错误: ${error.message}`);
            }
        });
    },
    
    /**
     * 复杂对象的处理
     */
    complexObjectHandling() {
        console.log('=== 复杂对象处理 ===');
        
        function processMessage(message) {
            switch (message.type) {
                case 'user_login':
                    return {
                        action: '记录用户登录',
                        data: {
                            userId: message.payload.userId,
                            timestamp: new Date().toISOString(),
                            ip: message.payload.ip
                        }
                    };
                    
                case 'user_logout':
                    return {
                        action: '记录用户登出',
                        data: {
                            userId: message.payload.userId,
                            sessionDuration: message.payload.duration,
                            timestamp: new Date().toISOString()
                        }
                    };
                    
                case 'order_created':
                    return {
                        action: '处理新订单',
                        data: {
                            orderId: message.payload.orderId,
                            amount: message.payload.total,
                            timestamp: new Date().toISOString(),
                            notifications: ['email', 'sms']
                        }
                    };
                    
                case 'payment_completed':
                    return {
                        action: '确认支付完成',
                        data: {
                            paymentId: message.payload.paymentId,
                            orderId: message.payload.orderId,
                            amount: message.payload.amount,
                            timestamp: new Date().toISOString()
                        }
                    };
                    
                default:
                    return {
                        action: '未知消息类型',
                        data: {
                            originalMessage: message,
                            timestamp: new Date().toISOString(),
                            needsManualReview: true
                        }
                    };
            }
        }
        
        const messages = [
            {
                type: 'user_login',
                payload: { userId: '123', ip: '192.168.1.1' }
            },
            {
                type: 'order_created',
                payload: { orderId: 'ORD-001', total: 99.99 }
            },
            {
                type: 'unknown_event',
                payload: { someData: 'value' }
            }
        ];
        
        console.log('消息处理结果:');
        messages.forEach((msg, index) => {
            const result = processMessage(msg);
            console.log(`消息${index + 1}:`, result);
        });
    },
    
    /**
     * switch vs if/else 性能对比
     */
    performanceComparison() {
        console.log('=== 性能对比 ===');
        
        // switch版本
        function processWithSwitch(type) {
            switch (type) {
                case 'type1': return 'Processing type 1';
                case 'type2': return 'Processing type 2';
                case 'type3': return 'Processing type 3';
                case 'type4': return 'Processing type 4';
                case 'type5': return 'Processing type 5';
                case 'type6': return 'Processing type 6';
                case 'type7': return 'Processing type 7';
                case 'type8': return 'Processing type 8';
                case 'type9': return 'Processing type 9';
                case 'type10': return 'Processing type 10';
                default: return 'Unknown type';
            }
        }
        
        // if/else版本
        function processWithIfElse(type) {
            if (type === 'type1') return 'Processing type 1';
            else if (type === 'type2') return 'Processing type 2';
            else if (type === 'type3') return 'Processing type 3';
            else if (type === 'type4') return 'Processing type 4';
            else if (type === 'type5') return 'Processing type 5';
            else if (type === 'type6') return 'Processing type 6';
            else if (type === 'type7') return 'Processing type 7';
            else if (type === 'type8') return 'Processing type 8';
            else if (type === 'type9') return 'Processing type 9';
            else if (type === 'type10') return 'Processing type 10';
            else return 'Unknown type';
        }
        
        // 对象映射版本
        const typeMap = {
            'type1': 'Processing type 1',
            'type2': 'Processing type 2',
            'type3': 'Processing type 3',
            'type4': 'Processing type 4',
            'type5': 'Processing type 5',
            'type6': 'Processing type 6',
            'type7': 'Processing type 7',
            'type8': 'Processing type 8',
            'type9': 'Processing type 9',
            'type10': 'Processing type 10'
        };
        
        function processWithMap(type) {
            return typeMap[type] || 'Unknown type';
        }
        
        // 简单性能测试
        const testTypes = ['type1', 'type5', 'type10', 'unknown'];
        
        console.log('各种方法的结果对比:');
        testTypes.forEach(type => {
            const switchResult = processWithSwitch(type);
            const ifElseResult = processWithIfElse(type);
            const mapResult = processWithMap(type);
            
            console.log(`${type}:`);
            console.log(`  Switch: ${switchResult}`);
            console.log(`  If/Else: ${ifElseResult}`);
            console.log(`  Map: ${mapResult}`);
        });
        
        console.log('性能特点:');
        console.log('- switch: 适合多个离散值的判断，代码清晰');
        console.log('- if/else: 适合复杂条件判断，灵活性高');
        console.log('- 对象映射: 适合简单的键值对应，查找速度快');
    }
};

AdvancedSwitchUsage.expressionCases();
AdvancedSwitchUsage.switchWithFunctions();
AdvancedSwitchUsage.complexObjectHandling();
AdvancedSwitchUsage.performanceComparison();
```

---

## 7.3 循环语句：for、while、do-while

循环语句允许重复执行代码块，是处理数组、对象和重复任务的核心工具。

### for循环

for循环是最常用的循环结构，适合已知循环次数的情况：

```javascript
/**
 * for循环基础与应用
 */
const ForLoopExamples = {
    /**
     * 基本for循环
     */
    basicForLoop() {
        console.log('=== 基本for循环 ===');
        
        // 基础语法
        console.log('数字序列:');
        for (let i = 0; i < 5; i++) {
            console.log(`循环 ${i + 1}: i = ${i}`);
        }
        
        // 数组遍历
        const fruits = ['苹果', '香蕉', '橙子', '葡萄'];
        console.log('水果列表:');
        for (let i = 0; i < fruits.length; i++) {
            console.log(`${i + 1}. ${fruits[i]}`);
        }
        
        // 逆序循环
        console.log('倒数:');
        for (let i = 5; i > 0; i--) {
            console.log(i);
        }
        console.log('发射！🚀');
        
        // 步长控制
        console.log('偶数序列:');
        for (let i = 0; i <= 10; i += 2) {
            console.log(i);
        }
    },
    
    /**
     * 复杂for循环应用
     */
    advancedForLoop() {
        console.log('=== 高级for循环 ===');
        
        // 嵌套循环：九九乘法表
        console.log('九九乘法表:');
        for (let i = 1; i <= 9; i++) {
            let row = '';
            for (let j = 1; j <= i; j++) {
                row += `${j}×${i}=${i * j}\t`;
            }
            console.log(row);
        }
        
        // 二维数组处理
        const matrix = [
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
        ];
        
        console.log('矩阵处理:');
        for (let row = 0; row < matrix.length; row++) {
            for (let col = 0; col < matrix[row].length; col++) {
                process.stdout.write(`${matrix[row][col]} `);
            }
            console.log('');
        }
        
        // 查找和统计
        const numbers = [1, 2, 3, 4, 5, 2, 3, 2];
        let count = 0;
        const target = 2;
        
        for (let i = 0; i < numbers.length; i++) {
            if (numbers[i] === target) {
                count++;
            }
        }
        console.log(`数字${target}出现${count}次`);
    }
};

ForLoopExamples.basicForLoop();
ForLoopExamples.advancedForLoop();
```

### while循环

while循环适用于条件未知何时满足的情况：

```javascript
/**
 * while循环示例
 */
const WhileLoopExamples = {
    /**
     * 基本while循环
     */
    basicWhileLoop() {
        console.log('=== 基本while循环 ===');
        
        // 基础计数
        let i = 0;
        console.log('计数到5:');
        while (i < 5) {
            console.log(`计数: ${i}`);
            i++;
        }
        
        // 条件循环
        let attempts = 0;
        const maxAttempts = 3;
        let success = false;
        
        console.log('模拟重试逻辑:');
        while (attempts < maxAttempts && !success) {
            attempts++;
            success = Math.random() > 0.7; // 30%成功率
            console.log(`尝试${attempts}: ${success ? '成功' : '失败'}`);
        }
        
        if (success) {
            console.log(`经过${attempts}次尝试，操作成功！`);
        } else {
            console.log(`经过${maxAttempts}次尝试，操作失败`);
        }
    },
    
    /**
     * 实际应用场景
     */
    practicalApplications() {
        console.log('=== 实际应用场景 ===');
        
        // 用户输入验证（模拟）
        function validateInput(inputs) {
            let index = 0;
            console.log('输入验证:');
            
            while (index < inputs.length) {
                const input = inputs[index];
                if (input && input.trim().length > 0) {
                    console.log(`输入 "${input}" 有效`);
                    break;
                } else {
                    console.log(`输入 "${input}" 无效，继续检查...`);
                }
                index++;
            }
            
            if (index >= inputs.length) {
                console.log('所有输入都无效');
            }
        }
        
        validateInput(['', '  ', 'valid input', 'another']);
        
        // 数据处理直到条件满足
        function processUntilThreshold() {
            const data = [1, 5, 3, 8, 2, 9, 4, 7, 6];
            let sum = 0;
            let index = 0;
            const threshold = 20;
            
            console.log('累加直到超过阈值:');
            while (sum < threshold && index < data.length) {
                sum += data[index];
                console.log(`加入 ${data[index]}, 当前总和: ${sum}`);
                index++;
            }
            
            if (sum >= threshold) {
                console.log(`达到阈值 ${threshold}，停止处理`);
            } else {
                console.log(`处理完所有数据，总和: ${sum}`);
            }
        }
        
        processUntilThreshold();
    }
};

WhileLoopExamples.basicWhileLoop();
WhileLoopExamples.practicalApplications();
```

### do-while循环

do-while循环至少执行一次代码块，适用于需要先执行后判断的场景：

```javascript
/**
 * do-while循环示例
 */
const DoWhileLoopExamples = {
    /**
     * 基本do-while循环
     */
    basicDoWhileLoop() {
        console.log('=== 基本do-while循环 ===');
        
        // do-while至少执行一次
        let i = 0;
        console.log('do-while计数:');
        do {
            console.log(`执行 ${i + 1}: i = ${i}`);
            i++;
        } while (i < 3);
        
        // 即使条件为false也会执行一次
        console.log('条件为false的情况:');
        let j = 10;
        do {
            console.log(`即使j=${j}大于5，这句话也会执行一次`);
            j++;
        } while (j < 5);
        
        console.log('执行后j的值:', j);
    },
    
    /**
     * 实际应用场景
     */
    practicalApplications() {
        console.log('=== 实际应用场景 ===');
        
        // 用户输入验证
        function getUserInput() {
            const inputs = ['', 'invalid', '', 'valid input'];
            let currentIndex = 0;
            let userInput;
            
            console.log('模拟用户输入验证:');
            do {
                userInput = inputs[currentIndex] || '';
                currentIndex++;
                console.log(`尝试输入: "${userInput}"`);
                
                if (!userInput || userInput.trim().length === 0) {
                    console.log('输入为空，请重新输入');
                } else if (userInput === 'invalid') {
                    console.log('输入无效，请重新输入');
                } else {
                    console.log('输入有效！');
                    break;
                }
            } while (currentIndex < inputs.length);
            
            return userInput;
        }
        
        const result = getUserInput();
        console.log('最终输入:', result);
        
        // 菜单系统
        function showMenu() {
            const choices = ['1', '2', 'invalid', '3', '0'];
            let choiceIndex = 0;
            
            console.log('模拟菜单选择:');
            do {
                const choice = choices[choiceIndex++] || '0';
                console.log(`\n=== 主菜单 ===`);
                console.log('1. 查看信息');
                console.log('2. 修改设置');  
                console.log('3. 帮助');
                console.log('0. 退出');
                console.log(`用户选择: ${choice}`);
                
                switch (choice) {
                    case '1':
                        console.log('显示用户信息...');
                        break;
                    case '2':
                        console.log('修改用户设置...');
                        break;
                    case '3':
                        console.log('显示帮助信息...');
                        break;
                    case '0':
                        console.log('退出程序');
                        return;
                    default:
                        console.log('无效选择，请重新选择');
                }
            } while (choiceIndex < choices.length);
        }
        
        showMenu();
    }
};

DoWhileLoopExamples.basicDoWhileLoop();
DoWhileLoopExamples.practicalApplications();
```

### 循环的性能优化

掌握循环性能优化技巧可以显著提升代码执行效率：

```javascript
/**
 * 循环性能优化
 */
const LoopOptimization = {
    /**
     * 循环变量优化
     */
    variableOptimization() {
        console.log('=== 循环变量优化 ===');
        
        const largeArray = new Array(1000).fill(0).map((_, i) => i);
        
        // ❌ 低效：每次都计算length
        function inefficientLoop() {
            console.log('低效循环开始');
            const start = performance.now();
            
            for (let i = 0; i < largeArray.length; i++) {
                // 模拟一些计算
                largeArray[i] * 2;
            }
            
            const end = performance.now();
            console.log(`低效循环耗时: ${end - start}ms`);
        }
        
        // ✅ 高效：缓存length值
        function efficientLoop() {
            console.log('高效循环开始');
            const start = performance.now();
            
            for (let i = 0, len = largeArray.length; i < len; i++) {
                // 相同的计算
                largeArray[i] * 2;
            }
            
            const end = performance.now();
            console.log(`高效循环耗时: ${end - start}ms`);
        }
        
        // ✅ 更高效：逆序循环（某些情况下）
        function reverseLoop() {
            console.log('逆序循环开始');
            const start = performance.now();
            
            for (let i = largeArray.length - 1; i >= 0; i--) {
                largeArray[i] * 2;
            }
            
            const end = performance.now();
            console.log(`逆序循环耗时: ${end - start}ms`);
        }
        
        inefficientLoop();
        efficientLoop();
        reverseLoop();
    },
    
    /**
     * 循环选择优化
     */
    loopSelection() {
        console.log('=== 循环选择优化 ===');
        
        const testData = new Array(1000).fill(0).map((_, i) => ({ id: i, value: Math.random() * 100 }));
        
        // 不同循环方式的性能对比
        function measurePerformance(name, fn) {
            const start = performance.now();
            fn();
            const end = performance.now();
            console.log(`${name}: ${end - start}ms`);
        }
        
        // for循环
        measurePerformance('传统for循环', () => {
            let sum = 0;
            for (let i = 0; i < testData.length; i++) {
                sum += testData[i].value;
            }
        });
        
        // forEach
        measurePerformance('forEach', () => {
            let sum = 0;
            testData.forEach(item => {
                sum += item.value;
            });
        });
        
        // for...of
        measurePerformance('for...of', () => {
            let sum = 0;
            for (const item of testData) {
                sum += item.value;
            }
        });
        
        // reduce (函数式)
        measurePerformance('reduce', () => {
            const sum = testData.reduce((acc, item) => acc + item.value, 0);
        });
        
        console.log('性能建议:');
        console.log('- 传统for循环通常最快');
        console.log('- for...of可读性好，性能适中');
        console.log('- forEach适合函数式编程风格');
        console.log('- reduce适合数据聚合操作');
    },
    
    /**
     * 避免循环中的昂贵操作
     */
    avoidExpensiveOperations() {
        console.log('=== 避免昂贵操作 ===');
        
        const items = ['item1', 'item2', 'item3', 'item4', 'item5'];
        const container = { items: [], processed: 0 };
        
        // ❌ 低效：循环中创建对象和调用函数
        function inefficientProcessing() {
            console.log('低效处理开始');
            
            for (let i = 0; i < items.length; i++) {
                // 每次循环都创建新的Date对象（昂贵）
                const timestamp = new Date().toISOString();
                
                // 每次循环都调用复杂计算（昂贵）
                const processed = {
                    item: items[i],
                    timestamp: timestamp,
                    hash: items[i].split('').reduce((a, b) => {
                        a = ((a << 5) - a) + b.charCodeAt(0);
                        return a & a;
                    }, 0)
                };
                
                container.items.push(processed);
            }
        }
        
        // ✅ 高效：提取循环外的操作
        function efficientProcessing() {
            console.log('高效处理开始');
            
            // 在循环外创建一次
            const timestamp = new Date().toISOString();
            const results = [];
            
            for (let i = 0, len = items.length; i < len; i++) {
                const item = items[i];
                
                // 简化的处理逻辑
                const processed = {
                    item: item,
                    timestamp: timestamp,
                    index: i
                };
                
                results.push(processed);
            }
            
            container.items = results;
        }
        
        // 性能测试
        const start1 = performance.now();
        inefficientProcessing();
        const end1 = performance.now();
        
        container.items = []; // 重置
        
        const start2 = performance.now();
        efficientProcessing();
        const end2 = performance.now();
        
        console.log(`低效处理耗时: ${end1 - start1}ms`);
        console.log(`高效处理耗时: ${end2 - start2}ms`);
        
        console.log('优化建议:');
        console.log('- 将不变的计算移出循环');
        console.log('- 缓存重复使用的值');
        console.log('- 避免在循环中创建大对象');
        console.log('- 减少函数调用开销');
    }
};

LoopOptimization.variableOptimization();
LoopOptimization.loopSelection();
LoopOptimization.avoidExpensiveOperations();
```

---

## 7.4 for...in、for...of

ES6引入了两种特殊的循环语句，分别用于遍历对象属性和可迭代对象。

### for...in 遍历对象属性

for...in循环用于遍历对象的可枚举属性：

```javascript
/**
 * for...in循环详解
 */
const ForInLoopExamples = {
    /**
     * 基本对象属性遍历
     */
    basicObjectIteration() {
        console.log('=== 基本对象属性遍历 ===');
        
        const person = {
            name: 'Alice',
            age: 30,
            city: 'Beijing',
            job: 'Developer'
        };
        
        console.log('遍历对象属性:');
        for (const key in person) {
            console.log(`${key}: ${person[key]}`);
        }
        
        // 获取所有键和值
        const keys = [];
        const values = [];
        
        for (const key in person) {
            keys.push(key);
            values.push(person[key]);
        }
        
        console.log('所有键:', keys);
        console.log('所有值:', values);
    },
    
    /**
     * 数组遍历（不推荐）
     */
    arrayIteration() {
        console.log('=== 数组遍历（展示问题）===');
        
        const fruits = ['apple', 'banana', 'orange'];
        fruits.customProperty = 'custom value';
        
        console.log('for...in遍历数组:');
        for (const index in fruits) {
            console.log(`${index}: ${fruits[index]}`);
        }
        
        console.log('注意：for...in会遍历自定义属性');
        
        // 对比：传统for循环只遍历数组元素
        console.log('传统for循环:');
        for (let i = 0; i < fruits.length; i++) {
            console.log(`${i}: ${fruits[i]}`);
        }
    },
    
    /**
     * 继承属性处理
     */
    inheritanceHandling() {
        console.log('=== 继承属性处理 ===');
        
        // 创建原型对象
        const Animal = {
            species: 'Animal',
            breathe: function() { return 'breathing'; }
        };
        
        // 创建继承对象
        const dog = Object.create(Animal);
        dog.name = 'Buddy';
        dog.breed = 'Golden Retriever';
        dog.age = 3;
        
        console.log('包含继承属性的遍历:');
        for (const key in dog) {
            console.log(`${key}: ${dog[key]}`);
        }
        
        console.log('只遍历自有属性:');
        for (const key in dog) {
            if (dog.hasOwnProperty(key)) {
                console.log(`${key}: ${dog[key]}`);
            }
        }
        
        // 现代写法
        console.log('现代写法（Object.hasOwn）:');
        for (const key in dog) {
            if (Object.hasOwn(dog, key)) {
                console.log(`${key}: ${dog[key]}`);
            }
        }
    },
    
    /**
     * 实际应用场景
     */
    practicalApplications() {
        console.log('=== 实际应用场景 ===');
        
        // 对象数据转换
        const userData = {
            firstName: 'John',
            lastName: 'Doe', 
            email: 'john@example.com',
            age: 28,
            isActive: true
        };
        
        // 生成表单字段
        function generateFormFields(data) {
            const fields = [];
            
            for (const key in data) {
                if (Object.hasOwn(data, key)) {
                    fields.push({
                        name: key,
                        label: key.charAt(0).toUpperCase() + key.slice(1),
                        value: data[key],
                        type: typeof data[key]
                    });
                }
            }
            
            return fields;
        }
        
        const formFields = generateFormFields(userData);
        console.log('表单字段生成:');
        formFields.forEach(field => {
            console.log(`${field.label}: ${field.value} (${field.type})`);
        });
        
        // 对象属性验证
        function validateObject(obj, requiredFields) {
            const missingFields = [];
            
            for (const field of requiredFields) {
                if (!(field in obj) || obj[field] === null || obj[field] === undefined) {
                    missingFields.push(field);
                }
            }
            
            return {
                isValid: missingFields.length === 0,
                missingFields: missingFields
            };
        }
        
        const validation = validateObject(userData, ['firstName', 'lastName', 'email', 'phone']);
        console.log('验证结果:', validation);
    }
};

ForInLoopExamples.basicObjectIteration();
ForInLoopExamples.arrayIteration();
ForInLoopExamples.inheritanceHandling();
ForInLoopExamples.practicalApplications();
```

### for...of 遍历可迭代对象

for...of循环用于遍历可迭代对象（如数组、字符串、Map、Set等）的值：

```javascript
/**
 * for...of循环详解
 */
const ForOfLoopExamples = {
    /**
     * 基本可迭代对象遍历
     */
    basicIteration() {
        console.log('=== 基本可迭代对象遍历 ===');
        
        // 数组遍历
        const fruits = ['apple', 'banana', 'orange'];
        console.log('数组遍历:');
        for (const fruit of fruits) {
            console.log(fruit);
        }
        
        // 字符串遍历
        const text = 'Hello';
        console.log('字符串遍历:');
        for (const char of text) {
            console.log(char);
        }
        
        // Set遍历
        const uniqueNumbers = new Set([1, 2, 3, 2, 4, 1]);
        console.log('Set遍历:');
        for (const number of uniqueNumbers) {
            console.log(number);
        }
        
        // Map遍历
        const userRoles = new Map([
            ['alice', 'admin'],
            ['bob', 'user'],
            ['charlie', 'moderator']
        ]);
        
        console.log('Map遍历（键值对）:');
        for (const [username, role] of userRoles) {
            console.log(`${username}: ${role}`);
        }
        
        console.log('Map键遍历:');
        for (const key of userRoles.keys()) {
            console.log(key);
        }
        
        console.log('Map值遍历:');
        for (const value of userRoles.values()) {
            console.log(value);
        }
    },
    
    /**
     * 数组索引和值同时获取
     */
    arrayWithIndex() {
        console.log('=== 数组索引和值 ===');
        
        const colors = ['red', 'green', 'blue'];
        
        // 使用entries()获取索引和值
        console.log('使用entries():');
        for (const [index, color] of colors.entries()) {
            console.log(`${index}: ${color}`);
        }
        
        // 对比传统方式
        console.log('传统for循环:');
        for (let i = 0; i < colors.length; i++) {
            console.log(`${i}: ${colors[i]}`);
        }
        
        // 对比forEach
        console.log('forEach方式:');
        colors.forEach((color, index) => {
            console.log(`${index}: ${color}`);
        });
    },
    
    /**
     * 异步迭代处理
     */
    asyncIteration() {
        console.log('=== 异步迭代处理 ===');
        
        /**
         * 模拟异步处理函数
         * @param {*} item - 要处理的项目
         * @returns {Promise} 处理结果
         */
        function processItemAsync(item) {
            return new Promise(resolve => {
                setTimeout(() => {
                    const result = `processed: ${item}`;
                    console.log(result);
                    resolve(result);
                }, Math.random() * 100);
            });
        }
        
        const items = ['item1', 'item2', 'item3'];
        
        // 串行处理（等待每个完成）
        async function processSerially() {
            console.log('串行处理开始:');
            const results = [];
            
            for (const item of items) {
                const result = await processItemAsync(item);
                results.push(result);
            }
            
            console.log('串行处理完成:', results);
        }
        
        // 并行处理（同时开始所有）
        async function processInParallel() {
            console.log('并行处理开始:');
            const promises = [];
            
            for (const item of items) {
                promises.push(processItemAsync(item));
            }
            
            const results = await Promise.all(promises);
            console.log('并行处理完成:', results);
        }
        
        // 注意：这里只是展示语法，实际执行需要在async环境中
        console.log('异步处理示例（需要在async函数中执行）');
        // processSerially();
        // processInParallel();
    },
    
    /**
     * 自定义可迭代对象
     */
    customIterable() {
        console.log('=== 自定义可迭代对象 ===');
        
        // 创建一个数字范围生成器
        function createRange(start, end, step = 1) {
            return {
                [Symbol.iterator]() {
                    let current = start;
                    return {
                        next() {
                            if (current < end) {
                                const value = current;
                                current += step;
                                return { value: value, done: false };
                            } else {
                                return { done: true };
                            }
                        }
                    };
                }
            };
        }
        
        const range = createRange(1, 6, 2);
        console.log('自定义范围遍历:');
        for (const number of range) {
            console.log(number); // 1, 3, 5
        }
        
        // 创建斐波那契数列生成器
        function createFibonacci(limit) {
            return {
                [Symbol.iterator]() {
                    let prev = 0;
                    let curr = 1;
                    let count = 0;
                    
                    return {
                        next() {
                            if (count < limit) {
                                const value = count === 0 ? prev : curr;
                                [prev, curr] = [curr, prev + curr];
                                count++;
                                return { value: value, done: false };
                            }
                            return { done: true };
                        }
                    };
                }
            };
        }
        
        const fibonacci = createFibonacci(8);
        console.log('斐波那契数列:');
        const fibArray = [];
        for (const number of fibonacci) {
            fibArray.push(number);
        }
        console.log(fibArray); // [0, 1, 1, 2, 3, 5, 8, 13]
    }
};

ForOfLoopExamples.basicIteration();
ForOfLoopExamples.arrayWithIndex();
ForOfLoopExamples.asyncIteration();
ForOfLoopExamples.customIterable();
```

### 两种循环的差异与选择

理解for...in和for...of的区别，有助于在不同场景中选择合适的遍历方式：

```javascript
/**
 * for...in vs for...of 选择指南
 */
const LoopComparisonGuide = {
    /**
     * 基本差异对比
     */
    basicDifferences() {
        console.log('=== 基本差异对比 ===');
        
        const data = ['a', 'b', 'c'];
        data.customProp = 'custom';
        
        console.log('for...in (遍历键/索引):');
        for (const key in data) {
            console.log(`${key}: ${data[key]}`);
        }
        
        console.log('for...of (遍历值):');
        for (const value of data) {
            console.log(value);
        }
        
        // 对象遍历
        const obj = { name: 'Alice', age: 30 };
        
        console.log('对象for...in:');
        for (const key in obj) {
            console.log(`${key}: ${obj[key]}`);
        }
        
        console.log('对象转换后用for...of:');
        for (const [key, value] of Object.entries(obj)) {
            console.log(`${key}: ${value}`);
        }
    },
    
    /**
     * 选择建议
     */
    selectionGuidelines() {
        console.log('=== 选择建议 ===');
        
        console.log('使用for...in的场景:');
        console.log('- 遍历对象属性');
        console.log('- 需要获取数组索引且要包含自定义属性');
        console.log('- 动态属性检查');
        
        console.log('使用for...of的场景:');
        console.log('- 遍历数组、字符串、Set、Map等可迭代对象');
        console.log('- 关注值而不是索引/键');
        console.log('- 异步迭代处理');
        console.log('- 使用迭代器协议的场景');
        
        console.log('性能对比:');
        console.log('- for...of通常性能更好（针对数组）');
        console.log('- for...in适合稀疏数组');
        console.log('- 传统for循环在大数据量时最快');
    }
};

LoopComparisonGuide.basicDifferences();
LoopComparisonGuide.selectionGuidelines();
```

---

## 7.5 break 与 continue

break和continue语句用于控制循环的执行流程，提供了更精细的循环控制能力。

### break语句

break语句用于立即退出当前循环：

```javascript
/**
 * break语句详解
 */
const BreakStatements = {
    /**
     * 基本break用法
     */
    basicBreak() {
        console.log('=== 基本break用法 ===');
        
        // 在for循环中使用break
        console.log('查找目标数字:');
        const numbers = [1, 3, 5, 7, 9, 11, 13];
        const target = 7;
        
        for (let i = 0; i < numbers.length; i++) {
            console.log(`检查: ${numbers[i]}`);
            if (numbers[i] === target) {
                console.log(`找到目标: ${target}`);
                break; // 立即退出循环
            }
        }
        
        // 在while循环中使用break
        console.log('用户输入模拟:');
        const inputs = ['hello', 'world', 'exit', 'never reached'];
        let index = 0;
        
        while (index < inputs.length) {
            const input = inputs[index];
            console.log(`处理输入: ${input}`);
            
            if (input === 'exit') {
                console.log('接收到退出信号');
                break;
            }
            
            index++;
        }
        
        console.log('循环已结束');
    },
    
    /**
     * 嵌套循环中的break
     */
    nestedLoopBreak() {
        console.log('=== 嵌套循环中的break ===');
        
        console.log('矩阵中查找目标值:');
        const matrix = [
            [1, 2, 3, 4],
            [5, 6, 7, 8],
            [9, 10, 11, 12]
        ];
        const searchTarget = 7;
        let found = false;
        
        // break只退出当前层循环
        for (let row = 0; row < matrix.length; row++) {
            console.log(`搜索第${row + 1}行`);
            for (let col = 0; col < matrix[row].length; col++) {
                const value = matrix[row][col];
                console.log(`  检查位置[${row}][${col}]: ${value}`);
                
                if (value === searchTarget) {
                    console.log(`  找到目标值 ${searchTarget}!`);
                    found = true;
                    break; // 只退出内层循环
                }
            }
            
            if (found) {
                console.log('退出外层循环');
                break; // 退出外层循环
            }
        }
    }
};

BreakStatements.basicBreak();
BreakStatements.nestedLoopBreak();
```

### continue语句

continue语句用于跳过当前迭代，继续执行下一次迭代：

```javascript
/**
 * continue语句详解
 */
const ContinueStatements = {
    /**
     * 基本continue用法
     */
    basicContinue() {
        console.log('=== 基本continue用法 ===');
        
        // 跳过偶数，只处理奇数
        console.log('处理奇数:');
        for (let i = 1; i <= 10; i++) {
            if (i % 2 === 0) {
                continue; // 跳过偶数
            }
            console.log(`处理奇数: ${i}`);
        }
        
        // 数组过滤处理
        const data = [1, null, 3, undefined, 5, '', 7, 0, 9];
        console.log('处理有效数据:');
        
        for (let i = 0; i < data.length; i++) {
            const item = data[i];
            
            // 跳过无效数据
            if (item === null || item === undefined || item === '') {
                console.log(`跳过无效数据: ${item}`);
                continue;
            }
            
            console.log(`处理数据: ${item}`);
        }
    },
    
    /**
     * 条件性跳过
     */
    conditionalSkip() {
        console.log('=== 条件性跳过 ===');
        
        const users = [
            { name: 'Alice', active: true, role: 'admin' },
            { name: 'Bob', active: false, role: 'user' },
            { name: 'Charlie', active: true, role: 'user' }
        ];
        
        console.log('处理活跃用户:');
        for (const user of users) {
            // 跳过非活跃用户
            if (!user.active) {
                console.log(`跳过非活跃用户: ${user.name}`);
                continue;
            }
            
            console.log(`处理用户: ${user.name} (${user.role})`);
        }
    }
};

ContinueStatements.basicContinue();
ContinueStatements.conditionalSkip();
```

### 标签语句与多层循环控制

标签语句允许在多层嵌套循环中精确控制break和continue的作用范围：

```javascript
/**
 * 标签语句与多层循环控制
 */
const LabeledStatements = {
    /**
     * 基本标签语法
     */
    basicLabels() {
        console.log('=== 基本标签语法 ===');
        
        // 使用标签控制外层循环
        outer: for (let i = 1; i <= 3; i++) {
            console.log(`外层循环: ${i}`);
            
            for (let j = 1; j <= 3; j++) {
                console.log(`  内层循环: ${j}`);
                
                if (i === 2 && j === 2) {
                    console.log('  触发break outer');
                    break outer; // 跳出外层循环
                }
            }
            
            console.log(`外层循环 ${i} 完成`);
        }
        
        console.log('所有循环结束');
    },
    
    /**
     * 标签continue的使用
     */
    labeledContinue() {
        console.log('=== 标签continue ===');
        
        // 跳过外层循环的当前迭代
        outer: for (let i = 1; i <= 3; i++) {
            console.log(`开始外层循环: ${i}`);
            
            for (let j = 1; j <= 3; j++) {
                console.log(`  内层循环: ${j}`);
                
                if (i === 2 && j === 1) {
                    console.log('  触发continue outer');
                    continue outer; // 跳过外层循环的剩余部分
                }
            }
            
            console.log(`外层循环 ${i} 正常完成`);
        }
    }
};

LabeledStatements.basicLabels();
LabeledStatements.labeledContinue();
```

---

## 7.6 常见流程控制场景

流程控制在实际开发中有许多典型的应用模式，掌握这些场景能够写出更高效、更可维护的代码。

### 数据处理流程

数据处理是最常见的流程控制应用场景：

```javascript
/**
 * 数据处理流程控制
 */
const DataProcessingFlows = {
    /**
     * 批量数据验证
     */
    batchValidation() {
        console.log('=== 批量数据验证 ===');
        
        const userDataList = [
            { name: 'Alice', email: 'alice@example.com', age: 25 },
            { name: '', email: 'invalid-email', age: -5 },
            { name: 'Bob', email: 'bob@example.com', age: 30 },
            { name: 'Charlie', email: 'charlie@test.com', age: 'invalid' }
        ];
        
        const validatedData = [];
        const errors = [];
        
        for (let i = 0; i < userDataList.length; i++) {
            const user = userDataList[i];
            const userErrors = [];
            
            // 姓名验证
            if (!user.name || user.name.trim() === '') {
                userErrors.push('姓名不能为空');
            }
            
            // 邮箱验证
            if (!user.email || !user.email.includes('@')) {
                userErrors.push('邮箱格式不正确');
            }
            
            // 年龄验证
            if (typeof user.age !== 'number' || user.age < 0 || user.age > 150) {
                userErrors.push('年龄必须是0-150之间的数字');
            }
            
            if (userErrors.length === 0) {
                validatedData.push(user);
                console.log(`用户 ${i + 1} 验证通过`);
            } else {
                errors.push({ index: i + 1, errors: userErrors });
                console.log(`用户 ${i + 1} 验证失败:`, userErrors);
            }
        }
        
        console.log(`处理完成: ${validatedData.length}个有效用户, ${errors.length}个错误`);
        return { validatedData, errors };
    },
    
    /**
     * 数据转换管道
     */
    dataTransformationPipeline() {
        console.log('=== 数据转换管道 ===');
        
        const rawData = [
            'john doe, 25, developer',
            'jane smith, 30, designer', 
            'invalid data line',
            'bob wilson, 28, manager'
        ];
        
        const processedData = [];
        
        for (const line of rawData) {
            try {
                // 跳过空行
                if (!line.trim()) {
                    continue;
                }
                
                // 数据解析
                const parts = line.split(',').map(part => part.trim());
                
                if (parts.length !== 3) {
                    console.log(`跳过无效格式: ${line}`);
                    continue;
                }
                
                const [name, ageStr, role] = parts;
                const age = parseInt(ageStr);
                
                // 数据验证
                if (isNaN(age) || age < 0) {
                    console.log(`跳过无效年龄: ${line}`);
                    continue;
                }
                
                // 数据标准化
                const processedUser = {
                    name: name.toLowerCase().replace(/\b\w/g, l => l.toUpperCase()),
                    age: age,
                    role: role.toLowerCase(),
                    processedAt: new Date().toISOString()
                };
                
                processedData.push(processedUser);
                console.log(`处理成功:`, processedUser);
                
            } catch (error) {
                console.log(`处理错误: ${line} - ${error.message}`);
                continue;
            }
        }
        
        console.log(`管道处理完成，输出${processedData.length}条记录`);
        return processedData;
    }
};

DataProcessingFlows.batchValidation();
DataProcessingFlows.dataTransformationPipeline();
```

### 用户交互逻辑

用户交互场景需要复杂的条件判断和状态管理：

```javascript
/**
 * 用户交互逻辑控制
 */
const UserInteractionFlows = {
    /**
     * 菜单导航系统
     */
    menuNavigationSystem() {
        console.log('=== 菜单导航系统 ===');
        
        const menuItems = [
            { id: 'home', label: '首页', available: true },
            { id: 'profile', label: '个人资料', available: true },
            { id: 'settings', label: '设置', available: true },
            { id: 'admin', label: '管理面板', available: false },
            { id: 'help', label: '帮助', available: true }
        ];
        
        const userRole = 'user'; // 模拟用户角色
        const userSelections = ['home', 'admin', 'profile', 'settings', 'invalid', 'help'];
        
        for (const selection of userSelections) {
            console.log(`\n用户选择: ${selection}`);
            
            // 查找菜单项
            const menuItem = menuItems.find(item => item.id === selection);
            
            if (!menuItem) {
                console.log('❌ 无效的菜单选择');
                continue;
            }
            
            // 检查可用性
            if (!menuItem.available) {
                console.log('❌ 该功能当前不可用');
                continue;
            }
            
            // 权限检查
            if (menuItem.id === 'admin' && userRole !== 'admin') {
                console.log('❌ 权限不足，无法访问管理面板');
                continue;
            }
            
            // 执行导航
            console.log(`✓ 导航到: ${menuItem.label}`);
            
            // 特殊处理
            switch (menuItem.id) {
                case 'settings':
                    console.log('  载入用户设置...');
                    break;
                case 'profile':
                    console.log('  载入个人资料...');
                    break;
                default:
                    console.log(`  载入${menuItem.label}页面...`);
            }
        }
    },
    
    /**
     * 表单验证流程
     */
    formValidationFlow() {
        console.log('=== 表单验证流程 ===');
        
        const formData = {
            username: 'john_doe',
            password: 'weak',
            email: 'john@example.com',
            age: 25,
            terms: false
        };
        
        const validationRules = {
            username: {
                required: true,
                minLength: 3,
                pattern: /^[a-zA-Z0-9_]+$/
            },
            password: {
                required: true,
                minLength: 8,
                requireSpecialChar: true
            },
            email: {
                required: true,
                pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
            },
            age: {
                required: true,
                min: 18,
                max: 100
            },
            terms: {
                required: true,
                mustBeTrue: true
            }
        };
        
        const errors = {};
        let isValid = true;
        
        // 遍历所有字段进行验证
        for (const [fieldName, rules] of Object.entries(validationRules)) {
            const value = formData[fieldName];
            const fieldErrors = [];
            
            console.log(`验证字段: ${fieldName}`);
            
            // 必填验证
            if (rules.required && (value === null || value === undefined || value === '')) {
                fieldErrors.push('该字段为必填项');
            }
            
            // 如果字段为空且不是必填，跳过其他验证
            if (!rules.required && (value === null || value === undefined || value === '')) {
                continue;
            }
            
            // 最小长度验证
            if (rules.minLength && typeof value === 'string' && value.length < rules.minLength) {
                fieldErrors.push(`长度不能少于${rules.minLength}个字符`);
            }
            
            // 数值范围验证
            if (rules.min !== undefined && typeof value === 'number' && value < rules.min) {
                fieldErrors.push(`值不能小于${rules.min}`);
            }
            
            if (rules.max !== undefined && typeof value === 'number' && value > rules.max) {
                fieldErrors.push(`值不能大于${rules.max}`);
            }
            
            // 正则表达式验证
            if (rules.pattern && typeof value === 'string' && !rules.pattern.test(value)) {
                fieldErrors.push('格式不正确');
            }
            
            // 特殊验证
            if (rules.requireSpecialChar && typeof value === 'string') {
                if (!/[!@#$%^&*(),.?":{}|<>]/.test(value)) {
                    fieldErrors.push('必须包含特殊字符');
                }
            }
            
            if (rules.mustBeTrue && value !== true) {
                fieldErrors.push('必须同意条款');
            }
            
            // 记录错误
            if (fieldErrors.length > 0) {
                errors[fieldName] = fieldErrors;
                isValid = false;
                console.log(`  ❌ ${fieldErrors.join(', ')}`);
            } else {
                console.log(`  ✓ 验证通过`);
            }
        }
        
        console.log(`表单验证${isValid ? '成功' : '失败'}`);
        if (!isValid) {
            console.log('错误详情:', errors);
        }
        
        return { isValid, errors };
    }
};

UserInteractionFlows.menuNavigationSystem();
UserInteractionFlows.formValidationFlow();
```

### 错误处理与异常流程

健壮的错误处理是高质量代码的重要特征：

```javascript
/**
 * 错误处理与异常流程
 */
const ErrorHandlingFlows = {
    /**
     * 多重错误处理策略
     */
    multiLevelErrorHandling() {
        console.log('=== 多重错误处理 ===');
        
        /**
         * 模拟API调用
         * @param {string} endpoint - API端点
         * @returns {Promise} API响应
         */
        async function simulateApiCall(endpoint) {
            const responses = {
                '/users': { success: true, data: [{ id: 1, name: 'Alice' }] },
                '/error': { success: false, error: 'Server Error' },
                '/timeout': 'TIMEOUT',
                '/network': 'NETWORK_ERROR'
            };
            
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    const response = responses[endpoint];
                    if (response === 'TIMEOUT') {
                        reject(new Error('Request timeout'));
                    } else if (response === 'NETWORK_ERROR') {
                        reject(new Error('Network connection failed'));
                    } else {
                        resolve(response);
                    }
                }, Math.random() * 100);
            });
        }
        
        /**
         * 带重试机制的API调用
         * @param {string} endpoint - API端点
         * @param {number} maxRetries - 最大重试次数
         */
        async function apiCallWithRetry(endpoint, maxRetries = 3) {
            let lastError;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    console.log(`尝试${attempt}: 调用 ${endpoint}`);
                    
                    const response = await simulateApiCall(endpoint);
                    
                    if (response.success) {
                        console.log(`✓ 成功获取数据:`, response.data);
                        return response;
                    } else {
                        throw new Error(response.error);
                    }
                    
                } catch (error) {
                    lastError = error;
                    console.log(`❌ 尝试${attempt}失败: ${error.message}`);
                    
                    // 根据错误类型决定是否重试
                    if (error.message.includes('timeout')) {
                        console.log('  超时错误，将重试...');
                        continue;
                    } else if (error.message.includes('Network')) {
                        console.log('  网络错误，等待后重试...');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        continue;
                    } else {
                        console.log('  服务器错误，停止重试');
                        break;
                    }
                }
            }
            
            console.log(`所有重试失败，最终错误: ${lastError.message}`);
            throw lastError;
        }
        
        // 测试不同的错误场景
        const testEndpoints = ['/users', '/error', '/timeout', '/network'];
        
        for (const endpoint of testEndpoints) {
            try {
                console.log(`\n开始处理: ${endpoint}`);
                await apiCallWithRetry(endpoint, 2);
            } catch (error) {
                console.log(`最终处理失败: ${error.message}`);
            }
        }
    },
    
    /**
     * 资源清理流程
     */
    resourceCleanupFlow() {
        console.log('=== 资源清理流程 ===');
        
        /**
         * 模拟资源管理类
         */
        class ResourceManager {
            constructor() {
                this.resources = new Map();
                this.isProcessing = false;
            }
            
            /**
             * 获取资源
             * @param {string} resourceId - 资源ID
             */
            acquireResource(resourceId) {
                console.log(`获取资源: ${resourceId}`);
                this.resources.set(resourceId, {
                    id: resourceId,
                    acquired: Date.now(),
                    inUse: true
                });
            }
            
            /**
             * 释放资源
             * @param {string} resourceId - 资源ID
             */
            releaseResource(resourceId) {
                if (this.resources.has(resourceId)) {
                    console.log(`释放资源: ${resourceId}`);
                    this.resources.delete(resourceId);
                }
            }
            
            /**
             * 清理所有资源
             */
            cleanup() {
                console.log('执行资源清理...');
                for (const [resourceId] of this.resources) {
                    this.releaseResource(resourceId);
                }
            }
            
            /**
             * 复杂的数据处理流程
             * @param {Array} data - 处理数据
             */
            async processData(data) {
                this.isProcessing = true;
                const processedItems = [];
                
                try {
                    // 获取必要资源
                    this.acquireResource('database');
                    this.acquireResource('cache');
                    this.acquireResource('logger');
                    
                    for (let i = 0; i < data.length; i++) {
                        try {
                            const item = data[i];
                            console.log(`处理项目 ${i + 1}/${data.length}: ${item}`);
                            
                            // 模拟处理可能失败
                            if (item === 'error') {
                                throw new Error(`处理项目 ${item} 时发生错误`);
                            }
                            
                            // 模拟异步处理
                            await new Promise(resolve => setTimeout(resolve, 50));
                            
                            processedItems.push(`processed_${item}`);
                            
                        } catch (itemError) {
                            console.log(`项目处理失败: ${itemError.message}`);
                            
                            // 决定是继续还是中断
                            if (item === 'critical_error') {
                                throw new Error('遇到关键错误，停止处理');
                            }
                            
                            // 非关键错误，继续处理下一项
                            console.log('跳过错误项目，继续处理...');
                            continue;
                        }
                    }
                    
                    console.log(`处理完成，成功处理${processedItems.length}个项目`);
                    return processedItems;
                    
                } catch (criticalError) {
                    console.log(`关键错误: ${criticalError.message}`);
                    throw criticalError;
                    
                } finally {
                    // 无论成功还是失败都要清理资源
                    console.log('执行清理操作...');
                    this.cleanup();
                    this.isProcessing = false;
                    console.log('清理完成');
                }
            }
        }
        
        // 测试资源管理
        const manager = new ResourceManager();
        
        const testCases = [
            ['item1', 'item2', 'item3'],
            ['item1', 'error', 'item3'],
            ['item1', 'critical_error', 'item3']
        ];
        
        for (let i = 0; i < testCases.length; i++) {
            try {
                console.log(`\n=== 测试案例 ${i + 1} ===`);
                const result = await manager.processData(testCases[i]);
                console.log('处理结果:', result);
            } catch (error) {
                console.log('处理失败:', error.message);
            }
        }
    }
};

// 注意：这里只展示代码结构，实际异步执行需要在适当环境中运行
console.log('错误处理示例代码已准备就绪');
ErrorHandlingFlows.multiLevelErrorHandling();
ErrorHandlingFlows.resourceCleanupFlow();
```

---

**本章总结**

第7章全面探讨了JavaScript的流程控制机制：

1. **条件语句(if/else)**: 掌握了基本条件判断、嵌套优化、早期返回模式和重构技巧
2. **多分支(switch)**: 学会了switch语句的各种用法、fall-through特性和与if/else的性能对比
3. **循环语句**: 深入理解了for、while、do-while的特点和性能优化策略
4. **现代循环**: 掌握了for...in和for...of的差异、适用场景和迭代器协议
5. **循环控制**: 学会了break、continue和标签语句的精确控制技巧
6. **实际应用**: 探讨了数据处理、用户交互和错误处理等常见流程控制场景

流程控制是编程的基础，正确运用这些控制结构能让代码逻辑更清晰、执行更高效、维护更容易。

**下一章预告**

第8章将深入探讨JavaScript的函数基础，包括函数声明方式、箭头函数、参数处理、返回值机制和闭包概念，为深入理解JavaScript的函数式编程特性打下坚实基础。
