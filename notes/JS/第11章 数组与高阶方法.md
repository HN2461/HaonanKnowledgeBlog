# 第11章　数组与高阶方法

数组是JavaScript中最重要的数据结构之一，也是函数式编程的核心载体。本章将深入探讨数组的本质、常用方法、迭代器模式，以及map、filter、reduce等高阶方法的实际应用。

## 11.1 数组的本质

理解数组的内部结构和特性是掌握数组操作的基础。

### 数组的内部结构

JavaScript数组是一种特殊的对象：

```javascript
/**
 * 数组本质示例
 */
const ArrayEssenceExamples = {
    /**
     * 数组作为特殊对象
     */
    arrayAsObject() {
        console.log('=== 数组的对象本质 ===');
        
        const arr = [1, 2, 3];
        
        // 数组本质上是对象
        console.log('typeof arr:', typeof arr); // 'object'
        console.log('Array.isArray(arr):', Array.isArray(arr)); // true
        console.log('arr instanceof Array:', arr instanceof Array); // true
        console.log('arr instanceof Object:', arr instanceof Object); // true
        
        // 数组的属性
        console.log('数组长度:', arr.length);
        console.log('数组构造函数:', arr.constructor.name);
        
        // 数组索引实际上是属性名
        console.log('arr[0] === arr["0"]:', arr[0] === arr["0"]); // true
        
        // 数组可以有非数字属性
        arr.customProp = 'custom value';
        arr['string-key'] = 'string value';
        
        console.log('数组的所有属性:', Object.keys(arr));
        console.log('数组的自有属性:', Object.getOwnPropertyNames(arr));
        
        // length属性的特殊性
        console.log('length是否可枚举:', Object.propertyIsEnumerable.call(arr, 'length')); // false
        
        const lengthDescriptor = Object.getOwnPropertyDescriptor(arr, 'length');
        console.log('length属性描述符:', lengthDescriptor);
    },
    
    /**
     * 数组长度的动态性
     */
    dynamicLength() {
        console.log('=== 数组长度的动态性 ===');
        
        const arr = [1, 2, 3];
        console.log('初始数组:', arr, 'length:', arr.length);
        
        // 通过索引扩展数组
        arr[10] = 'ten';
        console.log('设置arr[10]后:', arr, 'length:', arr.length);
        console.log('中间的空位:', arr[5]); // undefined
        
        // 直接修改length
        arr.length = 3;
        console.log('设置length=3后:', arr);
        
        arr.length = 5;
        console.log('设置length=5后:', arr);
        
        // length与最大索引的关系
        const sparse = [];
        sparse[100] = 'value';
        console.log('稀疏数组:', sparse.length); // 101
        
        // 负数和小数索引
        const mixed = [1, 2, 3];
        mixed[-1] = 'negative';
        mixed[1.5] = 'decimal';
        mixed['2'] = 'string index';
        
        console.log('混合索引数组:', mixed);
        console.log('length不受影响:', mixed.length); // 3
        console.log('负数索引:', mixed[-1]);
        console.log('小数索引:', mixed[1.5]);
    },
    
    /**
     * 类数组对象
     */
    arrayLikeObjects() {
        console.log('=== 类数组对象 ===');
        
        // 手动创建类数组对象
        const arrayLike = {
            0: 'first',
            1: 'second',
            2: 'third',
            length: 3
        };
        
        console.log('类数组对象:', arrayLike);
        console.log('是否为数组:', Array.isArray(arrayLike)); // false
        
        // 转换为真正的数组
        const realArray1 = Array.from(arrayLike);
        const realArray2 = [...arrayLike]; // 需要实现Iterator接口
        const realArray3 = Array.prototype.slice.call(arrayLike);
        
        console.log('Array.from转换:', realArray1);
        console.log('slice.call转换:', realArray3);
        
        // arguments对象（类数组）
        function testArguments() {
            console.log('arguments对象:', arguments);
            console.log('arguments类型:', typeof arguments);
            console.log('是否为数组:', Array.isArray(arguments));
            
            // 转换arguments为数组
            const argsArray = Array.from(arguments);
            console.log('转换后的数组:', argsArray);
            
            // 使用数组方法
            const doubled = argsArray.map(x => x * 2);
            console.log('数组方法结果:', doubled);
        }
        
        testArguments(1, 2, 3, 4);
        
        // NodeList也是类数组
        if (typeof document !== 'undefined') {
            const nodeList = document.querySelectorAll('div');
            console.log('NodeList类型:', nodeList.constructor.name);
            console.log('NodeList是否为数组:', Array.isArray(nodeList));
        }
    }
};

ArrayEssenceExamples.arrayAsObject();
ArrayEssenceExamples.dynamicLength();
ArrayEssenceExamples.arrayLikeObjects();
```

### 数组创建方式

掌握各种数组创建方法：

```javascript
/**
 * 数组创建方式示例
 */
const ArrayCreationExamples = {
    /**
     * 各种创建方式
     */
    creationMethods() {
        console.log('=== 数组创建方式 ===');
        
        // 1. 字面量方式（最常用）
        const literal = [1, 2, 3, 'four', true];
        console.log('字面量创建:', literal);
        
        // 2. Array构造函数
        const constructor1 = new Array(1, 2, 3);
        const constructor2 = Array(1, 2, 3); // 可省略new
        console.log('构造函数创建:', constructor1, constructor2);
        
        // 注意：单个数字参数的特殊性
        const special1 = new Array(5); // 创建长度为5的空数组
        const special2 = new Array('5'); // 创建包含字符串'5'的数组
        console.log('特殊构造:', special1, special2);
        console.log('空数组长度:', special1.length);
        
        // 3. Array.of() - 解决构造函数的问题
        const arrayOf1 = Array.of(5);
        const arrayOf2 = Array.of(1, 2, 3);
        console.log('Array.of创建:', arrayOf1, arrayOf2);
        
        // 4. Array.from() - 从可迭代对象创建
        const fromString = Array.from('hello');
        const fromSet = Array.from(new Set([1, 2, 2, 3]));
        const fromMap = Array.from(new Map([['a', 1], ['b', 2]]));
        
        console.log('从字符串创建:', fromString);
        console.log('从Set创建:', fromSet);
        console.log('从Map创建:', fromMap);
        
        // Array.from带映射函数
        const squares = Array.from({length: 5}, (_, i) => i * i);
        const doubled = Array.from([1, 2, 3], x => x * 2);
        
        console.log('带映射的创建:', squares, doubled);
        
        // 5. 扩展语法
        const spread1 = [...'hello'];
        const spread2 = [...new Set([1, 2, 3])];
        const combined = [...[1, 2], ...[3, 4]];
        
        console.log('扩展语法:', spread1, spread2, combined);
    },
    
    /**
     * 多维数组创建
     */
    multiDimensionalArrays() {
        console.log('=== 多维数组创建 ===');
        
        // 二维数组
        const matrix2D = [
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
        ];
        
        console.log('二维数组:', matrix2D);
        console.log('访问元素:', matrix2D[1][2]); // 6
        
        // 动态创建二维数组
        function create2DArray(rows, cols, defaultValue = 0) {
            return Array.from({length: rows}, () => 
                Array.from({length: cols}, () => defaultValue)
            );
        }
        
        const dynamic2D = create2DArray(3, 4, null);
        console.log('动态二维数组:', dynamic2D);
        
        // ❌ 错误的创建方式
        const wrong = new Array(3).fill(new Array(3).fill(0));
        wrong[0][0] = 1; // 会影响所有行！
        console.log('错误创建的问题:', wrong);
        
        // ✅ 正确的创建方式
        const correct = Array.from({length: 3}, () => Array(3).fill(0));
        correct[0][0] = 1;
        console.log('正确创建:', correct);
        
        // 三维数组
        const matrix3D = Array.from({length: 2}, () =>
            Array.from({length: 3}, () =>
                Array.from({length: 4}, () => Math.random())
            )
        );
        
        console.log('三维数组维度:', matrix3D.length, 'x', matrix3D[0].length, 'x', matrix3D[0][0].length);
    },
    
    /**
     * 稀疏数组
     */
    sparseArrays() {
        console.log('=== 稀疏数组 ===');
        
        // 创建稀疏数组的方式
        const sparse1 = [1, , , 4]; // 字面量中的空位
        const sparse2 = new Array(5); // 构造函数创建的空位
        const sparse3 = [1, 2, 3];
        delete sparse3[1]; // 删除元素创造空位
        
        console.log('稀疏数组1:', sparse1);
        console.log('稀疏数组2:', sparse2);
        console.log('稀疏数组3:', sparse3);
        
        // 检测空位
        console.log('0 in sparse1:', 0 in sparse1); // true
        console.log('1 in sparse1:', 1 in sparse1); // false (空位)
        console.log('2 in sparse1:', 2 in sparse1); // false (空位)
        console.log('3 in sparse1:', 3 in sparse1); // true
        
        // 空位的值
        console.log('sparse1[1]:', sparse1[1]); // undefined
        console.log('sparse1[2]:', sparse1[2]); // undefined
        
        // 遍历稀疏数组
        console.log('for循环遍历稀疏数组:');
        for (let i = 0; i < sparse1.length; i++) {
            console.log(`  ${i}: ${sparse1[i]} (${i in sparse1 ? '存在' : '空位'})`);
        }
        
        console.log('forEach遍历稀疏数组:');
        sparse1.forEach((value, index) => {
            console.log(`  ${index}: ${value}`); // 跳过空位
        });
        
        // 密集化稀疏数组
        const dense1 = [...sparse1]; // 空位变为undefined
        const dense2 = Array.from(sparse1); // 空位变为undefined
        
        console.log('密集化结果1:', dense1);
        console.log('密集化结果2:', dense2);
    }
};

ArrayCreationExamples.creationMethods();
ArrayCreationExamples.multiDimensionalArrays();
ArrayCreationExamples.sparseArrays();
```

---

## 11.2 常用数组方法

JavaScript提供了丰富的数组方法来处理各种操作需求。

### 基础操作方法

数组的增删改查基础操作：

```javascript
/**
 * 基础操作方法示例
 */
const BasicArrayMethodsExamples = {
    /**
     * 增加元素方法
     */
    addingElements() {
        console.log('=== 增加元素方法 ===');
        
        let arr = [1, 2, 3];
        
        // push() - 末尾添加（改变原数组）
        const pushResult = arr.push(4, 5);
        console.log('push后数组:', arr, '返回值:', pushResult);
        
        // unshift() - 开头添加（改变原数组）
        const unshiftResult = arr.unshift(0, -1);
        console.log('unshift后数组:', arr, '返回值:', unshiftResult);
        
        // concat() - 合并数组（不改变原数组）
        const arr2 = [6, 7];
        const concatResult = arr.concat(arr2, [8, 9]);
        console.log('原数组:', arr);
        console.log('concat结果:', concatResult);
        
        // 扩展操作符 - 合并数组（不改变原数组）
        const spreadResult = [...arr, ...arr2, 10];
        console.log('扩展操作符结果:', spreadResult);
        
        // splice() - 任意位置插入
        arr = [1, 2, 3, 4, 5];
        const spliceResult = arr.splice(2, 0, 'a', 'b'); // 位置2，删除0个，插入'a','b'
        console.log('splice插入后:', arr, '返回值:', spliceResult);
    },
    
    /**
     * 删除元素方法
     */
    removingElements() {
        console.log('=== 删除元素方法 ===');
        
        let arr = [1, 2, 3, 4, 5];
        
        // pop() - 删除末尾元素
        const popResult = arr.pop();
        console.log('pop后数组:', arr, '删除的元素:', popResult);
        
        // shift() - 删除开头元素
        const shiftResult = arr.shift();
        console.log('shift后数组:', arr, '删除的元素:', shiftResult);
        
        // splice() - 删除指定位置元素
        arr = [1, 2, 3, 4, 5];
        const spliceDeleted = arr.splice(1, 2); // 从位置1删除2个元素
        console.log('splice删除后:', arr, '删除的元素:', spliceDeleted);
        
        // delete操作符 - 创建稀疏数组（不推荐）
        arr = [1, 2, 3, 4, 5];
        delete arr[2];
        console.log('delete后:', arr, 'length:', arr.length);
        console.log('2 in arr:', 2 in arr);
        
        // filter() - 条件删除（不改变原数组）
        arr = [1, 2, 3, 4, 5];
        const filtered = arr.filter(x => x !== 3);
        console.log('原数组:', arr);
        console.log('filter结果:', filtered);
    },
    
    /**
     * 修改元素方法
     */
    modifyingElements() {
        console.log('=== 修改元素方法 ===');
        
        let arr = [1, 2, 3, 4, 5];
        
        // 直接索引赋值
        arr[0] = 'first';
        console.log('索引赋值后:', arr);
        
        // splice() - 替换元素
        arr = [1, 2, 3, 4, 5];
        const replaced = arr.splice(1, 2, 'two', 'three'); // 位置1，删除2个，插入新元素
        console.log('splice替换后:', arr, '被替换的元素:', replaced);
        
        // fill() - 填充数组
        arr = new Array(5);
        arr.fill(0);
        console.log('fill填充:', arr);
        
        arr.fill('x', 1, 3); // 从索引1到3填充
        console.log('fill部分填充:', arr);
        
        // copyWithin() - 内部复制
        arr = [1, 2, 3, 4, 5];
        arr.copyWithin(0, 3, 4); // 将索引3-4的元素复制到索引0
        console.log('copyWithin后:', arr);
        
        // map() - 映射转换（不改变原数组）
        arr = [1, 2, 3, 4, 5];
        const mapped = arr.map(x => x * 2);
        console.log('原数组:', arr);
        console.log('map结果:', mapped);
    }
};

BasicArrayMethodsExamples.addingElements();
BasicArrayMethodsExamples.removingElements();
BasicArrayMethodsExamples.modifyingElements();
```

### 查找和检测方法

数组中元素的查找和检测：

```javascript
/**
 * 查找和检测方法示例
 */
const SearchAndTestExamples = {
    /**
     * 基础查找方法
     */
    basicSearchMethods() {
        console.log('=== 基础查找方法 ===');
        
        const arr = [1, 2, 3, 4, 5, 3, 6];
        const objArr = [
            {id: 1, name: 'Alice'},
            {id: 2, name: 'Bob'},
            {id: 3, name: 'Charlie'}
        ];
        
        // indexOf() - 第一次出现的索引
        console.log('indexOf(3):', arr.indexOf(3)); // 2
        console.log('indexOf(7):', arr.indexOf(7)); // -1（不存在）
        console.log('indexOf(3, 3):', arr.indexOf(3, 3)); // 5（从索引3开始查找）
        
        // lastIndexOf() - 最后一次出现的索引
        console.log('lastIndexOf(3):', arr.lastIndexOf(3)); // 5
        
        // includes() - 是否包含某元素
        console.log('includes(3):', arr.includes(3)); // true
        console.log('includes(7):', arr.includes(7)); // false
        
        // find() - 找到第一个满足条件的元素
        const found = objArr.find(item => item.name === 'Bob');
        console.log('find结果:', found);
        
        const notFound = objArr.find(item => item.name === 'David');
        console.log('找不到时:', notFound); // undefined
        
        // findIndex() - 找到第一个满足条件的元素索引
        const foundIndex = objArr.findIndex(item => item.name === 'Bob');
        console.log('findIndex结果:', foundIndex);
        
        // findLast() 和 findLastIndex() (ES2022)
        const nums = [1, 2, 3, 4, 3, 5];
        console.log('findLast > 2:', nums.findLast(x => x > 2)); // 5
        console.log('findLastIndex > 2:', nums.findLastIndex(x => x > 2)); // 5
    },
    
    /**
     * 条件检测方法
     */
    conditionalTestMethods() {
        console.log('=== 条件检测方法 ===');
        
        const numbers = [2, 4, 6, 8, 10];
        const mixed = [1, 2, 3, 4, 5];
        const empty = [];
        
        // every() - 所有元素都满足条件
        console.log('所有都是偶数:', numbers.every(x => x % 2 === 0)); // true
        console.log('所有都是偶数:', mixed.every(x => x % 2 === 0)); // false
        console.log('空数组every:', empty.every(x => x > 0)); // true（空数组返回true）
        
        // some() - 至少有一个元素满足条件
        console.log('有偶数:', mixed.some(x => x % 2 === 0)); // true
        console.log('有大于10的:', numbers.some(x => x > 10)); // false
        console.log('空数组some:', empty.some(x => x > 0)); // false（空数组返回false）
        
        // 实际应用示例
        const users = [
            {name: 'Alice', age: 25, active: true},
            {name: 'Bob', age: 30, active: false},
            {name: 'Charlie', age: 35, active: true}
        ];
        
        console.log('所有用户都成年:', users.every(user => user.age >= 18));
        console.log('有活跃用户:', users.some(user => user.active));
        console.log('所有用户都活跃:', users.every(user => user.active));
        
        // 组合使用
        function validateArray(arr, validators) {
            return validators.every(validator => 
                arr.some(item => validator(item))
            );
        }
        
        const data = [1, 2, 3, 4, 5];
        const validators = [
            x => x > 0,  // 有正数
            x => x < 10, // 有小于10的数
            x => x % 2 === 0 // 有偶数
        ];
        
        console.log('数据验证通过:', validateArray(data, validators));
    },
    
    /**
     * 高级查找模式
     */
    advancedSearchPatterns() {
        console.log('=== 高级查找模式 ===');
        
        const products = [
            {id: 1, name: 'Laptop', price: 1000, category: 'Electronics'},
            {id: 2, name: 'Shirt', price: 50, category: 'Clothing'},
            {id: 3, name: 'Phone', price: 800, category: 'Electronics'},
            {id: 4, name: 'Jeans', price: 80, category: 'Clothing'}
        ];
        
        // 多条件查找
        function findProducts(products, criteria) {
            return products.filter(product => {
                return Object.keys(criteria).every(key => {
                    const criterion = criteria[key];
                    const value = product[key];
                    
                    if (typeof criterion === 'function') {
                        return criterion(value);
                    } else if (Array.isArray(criterion)) {
                        return criterion.includes(value);
                    } else {
                        return value === criterion;
                    }
                });
            });
        }
        
        // 使用示例
        const electronicsUnder900 = findProducts(products, {
            category: 'Electronics',
            price: price => price < 900
        });
        
        console.log('价格低于900的电子产品:', electronicsUnder900);
        
        const specificCategories = findProducts(products, {
            category: ['Electronics', 'Clothing']
        });
        
        console.log('特定类别的产品:', specificCategories);
        
        // 模糊搜索
        function fuzzySearch(arr, searchTerm, searchKeys) {
            const term = searchTerm.toLowerCase();
            
            return arr.filter(item => {
                return searchKeys.some(key => {
                    const value = item[key];
                    return typeof value === 'string' && 
                           value.toLowerCase().includes(term);
                });
            });
        }
        
        const searchResult = fuzzySearch(products, 'lap', ['name']);
        console.log('模糊搜索"lap":', searchResult);
        
        // 二分查找（需要有序数组）
        function binarySearch(sortedArr, target, compareFunc = (a, b) => a - b) {
            let left = 0;
            let right = sortedArr.length - 1;
            
            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                const comparison = compareFunc(sortedArr[mid], target);
                
                if (comparison === 0) return mid;
                if (comparison < 0) left = mid + 1;
                else right = mid - 1;
            }
            
            return -1;
        }
        
        const sortedNumbers = [1, 3, 5, 7, 9, 11, 13];
        console.log('二分查找7:', binarySearch(sortedNumbers, 7));
        console.log('二分查找8:', binarySearch(sortedNumbers, 8));
    }
};

SearchAndTestExamples.basicSearchMethods();
SearchAndTestExamples.conditionalTestMethods();
SearchAndTestExamples.advancedSearchPatterns();
```

### 排序方法

数组排序和重新排列：

```javascript
/**
 * 排序方法示例
 */
const SortingExamples = {
    /**
     * 基础排序方法
     */
    basicSorting() {
        console.log('=== 基础排序方法 ===');
        
        // sort() - 默认字典序排序（改变原数组）
        let arr = [3, 1, 4, 1, 5, 9, 2];
        console.log('原数组:', arr);
        
        const sorted = arr.sort();
        console.log('sort后:', arr, '返回值:', sorted);
        console.log('原数组已改变:', arr === sorted);
        
        // 数字排序的问题
        arr = [10, 2, 30, 4];
        arr.sort();
        console.log('数字默认排序问题:', arr); // [10, 2, 30, 4]
        
        // 正确的数字排序
        arr = [10, 2, 30, 4];
        arr.sort((a, b) => a - b); // 升序
        console.log('数字升序排序:', arr);
        
        arr.sort((a, b) => b - a); // 降序
        console.log('数字降序排序:', arr);
        
        // reverse() - 反转数组（改变原数组）
        arr = [1, 2, 3, 4, 5];
        arr.reverse();
        console.log('reverse后:', arr);
        
        // 不改变原数组的排序方法
        const original = [3, 1, 4, 1, 5];
        const sortedCopy1 = [...original].sort((a, b) => a - b);
        const sortedCopy2 = Array.from(original).sort((a, b) => a - b);
        
        console.log('原数组未变:', original);
        console.log('排序副本1:', sortedCopy1);
        console.log('排序副本2:', sortedCopy2);
    },
    
    /**
     * 复杂对象排序
     */
    objectSorting() {
        console.log('=== 复杂对象排序 ===');
        
        const students = [
            {name: 'Alice', age: 22, grade: 85},
            {name: 'Bob', age: 20, grade: 90},
            {name: 'Charlie', age: 21, grade: 85},
            {name: 'David', age: 22, grade: 88}
        ];
        
        // 按年龄排序
        const byAge = [...students].sort((a, b) => a.age - b.age);
        console.log('按年龄排序:', byAge);
        
        // 按姓名排序
        const byName = [...students].sort((a, b) => a.name.localeCompare(b.name));
        console.log('按姓名排序:', byName);
        
        // 多级排序（先按成绩，再按年龄）
        const multiSort = [...students].sort((a, b) => {
            // 先比较成绩
            if (a.grade !== b.grade) {
                return b.grade - a.grade; // 成绩降序
            }
            // 成绩相同则比较年龄
            return a.age - b.age; // 年龄升序
        });
        console.log('多级排序:', multiSort);
        
        // 通用排序函数
        function sortBy(arr, ...sortKeys) {
            return [...arr].sort((a, b) => {
                for (let key of sortKeys) {
                    let valueA, valueB, desc = false;
                    
                    if (typeof key === 'string') {
                        valueA = a[key];
                        valueB = b[key];
                    } else if (typeof key === 'object') {
                        valueA = a[key.key];
                        valueB = b[key.key];
                        desc = key.desc || false;
                    }
                    
                    let comparison;
                    if (typeof valueA === 'string') {
                        comparison = valueA.localeCompare(valueB);
                    } else {
                        comparison = valueA - valueB;
                    }
                    
                    if (desc) comparison = -comparison;
                    if (comparison !== 0) return comparison;
                }
                return 0;
            });
        }
        
        // 使用通用排序函数
        const sorted1 = sortBy(students, {key: 'grade', desc: true}, 'age');
        console.log('通用排序结果:', sorted1);
        
        // 自定义比较函数
        const products = [
            {name: 'Apple', price: 1.2, inStock: true},
            {name: 'Banana', price: 0.8, inStock: false},
            {name: 'Orange', price: 1.5, inStock: true},
            {name: 'Grape', price: 2.0, inStock: false}
        ];
        
        const productSort = products.sort((a, b) => {
            // 优先显示有库存的商品
            if (a.inStock !== b.inStock) {
                return b.inStock - a.inStock;
            }
            // 然后按价格排序
            return a.price - b.price;
        });
        
        console.log('产品排序（库存优先）:', productSort);
    },
    
    /**
     * 高级排序技巧
     */
    advancedSorting() {
        console.log('=== 高级排序技巧 ===');
        
        // 稳定排序检验
        const data = [
            {key: 'a', value: 1},
            {key: 'b', value: 2},
            {key: 'a', value: 3},
            {key: 'b', value: 4}
        ];
        
        const stableSort = [...data].sort((a, b) => a.key.localeCompare(b.key));
        console.log('稳定排序测试:', stableSort);
        
        // 随机排序（洗牌）
        function shuffle(arr) {
            const shuffled = [...arr];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        
        const deck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        console.log('原数组:', deck);
        console.log('洗牌结果:', shuffle(deck));
        
        // 部分排序（只排序前N个）
        function partialSort(arr, n, compareFunc = (a, b) => a - b) {
            if (n >= arr.length) return [...arr].sort(compareFunc);
            
            const result = [...arr];
            
            // 选择排序的变种，只排序前n个
            for (let i = 0; i < n; i++) {
                let minIndex = i;
                for (let j = i + 1; j < result.length; j++) {
                    if (compareFunc(result[j], result[minIndex]) < 0) {
                        minIndex = j;
                    }
                }
                [result[i], result[minIndex]] = [result[minIndex], result[i]];
            }
            
            return result;
        }
        
        const numbers = [64, 34, 25, 12, 22, 11, 90];
        console.log('部分排序前3个:', partialSort(numbers, 3));
        
        // 自然排序（处理数字字符串）
        const versions = ['v1.10', 'v1.2', 'v1.1', 'v2.0', 'v1.20'];
        const naturalSort = versions.sort((a, b) => {
            return a.localeCompare(b, undefined, {
                numeric: true,
                sensitivity: 'base'
            });
        });
        console.log('自然排序:', naturalSort);
    }
};

SortingExamples.basicSorting();
SortingExamples.objectSorting();
SortingExamples.advancedSorting();
```

---

## 11.3 数组迭代器

数组遍历从传统循环到现代迭代器的演进。

### 传统遍历方式

经典的数组遍历方法：

```javascript
/**
 * 传统遍历方式示例
 */
const TraditionalIterationExamples = {
    /**
     * 基础循环方法
     */
    basicLoops() {
        console.log('=== 基础循环方法 ===');
        
        const arr = ['a', 'b', 'c', 'd', 'e'];
        
        // for循环 - 最基础，性能最好
        console.log('for循环:');
        for (let i = 0; i < arr.length; i++) {
            console.log(`  ${i}: ${arr[i]}`);
        }
        
        // while循环
        console.log('while循环:');
        let i = 0;
        while (i < arr.length) {
            console.log(`  ${i}: ${arr[i]}`);
            i++;
        }
        
        // for...in循环（遍历可枚举属性）
        console.log('for...in循环:');
        for (let index in arr) {
            console.log(`  ${index}: ${arr[index]} (type: ${typeof index})`);
        }
        
        // for...of循环（遍历可迭代对象）
        console.log('for...of循环:');
        for (let value of arr) {
            console.log(`  ${value}`);
        }
        
        // 带索引的for...of
        console.log('带索引的for...of:');
        for (let [index, value] of arr.entries()) {
            console.log(`  ${index}: ${value}`);
        }
    },
    
    /**
     * 数组方法遍历
     */
    arrayMethodIteration() {
        console.log('=== 数组方法遍历 ===');
        
        const numbers = [1, 2, 3, 4, 5];
        
        // forEach - 最常用的数组遍历方法
        console.log('forEach遍历:');
        numbers.forEach((value, index, array) => {
            console.log(`  ${index}: ${value}, 数组长度: ${array.length}`);
        });
        
        // forEach的返回值
        const forEachResult = numbers.forEach(x => x * 2);
        console.log('forEach返回值:', forEachResult); // undefined
        
        // forEach不能被break中断
        console.log('forEach不能中断:');
        try {
            numbers.forEach(value => {
                if (value === 3) {
                    // break; // 语法错误
                    return; // 只是跳过当前迭代
                }
                console.log(`  ${value}`);
            });
        } catch (e) {
            console.log('  错误:', e.message);
        }
        
        // 需要中断时使用some/every
        console.log('使用some实现中断:');
        numbers.some(value => {
            if (value === 3) {
                console.log('  遇到3，停止遍历');
                return true; // 中断遍历
            }
            console.log(`  ${value}`);
            return false;
        });
    },
    
    /**
     * 性能对比
     */
    performanceComparison() {
        console.log('=== 遍历性能对比 ===');
        
        const largeArray = Array.from({length: 100000}, (_, i) => i);
        
        // for循环
        console.time('for循环');
        for (let i = 0; i < largeArray.length; i++) {
            const value = largeArray[i];
        }
        console.timeEnd('for循环');
        
        // for...of循环
        console.time('for...of循环');
        for (let value of largeArray) {
            // 处理value
        }
        console.timeEnd('for...of循环');
        
        // forEach方法
        console.time('forEach方法');
        largeArray.forEach(value => {
            // 处理value
        });
        console.timeEnd('forEach方法');
        
        // 缓存length的for循环
        console.time('缓存length的for循环');
        for (let i = 0, len = largeArray.length; i < len; i++) {
            const value = largeArray[i];
        }
        console.timeEnd('缓存length的for循环');
        
        console.log('一般来说: for循环 > 缓存length的for > for...of > forEach');
    }
};

TraditionalIterationExamples.basicLoops();
TraditionalIterationExamples.arrayMethodIteration();
TraditionalIterationExamples.performanceComparison();
```

### 现代迭代器

ES6迭代器协议和Iterator接口：

```javascript
/**
 * 现代迭代器示例
 */
const ModernIteratorExamples = {
    /**
     * Iterator协议基础
     */
    iteratorProtocol() {
        console.log('=== Iterator协议基础 ===');
        
        const arr = [1, 2, 3];
        
        // 获取迭代器
        const iterator = arr[Symbol.iterator]();
        console.log('迭代器对象:', iterator);
        
        // 手动迭代
        console.log('手动迭代:');
        let result = iterator.next();
        while (!result.done) {
            console.log(`  value: ${result.value}, done: ${result.done}`);
            result = iterator.next();
        }
        console.log(`  最后一次: value: ${result.value}, done: ${result.done}`);
        
        // 迭代器一次性使用
        console.log('尝试再次迭代:');
        const secondResult = iterator.next();
        console.log(`  ${secondResult.value}, ${secondResult.done}`);
        
        // 重新创建迭代器
        const newIterator = arr[Symbol.iterator]();
        console.log('新迭代器第一个值:', newIterator.next().value);
    },
    
    /**
     * 内置迭代方法
     */
    builtinIterators() {
        console.log('=== 内置迭代方法 ===');
        
        const arr = ['a', 'b', 'c'];
        
        // keys() - 索引迭代器
        console.log('keys()迭代器:');
        for (let key of arr.keys()) {
            console.log(`  key: ${key}`);
        }
        
        // values() - 值迭代器
        console.log('values()迭代器:');
        for (let value of arr.values()) {
            console.log(`  value: ${value}`);
        }
        
        // entries() - 键值对迭代器
        console.log('entries()迭代器:');
        for (let [index, value] of arr.entries()) {
            console.log(`  [${index}, ${value}]`);
        }
        
        // 解构迭代器
        const keysArray = [...arr.keys()];
        const valuesArray = [...arr.values()];
        const entriesArray = [...arr.entries()];
        
        console.log('解构结果:');
        console.log('  keys:', keysArray);
        console.log('  values:', valuesArray);
        console.log('  entries:', entriesArray);
    },
    
    /**
     * 可迭代对象
     */
    iterableObjects() {
        console.log('=== 可迭代对象 ===');
        
        // 检查是否可迭代
        function isIterable(obj) {
            return obj != null && typeof obj[Symbol.iterator] === 'function';
        }
        
        console.log('可迭代性检查:');
        console.log('  Array:', isIterable([]));
        console.log('  String:', isIterable(''));
        console.log('  Set:', isIterable(new Set()));
        console.log('  Map:', isIterable(new Map()));
        console.log('  Object:', isIterable({}));
        console.log('  NodeList:', typeof document !== 'undefined' ? isIterable(document.querySelectorAll('div')) : 'N/A');
        
        // 字符串迭代
        console.log('字符串迭代:');
        for (let char of 'hello') {
            console.log(`  ${char}`);
        }
        
        // Set迭代
        const set = new Set([1, 2, 3, 2, 1]);
        console.log('Set迭代:');
        for (let value of set) {
            console.log(`  ${value}`);
        }
        
        // Map迭代
        const map = new Map([['a', 1], ['b', 2], ['c', 3]]);
        console.log('Map迭代:');
        for (let [key, value] of map) {
            console.log(`  ${key}: ${value}`);
        }
        
        // arguments对象迭代（ES6+）
        function testArguments() {
            console.log('arguments迭代:');
            for (let arg of arguments) {
                console.log(`  ${arg}`);
            }
        }
        testArguments('x', 'y', 'z');
    }
};

ModernIteratorExamples.iteratorProtocol();
ModernIteratorExamples.builtinIterators();
ModernIteratorExamples.iterableObjects();
```

---

## 11.4 map / filter / reduce

函数式编程的核心高阶方法。

### map方法深度解析

数据映射和转换：

```javascript
/**
 * map方法示例
 */
const MapMethodExamples = {
    /**
     * 基础映射操作
     */
    basicMapping() {
        console.log('=== 基础映射操作 ===');
        
        const numbers = [1, 2, 3, 4, 5];
        
        // 基本数值转换
        const doubled = numbers.map(x => x * 2);
        const squared = numbers.map(x => x ** 2);
        const stringified = numbers.map(x => String(x));
        
        console.log('原数组:', numbers);
        console.log('翻倍:', doubled);
        console.log('平方:', squared);
        console.log('字符串化:', stringified);
        
        // 带索引的映射
        const withIndex = numbers.map((value, index) => ({
            index,
            value,
            isEven: value % 2 === 0
        }));
        
        console.log('带索引映射:', withIndex);
        
        // 访问原数组
        const normalized = numbers.map((value, index, array) => 
            value / Math.max(...array)
        );
        console.log('归一化:', normalized);
    },
    
    /**
     * 对象数组映射
     */
    objectArrayMapping() {
        console.log('=== 对象数组映射 ===');
        
        const users = [
            { id: 1, name: 'Alice', age: 25, salary: 50000 },
            { id: 2, name: 'Bob', age: 30, salary: 60000 },
            { id: 3, name: 'Charlie', age: 35, salary: 70000 }
        ];
        
        // 提取特定属性
        const names = users.map(user => user.name);
        const ages = users.map(user => user.age);
        
        console.log('姓名:', names);
        console.log('年龄:', ages);
        
        // 计算新属性
        const withBonus = users.map(user => ({
            ...user,
            bonus: user.salary * 0.1,
            category: user.age >= 30 ? 'senior' : 'junior'
        }));
        
        console.log('增加奖金和类别:', withBonus);
        
        // 重构数据结构
        const userMap = users.map(user => ({
            [`user_${user.id}`]: {
                profile: { name: user.name, age: user.age },
                employment: { salary: user.salary }
            }
        }));
        
        console.log('重构数据:', userMap);
        
        // 条件映射
        const processed = users.map(user => {
            if (user.age < 30) {
                return { ...user, status: 'junior', training: true };
            } else {
                return { ...user, status: 'senior', mentor: true };
            }
        });
        
        console.log('条件处理:', processed);
    },
    
    /**
     * 高级映射技巧
     */
    advancedMapping() {
        console.log('=== 高级映射技巧 ===');
        
        // 异步映射（需要Promise.all）
        async function asyncMap(array, asyncFn) {
            return Promise.all(array.map(asyncFn));
        }
        
        const urls = [
            'https://api.example.com/1',
            'https://api.example.com/2',
            'https://api.example.com/3'
        ];
        
        // 模拟异步操作
        const mockFetch = url => 
            Promise.resolve(`Data from ${url}`);
        
        asyncMap(urls, mockFetch).then(results => {
            console.log('异步映射结果:', results);
        });
        
        // 嵌套数组映射
        const matrix = [
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
        ];
        
        const doubled2D = matrix.map(row => 
            row.map(cell => cell * 2)
        );
        
        console.log('二维数组映射:', doubled2D);
        
        // 链式映射
        const data = [1, 2, 3, 4, 5];
        const result = data
            .map(x => x * 2)      // [2, 4, 6, 8, 10]
            .map(x => x + 1)      // [3, 5, 7, 9, 11]
            .map(x => `#${x}`);   // ['#3', '#5', '#7', '#9', '#11']
        
        console.log('链式映射:', result);
        
        // 映射到不同类型
        const mixed = [1, '2', true, null, undefined, {}];
        const typeMap = mixed.map(value => ({
            value,
            type: typeof value,
            isNull: value === null,
            isUndefined: value === undefined,
            stringValue: String(value)
        }));
        
        console.log('类型映射:', typeMap);
        
        // 索引映射创建查找表
        const items = ['apple', 'banana', 'cherry'];
        const indexMap = items.map((item, index) => ({ [item]: index }));
        const lookupTable = Object.assign({}, ...indexMap);
        
        console.log('查找表:', lookupTable);
    }
};

MapMethodExamples.basicMapping();
MapMethodExamples.objectArrayMapping();
MapMethodExamples.advancedMapping();
```

### filter方法应用

数据过滤和筛选：

```javascript
/**
 * filter方法示例
 */
const FilterMethodExamples = {
    /**
     * 基础过滤操作
     */
    basicFiltering() {
        console.log('=== 基础过滤操作 ===');
        
        const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        
        // 基本数值过滤
        const evens = numbers.filter(x => x % 2 === 0);
        const odds = numbers.filter(x => x % 2 !== 0);
        const greaterThan5 = numbers.filter(x => x > 5);
        
        console.log('原数组:', numbers);
        console.log('偶数:', evens);
        console.log('奇数:', odds);
        console.log('大于5:', greaterThan5);
        
        // 带索引的过滤
        const evenIndexes = numbers.filter((value, index) => index % 2 === 0);
        console.log('偶数索引位置的元素:', evenIndexes);
        
        // 复合条件
        const complexFilter = numbers.filter((value, index) => 
            value > 3 && index < 7
        );
        console.log('值>3且索引<7:', complexFilter);
    },
    
    /**
     * 对象数组过滤
     */
    objectArrayFiltering() {
        console.log('=== 对象数组过滤 ===');
        
        const products = [
            { id: 1, name: 'Laptop', price: 1200, category: 'Electronics', inStock: true },
            { id: 2, name: 'Phone', price: 800, category: 'Electronics', inStock: false },
            { id: 3, name: 'Shirt', price: 30, category: 'Clothing', inStock: true },
            { id: 4, name: 'Jeans', price: 80, category: 'Clothing', inStock: true },
            { id: 5, name: 'Watch', price: 200, category: 'Accessories', inStock: false }
        ];
        
        // 单条件过滤
        const electronics = products.filter(p => p.category === 'Electronics');
        const inStock = products.filter(p => p.inStock);
        const affordable = products.filter(p => p.price < 100);
        
        console.log('电子产品:', electronics);
        console.log('有库存:', inStock);
        console.log('价格<100:', affordable);
        
        // 多条件过滤
        const availableElectronics = products.filter(p => 
            p.category === 'Electronics' && p.inStock
        );
        
        const expensiveClothing = products.filter(p => 
            p.category === 'Clothing' && p.price > 50
        );
        
        console.log('有库存的电子产品:', availableElectronics);
        console.log('昂贵的服装:', expensiveClothing);
        
        // 范围过滤
        const midRange = products.filter(p => 
            p.price >= 50 && p.price <= 500
        );
        
        console.log('中等价位产品:', midRange);
    },
    
    /**
     * 高级过滤技巧
     */
    advancedFiltering() {
        console.log('=== 高级过滤技巧 ===');
        
        const users = [
            { name: 'Alice', age: 25, skills: ['JavaScript', 'React'], active: true },
            { name: 'Bob', age: 30, skills: ['Python', 'Django'], active: false },
            { name: 'Charlie', age: 35, skills: ['JavaScript', 'Node.js'], active: true },
            { name: 'David', age: 28, skills: ['Java', 'Spring'], active: true }
        ];
        
        // 基于数组属性过滤
        const jsUsers = users.filter(user => 
            user.skills.includes('JavaScript')
        );
        
        console.log('会JavaScript的用户:', jsUsers);
        
        // 动态过滤条件
        function createFilter(criteria) {
            return function(item) {
                return Object.keys(criteria).every(key => {
                    const criterion = criteria[key];
                    const value = item[key];
                    
                    if (typeof criterion === 'function') {
                        return criterion(value);
                    } else if (Array.isArray(criterion)) {
                        return criterion.includes(value);
                    } else {
                        return value === criterion;
                    }
                });
            };
        }
        
        const activeJsUsers = users.filter(createFilter({
            active: true,
            skills: skills => skills.includes('JavaScript')
        }));
        
        console.log('活跃的JS用户:', activeJsUsers);
        
        // 去重过滤
        const numbers = [1, 2, 2, 3, 3, 3, 4, 4, 5];
        const unique = numbers.filter((value, index, array) => 
            array.indexOf(value) === index
        );
        
        console.log('原数组:', numbers);
        console.log('去重后:', unique);
        
        // 对象数组去重
        const duplicateUsers = [
            { id: 1, name: 'Alice' },
            { id: 2, name: 'Bob' },
            { id: 1, name: 'Alice' },
            { id: 3, name: 'Charlie' }
        ];
        
        const uniqueUsers = duplicateUsers.filter((user, index, array) => 
            array.findIndex(u => u.id === user.id) === index
        );
        
        console.log('去重用户:', uniqueUsers);
        
        // 分组过滤（获取每组的第一个）
        const data = [
            { group: 'A', value: 1 },
            { group: 'B', value: 2 },
            { group: 'A', value: 3 },
            { group: 'B', value: 4 },
            { group: 'C', value: 5 }
        ];
        
        const firstInGroup = data.filter((item, index, array) => 
            array.findIndex(x => x.group === item.group) === index
        );
        
        console.log('每组第一个:', firstInGroup);
    }
};

FilterMethodExamples.basicFiltering();
FilterMethodExamples.objectArrayFiltering();
FilterMethodExamples.advancedFiltering();
```

### reduce的强大功能

数据聚合和累积操作：

```javascript
/**
 * reduce方法示例
 */
const ReduceMethodExamples = {
    /**
     * 基础reduce操作
     */
    basicReduce() {
        console.log('=== 基础reduce操作 ===');
        
        const numbers = [1, 2, 3, 4, 5];
        
        // 求和
        const sum = numbers.reduce((acc, curr) => acc + curr, 0);
        console.log('数组求和:', sum);
        
        // 求积
        const product = numbers.reduce((acc, curr) => acc * curr, 1);
        console.log('数组求积:', product);
        
        // 找最大值
        const max = numbers.reduce((acc, curr) => Math.max(acc, curr), -Infinity);
        console.log('最大值:', max);
        
        // 找最小值
        const min = numbers.reduce((acc, curr) => Math.min(acc, curr), Infinity);
        console.log('最小值:', min);
        
        // 不提供初始值
        const sumNoInit = numbers.reduce((acc, curr) => acc + curr);
        console.log('无初始值求和:', sumNoInit);
        
        // 字符串连接
        const words = ['Hello', ' ', 'World', '!'];
        const sentence = words.reduce((acc, curr) => acc + curr, '');
        console.log('字符串连接:', sentence);
        
        // 数组扁平化（一级）
        const nested = [[1, 2], [3, 4], [5, 6]];
        const flattened = nested.reduce((acc, curr) => acc.concat(curr), []);
        console.log('数组扁平化:', flattened);
    },
    
    /**
     * 对象数组reduce
     */
    objectArrayReduce() {
        console.log('=== 对象数组reduce ===');
        
        const sales = [
            { product: 'Laptop', amount: 1200, quantity: 2 },
            { product: 'Phone', amount: 800, quantity: 5 },
            { product: 'Tablet', amount: 400, quantity: 3 },
            { product: 'Phone', amount: 800, quantity: 2 }
        ];
        
        // 计算总收入
        const totalRevenue = sales.reduce((acc, sale) => 
            acc + (sale.amount * sale.quantity), 0
        );
        console.log('总收入:', totalRevenue);
        
        // 按产品分组计算
        const productSales = sales.reduce((acc, sale) => {
            const product = sale.product;
            if (!acc[product]) {
                acc[product] = { totalAmount: 0, totalQuantity: 0 };
            }
            acc[product].totalAmount += sale.amount * sale.quantity;
            acc[product].totalQuantity += sale.quantity;
            return acc;
        }, {});
        console.log('按产品统计:', productSales);
        
        // 找到最高销售额的记录
        const topSale = sales.reduce((acc, sale) => {
            const saleTotal = sale.amount * sale.quantity;
            const accTotal = acc.amount * acc.quantity;
            return saleTotal > accTotal ? sale : acc;
        });
        console.log('最高销售:', topSale);
        
        // 统计产品种类
        const productCount = sales.reduce((acc, sale) => {
            acc[sale.product] = (acc[sale.product] || 0) + 1;
            return acc;
        }, {});
        console.log('产品出现次数:', productCount);
    },
    
    /**
     * 高级reduce应用
     */
    advancedReduce() {
        console.log('=== 高级reduce应用 ===');
        
        // 实现map功能
        const numbers = [1, 2, 3, 4, 5];
        const doubled = numbers.reduce((acc, curr) => {
            acc.push(curr * 2);
            return acc;
        }, []);
        console.log('reduce实现map:', doubled);
        
        // 实现filter功能
        const evens = numbers.reduce((acc, curr) => {
            if (curr % 2 === 0) {
                acc.push(curr);
            }
            return acc;
        }, []);
        console.log('reduce实现filter:', evens);
        
        // 数组去重
        const duplicates = [1, 2, 2, 3, 3, 3, 4];
        const unique = duplicates.reduce((acc, curr) => {
            if (!acc.includes(curr)) {
                acc.push(curr);
            }
            return acc;
        }, []);
        console.log('reduce去重:', unique);
        
        // 深层对象合并
        const objects = [
            { a: 1, b: { x: 1 } },
            { b: { y: 2 }, c: 3 },
            { a: 2, b: { z: 3 } }
        ];
        
        const merged = objects.reduce((acc, obj) => {
            Object.keys(obj).forEach(key => {
                if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) {
                    acc[key] = { ...acc[key], ...obj[key] };
                } else {
                    acc[key] = obj[key];
                }
            });
            return acc;
        }, {});
        console.log('深层合并:', merged);
        
        // 管道函数实现
        const pipe = (...functions) => (value) =>
            functions.reduce((acc, fn) => fn(acc), value);
        
        const transform = pipe(
            x => x * 2,
            x => x + 1,
            x => `Result: ${x}`
        );
        
        console.log('管道函数:', transform(5)); // "Result: 11"
        
        // 异步reduce（顺序执行）
        async function asyncReduce(array, asyncFn, initialValue) {
            let accumulator = initialValue;
            for (let i = 0; i < array.length; i++) {
                accumulator = await asyncFn(accumulator, array[i], i, array);
            }
            return accumulator;
        }
        
        const urls = ['url1', 'url2', 'url3'];
        const mockAsyncFetch = (acc, url) => 
            Promise.resolve([...acc, `data-${url}`]);
        
        asyncReduce(urls, mockAsyncFetch, []).then(result => {
            console.log('异步reduce结果:', result);
        });
    }
};

ReduceMethodExamples.basicReduce();
ReduceMethodExamples.objectArrayReduce();
ReduceMethodExamples.advancedReduce();
```

### 组合使用模式

高阶方法的链式组合：

```javascript
/**
 * 组合使用模式示例
 */
const CombinationPatternExamples = {
    /**
     * 基础链式调用
     */
    basicChaining() {
        console.log('=== 基础链式调用 ===');
        
        const users = [
            { name: 'Alice', age: 25, salary: 50000, active: true },
            { name: 'Bob', age: 30, salary: 60000, active: false },
            { name: 'Charlie', age: 35, salary: 70000, active: true },
            { name: 'David', age: 28, salary: 55000, active: true },
            { name: 'Eve', age: 32, salary: 65000, active: false }
        ];
        
        // 筛选活跃用户，计算平均薪资
        const activeUsersAvgSalary = users
            .filter(user => user.active)
            .map(user => user.salary)
            .reduce((sum, salary) => sum + salary, 0) / 
            users.filter(user => user.active).length;
        
        console.log('活跃用户平均薪资:', activeUsersAvgSalary);
        
        // 优化版本（避免重复过滤）
        const activeUsers = users.filter(user => user.active);
        const avgSalary = activeUsers
            .map(user => user.salary)
            .reduce((sum, salary) => sum + salary, 0) / activeUsers.length;
        
        console.log('优化后平均薪资:', avgSalary);
        
        // 复杂的数据转换
        const processedData = users
            .filter(user => user.age >= 25 && user.active)
            .map(user => ({
                ...user,
                salaryLevel: user.salary > 60000 ? 'high' : 'medium',
                bonus: user.salary * 0.1
            }))
            .sort((a, b) => b.salary - a.salary)
            .slice(0, 3);
        
        console.log('处理后的前3名用户:', processedData);
    },
    
    /**
     * 实际业务场景
     */
    realWorldScenarios() {
        console.log('=== 实际业务场景 ===');
        
        const orders = [
            { id: 1, customerId: 101, items: [
                { productId: 'A', price: 100, quantity: 2 },
                { productId: 'B', price: 50, quantity: 1 }
            ], status: 'completed' },
            { id: 2, customerId: 102, items: [
                { productId: 'A', price: 100, quantity: 1 },
                { productId: 'C', price: 200, quantity: 1 }
            ], status: 'pending' },
            { id: 3, customerId: 101, items: [
                { productId: 'B', price: 50, quantity: 3 }
            ], status: 'completed' }
        ];
        
        // 计算已完成订单的总收入
        const completedOrdersRevenue = orders
            .filter(order => order.status === 'completed')
            .map(order => order.items.reduce((sum, item) => 
                sum + (item.price * item.quantity), 0))
            .reduce((total, orderTotal) => total + orderTotal, 0);
        
        console.log('已完成订单总收入:', completedOrdersRevenue);
        
        // 产品销量统计
        const productSales = orders
            .filter(order => order.status === 'completed')
            .flatMap(order => order.items)
            .reduce((acc, item) => {
                acc[item.productId] = (acc[item.productId] || 0) + item.quantity;
                return acc;
            }, {});
        
        console.log('产品销量统计:', productSales);
        
        // 客户消费分析
        const customerAnalysis = orders
            .reduce((acc, order) => {
                const customerId = order.customerId;
                const orderTotal = order.items.reduce((sum, item) => 
                    sum + (item.price * item.quantity), 0);
                
                if (!acc[customerId]) {
                    acc[customerId] = {
                        totalSpent: 0,
                        orderCount: 0,
                        completedOrders: 0
                    };
                }
                
                acc[customerId].totalSpent += orderTotal;
                acc[customerId].orderCount += 1;
                if (order.status === 'completed') {
                    acc[customerId].completedOrders += 1;
                }
                
                return acc;
            }, {});
        
        console.log('客户消费分析:', customerAnalysis);
    },
    
    /**
     * 性能优化技巧
     */
    performanceOptimization() {
        console.log('=== 性能优化技巧 ===');
        
        const largeDataset = Array.from({length: 10000}, (_, i) => ({
            id: i,
            value: Math.random() * 100,
            category: ['A', 'B', 'C'][i % 3],
            active: Math.random() > 0.5
        }));
        
        // ❌ 低效：多次遍历
        console.time('多次遍历');
        const result1 = largeDataset
            .filter(item => item.active)
            .filter(item => item.value > 50)
            .map(item => ({ ...item, processed: true }))
            .sort((a, b) => b.value - a.value)
            .slice(0, 10);
        console.timeEnd('多次遍历');
        
        // ✅ 高效：单次遍历 + 优化
        console.time('优化遍历');
        const result2 = largeDataset
            .reduce((acc, item) => {
                if (item.active && item.value > 50) {
                    acc.push({ ...item, processed: true });
                }
                return acc;
            }, [])
            .sort((a, b) => b.value - a.value)
            .slice(0, 10);
        console.timeEnd('优化遍历');
        
        // 使用for循环的最优版本
        console.time('for循环版本');
        const candidates = [];
        for (let i = 0; i < largeDataset.length; i++) {
            const item = largeDataset[i];
            if (item.active && item.value > 50) {
                candidates.push({ ...item, processed: true });
            }
        }
        const result3 = candidates
            .sort((a, b) => b.value - a.value)
            .slice(0, 10);
        console.timeEnd('for循环版本');
        
        console.log('结果长度对比:', result1.length, result2.length, result3.length);
        
        // 早期终止优化
        function findFirstN(array, predicate, n) {
            const result = [];
            for (let item of array) {
                if (predicate(item)) {
                    result.push(item);
                    if (result.length === n) break;
                }
            }
            return result;
        }
        
        console.time('早期终止');
        const first5Active = findFirstN(largeDataset, item => item.active, 5);
        console.timeEnd('早期终止');
        
        console.log('找到的前5个活跃项:', first5Active.length);
    }
};

CombinationPatternExamples.basicChaining();
CombinationPatternExamples.realWorldScenarios();
CombinationPatternExamples.performanceOptimization();
```

---

## 11.5 在实际项目中的数组处理模式

实际开发中的数组处理最佳实践。

### 数据转换模式

常见的数据处理场景：

```javascript
/**
 * 数据转换模式示例
 */
const DataTransformationPatterns = {
    /**
     * API数据标准化
     */
    apiDataNormalization() {
        console.log('=== API数据标准化 ===');
        
        // 模拟API返回的数据
        const apiResponse = {
            users: [
                { user_id: 1, first_name: 'Alice', last_name: 'Johnson', email_address: 'alice@example.com' },
                { user_id: 2, first_name: 'Bob', last_name: 'Smith', email_address: 'bob@example.com' }
            ],
            products: [
                { product_id: 'A001', product_name: 'Laptop', unit_price: 1200, in_stock: true },
                { product_id: 'A002', product_name: 'Mouse', unit_price: 25, in_stock: false }
            ]
        };
        
        // 标准化用户数据
        const normalizedUsers = apiResponse.users.map(user => ({
            id: user.user_id,
            name: `${user.first_name} ${user.last_name}`,
            email: user.email_address,
            firstName: user.first_name,
            lastName: user.last_name
        }));
        
        // 标准化产品数据
        const normalizedProducts = apiResponse.products.map(product => ({
            id: product.product_id,
            name: product.product_name,
            price: product.unit_price,
            available: product.in_stock,
            priceFormatted: `$${product.unit_price.toFixed(2)}`
        }));
        
        console.log('标准化用户:', normalizedUsers);
        console.log('标准化产品:', normalizedProducts);
        
        // 通用标准化函数
        function normalizeKeys(obj, keyMap) {
            const normalized = {};
            Object.keys(keyMap).forEach(newKey => {
                const oldKey = keyMap[newKey];
                if (obj.hasOwnProperty(oldKey)) {
                    normalized[newKey] = obj[oldKey];
                }
            });
            return { ...obj, ...normalized };
        }
        
        const userKeyMap = {
            id: 'user_id',
            fullName: 'first_name'
        };
        
        const normalizedWithMap = apiResponse.users.map(user => 
            normalizeKeys(user, userKeyMap)
        );
        
        console.log('通用标准化结果:', normalizedWithMap);
    },
    
    /**
     * 表格数据处理
     */
    tableDataProcessing() {
        console.log('=== 表格数据处理 ===');
        
        const rawData = [
            ['Name', 'Age', 'Salary', 'Department'],
            ['Alice Johnson', '25', '50000', 'Engineering'],
            ['Bob Smith', '30', '60000', 'Marketing'],
            ['Charlie Brown', '35', '70000', 'Engineering'],
            ['David Wilson', '28', '55000', 'Sales']
        ];
        
        // 转换为对象数组
        const [headers, ...rows] = rawData;
        const tableData = rows.map(row => {
            const obj = {};
            headers.forEach((header, index) => {
                let value = row[index];
                
                // 智能类型转换
                if (header === 'Age' || header === 'Salary') {
                    value = parseInt(value);
                }
                
                obj[header.toLowerCase()] = value;
            });
            return obj;
        });
        
        console.log('表格数据转换:', tableData);
        
        // 数据分析
        const analysis = {
            avgAge: tableData.reduce((sum, person) => sum + person.age, 0) / tableData.length,
            avgSalary: tableData.reduce((sum, person) => sum + person.salary, 0) / tableData.length,
            departments: [...new Set(tableData.map(person => person.department))],
            ageGroups: tableData.reduce((groups, person) => {
                const group = person.age < 30 ? 'young' : 'senior';
                groups[group] = (groups[group] || 0) + 1;
                return groups;
            }, {})
        };
        
        console.log('数据分析结果:', analysis);
        
        // 导出为CSV
        function exportToCSV(data) {
            const headers = Object.keys(data[0]);
            const csvContent = [
                headers.join(','),
                ...data.map(row => headers.map(header => row[header]).join(','))
            ].join('\n');
            return csvContent;
        }
        
        const csvOutput = exportToCSV(tableData);
        console.log('CSV导出:\n', csvOutput);
    },
    
    /**
     * 嵌套数据扁平化
     */
    nestedDataFlattening() {
        console.log('=== 嵌套数据扁平化 ===');
        
        const nestedData = [
            {
                id: 1,
                name: 'Category A',
                subcategories: [
                    { id: 11, name: 'Sub A1', items: ['item1', 'item2'] },
                    { id: 12, name: 'Sub A2', items: ['item3'] }
                ]
            },
            {
                id: 2,
                name: 'Category B',
                subcategories: [
                    { id: 21, name: 'Sub B1', items: ['item4', 'item5', 'item6'] }
                ]
            }
        ];
        
        // 扁平化到所有项目
        const allItems = nestedData
            .flatMap(category => 
                category.subcategories.flatMap(sub => 
                    sub.items.map(item => ({
                        item,
                        categoryId: category.id,
                        categoryName: category.name,
                        subcategoryId: sub.id,
                        subcategoryName: sub.name
                    }))
                )
            );
        
        console.log('扁平化项目:', allItems);
        
        // 递归扁平化（处理任意层级）
        function flattenDeep(arr) {
            return arr.reduce((acc, val) => {
                if (Array.isArray(val)) {
                    acc.push(...flattenDeep(val));
                } else {
                    acc.push(val);
                }
                return acc;
            }, []);
        }
        
        const deepNested = [1, [2, 3], [4, [5, 6]], [[7, 8], 9]];
        const flattened = flattenDeep(deepNested);
        console.log('深度扁平化:', flattened);
        
        // 对象路径扁平化
        function flattenObject(obj, prefix = '') {
            const flattened = {};
            
            Object.keys(obj).forEach(key => {
                const newKey = prefix ? `${prefix}.${key}` : key;
                const value = obj[key];
                
                if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                    Object.assign(flattened, flattenObject(value, newKey));
                } else {
                    flattened[newKey] = value;
                }
            });
            
            return flattened;
        }
        
        const complexObject = {
            user: {
                profile: { name: 'Alice', age: 25 },
                settings: { theme: 'dark', notifications: true }
            },
            data: [1, 2, 3]
        };
        
        const flatObject = flattenObject(complexObject);
        console.log('对象扁平化:', flatObject);
    }
};

DataTransformationPatterns.apiDataNormalization();
DataTransformationPatterns.tableDataProcessing();
DataTransformationPatterns.nestedDataFlattening();
```

---

**本章总结**

第11章全面探讨了JavaScript数组与高阶方法的核心知识：

1. **数组的本质**：
   - 数组作为特殊对象的内部结构
   - 长度属性的动态性和特殊行为  
   - 多种创建方式和稀疏数组处理

2. **常用数组方法**：
   - 增删改查的基础操作方法
   - 查找和检测的多种技巧
   - 排序和重新排列的高级应用

3. **数组迭代器**：
   - 从传统循环到现代迭代器的演进
   - Iterator协议和可迭代对象
   - 性能优化和最佳实践

4. **高阶方法**：
   - map方法的数据映射和转换
   - filter方法的筛选和去重
   - reduce方法的聚合和累积操作
   - 方法链式组合的强大威力

5. **实际项目应用**：
   - API数据标准化处理
   - 表格数据的智能转换
   - 嵌套数据的扁平化技巧

**关键要点**：
- 数组是JavaScript中最重要的数据结构
- 高阶方法是函数式编程的核心工具
- 合理的方法组合能简化复杂的数据处理
- 性能优化要在可读性和效率间找到平衡

**下一章预告**

第12章将学习DOM基础，包括DOM树结构、元素获取与操作、属性和样式修改、节点关系遍历，以及DOM性能优化技巧。这将开启我们与浏览器交互的重要篇章。
