# 第25章 深拷贝与浅拷贝

> 理解对象复制机制是JavaScript编程的重要技能。深拷贝与浅拷贝的区别影响着数据安全性和程序的正确性。

---

## 25.1 引用复制

### 25.1.1 基本类型与引用类型的复制

```javascript
/**
 * 基本类型的复制（值复制）
 */
let a = 5;
let b = a; // 值复制

a = 10;
console.log(a); // 10
console.log(b); // 5（不受影响）

/**
 * 引用类型的复制（引用复制）
 */
let obj1 = { name: 'Alice', age: 25 };
let obj2 = obj1; // 引用复制

obj1.age = 30;
console.log(obj1.age); // 30
console.log(obj2.age); // 30（受影响）

console.log(obj1 === obj2); // true（指向同一个对象）

/**
 * 数组的引用复制
 */
let arr1 = [1, 2, 3, { value: 4 }];
let arr2 = arr1; // 引用复制

arr1.push(5);
arr1[3].value = 40;

console.log(arr1); // [1, 2, 3, { value: 40 }, 5]
console.log(arr2); // [1, 2, 3, { value: 40 }, 5]（完全相同）

/**
 * 函数参数的传递
 */
function modifyPrimitive(num) {
    num = 100;
}

function modifyObject(obj) {
    obj.modified = true;
}

let number = 50;
let object = { name: 'Test' };

modifyPrimitive(number);
console.log(number); // 50（不变）

modifyObject(object);
console.log(object); // { name: 'Test', modified: true }（改变）
```

---

## 25.2 常用浅拷贝方式

### 25.2.1 对象的浅拷贝

```javascript
/**
 * Object.assign()
 */
let original = {
    name: 'Bob',
    age: 30,
    hobbies: ['reading', 'swimming'],
    address: {
        city: 'New York',
        country: 'USA'
    }
};

let copy1 = Object.assign({}, original);

// 修改第一层属性
copy1.name = 'Charlie';
console.log(original.name); // 'Bob'（不受影响）
console.log(copy1.name); // 'Charlie'

// 修改嵌套对象
copy1.address.city = 'Boston';
console.log(original.address.city); // 'Boston'（受影响！）
console.log(copy1.address.city); // 'Boston'

/**
 * 展开语法（Spread Operator）
 */
let copy2 = { ...original };

// 同样是浅拷贝
copy2.age = 35;
console.log(original.age); // 30（不受影响）

copy2.hobbies.push('gaming');
console.log(original.hobbies); // ['reading', 'swimming', 'gaming']（受影响）

/**
 * Object.create()
 */
let copy3 = Object.create(
    Object.getPrototypeOf(original),
    Object.getOwnPropertyDescriptors(original)
);

/**
 * 自定义浅拷贝函数
 */
function shallowCopy(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    
    if (obj instanceof Array) {
        return obj.slice();
    }
    
    if (obj instanceof Date) {
        return new Date(obj.getTime());
    }
    
    if (obj instanceof RegExp) {
        return new RegExp(obj.source, obj.flags);
    }
    
    const copy = {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            copy[key] = obj[key];
        }
    }
    return copy;
}
```

### 25.2.2 数组的浅拷贝

```javascript
/**
 * 数组浅拷贝方法
 */
let originalArray = [
    1, 
    'hello', 
    { id: 1, name: 'Item' },
    [1, 2, 3]
];

// slice() 方法
let copy1 = originalArray.slice();

// 展开语法
let copy2 = [...originalArray];

// Array.from()
let copy3 = Array.from(originalArray);

// concat() 方法
let copy4 = [].concat(originalArray);

// 测试浅拷贝效果
copy1.push('new item');
console.log(originalArray.length); // 4（不受影响）
console.log(copy1.length); // 5

copy1[2].name = 'Modified Item';
console.log(originalArray[2].name); // 'Modified Item'（受影响）

/**
 * map() 方法的浅拷贝特性
 */
let users = [
    { id: 1, name: 'Alice', profile: { age: 25 } },
    { id: 2, name: 'Bob', profile: { age: 30 } }
];

// map返回新数组，但对象元素仍是引用
let copiedUsers = users.map(user => user);

copiedUsers[0].name = 'Alice Updated';
console.log(users[0].name); // 'Alice Updated'（受影响）

// 正确的做法：在map中进行浅拷贝
let properCopy = users.map(user => ({ ...user }));
properCopy[0].name = 'Alice Modified';
console.log(users[0].name); // 'Alice Updated'（不再受影响）

// 但嵌套对象仍然是引用
properCopy[0].profile.age = 99;
console.log(users[0].profile.age); // 99（仍然受影响）
```

---

## 25.3 深拷贝解决方案

### 25.3.1 JSON方法深拷贝

```javascript
/**
 * JSON.parse(JSON.stringify()) 方法
 */
let complexObj = {
    name: 'Complex Object',
    numbers: [1, 2, 3],
    nested: {
        deep: {
            value: 'deep value'
        }
    },
    date: new Date(),
    func: function() { return 'function'; },
    regexp: /test/g,
    undefined: undefined,
    symbol: Symbol('test'),
    nan: NaN,
    infinity: Infinity
};

let jsonCopy = JSON.parse(JSON.stringify(complexObj));

console.log(jsonCopy);
// 注意：函数、undefined、symbol被忽略
// Date对象变成字符串
// RegExp对象变成空对象

/**
 * JSON方法的局限性
 */
let problematicObj = {
    circular: null,
    func: () => 'arrow function',
    date: new Date('2023-01-01'),
    regexp: /pattern/gi,
    map: new Map([['key', 'value']]),
    set: new Set([1, 2, 3]),
    buffer: new ArrayBuffer(8)
};

// 设置循环引用
problematicObj.circular = problematicObj;

try {
    JSON.parse(JSON.stringify(problematicObj));
} catch (error) {
    console.log('JSON方法无法处理循环引用:', error.message);
}

/**
 * 适用JSON方法的数据类型
 */
let jsonFriendlyObj = {
    string: 'text',
    number: 42,
    boolean: true,
    null: null,
    array: [1, 2, 3],
    object: { nested: 'value' }
};

let safeJsonCopy = JSON.parse(JSON.stringify(jsonFriendlyObj));
console.log('JSON深拷贝成功:', safeJsonCopy);
```

### 25.3.2 递归深拷贝实现

```javascript
/**
 * 基础递归深拷贝
 */
function simpleDeepCopy(obj) {
    // 处理基本类型和null
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    
    // 处理数组
    if (Array.isArray(obj)) {
        return obj.map(item => simpleDeepCopy(item));
    }
    
    // 处理对象
    const copy = {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            copy[key] = simpleDeepCopy(obj[key]);
        }
    }
    
    return copy;
}

/**
 * 增强版深拷贝
 */
function enhancedDeepCopy(obj, hash = new WeakMap()) {
    // 处理null和非对象类型
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    
    // 处理循环引用
    if (hash.has(obj)) {
        return hash.get(obj);
    }
    
    // 处理Date对象
    if (obj instanceof Date) {
        return new Date(obj);
    }
    
    // 处理RegExp对象
    if (obj instanceof RegExp) {
        return new RegExp(obj.source, obj.flags);
    }
    
    // 处理数组
    if (Array.isArray(obj)) {
        const arrCopy = [];
        hash.set(obj, arrCopy);
        obj.forEach((item, index) => {
            arrCopy[index] = enhancedDeepCopy(item, hash);
        });
        return arrCopy;
    }
    
    // 处理普通对象
    const objCopy = {};
    hash.set(obj, objCopy);
    
    Object.keys(obj).forEach(key => {
        objCopy[key] = enhancedDeepCopy(obj[key], hash);
    });
    
    return objCopy;
}

/**
 * 测试增强版深拷贝
 */
let testObj = {
    name: 'Test',
    date: new Date(),
    regexp: /test/gi,
    nested: {
        array: [1, 2, { deep: 'value' }]
    }
};

// 添加循环引用
testObj.self = testObj;

let deepCopied = enhancedDeepCopy(testObj);
console.log('深拷贝成功');
console.log(deepCopied.date instanceof Date); // true
console.log(deepCopied.regexp instanceof RegExp); // true
console.log(deepCopied.self === deepCopied); // true（循环引用保持）
```

### 25.3.3 完整的深拷贝实现

```javascript
/**
 * 完整的深拷贝函数
 */
function fullDeepCopy(obj, hash = new WeakMap()) {
    // 处理基本类型
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    
    // 处理循环引用
    if (hash.has(obj)) {
        return hash.get(obj);
    }
    
    // 处理各种对象类型
    const type = Object.prototype.toString.call(obj);
    let result;
    
    switch (type) {
        case '[object Array]':
            result = [];
            break;
        case '[object Date]':
            return new Date(obj);
        case '[object RegExp]':
            return new RegExp(obj.source, obj.flags);
        case '[object Map]':
            result = new Map();
            hash.set(obj, result);
            obj.forEach((value, key) => {
                result.set(key, fullDeepCopy(value, hash));
            });
            return result;
        case '[object Set]':
            result = new Set();
            hash.set(obj, result);
            obj.forEach(value => {
                result.add(fullDeepCopy(value, hash));
            });
            return result;
        case '[object Function]':
            // 函数的深拷贝比较复杂，这里简单返回原函数
            return obj;
        case '[object Object]':
            // 处理普通对象和自定义类实例
            if (obj.constructor !== Object) {
                // 自定义类实例，保持原型链
                result = Object.create(Object.getPrototypeOf(obj));
            } else {
                result = {};
            }
            break;
        default:
            // 其他类型（如Error、ArrayBuffer等）
            return obj;
    }
    
    // 设置循环引用标记
    hash.set(obj, result);
    
    // 复制属性（包括不可枚举属性）
    Object.getOwnPropertyNames(obj).forEach(key => {
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor.value !== undefined) {
            descriptor.value = fullDeepCopy(descriptor.value, hash);
        }
        Object.defineProperty(result, key, descriptor);
    });
    
    // 复制Symbol属性
    Object.getOwnPropertySymbols(obj).forEach(symbol => {
        const descriptor = Object.getOwnPropertyDescriptor(obj, symbol);
        if (descriptor.value !== undefined) {
            descriptor.value = fullDeepCopy(descriptor.value, hash);
        }
        Object.defineProperty(result, symbol, descriptor);
    });
    
    return result;
}

/**
 * 测试完整深拷贝
 */
class Person {
    constructor(name) {
        this.name = name;
    }
    
    greet() {
        return `Hello, I'm ${this.name}`;
    }
}

let complexTest = {
    person: new Person('Alice'),
    map: new Map([['key1', 'value1'], ['key2', { nested: 'data' }]]),
    set: new Set([1, 2, { id: 3 }]),
    symbol: Symbol('test'),
    [Symbol('hidden')]: 'symbol property'
};

let fullCopy = fullDeepCopy(complexTest);
console.log(fullCopy.person instanceof Person); // true
console.log(fullCopy.person.greet()); // "Hello, I'm Alice"
console.log(fullCopy.map instanceof Map); // true
console.log(fullCopy.set instanceof Set); // true
```

---

## 25.4 手写深拷贝函数

### 25.4.1 逐步构建深拷贝函数

```javascript
/**
 * 第一版：处理基本类型和简单对象
 */
function deepCopyV1(obj) {
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    
    const result = Array.isArray(obj) ? [] : {};
    
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            result[key] = deepCopyV1(obj[key]);
        }
    }
    
    return result;
}

/**
 * 第二版：处理循环引用
 */
function deepCopyV2(obj, visited = new WeakMap()) {
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    
    if (visited.has(obj)) {
        return visited.get(obj);
    }
    
    const result = Array.isArray(obj) ? [] : {};
    visited.set(obj, result);
    
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            result[key] = deepCopyV2(obj[key], visited);
        }
    }
    
    return result;
}

/**
 * 第三版：处理特殊对象类型
 */
function deepCopyV3(obj, visited = new WeakMap()) {
    // 基本类型直接返回
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    
    // 处理循环引用
    if (visited.has(obj)) {
        return visited.get(obj);
    }
    
    // 处理特殊对象
    if (obj instanceof Date) {
        return new Date(obj);
    }
    
    if (obj instanceof RegExp) {
        return new RegExp(obj);
    }
    
    if (obj instanceof Map) {
        const mapCopy = new Map();
        visited.set(obj, mapCopy);
        for (let [key, value] of obj) {
            mapCopy.set(
                deepCopyV3(key, visited),
                deepCopyV3(value, visited)
            );
        }
        return mapCopy;
    }
    
    if (obj instanceof Set) {
        const setCopy = new Set();
        visited.set(obj, setCopy);
        for (let value of obj) {
            setCopy.add(deepCopyV3(value, visited));
        }
        return setCopy;
    }
    
    // 处理数组和对象
    const result = Array.isArray(obj) ? [] : {};
    visited.set(obj, result);
    
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            result[key] = deepCopyV3(obj[key], visited);
        }
    }
    
    return result;
}

/**
 * 第四版：处理函数和Symbol
 */
function deepCopyV4(obj, visited = new WeakMap()) {
    // 基本类型
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    
    // 循环引用
    if (visited.has(obj)) {
        return visited.get(obj);
    }
    
    // 特殊对象类型
    if (obj instanceof Date) return new Date(obj);
    if (obj instanceof RegExp) return new RegExp(obj);
    
    if (obj instanceof Map) {
        const mapCopy = new Map();
        visited.set(obj, mapCopy);
        obj.forEach((value, key) => {
            mapCopy.set(
                deepCopyV4(key, visited),
                deepCopyV4(value, visited)
            );
        });
        return mapCopy;
    }
    
    if (obj instanceof Set) {
        const setCopy = new Set();
        visited.set(obj, setCopy);
        obj.forEach(value => {
            setCopy.add(deepCopyV4(value, visited));
        });
        return setCopy;
    }
    
    // 函数处理
    if (typeof obj === 'function') {
        return obj; // 函数通常不需要深拷贝
    }
    
    // 创建结果对象
    const result = Array.isArray(obj) ? [] : {};
    visited.set(obj, result);
    
    // 复制所有属性（包括Symbol）
    Reflect.ownKeys(obj).forEach(key => {
        result[key] = deepCopyV4(obj[key], visited);
    });
    
    return result;
}
```

### 25.4.2 性能优化版本

```javascript
/**
 * 性能优化的深拷贝函数
 */
function optimizedDeepCopy(obj) {
    // 类型检查优化
    const type = typeof obj;
    if (type !== 'object' || obj === null) {
        return obj;
    }
    
    // 使用栈替代递归，避免栈溢出
    const stack = [{ original: obj, copy: null, parent: null, key: null }];
    const visited = new WeakMap();
    let root = null;
    
    while (stack.length > 0) {
        const { original, copy, parent, key } = stack.pop();
        
        // 检查循环引用
        if (visited.has(original)) {
            const existingCopy = visited.get(original);
            if (parent) {
                parent[key] = existingCopy;
            }
            continue;
        }
        
        // 创建副本
        let currentCopy;
        
        if (Array.isArray(original)) {
            currentCopy = [];
        } else if (original instanceof Date) {
            currentCopy = new Date(original);
        } else if (original instanceof RegExp) {
            currentCopy = new RegExp(original);
        } else if (original instanceof Map) {
            currentCopy = new Map();
        } else if (original instanceof Set) {
            currentCopy = new Set();
        } else {
            currentCopy = {};
        }
        
        // 设置visited标记
        visited.set(original, currentCopy);
        
        // 设置父子关系
        if (parent) {
            parent[key] = currentCopy;
        } else {
            root = currentCopy;
        }
        
        // 处理不同类型的属性复制
        if (original instanceof Map) {
            for (let [mapKey, mapValue] of original) {
                if (typeof mapValue === 'object' && mapValue !== null) {
                    stack.push({
                        original: mapValue,
                        copy: null,
                        parent: currentCopy,
                        key: mapKey
                    });
                } else {
                    currentCopy.set(mapKey, mapValue);
                }
            }
        } else if (original instanceof Set) {
            for (let setValue of original) {
                if (typeof setValue === 'object' && setValue !== null) {
                    stack.push({
                        original: setValue,
                        copy: null,
                        parent: currentCopy,
                        key: 'add' // 特殊标记用于Set
                    });
                } else {
                    currentCopy.add(setValue);
                }
            }
        } else {
            // 处理对象和数组
            for (let objKey in original) {
                if (original.hasOwnProperty(objKey)) {
                    const value = original[objKey];
                    if (typeof value === 'object' && value !== null) {
                        stack.push({
                            original: value,
                            copy: null,
                            parent: currentCopy,
                            key: objKey
                        });
                    } else {
                        currentCopy[objKey] = value;
                    }
                }
            }
        }
    }
    
    return root;
}

/**
 * 性能测试
 */
function performanceTest() {
    // 创建复杂的测试对象
    const createComplexObject = (depth, breadth) => {
        if (depth <= 0) return { value: Math.random() };
        
        const obj = {};
        for (let i = 0; i < breadth; i++) {
            obj[`prop${i}`] = createComplexObject(depth - 1, breadth);
        }
        return obj;
    };
    
    const testObj = createComplexObject(5, 5);
    
    // 测试不同深拷贝方法的性能
    console.time('JSON方法');
    try {
        JSON.parse(JSON.stringify(testObj));
    } catch (e) {
        console.log('JSON方法失败');
    }
    console.timeEnd('JSON方法');
    
    console.time('递归深拷贝');
    deepCopyV4(testObj);
    console.timeEnd('递归深拷贝');
    
    console.time('优化深拷贝');
    optimizedDeepCopy(testObj);
    console.timeEnd('优化深拷贝');
}

// performanceTest();
```

### 25.4.3 工具库级别的实现

```javascript
/**
 * 生产级深拷贝实现
 */
class DeepCloner {
    constructor() {
        this.visited = new WeakMap();
    }
    
    clone(obj) {
        this.visited.clear();
        return this._clone(obj);
    }
    
    _clone(obj) {
        // 基本类型检查
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }
        
        // 循环引用检查
        if (this.visited.has(obj)) {
            return this.visited.get(obj);
        }
        
        // 获取对象类型
        const tag = Object.prototype.toString.call(obj);
        
        // 根据类型处理
        const cloneMethod = this._getCloneMethod(tag);
        return cloneMethod ? cloneMethod.call(this, obj) : obj;
    }
    
    _getCloneMethod(tag) {
        const cloneMethods = {
            '[object Object]': this._cloneObject,
            '[object Array]': this._cloneArray,
            '[object Date]': this._cloneDate,
            '[object RegExp]': this._cloneRegExp,
            '[object Map]': this._cloneMap,
            '[object Set]': this._cloneSet,
            '[object Function]': this._cloneFunction,
            '[object Error]': this._cloneError,
            '[object Symbol]': this._cloneSymbol
        };
        
        return cloneMethods[tag];
    }
    
    _cloneObject(obj) {
        const cloned = Object.create(Object.getPrototypeOf(obj));
        this.visited.set(obj, cloned);
        
        // 复制所有属性描述符
        const descriptors = Object.getOwnPropertyDescriptors(obj);
        for (let key in descriptors) {
            if (descriptors[key].value !== undefined) {
                descriptors[key].value = this._clone(descriptors[key].value);
            }
        }
        
        Object.defineProperties(cloned, descriptors);
        return cloned;
    }
    
    _cloneArray(arr) {
        const cloned = [];
        this.visited.set(arr, cloned);
        
        arr.forEach((item, index) => {
            cloned[index] = this._clone(item);
        });
        
        return cloned;
    }
    
    _cloneDate(date) {
        return new Date(date.getTime());
    }
    
    _cloneRegExp(regexp) {
        return new RegExp(regexp.source, regexp.flags);
    }
    
    _cloneMap(map) {
        const cloned = new Map();
        this.visited.set(map, cloned);
        
        map.forEach((value, key) => {
            cloned.set(this._clone(key), this._clone(value));
        });
        
        return cloned;
    }
    
    _cloneSet(set) {
        const cloned = new Set();
        this.visited.set(set, cloned);
        
        set.forEach(value => {
            cloned.add(this._clone(value));
        });
        
        return cloned;
    }
    
    _cloneFunction(func) {
        // 函数克隆的复杂实现
        const funcString = func.toString();
        const result = eval(`(${funcString})`);
        return result;
    }
    
    _cloneError(error) {
        const cloned = new Error(error.message);
        cloned.stack = error.stack;
        cloned.name = error.name;
        return cloned;
    }
    
    _cloneSymbol(symbol) {
        return Object(Symbol.prototype.valueOf.call(symbol));
    }
}

// 使用示例
const cloner = new DeepCloner();

const testData = {
    name: 'Test',
    date: new Date(),
    regexp: /test/gi,
    map: new Map([['key', 'value']]),
    set: new Set([1, 2, 3]),
    nested: {
        array: [1, 2, { deep: 'value' }]
    }
};

const cloned = cloner.clone(testData);
console.log('Production-level deep clone completed');
```

---

## 本章小结

深拷贝与浅拷贝是JavaScript中处理对象复制的重要概念：

### 核心要点

1. **引用复制**：基本类型值复制，引用类型引用复制
2. **浅拷贝**：只复制第一层属性，嵌套对象仍为引用
3. **深拷贝**：递归复制所有层级的属性
4. **实现方式**：JSON方法、递归实现、库函数等
5. **特殊处理**：循环引用、特殊对象类型、性能优化

### 实用技巧

- 根据数据结构选择合适的复制方式
- JSON方法适用于简单的纯数据对象
- 自定义实现可以处理复杂的对象类型
- 注意性能优化和循环引用问题
- 在项目中可以使用成熟的第三方库

### 应用场景

- 状态管理中的不可变数据操作
- 组件Props的安全传递  
- 缓存数据的独立副本
- 防止意外的数据修改

这就完成了JavaScript深入机制部分的学习，为现代前端开发奠定了坚实的理论基础。
